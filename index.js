(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["matrixConsoleApi"] = factory();
	else
		root["matrixConsoleApi"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(2), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, DeveloperTools_1, MatrixLibInterfaces_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.JSONTools = exports.LoggerTools = exports.ml = void 0;
    Object.defineProperty(exports, "JSONTools", ({ enumerable: true, get: function () { return index_1.JSONTools; } }));
    Object.defineProperty(exports, "LoggerTools", ({ enumerable: true, get: function () { return index_1.LoggerTools; } }));
    class matrix {
        constructor() {
            this.Search = new index_1.SearchTools();
            this.Item = new index_1.ItemTools();
            this.ContextFrames = new index_1.ContextFramesTools();
            // console / error logging
            this.Logger = new index_1.LoggerTools();
            // highlight / search function
            this.JSON = new index_1.JSONTools(this.Logger);
            this.XPath = new index_1.XPathTools();
            this.URL = new index_1.URLTools();
            this.Mail = new index_1.MailTools();
            // label tools (labels and filters)
            this.LabelTools = new index_1.LabelTools();
            // tooltipsmessage boxes and other ui controls
            this.UI = new index_1.UIToolsEnum();
            this.File = new index_1.FileTools();
            this.DeveloperTools = new DeveloperTools_1.DeveloperTools();
            this.ReportGenerator = new index_1.ReportGeneratorTools();
            this.SmartText = new index_1.SmartTextTools();
        }
    }
    let ml;
    exports.ml = ml;
    exports.ml = ml = new matrix();
    // Let's save this on the window.
    globalThis.ml = ml;
    // TODO(modules): UIToolsEnum was split into two classes because of circular dependencies.
    // UIToolsConstants was the result. Legacy plugins often use those constants, so let's
    // make it easy for them by exposing those in the old name they know. This is a TODO
    // because it reflects that those plugins need to be refactored.
    globalThis.UIToolsEnum = MatrixLibInterfaces_1.UIToolsConstants;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 2 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DeveloperTools = void 0;
    class DeveloperTools {
        getStagingCode() {
            const code = localStorage.getItem(DeveloperTools.THE_SETTING);
            if (!code)
                return "";
            return code;
        }
        setStagingCode(newCode) {
            localStorage.setItem(DeveloperTools.THE_SETTING, newCode);
        }
        runStagingCode() {
            const code = this.getStagingCode();
            const trimmedCode = code.trim();
            if (trimmedCode != "") {
                matrixlib_1.ml.Logger.info("Evaluating non-empty developer staging code.");
                eval(code);
                matrixlib_1.ml.Logger.info("Developer staging code evaluated.");
            }
        }
    }
    exports.DeveloperTools = DeveloperTools;
    DeveloperTools.THE_SETTING = "developerStaging";
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 3 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.UIToolsConstants = exports.DOCUMENT_STATUS_LABEL_GROUP_TYPE = void 0;
    const DOCUMENT_STATUS_LABEL_GROUP_TYPE = "_DOCUMENT_STATUS_";
    exports.DOCUMENT_STATUS_LABEL_GROUP_TYPE = DOCUMENT_STATUS_LABEL_GROUP_TYPE;
    ;
    class UIToolsConstants {
    }
    exports.UIToolsConstants = UIToolsConstants;
    UIToolsConstants.CIColors = {
        Black: { color: "#000", alternateColor: "#FFF" },
        BrownCoffeeRoyal: { color: "#6C3008", alternateColor: "#FFF" },
        BlueEastBay: { color: "#3D5A7F", alternateColor: "#FFF" },
        BlueLagoon: { color: "#027E8E", alternateColor: "#FFF" },
        BlueDoger: { color: "#41B4FF", alternateColor: "#FFF" },
        BlueZiggurat: { color: "#B3D9DD", alternateColor: "#000" },
        GreenYellow: { color: "#B9D771", alternateColor: "#000" },
        GreenSushi: { color: "#68C037", alternateColor: "#000" },
        YellowBrightSun: { color: "#FFE541", alternateColor: "#000" },
        OrangeYellow: { color: "#FBA043", alternateColor: "#000" },
        //YellowOrange:{bg:"#FBA043",fg:"#000"},
        RedPersimmon: { color: "#FF545D", alternateColor: "#FFF  " },
        VioletElectric: { color: "#A543FB", alternateColor: "#000" },
        VioletMauve: { color: "#DEA3FF", alternateColor: "#000" },
        PinkHot: { color: "#FF6FBC", alternateColor: "#000" },
        BrownTiaMaria: { color: "#C6490C", alternateColor: "#FFF" },
        BrownDiSerria: { color: "#E19E72", alternateColor: "#FFF" },
        PinkBeautyBush: { color: "#F5CECE", alternateColor: "#000" },
        GreyDark: { color: "#838383", alternateColor: "#FFF" },
        GreyLightAlto: { color: "#DCDCDC", alternateColor: "#000" },
        White: { color: "#FFFFFF", alternateColor: "#000" }
    };
    UIToolsConstants.CIColorsGrey = {
        G0_VeryDark: { color: "#1d2227", alternateColor: "#FFF" },
        G1: { color: "#32373c", alternateColor: "#FFF" },
        G2: { color: "#465055", alternateColor: "#FFF" },
        G3_GreyDark: { color: "#838383", alternateColor: "#FFF" },
        G4: { color: "#a9b3b8", alternateColor: "#FFF" },
        G5: { color: "#cdd2d7", alternateColor: "#000" },
        G6: { color: "#dbe0e5", alternateColor: "#000" },
        G7_GreyLightAlto: { color: "#DCDCDC", alternateColor: "#000" },
        G8: { color: "#f0f0f5", alternateColor: "#000" },
        G9: { color: "#f5f5fa", alternateColor: "#000" }
    };
    UIToolsConstants.allGrey = [
        UIToolsConstants.CIColorsGrey.G0_VeryDark.color,
        UIToolsConstants.CIColorsGrey.G1.color,
        UIToolsConstants.CIColorsGrey.G2.color,
        UIToolsConstants.CIColorsGrey.G3_GreyDark.color,
        UIToolsConstants.CIColorsGrey.G4.color,
        UIToolsConstants.CIColorsGrey.G5.color,
        UIToolsConstants.CIColorsGrey.G6.color,
        UIToolsConstants.CIColorsGrey.G7_GreyLightAlto.color,
        UIToolsConstants.CIColorsGrey.G8.color,
        UIToolsConstants.CIColorsGrey.G9.color
    ];
    // based on green sushi
    UIToolsConstants.CIColorsPrimary = {
        P0_LogoGreenYellow: { color: "#b9d771", alternateColor: "#FFF" },
        P1: { color: "#9bcf45", alternateColor: "#FFF" },
        P2: { color: "#6dcf45", alternateColor: "#FFF" },
        P3_GreenSushi: { color: "#68C037", alternateColor: "#FFF" },
        P4: { color: "#75b10f", alternateColor: "#FFF" },
        P5: { color: "#7aa608", alternateColor: "#FFF" },
        P6_LogoDarkGreen: { color: "#007e8d", alternateColor: "#FFF" },
    };
    (function (UIToolsConstants) {
        let Scroll;
        (function (Scroll) {
            Scroll[Scroll["Auto"] = 0] = "Auto";
            Scroll[Scroll["Vertical"] = 1] = "Vertical";
            Scroll[Scroll["None"] = 2] = "None";
        })(Scroll = UIToolsConstants.Scroll || (UIToolsConstants.Scroll = {}));
    })(UIToolsConstants || (UIToolsConstants = {}));
    exports.UIToolsConstants = UIToolsConstants;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(5), __webpack_require__(8), __webpack_require__(11), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71), __webpack_require__(72), __webpack_require__(73), __webpack_require__(74), __webpack_require__(84), __webpack_require__(85)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, SearchTools_1, ItemTools_1, ContextFramesTools_1, FileTools_1, HTMLCleaner_1, JSONTools_1, LabelTools_1, LoggerTools_1, MailTools_1, ReportGeneratorTools_1, SmartTextTools_1, UITools_1, URLTools_1, XPathTools_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SearchTools = void 0;
    Object.defineProperty(exports, "SearchTools", ({ enumerable: true, get: function () { return SearchTools_1.SearchTools; } }));
    __exportStar(ItemTools_1, exports);
    __exportStar(ContextFramesTools_1, exports);
    __exportStar(FileTools_1, exports);
    __exportStar(HTMLCleaner_1, exports);
    __exportStar(JSONTools_1, exports);
    __exportStar(LabelTools_1, exports);
    __exportStar(LoggerTools_1, exports);
    __exportStar(MailTools_1, exports);
    __exportStar(ReportGeneratorTools_1, exports);
    __exportStar(SmartTextTools_1, exports);
    __exportStar(UITools_1, exports);
    __exportStar(URLTools_1, exports);
    __exportStar(XPathTools_1, exports);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 5 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, MatrixRequirementsAPI_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SearchTools = void 0;
    class CancelSearchEvent {
    }
    ;
    class SearchTools {
        constructor() {
            // context is used to highlight only in select from tree dialog. by default all is
            this.highlightContext = $("#highlightContext");
            this.OnCancelSearch = new MatrixRequirementsAPI_1.EventDispatcher();
        }
        getFilter() {
            return this.globalFilter;
        }
        cancelSearch() {
            // from all search filters, remove the search term and details
            $(".treeCtrl input[name=search]").val("");
            $(".treeCtrl :checkbox").prop("checked", false);
            // remove any kind of highlighting in main tree
            this.OnCancelSearch.dispatch(new CancelSearchEvent());
            this.hideHighlight();
        }
        searchInDialog() {
            this.cancelSearch();
            // now set search to dialog
            this.highlightContext = globals_1.app.dlgForm;
        }
        ;
        endSearchInDialog() {
            this.highlightContext = $("#highlightContext");
            this.globalFilter = "";
        }
        ;
        highlight(term) {
            this.globalFilter = term;
            this.renderHighlight();
        }
        ;
        hideHighlight() {
            this.globalFilter = "";
            this.highlightContext.unhighlight();
            this.updateTinys();
        }
        ;
        renderHighlight() {
            this.highlightContext.unhighlight();
            if (this.globalFilter && this.globalFilter.length > 0) {
                this.highlightContext.highlight(this.globalFilter);
            }
            this.updateTinys();
        }
        updateTinys() {
            let that = this;
            if (this.globalFilter) {
                $(".thisIsTiny").each(function (idx, tiny) {
                    let editor = tinymce.get($(tiny).attr("id"));
                    if (editor) {
                        $(editor.getBody()).unhighlight().highlight(that.getFilter());
                    }
                });
            }
            else {
                $(".thisIsTiny").each(function (idx, tiny) {
                    let editor = tinymce.get($(tiny).attr("id"));
                    if (editor) {
                        $(editor.getBody()).unhighlight();
                    }
                });
            }
        }
    }
    exports.SearchTools = SearchTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 6 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InstallLegacyAdaptor = exports.setApp = exports.setMatrixApplicationUI = exports.setRestConnection = exports.setMatrixSession = exports.setIC = exports.matrixApplicationUI = exports.app = exports.restConnection = exports.matrixSession = exports.globalMatrix = exports.ControlState = void 0;
    ;
    class GlobalMatrix {
        constructor() {
            this.ITEM_DOES_NOT_EXIST = "";
            this.globalShiftDown = false;
            this.globalCtrlDown = false;
            this.historyFilter = "merge,delete,undelete,add,edit,execute,reviewed,signature,report,touch,release";
            this.mobileApp = undefined;
        }
        installLegacyAdaptor() {
            globalThis.ITEM_DOES_NOT_EXIST = this.ITEM_DOES_NOT_EXIST;
            globalThis.matrixRestUrl = this.matrixRestUrl;
            globalThis.matrixBaseUrl = this.matrixBaseUrl;
            globalThis.matrixWfgw = this.matrixWfgw;
            globalThis.matrixExpress = this.matrixExpress;
            globalThis.matrixProduct = this.matrixProduct;
            globalThis.mxOauth = this.mxOauth;
            globalThis.mxOauthLoginUrl = this.mxOauthLoginUrl;
            globalThis.serverStorage = this.serverStorage;
            globalThis.projectStorage = this.projectStorage;
            globalThis.wfgwConnection = this.wfgwConnection;
            globalThis.globalShiftDown = this.globalShiftDown;
            globalThis.globalCtrlDown = this.globalCtrlDown;
            globalThis.jsonValidator = this.jsonValidator;
        }
    }
    var globalMatrix = new GlobalMatrix();
    exports.globalMatrix = globalMatrix;
    function setIC(newIC) {
        globalMatrix.ItemConfig = newIC; // To use in matrixApi
        globalThis.IC = newIC; // legacy support
    }
    exports.setIC = setIC;
    var matrixSession;
    exports.matrixSession = matrixSession;
    function setMatrixSession(session) {
        exports.matrixSession = matrixSession = session;
    }
    exports.setMatrixSession = setMatrixSession;
    var restConnection; // global rest connection
    exports.restConnection = restConnection;
    function setRestConnection(rc) {
        exports.restConnection = restConnection = rc;
    }
    exports.setRestConnection = setRestConnection;
    var matrixApplicationUI; // the application
    exports.matrixApplicationUI = matrixApplicationUI;
    function setMatrixApplicationUI(ui) {
        exports.matrixApplicationUI = matrixApplicationUI = ui;
    }
    exports.setMatrixApplicationUI = setMatrixApplicationUI;
    // TODO(modules): app was declared as interface MatrixReq, which is empty, and then usually
    // assigned to a variable of type businesslogic/UI/MatrixReq. We just opt out of typing for
    // this variable and ideally we should fix that with a real interface. I changed the type to
    // any to make the true situation easier to see.
    var app; // main application 
    exports.app = app;
    function setApp(newApp) {
        exports.app = app = newApp;
    }
    exports.setApp = setApp;
    ;
    var ControlState;
    (function (ControlState) {
        ControlState[ControlState["FormEdit"] = 0] = "FormEdit";
        ControlState[ControlState["FormView"] = 1] = "FormView";
        ControlState[ControlState["DialogCreate"] = 2] = "DialogCreate";
        ControlState[ControlState["HistoryView"] = 3] = "HistoryView";
        ControlState[ControlState["Tooltip"] = 4] = "Tooltip";
        ControlState[ControlState["Print"] = 5] = "Print";
        ControlState[ControlState["Report"] = 6] = "Report";
        ControlState[ControlState["DialogEdit"] = 7] = "DialogEdit"; // between FormEdit and DialogCreate to edit an item in popup
    })(ControlState || (ControlState = {}));
    exports.ControlState = ControlState;
    ;
    // This is so that old legacy scripts can "just work" to a degree.
    function InstallLegacyAdaptor() {
        globalThis.ControlState = ControlState;
        globalThis.IC = globalMatrix.ItemConfig;
        globalThis.matrixSession = matrixSession;
        globalThis.restConnection = restConnection;
        globalThis.app = app;
        globalThis.matrixApplicationUI = matrixApplicationUI;
        globalMatrix.installLegacyAdaptor();
    }
    exports.InstallLegacyAdaptor = InstallLegacyAdaptor;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 7 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.MR1 = exports.EventDispatcherAsync = exports.EventDispatcher = void 0;
    class EventDispatcher {
        constructor() {
            this._subscriptions = new Array();
            this._callers = new Array();
        }
        subscribe(caller, fn) {
            this._callers.push(caller);
            this._subscriptions.push(fn);
        }
        unsubscribe(fn) {
            var i = this._subscriptions.indexOf(fn);
            if (i > -1) {
                this._subscriptions.splice(i, 1);
                this._callers.splice(i, 1);
            }
        }
        dispatch(args) {
            for (var i = 0; i < this._subscriptions.length; i++) {
                var handler = this._subscriptions[i];
                if (handler != null) {
                    args.caller = this._callers[i];
                    handler(args);
                }
            }
        }
    }
    exports.EventDispatcher = EventDispatcher;
    class EventDispatcherAsync {
        constructor() {
            this._subscriptionsAsync = new Array();
            this._callersAsync = new Array();
        }
        // now same for asyncs
        subscribe(caller, fn) {
            this._callersAsync.push(caller);
            this._subscriptionsAsync.push(fn);
        }
        unsubscribe(fn) {
            var i = this._subscriptionsAsync.indexOf(fn);
            if (i > -1) {
                this._subscriptionsAsync.splice(i, 1);
                this._callersAsync.splice(i, 1);
            }
        }
        dispatch(args) {
            return this.dispatchAsyncOne(args, 0);
        }
        dispatchAsyncOne(args, idx) {
            let that = this;
            let res = $.Deferred();
            if (idx >= this._subscriptionsAsync.length) {
                res.resolve();
                return res;
            }
            var handler = this._subscriptionsAsync[idx];
            if (handler != null) {
                args.caller = this._callersAsync[idx];
                handler(args).done(function () {
                    that.dispatchAsyncOne(args, idx + 1).done(function () {
                        res.resolve();
                    }).fail(function () {
                        res.reject();
                    });
                }).fail(function () {
                    res.reject();
                });
            }
            else {
                that.dispatchAsyncOne(args, idx + 1).done(function () {
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }
            return res;
        }
    }
    exports.EventDispatcherAsync = EventDispatcherAsync;
    class MR1Impl {
        constructor() {
            this.cbsItemDisplayed = new EventDispatcher();
            this.cbsCreateItemDisplayed = new EventDispatcher();
            this.cbsCreateItemDisplayedClose = new EventDispatcher();
            this.cbsBeforeSave = new EventDispatcherAsync();
            this.cbsAfterSave = new EventDispatcher();
            this.cbsAfterRestore = new EventDispatcher();
            this.cbsAfterDelete = new EventDispatcher();
            this.cbsAfterCreate = new EventDispatcher();
            this.cbsAfterCreateSign = new EventDispatcher();
            this.cbsBeforeDelete = new EventDispatcherAsync();
            this.cbsAfterLabelChange = new EventDispatcher();
            this.cbsAfterSignature = new EventDispatcher();
        }
        // triggers
        triggerItemCreate(view, isItem, category) { this.cbsCreateItemDisplayed.dispatch({ view: view, isItem: isItem, category: category }); }
        triggerItemCreateClose(ok) { this.cbsCreateItemDisplayedClose.dispatch({ ok: ok }); }
        triggerItemDisplayed(item, view) { this.cbsItemDisplayed.dispatch({ item: item, view: view }); }
        triggerBeforeSaveAsync(view, before, after) { return this.cbsBeforeSave.dispatch({ view: view, before, after }); }
        triggerAfterSave(view, before, after) { this.cbsAfterSave.dispatch({ before: before, after: after, view: view }); }
        triggerAfterRestore(itemId) { this.cbsAfterRestore.dispatch({ itemId: itemId }); }
        triggerAfterDelete(item) { this.cbsAfterDelete.dispatch({ item: item }); }
        triggerAfterItemCreate(item) { this.cbsAfterCreate.dispatch({ item: item }); }
        triggerAfterCreateSign(item) { this.cbsAfterCreateSign.dispatch({ item: item }); }
        triggerBeforeDeleteAsync(item) { return this.cbsBeforeDelete.dispatch({ item: item }); }
        triggerAfterLabelChange(item, before, after) { this.cbsAfterLabelChange.dispatch({ item: item, set: before, unset: after }); }
        triggerAfterSignature(item, lastuser) { this.cbsAfterSignature.dispatch({ item: item, lastuser: lastuser }); }
        // notifications 
        onItemDisplayed() { /* fired after item is rendered */ return this.cbsItemDisplayed; }
        onItemCreateDlgOpen() { /* fired after dialog is opened */ return this.cbsCreateItemDisplayed; }
        onItemCreateDlgClose() { /* fired after dialog is closed */ return this.cbsCreateItemDisplayedClose; }
        onAfterSave() { /* fired after item was saved */ return this.cbsAfterSave; }
        onAfterRestore() { /* fired after item was restored */ return this.cbsAfterRestore; }
        onAfterDelete() { /* event after an item (or a folder) has been deleted */ return this.cbsAfterDelete; }
        onAfterCreate() { /* event after an item (or a folder) has been created */ return this.cbsAfterCreate; }
        onAfterCreateSign() { /* event after a SIGN item has been created */ return this.cbsAfterCreateSign; }
        onAfterLabelChange() { return this.cbsAfterLabelChange; }
        onAfterSignature() { return this.cbsAfterSignature; }
        // allowing to stop execution. need to return promise, reject() to stop resolve() to continue.
        onBeforeSaveAsync() { /* event before  an item will be saved. */ return this.cbsBeforeSave; }
        onBeforeDeleteAsync() { /* event before  an item (or a folder) has been deleted. */ return this.cbsBeforeDelete; }
    }
    var MR1 = new MR1Impl();
    exports.MR1 = MR1;
    globalThis.MR1 = MR1;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/** tests...

// MR1.onAfterLabelChange().subscribe( this, function (event:ILabelChangeEvent) { console.log("Label changed for " + event.item.id + " set: '" + event.set.join() + "' unset: '" + event.unset.join() + "'");} );


MR1.onBeforeDeleteAsync().subscribe( this, function (event:IGenericItemEvent) {
    console.log("MR1 >>>Could cancel item delete " + event.item.id);

    let res = $.Deferred();
    res.resolve(); // res.reject(); to cancel
    return res;
});

MR1.onBeforeSaveAsync().subscribe( this, function (event:IItemChangeEvent) {
    console.log("MR1 >>>Could cancel save of " + event.before.id);

    let res = $.Deferred();
    res.resolve(); // res.reject(); to cancel
    return res;
});

MR1.onAfterCreate().subscribe( this, function (event:INewItemIdEvent) { console.log("MR1 >>>Item created " + event.item.item.id);} );
MR1.onAfterCreateSign().subscribe( this, function (event:IGenericItemEvent) { console.log("MR1 >>>SIGN created " + event.item.id);} );

MR1.onAfterSignature().subscribe( this, function (event:ISignatureEvent) { console.log("MR1 >>>SIGNED " + event.item.id + " by " + matrixSession.getUser() +  ( event.lastuser?" as last signature":" but not last signature"));} );

MR1.onAfterSave().subscribe( this, function (event:IItemChangeEvent) { console.log("MR1 >>>Item saved " + event.after.id);} );
MR1.onAfterRestore().subscribe( this, function (event:IGenericItemIdEvent) { console.log("MR1 >>>Item restored " + event.itemId);} );

MR1.onAfterDelete().subscribe( this, function (event:IGenericItemEvent) { console.log("MR1 >>>Item deleted " + event.item.id);} );

MR1.onItemDisplayed().subscribe( this, function (event:IGenericItemEvent) { console.log("MR1 >>>Item displayed " + event.item.id);} );

MR1.onItemCreateDlgOpen().subscribe( this, function (event:IPreCreateItemEvent) {  console.log("MR1 >>>Create item dialog with " + event.view.getControls().length + " controls.");}  );

*/
/** example extract all italic from text and put in title when saving if title is " " or ""
MR1.onBeforeSaveAsync().subscribe( this, function (event:IItemChangeEvent) {
    console.log("MR1 >>>Could cancel save of " + event.before.title);

    if (event.after.title == " " || event.after.title == "") {
        let tf = IC.getFieldsOfType("richtext",event.after.type);
        let italics="";
        $.each( tf, function(idx, tfd) {
            let tfc = $("<div>").html(event.after[tfd.field.id]);
            $("span", tfc).each( function(spanIdx,span) {
                if ($(span).css("font-style").indexOf("italic")!=-1) {
                    italics += italics?(" "+$(span).text()):$(span).text();
                }
            });
        });
        event.after.title = italics?italics:"title required";
    }

    let res = $.Deferred();
    res.resolve();
    return res;
});

 */


/***/ }),
/* 8 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(6), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, globals_2, SimpleItemTools_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ItemTools = void 0;
    class ItemTools {
        constructor() {
            this.simpleItemTools = new SimpleItemTools_1.SimpleItemTools();
        }
        // extract different parts from item ids, like version, category, ...
        parseRef(itemRef) {
            return this.simpleItemTools.parseRef(itemRef, globals_1.matrixSession.getProject(), globals_2.globalMatrix.matrixBaseUrl);
        }
        ;
        getCreator(item) {
            return this.simpleItemTools.getCreator(item);
        }
        getLastEditor(item) {
            return this.simpleItemTools.getLastEditor(item);
        }
        // render a list of item ids, to show up as <b>ID</b> name, <b>ID</b> name, 
        refListToDisplayString(inputItems, prefix, shorten) {
            return this.simpleItemTools.refListToDisplayString(inputItems, prefix, (ref) => globals_1.app.getItemTitle(ref), shorten);
        }
        renderLink(itemId, itemTitle, newWindow) {
            const realTitle = itemTitle ? itemTitle : globals_1.app.getItemTitle(itemId);
            return this.simpleItemTools.renderLink(itemId, realTitle, newWindow);
        }
        // update and changes to reference lists
        updateReferences(oldReferences, newReferences, fromId, toId) {
            return this.simpleItemTools.updateReferences(oldReferences, newReferences, fromId, toId);
        }
        // clone item from IItemGet to IItemPut
        clone(item, copyLabels) {
            return this.simpleItemTools.clone(item, copyLabels);
        }
        sort(a, b) {
            return this.simpleItemTools.sort(a, b, globals_1.matrixSession.getProject(), globals_2.globalMatrix.matrixBaseUrl);
        }
    }
    exports.ItemTools = ItemTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 9 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, RefLinkDefines_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SimpleItemTools = void 0;
    // Implements ItemTools functionality with minimal dependencies
    class SimpleItemTools {
        // extract different parts from item ids, like version, category, ...
        parseRef(itemRef, project, matrixBaseUrl) {
            let ref = itemRef; // e.g. F-REQ-13-v12
            var result = {
                id: "",
                number: 0,
                version: 0,
                type: "",
                isFolder: false,
                url: "",
                link: "",
                linkv: "" // <a href=url>url</a>
            };
            var vp = ref.indexOf("-v");
            if (vp !== -1) {
                result.version = parseInt(ref.substr(vp + 2));
                ref = ref.substr(0, vp);
            }
            result.id = ref;
            if (ref.indexOf("F-") === 0) {
                result.isFolder = true;
                ref = ref.substr(2);
            }
            var parts = ref.split("-");
            if (parts.length > 1) {
                result.type = parts[0];
                result.number = Number(parts[1]);
            }
            result.url = matrixBaseUrl + "/" + project + "/" + itemRef;
            result.link = "<a style='color:blue !important' href='" + result.url + "'>" + itemRef + "</a>";
            result.linkv = "<a style='color:blue !important' href='" + result.url + "'>" + result.url + "</a>";
            return result;
        }
        ;
        getCreator(item) {
            return item.history[item.history.length - 1].user;
        }
        getLastEditor(item) {
            return item.history.length > 0 ? item.history[0].user : "";
        }
        // render a list of item ids, to show up as <b>ID</b> name, <b>ID</b> name, 
        refListToDisplayString(inputItems, prefix, getTitleFunction, shorten) {
            function makeLink(itemobj, shorten) {
                if (!itemobj.projectShortLabel) {
                    return "<b>" + itemobj.to + "</b>" + (shorten ? "" : (" " + getTitleFunction(itemobj.to)));
                }
                var label = itemobj.projectShortLabel + ":" + itemobj.to;
                return "#" + itemobj.projectShortLabel + "/" + itemobj.to + "#";
                //return "<a class='crossProjectLink' title='" + itemobj.title + "' href='" + matrixBaseUrl + "/" + itemobj.projectShortLabel + "/" + itemobj.to + "' target='_blank'>" + label + "</a> ";
            }
            if (inputItems) {
                // build the list ItemId Title can take a long time, e.g. if there's dozens of search results and the list should be a short list. In that case only show names if there's less than 5 items 
                let refs = inputItems.map(function (inputItem) { return makeLink(inputItem, shorten && inputItems.length > 4 ? true : false); });
                let list = refs.join(", ");
                if (shorten && list.replace(/<b>/g, "").replace(/<\/b>/g, "").length > shorten) {
                    refs = inputItems.map(function (inputItem) { return makeLink(inputItem, true); });
                    list = refs.join(", ");
                }
                if (shorten && list.replace(/<b>/g, "").replace(/<\/b>/g, "").length > shorten) {
                    list = "<b>" + list.replace(/<b>/g, "").replace(/<\/b>/g, "").substr(0, shorten - 4) + " ...</b>";
                }
                if (prefix) {
                    list = prefix + " " + list;
                }
                return list;
            }
            else {
                return "";
            }
        }
        ;
        renderLink(itemId, itemTitle, newWindow) {
            let dbt = itemTitle;
            return $("<div>").refLink({
                id: itemId,
                folder: false,
                title: dbt ? dbt : "(deleted)",
                style: newWindow ? RefLinkDefines_1.refLinkStyle.link : RefLinkDefines_1.refLinkStyle.selectTree,
                tooltip: RefLinkDefines_1.refLinkTooltip.html
            });
        }
        // update and changes to reference lists
        updateReferences(oldReferences, newReferences, fromId, toId) {
            var changeList = [];
            // find links to add
            for (var idx = 0; idx < newReferences.length; idx++) {
                var found = false;
                for (var jdx = 0; jdx < oldReferences.length; jdx++) {
                    if (newReferences[idx].to === oldReferences[jdx].to) {
                        found = true;
                        continue;
                    }
                }
                if (!found) {
                    if (fromId) {
                        changeList.push({ action: 'addLink', fromId: fromId, toId: newReferences[idx].to });
                    }
                    else if (toId) {
                        changeList.push({ action: 'addLink', fromId: newReferences[idx].to, toId: toId });
                    }
                }
            }
            // find links to remove
            for (var jdx = 0; jdx < oldReferences.length; jdx++) {
                var found = false;
                for (var idx = 0; idx < newReferences.length; idx++) {
                    if (newReferences[idx].to === oldReferences[jdx].to) {
                        found = true;
                        continue;
                    }
                }
                if (!found) {
                    if (fromId) {
                        changeList.push({ action: 'removeLink', fromId: fromId, toId: oldReferences[jdx].to });
                    }
                    else if (toId) {
                        changeList.push({ action: 'removeLink', fromId: oldReferences[jdx].to, toId: toId });
                    }
                }
            }
            return changeList;
        }
        ;
        // clone item from IItemGet to IItemPut
        clone(item, copyLabels) {
            var newItem = {};
            $.each(item, function (idx, val) {
                if (idx !== "maxVersion" && idx !== "labels" && idx !== "labels" && idx !== "downLinks" && idx !== "upLinks" && idx !== "type" && idx !== "children" && idx !== "hide" && idx !== "history" && idx !== "isUnselected" && idx !== "modDate" && idx !== "restricted" && idx !== "upLinkList" && idx !== "userRights") {
                    newItem[idx] = val;
                }
            });
            if (copyLabels) {
                newItem.labels = item.labels.join(",");
            }
            else {
                newItem.labels = "";
            }
            return newItem;
        }
        sort(a, b, project, matrixBaseUrl) {
            let at = this.parseRef(a, project, matrixBaseUrl);
            let bt = this.parseRef(b, project, matrixBaseUrl);
            if (at.type == bt.type) {
                if (at.isFolder && !bt.isFolder)
                    return -1;
                if (bt.isFolder && !at.isFolder)
                    return 1;
                return at.number - bt.number;
            }
            return a < b ? -1 : 1;
        }
    }
    exports.SimpleItemTools = SimpleItemTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 10 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.refLinkTooltip = exports.refLinkStyle = void 0;
    var refLinkStyle;
    (function (refLinkStyle) {
        refLinkStyle[refLinkStyle["edit"] = 1] = "edit";
        refLinkStyle[refLinkStyle["link"] = 2] = "link";
        refLinkStyle[refLinkStyle["show"] = 3] = "show";
        refLinkStyle[refLinkStyle["select"] = 4] = "select";
        refLinkStyle[refLinkStyle["selectTree"] = 5] = "selectTree"; // like link, but selects in tree unless ctrl-was clicked
    })(refLinkStyle || (refLinkStyle = {}));
    exports.refLinkStyle = refLinkStyle;
    var refLinkTooltip;
    (function (refLinkTooltip) {
        refLinkTooltip[refLinkTooltip["none"] = 1] = "none";
        refLinkTooltip[refLinkTooltip["html"] = 2] = "html"; // full html tooltip
    })(refLinkTooltip || (refLinkTooltip = {}));
    exports.refLinkTooltip = refLinkTooltip;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 11 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(17), __webpack_require__(6), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, globals_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ContextFramesTools = void 0;
    class ContextFramesTools {
        constructor() {
            this.exists = false;
            this.visible = false;
            this.support = false;
            this.resetSmartLinks = true;
            this.maxNumberOfLinks = 20;
            this.categoryFilter = {};
            this.shouldBeVisible = false;
            // to be done once
            let that = this;
            $('#contextframesizer').mousedown(function (e) {
                if (e.preventDefault)
                    e.preventDefault();
                $(document).mousemove(function (e) {
                    let contextframeWidth = Math.max(0, ($(document).width() - e.pageX + 2));
                    if (contextframeWidth < 150) {
                        contextframeWidth = 500;
                        localStorage.setItem('contextframeWidth', contextframeWidth.toString());
                        that.hideContextFrames();
                    }
                    else {
                        localStorage.setItem('contextframeWidth', contextframeWidth.toString());
                        that.showContextFrames();
                    }
                    $(document).trigger("contextFrameResized");
                    globals_1.app.resizeItem(true);
                });
            });
            // to hide / resize context frame if it would be to small
            let resizeHandleTimeout;
            $(window).resize(function () {
                clearTimeout(resizeHandleTimeout);
                resizeHandleTimeout = window.setTimeout(function () {
                    if (that.visible) {
                        that.showContextFrames();
                    }
                }, 300);
            });
        }
        setToogleIcon(allowClose) {
            let faIcon = $("#contextFrameButton span.fal");
            faIcon.removeClass("fa-arrow-to-right");
            faIcon.removeClass("fa-arrow-from-right");
            if (allowClose) {
                faIcon.addClass("fa-arrow-to-right");
            }
            else {
                faIcon.addClass("fa-arrow-from-right");
            }
        }
        toggleFunction() {
            // toggle status;
            let contextframeWidth = Number(localStorage.getItem('contextframeWidth'));
            localStorage.setItem('contextframeWidth', (-contextframeWidth).toString());
            if (this.visible) {
                this.shouldBeVisible = false;
                this.hideContextFrames();
            }
            else {
                this.shouldBeVisible = true;
                this.showContextFrames();
                this.renderContextFrames();
            }
            this.setToogleIcon(this.shouldBeVisible); // if visible allow close
            globals_1.app.resizeItem(true);
        }
        showContextFrame(tabType, makeVisible) {
            let tab = "";
            $.each(this.getTabs(), function (tabIdx, tabDef) {
                if (tabDef.type == tabType) {
                    tab = tabDef.tabId;
                }
            });
            if (!tab)
                return false;
            // toggle status;
            if (!this.visible) {
                if (!makeVisible) {
                    return false;
                }
                this.showContextFrames();
                this.renderContextFrames();
            }
            $('.nav-tabs a[href="#' + tab + '"]').tab('show');
            return true;
        }
        getExpender() {
            let that = this;
            let direction = this.shouldBeVisible ? "fa-arrow-to-right" : "fa-arrow-from-right";
            let icon = $('<div class="btn-group contextCloseX" ><button id="contextFrameButton" tabindex="-1" class="btn btn-item" data-original-title="Context frame"><span class="fal ' + direction + '"  ></span></button></div>');
            let faIcon = $(".fal", icon);
            icon.click(function () {
                that.toggleFunction();
            });
            return icon;
        }
        // get tabs enabled for project
        getTabs() {
            let tabs = [];
            let projectHelp = globals_1.globalMatrix.ItemConfig && globals_1.globalMatrix.ItemConfig.getContextPagesConfig();
            if (projectHelp && projectHelp.tabs) {
                tabs = projectHelp.tabs;
            }
            else {
                tabs = ContextFramesTools.defaultPages.tabs;
            }
            return tabs;
        }
        visibility(enabled) {
            if (enabled) {
                if (this.shouldBeVisible && !this.visible) {
                    this.showContextFrames();
                }
            }
            else if (this.visible) {
                this.hideContextFrames();
            }
        }
        // hide context frames, remember as hidden
        hideContextFrames() {
            $(".contextCloseX").show();
            $("#contextframemenu").html("Show Context Pages");
            $('#contextframe').addClass('hidden');
            $('#main').css("margin-right", "5px");
            //$('#contextframesizer').addClass('hidden');
            $('#contextframesizer').css('right', "0px");
            let contextframeWidth = Math.abs(Number(localStorage.getItem('contextframeWidth')));
            localStorage.setItem('contextframeWidth', (-contextframeWidth).toString());
            this.visible = false;
            this.setToogleIcon(false); // don't allow close it's closed
            $(document).trigger("contextFrameResized");
        }
        ;
        // show context frames, remember as displayed
        showContextFrames() {
            let ww = $(window).width();
            let sw = $('#sidebar').width() + $('#sidebar').position().left;
            let cw = Math.abs(Number(localStorage.getItem('contextframeWidth')));
            if (ww < 767) {
                // mobile device... hide
                $('#contextframe').addClass('hidden');
                $('#main').css("margin-right", 0);
                $('#contextframesizer').addClass('hidden');
                return;
            }
            // adjust context frame width (i.e. if the screen size changed)
            if (cw > Math.max(ww - sw, 0) / 2) {
                cw = (ww - sw) / 2;
                if (cw < 100) {
                    // hide temporarily... until screen is bigger
                    $('#contextframe').addClass('hidden');
                    $('#main').css("margin-right", 0);
                    $('#contextframesizer').addClass('hidden');
                    return;
                }
            }
            localStorage.setItem('contextframeWidth', cw.toString());
            $('#contextframe').css("width", (cw - 10) + "px").removeClass('hidden');
            $('#main').css("margin-right", (cw + 5) + "px");
            $('#contextframesizer').css("right", cw + "px").removeClass('hidden');
            let container = $('#contextframe .contextFrameContainer');
            let content = $('#contextframe .tab-content');
            let tabs = $('#contextframe .contextFrameTabs');
            content.height(container.height() - tabs.height());
            this.visible = true;
            this.setToogleIcon(true);
            $(document).trigger("contextFrameResized");
            $(document).trigger("contextFrameResized");
        }
        ;
        showSupport(panel, tabData) {
            let that = this;
            if (!this.support) {
                let formContainer = $(`<div data-cy="${tabData.title}">`);
                let requireEmail = globals_1.globalMatrix.matrixBaseUrl.indexOf('demo.matrixreq.com') !== -1 || globals_1.matrixSession.isSuperAdmin();
                formContainer.append('<p>You can use the form below to create a ticket with the Matrix help desk:</p>');
                formContainer.append('<form id="supportMailForm" role="form">'
                    + '  <div class="form-group"><label for="sup_summary">Summary:</label><input autocomplete="off" type="text" class="form-control" id="sup_summary" /></div>'
                    + '  <div class="form-group"><label for="sup_description">Description:</label> <textarea  class="form-control" id="sup_description" ></textarea> </div>'
                    + (requireEmail ? '  <div class="form-group sup_email"><label for="sup_email">E-mail:</label><input type="email" class="form-control" id="sup_email" /></div>' : '')
                    + '  <div class="text-center"><button href="#" class="btn btn-large btn-success" id="support_send" >Create Ticket</button></div>'
                    + '  <div class="text-center" style="padding:12px"><span id="sup_last_ticket">sending...</span></div>'
                    + '  <div class="form-group sup_metainfo"><label for="sup_project">Related Project(s):</label><input autocomplete="off" type="text" class="form-control" id="sup_project" /></div>'
                    + '  <div class="form-group sup_metainfo"><label for="sup_item">Related Item(s):</label><input autocomplete="off" type="text" class="form-control" id="sup_item" /></div>'
                    + '  <div class="form-group sup_metainfo"><label for="sup_browser">Browser Info:</label><textarea class="form-control" id="sup_browser" ></textarea></div>'
                    + '  <div class="form-group sup_metainfo"><label for="sup_log">Application Log:</label><textarea class="form-control" id="sup_log"></textarea>'
                    + ' <input type="hidden" id="sup_version" />'
                    + '</div>');
                panel.html("");
                panel.append(formContainer);
                $('#supportMailForm').on('keyup keypress', function (e) {
                    // prevent people hitting return (even multiple times? ...MATRIX-2253)
                    if (e.originalEvent && e.originalEvent.target && e.originalEvent.target.nodeName == "TEXTAREA") {
                        return true;
                    }
                    let keyCode = e.keyCode || e.which;
                    if (keyCode === 13) {
                        e.preventDefault();
                        return false;
                    }
                    return true;
                });
                $("#support_send").prop('disabled', true);
                $("#sup_last_ticket").hide();
                $("#sup_summary").on("change keyup paste", function () {
                    $("#support_send").prop('disabled', $("#sup_summary").val() == "" || (requireEmail && $("#sup_email").val() == ""));
                });
                $("#sup_email").on("change keyup paste", function () {
                    $("#support_send").prop('disabled', $("#sup_summary").val() == "" || (requireEmail && $("#sup_email").val() == ""));
                });
                $("#support_send").on("click", function (evt) {
                    $("#support_send").prop('disabled', true);
                    if (evt.preventDefault)
                        evt.preventDefault();
                    if (evt.stopPropagation)
                        evt.stopPropagation();
                    var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                    if (requireEmail && !re.test($("#sup_email").val())) {
                        matrixlib_1.ml.UI.showError("Invalid Email", "Please enter a correct email.");
                        return;
                    }
                    let param = {
                        summary: $("#sup_summary").val(),
                        description: $("#sup_description").val(),
                        matrixProject: $("#sup_project").val(),
                        matrixItem: $("#sup_item").val(),
                        browser: $("#sup_browser").val(),
                        log: $("#sup_log").val()
                    };
                    $("#sup_summary").val("");
                    if (requireEmail) {
                        param.email = $("#sup_email").val();
                    }
                    $("#sup_last_ticket").show();
                    let call_param = {
                        type: "POST",
                        url: globals_1.globalMatrix.matrixBaseUrl + "/rest/1/all/servicedesk",
                        data: JSON.stringify(param),
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        success: function (data) {
                            if (data.key) {
                                $("#sup_last_ticket").html("Created ticket " + data.key + " " + param.description);
                            }
                            else {
                                $("#sup_last_ticket").html(data.message);
                            }
                        },
                        error: function (errMsg) {
                            $("#sup_last_ticket").html("Failed to create ticket: " + errMsg);
                        }
                    };
                    $.ajax(call_param);
                });
                $("#sup_url").val(globals_1.globalMatrix.matrixBaseUrl);
                this.support = true;
            }
            let tz_offset = -(new Date().getTimezoneOffset()) / 60;
            let device = {
                screen: {
                    width: window.screen.width,
                    height: window.screen.height
                },
                viewport: {
                    width: 0,
                    height: 0
                }
            };
            let width = 0, height = 0;
            try {
                width = window.innerWidth || globals_1.globalMatrix.doc.documentElement.clientWidth || globals_1.globalMatrix.doc.body.clientWidth;
            }
            catch (e) { }
            try {
                height = window.innerHeight || globals_1.globalMatrix.doc.documentElement.clientHeight || globals_1.globalMatrix.doc.body.clientHeight;
            }
            catch (e) { }
            device.viewport = {
                width: width,
                height: height
            };
            $("#sup_browser").val(navigator.userAgent + "\nTimezone: " + tz_offset
                + "\nScreen width: " + device.screen.width
                + "\nScreen height: " + device.screen.height
                + "\nScreen viewport width: " + device.viewport.width
                + "\nScreen viewport height: " + device.viewport.height);
            // Get full version for SER ticket creation
            $("#sup_version").val(globals_1.app.getVersion());
            $("#sup_log").val(matrixlib_1.ml.Logger.getLog());
            const user = globals_1.matrixSession.getUser();
            let umail = (!globals_1.globalMatrix.ItemConfig || user == "demo") ? "" : globals_1.globalMatrix.ItemConfig.getEmail(user);
            $("#sup_email").val(umail);
            $("#sup_user").val(globals_1.matrixSession ? globals_1.matrixSession.getUser() : "");
            $("#sup_project").val(globals_1.matrixSession ? globals_1.matrixSession.getProject() : "");
            $("#sup_item").val(globals_1.app ? globals_1.app.getCurrentItemId() : "");
        }
        showHelp(panel, tabData) {
            panel.html("");
            let that = this;
            let help = "";
            if (!this.context || !this.context.itemId || (globals_1.matrixSession && globals_1.matrixSession.getProject() !== this.context.project)) {
                if (globals_1.matrixSession) {
                    help += '<p class="cathelp_summary">Welcome to the project ' + globals_1.matrixSession.getProject() + '</p>';
                    help += '<p class="">To get started explore the categories on the left.</p>';
                    help += '<br>';
                    help += '<br>';
                    help += '<br>';
                    help += '<br>';
                    help += '<br>';
                    panel.append(help);
                }
                return;
            }
            let item_type = matrixlib_1.ml.Item.parseRef(this.context.itemId).type;
            var projectHelp = globals_1.globalMatrix.ItemConfig.getContextPagesConfig();
            if (projectHelp && projectHelp.itemHelp && projectHelp.itemHelp[this.context.itemId]) {
                panel.append('<div class="cathelp text-left">' + projectHelp.itemHelp[this.context.itemId] + '</div>');
            }
            else if (projectHelp && projectHelp.categoryHelp && projectHelp.categoryHelp[item_type]) {
                panel.append('<div class="cathelp text-left">' + projectHelp.categoryHelp[item_type] + '</div>');
            }
            else {
                switch (this.context.itemId) {
                    case "F-PROJECT":
                        help += '<p class="cathelp_summary">Dashboards, reports and documents</p>';
                        help += '<p class="">In this folder you find <b>dashboards</b>, <b>reports</b>, <b>documents</b> as well as <b>signed / archived documents</b>.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>Dashboards are in the folder <b>AUDIT</b>. They can be used to see summaries of activities from the past</li>';
                        help += '<li>Reports are in the folder <b>REP</b>. Reports help to manage the project by extracting information about the status and the relationship of items in the database.</li>';
                        help += '<li>Documents are in <b>DOC</b>. Documents allow you to create your own reports with additional document headers and fields such as audit log or signature tables.</li>';
                        help += '<li>Signed / archived documents are in <b>SIGN</b>. Documents can be archived when a milestone has been reached. Once archived they will not change even if the items in the database changes and they can be signed electronically.</li>';
                        help += '</ul>';
                        break;
                    case "AUDIT":
                        help += '<p class="cathelp_summary">Audit tools show activities in the project</b>.</p>';
                        help += '<p class="">Depending on your project configuration the following tools are available in this folder:</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li><b>Changes</b> Shows a calendar view with all changes done by day.</li>';
                        help += '<li><b>Deleted Items</b> Show a list of deleted items, ordered by time.</li>';
                        help += '<li><b>Tags</b> Show a list tags that have been assigned to some point/version in the past.</li>';
                        help += '<li><b>Document Changes and Downloads</b> Shows when and by whom DOCs and SIGN items have been created and downloaded.</li>';
                        help += ' </ul>';
                        break;
                    case "DELETED":
                        help += '<p class="cathelp_summary">Deleted Items. Show a list of deleted items, ordered by time.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>You can restore deleted items by clicking on <b>restore</b>. This will restore the item into the project tree - in the same folder where it was when it was deleted. The item will be restored with all its history.</li>';
                        help += '<li>You tag (mark the point in time) when the item was deleted by clicking on <b>tag version</b>.</li>';
                        help += '</ul>';
                        break;
                    case "SYNC":
                        help += '<p class="cathelp_summary">Agile Sync.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>The agile sync module allows you to sync data from external tools such as JIRA, Confluence, TFS, Zephyr into Matrix</li>';
                        help += '<li>This dashboard allows you to sync multiple items quickly</b>.</li>';
                        help += '</ul>';
                        break;
                    case "MYDOCS":
                        help += '<p class="cathelp_summary">Signatures.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>Shows documents I need to sign</b>.</li>';
                        help += '</ul>';
                        break;
                    case "REDLINE":
                        help += '<p class="cathelp_summary">Redlining allows to compare project data between two dates</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>Select a from and to date/time and click on "compare" to show differences in items.</b>.</li>';
                        help += '<li>Select a from and click on "Timewarp" to browse the project as it was that day.</b>.</li>';
                        help += '</ul>';
                        break;
                    case "REVIEWS":
                        help += '<p class="cathelp_summary">Review Dashboard</p>';
                        help += '<ul class="cathelp_details">';
                        help += '<li>My Reviews: show all reviews I need to participate in and how much work I did already.</b></li>';
                        help += '<li>All Reviews: show all reviews how much work needs to be done.</b></li>';
                        help += '<li>Reviews Per Item: show all reviews done per item.</b></li>';
                        help += '</ul>';
                        break;
                    case "TAGS":
                        help += '<p class="cathelp_summary">Tags. Show a list of tags that have been assigned to some point/version in the past.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '    <li>Tags mark a point in time when a change occurred.</li>';
                        help += '    <li>Tags can be set in to changes done in the past (through the CHANGES dashboard).</li>';
                        help += '    <li>Tags can be used to restore a project until a certain point in the past (branch in the past).</li>';
                        help += '</ul>';
                        break;
                    case "CHANGES":
                        help += '<p class="cathelp_summary">Change Summary. Shows a calendar view with all changes done by day.</p>';
                        help += '<ul class="cathelp_details">';
                        help += '    <li>In the calendar view you can select a day or selection of days to see what changed in that period.</li>';
                        help += '    <li>You can tag version or just see the details of the changes in this stream.</li>';
                        help += '</ul>';
                        break;
                    case "DOCS":
                        help += '<p class="cathelp_summary">Document status and activity</p>';
                        help += '<p class="">Document Status. Shows when and by whom DOCs and SIGN items have been created, signed and downloaded.</p>';
                        break;
                    case "TAGS":
                        break;
                    default:
                        if (this.context.itemId) {
                            let itemId = this.context.itemId;
                            let isFolder = itemId.indexOf("F-") === 0;
                            let isTC = false; // mTM.isTC(item_type);
                            let isXTC = false; // mTM.isXTC(item_type);
                            let folderName = globals_1.app.getItemTitle("F-" + item_type + "-1");
                            let isSpecialItem = folderName === globals_1.app.getItemTitle("_NON_EXISTING_CATEGORY__");
                            let isXSLTType = item_type === "DOC" || item_type === "SIGN" || item_type === "REPORT";
                            // For all folders besides reports, docs, sign
                            if (!isXSLTType && isFolder && itemId.lastIndexOf("-1") + 2 === itemId.length) {
                                help += '<p class="cathelp_summary">This is the root folder of the category <span>' + globals_1.app.getItemTitle("F-" + item_type + "-1") + '</span></p>';
                                help += '<ul class="cathelp_details">';
                                help += '    <li>You can create a folder structure to organize the items of this category.</li>';
                                help += '    <li>You can create items of this type</li>';
                                help += '</ul>';
                            }
                            else if (!isXSLTType && isFolder && itemId.lastIndexOf("-1") + 2 !== itemId.length) {
                                help += '<p class="cathelp_summary">This is a folder of the category <span>' + globals_1.app.getItemTitle("F-" + item_type + "-1") + '</span></p>';
                                help += '<p class="">You can</p>';
                                help += '<ul class="cathelp_details">';
                                help += '    <li>create more folders of this category inside this folder.</li>';
                                if (!isXTC)
                                    help += '    <li>create items of the type ' + globals_1.app.getItemTitle("F-" + item_type + "-1") + '.</li>';
                                if (isXTC)
                                    help += '    <li>create test forms based on defined tests and use cases.</li>';
                                help += '</ul>';
                            }
                            // for all items besides DOC, SIGN, and REPORT, and special custom pages like JIRA, ZOHO
                            if (!isFolder && !isXSLTType && !isSpecialItem) {
                                help += '<p class="cathelp_summary">This item is of type <span>' + folderName + '</span></p>';
                                help += '<ul class="cathelp_details">';
                                help += '    <li>You can modify the title or the content and save it (hint: use ctrl-s).</li>';
                                help += '    <li>You can look at its history (<span class="helpGlyph fal fa-history"></span>).</li>';
                                help += '    <li>You can look at or modify the up or downlinks (<i class="helpGlyph fal fa-sitemap" aria-hidden="true"></i>).</li>';
                                if (isTC) {
                                    help += '<li>You can create a test form from this (<span class="helpGlyph fal fa-share">)</span>: <span style="font-style:italic">Prepare for test run</span>.</li>';
                                }
                                if (isXTC) {
                                    help += '<li>Execute the test. Hints: <ul><li>use keyboard shortcuts to set <span style="font-style:italic">actual results</span>';
                                    help += '<li><span style="font-style:italic">tab</span> to navigate between the cells</li>';
                                    help += '<li><span style="font-style:italic">shift return</span> in the comment cells to open a rich text editor, e.g. to attach images and files</li></ul></li>';
                                }
                                if (globals_1.globalMatrix.ItemConfig.getFieldsOfType("risk2", item_type).length > 0) {
                                    help += '<li>You can enter the parameters according to the configured risk formula.</li>';
                                }
                                help += '</ul>';
                                help += '<p>Traceability Information:</p>';
                                help += '<ul class="cathelp_details">';
                                $.each([true, false], function (tfi, required) {
                                    $.each([false, true], function (tfi, updown) {
                                        var cats = globals_1.globalMatrix.ItemConfig.getLinkTypes(item_type, updown, required);
                                        var text = (required ? 'required' : 'optional') + ' ' + (updown ? 'downlinks' : 'uplinks');
                                        if (cats.length === 0) {
                                            help += '    <li>There are no ' + text + ' configured.</li>';
                                        }
                                        else {
                                            help += '    <li>There are ' + text + ': ' + cats.join(', ') + '.</li>';
                                        }
                                    });
                                });
                                help += '</ul>';
                            }
                            // ZOHO JIRA,...
                            if (isSpecialItem) {
                            }
                            // for DOC 
                            if (item_type === "DOC") {
                                if (isFolder) {
                                    help += '<p class="cathelp_summary">Controlled documents basics</p>';
                                    help += '<p class="">Controlled documents allow you to extract and analyze data from the database in order to archive and electronically sign it as PDF or Word File.</p>';
                                    help += '<p class="">You can</p>';
                                    help += '<ul class="cathelp_details">';
                                    help += '    <li>define what the documents look like by selecting the sections, such as audit trail, purpose, scope, trace tables, list items, etc.</li>';
                                    help += '    <li>decide which content goes into the document, e.g. all requirements from one specific folder, or all tests results for a selected set of specifications.</li>';
                                    help += '    <li>download and review it as word, pdf or html.</li>';
                                    help += '    <li>archive it (this will make sure the content of document will not change even if the items in the database get updated afterwards)</li>';
                                    help += '    <li>electronically sign it</li>';
                                    help += '</ul>';
                                    help += '<img  class="cathelp_img" src="' + globals_1.globalMatrix.matrixBaseUrl + '/img/help/doc0.png">';
                                }
                                else {
                                    help += '<p class="cathelp_summary">Controlled document</p>';
                                    help += '<p class="">You can</p>';
                                    help += '<ul class="cathelp_details">';
                                    help += '    <li>modify the document.</li>';
                                    help += '    <li>download it as PDF, Word or html.</li>';
                                    help += '    <li>archive (freeze) it so that the content does not change anymore.</li>';
                                    help += '</ul>';
                                }
                                help += '<p class="cathelp_summary">Defining the structure</p>';
                                help += '<p class="">You can</p>';
                                help += '<ul class="cathelp_details">';
                                if (isFolder)
                                    help += '    <li>use a wizard to create new documents from scratch, by clicking on "Create Controlled Documents" button.</li>';
                                if (isFolder)
                                    help += '    <li>copy and paste an existing document from this or another project using the tool menu: <span class="fal fa-share"></span>.</li>';
                                // if (!isFolder) help += '    <li>modify an existing document by clicking on the configure section icon next to "' + mDHF.getArchiveButtonName() + '": <span class="fal fa-list"></span></li>';
                                if (!isFolder)
                                    help += '    <li>modify an existing document by clicking on the configure section icon next to "' + 'getArchiveButtonName' + '": <span class="fal fa-list"></span></li>';
                                help += '</ul>';
                                help += '<p class="">There are two types of document sections</p>';
                                help += '<ul class="cathelp_details">';
                                help += '    <li>Static sections: you type the content</li>';
                                help += '    <li>Dynamic sections: the content is taken from the database of entered items</li>';
                                help += '</ul>';
                                if (!isFolder) {
                                    help += '<img  class="cathelp_img" src="' + globals_1.globalMatrix.matrixBaseUrl + '/img/help/doc1.png">';
                                    help += '<p class="cathelp_summary">Changing the content and looks of sections</p>';
                                    help += '<p class="">You can</p>';
                                    help += '<ul class="cathelp_details">';
                                    help += '    <li>change the content by clicking on the triangle on the left of the section title</li>';
                                    help += '    <li>the looks by clicking on the <span class="fal fa-cog"></span> on the right of the section title</span></li>';
                                    help += '</ul>';
                                    help += '<img  class="cathelp_img" src="' + globals_1.globalMatrix.matrixBaseUrl + '/img/help/doc2.png">';
                                }
                            }
                            // for SIGN
                            if (item_type === "SIGN") {
                                if (isFolder) {
                                    help += '<p class="cathelp_summary">Archived documents</p>';
                                    help += '<p class="">Controlled documents allow you to extract and analyze data from the database in order to archive and electronically sign it as PDF or Word File.</p>';
                                    help += '<ul class="cathelp_details">';
                                    help += '   <li>Archived documents are controlled documents that have been archived and therefore will not change anymore.</li>';
                                    help += '   <li>You can only sign and download archived documents.</li>';
                                    help += '</ul>';
                                }
                                else {
                                    help += '<p class="cathelp_summary">Archived document</p>';
                                    help += '<p class="">Controlled documents with a signature table can be signed here.</p>';
                                }
                            }
                            // for REPORTS
                            if (item_type === "REPORT") {
                                if (isFolder) {
                                    help += '<p class="cathelp_summary">Reports</p>';
                                    help += '<p class="">Reports allow you to manage your project by</p>';
                                    help += '<ul class="cathelp_details">';
                                    help += '   <li>reviewing items</li>';
                                    help += '   <li>reviewing traceability</li>';
                                    help += '   <li>analyzing risks</li>';
                                    help += '   <li>planning tests</li>';
                                    help += '   <li>...</li>';
                                    help += '</ul>';
                                    help += '<p class="">If you want to create documents for certification, audits or archiving, see Controlled Documents (DOC) on the left side.</p>';
                                }
                                else {
                                    help += '<p class="cathelp_summary">Report</p>';
                                    help += '<p class="">This report can be created as html, PDF or word file.</p>';
                                }
                            }
                        }
                        ;
                        break;
                }
                panel.append('<div class="cathelp text-left">' + help + '</div>');
                panel.append('<hr>');
                var moreHelp = 'Questions? Here is the online <span id="helpDocu" class="helpLink">user guide</span>';
                if (tabData.hipchat) {
                    moreHelp += ', <a href="http://urlshort.matrixreq.com/helpdesk" target="_blank" class="helpLink" >Contact our service desk</a> with us send us an <span id="helpMail" class="helpLink">e-mail</span>';
                }
                else {
                    moreHelp += ' or send us an <span id="helpMail" class="helpLink">e-mail</span>';
                }
                panel.append('<p>' + moreHelp + '.</p>');
                $("#helpDocu").click(function () {
                    window.open("https://urlshort.matrixreq.com/d23/manual/main");
                });
                $("#helpMail").click(function () {
                    let email = globals_1.matrixSession.serverConfig.serviceEmail ? globals_1.matrixSession.serverConfig.serviceEmail : "support@matrixreq.com";
                    window.location.href = "mailto:" + email;
                });
            }
        }
        showSmartLinksTab(panel, tabData) {
            $("a[href='#" + tabData.tabId + "']").css("color", "");
            if (this.context.item && !matrixlib_1.ml.Item.parseRef(this.context.itemId).isFolder && this.resetSmartLinks) {
                this.resetSmartLinks = false; // avoid reloading same frame on tab switch
                panel.html("");
                var smartlinks = $(`<div data-cy="${tabData.title}">`);
                panel.append(smartlinks);
                panel.append("<br>");
                var item = JSON.parse(decodeURI(this.context.item));
                // match references (smart links) into project
                // not (folders) F-REQ-1 not (cross project).../REQ-1
                var regexstr = '((F-)*(\/)*(' + globals_1.globalMatrix.ItemConfig.getCategories(true).join("|") + ')-[1-9]+[0-9]*)';
                var re = new RegExp(regexstr, 'g');
                // parse fields
                var links = [];
                let inSection = {};
                $.each(globals_1.globalMatrix.ItemConfig.getItemConfiguration(item.type).fieldList, function (idx, field) {
                    if (field.fieldType === "richtext" || field.fieldType === "steplist" || field.fieldType === "test_steps" || field.fieldType === "test_steps_result" || field.fieldType === "dhf") {
                        var fieldVal = item[field.id];
                        var match = fieldVal ? fieldVal.match(re) : null;
                        if (match) {
                            $.each(match, function (midx, m) {
                                if (m.indexOf("F-") == 0 || m.indexOf("/") == 0)
                                    return; // folder or cross project are not yet supported
                                if (links.indexOf(m) === -1) {
                                    links.push(m);
                                }
                                let sn = (field.fieldType === "dhf") ? JSON.parse(fieldVal).name : field.label;
                                if (!inSection[m]) {
                                    inSection[m] = [];
                                }
                                if (inSection[m].indexOf(sn) == -1) {
                                    inSection[m].push(sn);
                                }
                            });
                        }
                    }
                });
                if (links.length === 0) {
                    smartlinks.append($("<div class='contextFrame-select-item'>").html("there are no smart links"));
                }
                else if (links.length > this.maxNumberOfLinks) {
                    this.renderIds(tabData, links, smartlinks, 'contextFramePreview contextFramePreviewUp', inSection, "There are to many smart links to show details.");
                }
                else {
                    this.renderFromIds(tabData, links, smartlinks, 'contextFramePreview contextFramePreviewUp', inSection);
                }
            }
            else if (this.resetSmartLinks) {
                panel.html("").append($("<div class='contextFrame-select-item'>").html("select an item to see smartlinks"));
            }
        }
        showReferencesTab(panel, tabData) {
            if (this.context.item && !matrixlib_1.ml.Item.parseRef(this.context.itemId).isFolder) {
                panel.html("");
                var uplinks = $("<div>");
                var downlinks = $("<div>");
                panel.append(uplinks);
                panel.append("<hr>");
                panel.append(downlinks);
                panel.append("<br>");
                let item = JSON.parse(decodeURI(this.context.item));
                if (item.upLinks.length === 0) {
                    uplinks.append($("<div class='contextFrame-select-item'>").html("there are no uplinks"));
                }
                else if (item.upLinks.length > this.maxNumberOfLinks) {
                    this.renderIds(tabData, this.getUpLinks(item), uplinks, 'contextFramePreview contextFramePreviewUp', null, "There are to many up links to show details.");
                }
                else {
                    this.renderFromIds(tabData, this.getUpLinks(item), uplinks, 'contextFramePreview contextFramePreviewUp');
                }
                if (item.downLinks.length === 0) {
                    downlinks.append($("<div class='contextFrame-select-item'>").html("there are no downlinks"));
                }
                else if (item.downLinks.length > this.maxNumberOfLinks) {
                    this.renderIds(tabData, this.getDownLinks(item), downlinks, 'contextFramePreview contextFramePreviewUp', null, "There are to many down links to show details.");
                }
                else {
                    this.renderFromIds(tabData, this.getDownLinks(item), downlinks, 'contextFramePreview contextFramePreviewDown');
                }
            }
            else {
                panel.html("").append($("<div class='contextFrame-select-item'>").html("select an item to see up and downlinks"));
            }
        }
        showItemsInFolderTab(panel, tabData) {
            if (this.context.item && matrixlib_1.ml.Item.parseRef(this.context.itemId).isFolder) {
                panel.html("");
                var items = $("<div>");
                panel.append(items);
                panel.append("<br>");
                this.renderAllInFolder(this.context.itemId, items);
            }
            else {
                panel.html("").append($("<div class='contextFrame-select-item'>").html("select a folder to see it's items"));
            }
        }
        showUpReferences(panel, tabData) {
            if (this.context.item && !matrixlib_1.ml.Item.parseRef(this.context.itemId).isFolder) {
                var links = $("<div>");
                panel.append(links);
                panel.append("<br>");
                this.renderAllUpOrDown(this.context.itemId, false, links);
            }
            else {
                panel.html("").append($("<div class='contextFrame-select-item'>").html("select an item to see the up references"));
            }
        }
        showDownReferences(panel, tabData) {
            if (this.context.item && !matrixlib_1.ml.Item.parseRef(this.context.itemId).isFolder) {
                var links = $("<div>");
                panel.append(links);
                panel.append("<br>");
                this.renderAllUpOrDown(this.context.itemId, true, links);
            }
            else {
                panel.html("").append($("<div class='contextFrame-select-item'>").html("select an item to see the down references"));
            }
        }
        getUpLinks(item) {
            let toDo = [];
            $.each(item.upLinks, function (lidx, link) {
                toDo.push(link.to);
            });
            return toDo;
        }
        getDownLinks(item) {
            let toDo = [];
            $.each(item.downLinks, function (lidx, link) {
                toDo.push(link.to);
            });
            return toDo;
        }
        // get full items for a number of items and render them
        renderFromIds(tabData, toDoList, render, renderClass, inSection) {
            let that = this;
            if (toDoList.length === 0) {
                return;
            }
            let searchExpr = toDoList.map(function (id) { return "id=" + id; }).join(" OR ");
            globals_1.app.getNeedlesAsync(searchExpr, false, true, "*", true, true).done(function (items) {
                $.each(toDoList, function (idx, itemId) {
                    let data = items.filter(function (item) { return item.id == itemId; });
                    if (data.length == 0) {
                        let linkDoesNotExist = $("<div class='contextFramePreview contextFramePreviewError'>");
                        render.append(linkDoesNotExist);
                        globals_1.matrixApplicationUI.renderErrorControl(linkDoesNotExist, "" + itemId + " does not exist", "Please correct the link.", true);
                        $("a[href='#" + tabData.tabId + "']").css("color", "red");
                    }
                    else if (globals_1.app.canViewItem(data[0])) {
                        var preview = $("<div class='" + renderClass + "'>");
                        render.append(preview);
                        var ctrl = new index_2.ItemControl({
                            control: preview,
                            controlState: globals_1.ControlState.Tooltip,
                            item: data[0],
                            isItem: (typeof data[0].children === 'undefined')
                        });
                        that.controls.push(ctrl);
                    }
                    else {
                        let noView = $("<div class='contextFramePreview contextFramePreviewError'>");
                        render.append(noView);
                        globals_1.matrixApplicationUI.renderErrorControl(noView, "You have no rights to view " + itemId + "", "Talk to the project administrator.", true);
                    }
                    if (inSection && inSection[itemId] && inSection[itemId].length) {
                        render.append($("<div class='TitleSpecial'>").html("used in: " + inSection[itemId].join(",")));
                    }
                });
            });
        }
        // show item ids as a flat list
        renderIds(tabData, toDoList, render, renderClass, inSection, infotext) {
            let that = this;
            render.append(infotext);
            render.append("<br>");
            let ul = $("<div>").appendTo(render);
            $.each(toDoList, function (idx, itemId) {
                let title = globals_1.app.getItemTitle(itemId);
                if (!title) {
                    let dash = itemId.indexOf("-");
                    $("<li><span style='font-weight:bold;color:red'><span>" + itemId.substr(0, dash) + "</span>" + itemId.substr(dash) + "</span> does not exist.</li>").appendTo(ul);
                    $("a[href='#" + tabData.tabId + "']").css("color", "red");
                }
                else {
                    $("<li>" + itemId + "!</li>").appendTo(ul);
                }
            });
            ul.highlightReferences();
        }
        nonBlockingRender(items, index, renderClass, render, hideShow) {
            let that = this;
            if (items.length <= index)
                return;
            let item = items[index];
            if (globals_1.app.canViewItem(item)) {
                let type = matrixlib_1.ml.Item.parseRef(item.id).type;
                let preview = $("<div class='" + renderClass + " " + type + "'>");
                render.append(preview);
                // need to hide after adding to DOM
                if (hideShow && !this.categoryFilter[type])
                    preview.hide();
                let ctrl = new index_2.ItemControl({
                    control: preview,
                    controlState: globals_1.ControlState.Tooltip,
                    item: item,
                    isItem: (typeof item.children === 'undefined')
                });
                that.controls.push(ctrl);
                // need to re-hide after adding to rendering
                if (hideShow && !this.categoryFilter[type])
                    preview.hide();
            }
            else {
                let noView = $("<div class='contextFramePreview contextFramePreviewUp'>");
                render.append(noView);
                globals_1.matrixApplicationUI.renderErrorControl(noView, "You have no rights to view " + item.id + "", "Talk to the project administrator.", true);
            }
            this.nonBlockingRenderNext = window.setTimeout(function () {
                that.nonBlockingRender(items, index + 1, renderClass, render, hideShow);
            }, 200);
        }
        renderAllUpOrDown(fromItemId, down, render) {
            let that = this;
            let renderSettings = {
                recursive: localStorage.getItem("recursive") == "1"
            };
            let filter = $("<div style='display:table'>").appendTo(render);
            matrixlib_1.ml.UI.addCheckbox(filter, "recursively", renderSettings, "recursive", function () {
                localStorage.setItem("recursive", renderSettings.recursive ? "1" : "0");
                render.html("");
                that.renderAllUpOrDown(fromItemId, down, render);
            }).css("display", "table-cell").addClass("showall_recursive");
            let renderClass = down ? "contextFramePreview contextFramePreviewDown" : "contextFramePreview contextFramePreviewUp";
            let recurse = renderSettings.recursive ? "m" : "";
            let searchExpr = down ? ("uplink" + recurse + "=" + fromItemId) : ("category!=XTC and downlink" + recurse + "=" + fromItemId);
            window.clearTimeout(this.nonBlockingRenderNext);
            globals_1.app.getNeedlesAsync(searchExpr, false, true, "*", true, true).done(function (items) {
                if (items.length == 0) {
                    that.showNothingFound(render);
                    return;
                }
                // find out which categories are returned and add checkbox to UI to show/hide that category
                let categories = [];
                $.each(items, function (idx, item) {
                    let type = matrixlib_1.ml.Item.parseRef(item.id).type;
                    if (categories.indexOf(type) == -1) {
                        // by default 'show items"
                        if (typeof that.categoryFilter[type] == 'undefined') {
                            that.categoryFilter[type] = type != "XTC";
                        }
                        matrixlib_1.ml.UI.addCheckbox(filter, type, that.categoryFilter, type, function () {
                            if (that.categoryFilter[type])
                                $("." + type, render).show();
                            else
                                $("." + type, render).hide();
                        }).css("display", "table-cell").css("padding-left", "12px").addClass("showall_" + type);
                        categories.push(type);
                    }
                });
                // render items
                that.nonBlockingRenderNext = window.setTimeout(function () {
                    that.nonBlockingRender(items, 0, renderClass, render, true);
                }, 200);
            });
        }
        renderAllInFolder(folderId, render) {
            let that = this;
            let renderSettings = {
                recursive: localStorage.getItem("recursiveFolder") == "1"
            };
            matrixlib_1.ml.UI.addCheckbox(render, "recursively", renderSettings, "recursive", function () {
                localStorage.setItem("recursiveFolder", renderSettings.recursive ? "1" : "0");
                render.html("");
                that.renderAllInFolder(folderId, render);
            }).addClass("showall_recursive");
            let renderClass = "contextFramePreview contextFramePreviewUp";
            let searchExpr = "folder" + (renderSettings.recursive ? "m" : "") + "=" + folderId;
            window.clearTimeout(this.nonBlockingRenderNext);
            globals_1.app.getNeedlesAsync(searchExpr, false, true, "*", true, true).done(function (items) {
                if (items.length == 0) {
                    that.showNothingFound(render);
                    return;
                }
                that.nonBlockingRenderNext = window.setTimeout(function () {
                    that.nonBlockingRender(items, 0, renderClass, render, false);
                }, 200);
            });
        }
        showNothingFound(render) {
            render.append("No items found.");
        }
        // write data into frames
        renderContextFrames() {
            this.controls = [];
            if (!this.exists || !this.visible || !this.context) {
                return;
            }
            let that = this;
            $.each(this.getTabs(), function (tabIdx, tabData) {
                var panel = $('#contextFrameSettingTab_' + tabIdx);
                if (tabData.type === "faq") {
                    // this is rendered statically once - keep it
                }
                else if (tabData.type === "support") {
                    that.showSupport(panel, tabData);
                }
                else if (tabData.type === "smartlinks") {
                    that.showSmartLinksTab(panel, tabData);
                }
                else if (tabData.type === "help") {
                    that.showHelp(panel, tabData);
                }
                else if (!panel.hasClass("active")) {
                    // don't actually render it just now, wait until user shows it
                    if (!panel.hasClass("noRefresh")) {
                        panel.html("").append(matrixlib_1.ml.UI.getSpinningWait("retrieving data"));
                    }
                }
                else if (tabData.type === "iframeget") {
                    let jp = matrixlib_1.ml.JSON.clone(that.context);
                    jp.item = "";
                    jp.fieldList = "";
                    var param = $.param(jp, true);
                    var page = tabData.baseURL + "?" + param;
                    $('.contextframeIframeget', panel)[0].src = page;
                }
                else if (tabData.type === "iframe") {
                    var iframePoster = $('<form style="display:none" target="contextframeIframe_' + tabIdx + '" method="post" action="' + tabData.baseURL + '">');
                    $("body").append(iframePoster);
                    $.each(that.context, function (vaIdx, va) {
                        iframePoster.append('<input type="hidden" name="' + vaIdx + '" value="' + va + '">');
                    });
                    iframePoster.submit().remove();
                }
                else if (index_1.ContextFrameManager.implements(tabData.type)) {
                    index_1.ContextFrameManager.renderTab(panel, tabData.type, tabData, that.context);
                }
                else if (tabData.type === "references") {
                    that.showReferencesTab(panel, tabData);
                }
                else if (tabData.type === "foldercontent") {
                    that.showItemsInFolderTab(panel, tabData);
                }
                else if (tabData.type === "upreferences") {
                    panel.html("");
                    that.showUpReferences(panel, tabData);
                }
                else if (tabData.type === "downreferences") {
                    panel.html("");
                    that.showDownReferences(panel, tabData);
                }
                else {
                    panel.html(tabData.type);
                }
            });
        }
        ;
        fillContextFrame(_data, itemId) {
            if (!this.exists) {
                return;
            }
            // save the data
            this.context = {
                project: globals_1.matrixSession.getProject(),
                user: globals_1.matrixSession.getUser(),
                server: globals_1.globalMatrix.matrixBaseUrl,
                version: globals_1.app.getVersion(),
                product: globals_1.globalMatrix.matrixProduct,
                itemId: itemId,
                item: _data ? encodeURI(JSON.stringify(_data)) : "",
                fieldList: _data ? encodeURI(JSON.stringify(globals_1.globalMatrix.ItemConfig.getItemConfiguration(_data.type).fieldList)) : ""
            };
            // fill the frames 
            this.resetSmartLinks = true;
            this.renderContextFrames();
        }
        ;
        // show context frames, remember as displayed
        init() {
            this.support = false; // make sure support tab is initialized
            this.exists = false;
            var contextBar = $("#contextframesizer");
            var container = $("#contextframe");
            if ($("#contextframe").length === 0) {
                // client has no context frames (e.g. admin, mobile, ...)
                return;
            }
            container.html("");
            if (this.getTabs().length === 0) {
                return;
            }
            let that = this;
            this.exists = true;
            // paint the tabs
            var tabpanel = $('<div role="tabpanel" class="tabpanel-container contextFrameContainer">');
            container.append(tabpanel);
            var tabpanelul = $('<ul class="nav nav-tabs contextFrameTabs" role="tablist">');
            tabpanel.append(tabpanelul);
            var tabpanels = $('<div class="tab-content">');
            tabpanel.append(tabpanels);
            $.each(this.getTabs(), function (tabIdx, tabData) {
                tabData.tabId = "contextFrameSettingTab_" + tabIdx;
                tabpanelul.append('<li data-cy="tab ' + tabData.title + '" role="presentation" ' + (tabIdx === 0 ? 'class="active"' : '') + '><a href="#contextFrameSettingTab_' + tabIdx + '"  role="tab" data-toggle="tab">' + tabData.title + '</a></li>');
                var panel = $('<div role="tabpanel"  style="height:100%" class="tabpaneltab tab-pane ' + (tabIdx === 0 ? 'active' : '') + '" id="' + tabData.tabId + '" >');
                tabpanels.append(panel);
                if (tabData.type === "iframe") {
                    panel.append(`<iframe data-cy="iframe ${tabData.title}" class="contextframeIframe" name="contextframeIframe_${tabIdx}"></iframe>`);
                }
                if (tabData.type === "iframeget") {
                    panel.append(`<iframe data-cy="iframe ${tabData.title}"  class="contextframeIframeget" name="contextframeIframe_${tabIdx}"></iframe>`);
                }
                else if (tabData.type === "faq") {
                    panel.append(`<iframe data-cy="iframe ${tabData.title}" class="contextframeIframe" name="contextframeIframe_${tabIdx}" src="https://urlshort.matrixreq.com/d23/faq" allowfullscreen="allowfullscreen"></iframe>`);
                }
                else if (tabData.type === "support") {
                    that.showSupport(panel, tabData);
                }
                else if (tabData.type === "help") {
                    that.showHelp(panel, tabData);
                }
            });
            $('a[data-toggle="tab"]', tabpanel).on('shown.bs.tab', function (e) {
                var target = $(e.target).attr("href"); // activated tab
                that.renderContextFrames();
            });
            // prepare initial size
            if (!localStorage.getItem('contextframeWidth')) {
                // it has never been shown, calculate default size amd 
                let contextframeWidth = $(document).width() - 722 - $("#main").position().left;
                if (contextframeWidth < 400) {
                    contextframeWidth = 400;
                }
                localStorage.setItem('contextframeWidth', contextframeWidth.toString());
            }
            // show frames if they should be visible
            var contextframeWidth = Number(localStorage.getItem('contextframeWidth'));
            if (Number(contextframeWidth) > 0) {
                this.shouldBeVisible = true;
                that.showContextFrames();
            }
            else {
                this.shouldBeVisible = false;
                that.hideContextFrames();
            }
            // to avoid bug that mouse up is stolen by iframe
            $(".contextframeIframe").mouseenter(function (e) {
                $(document).off('mousemove');
            });
            $(".contextframeIframeget").mouseenter(function (e) {
                $(document).off('mousemove');
            });
        }
        ;
    }
    exports.ContextFramesTools = ContextFramesTools;
    ContextFramesTools.defaultPages = {
        tabs: [{ title: "Help", type: "help", hipchat: false },
            { title: "Support", type: "support", hipchat: false }]
    };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(13), __webpack_require__(14), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(16), __webpack_require__(58), __webpack_require__(59), __webpack_require__(7), __webpack_require__(60), __webpack_require__(13), __webpack_require__(14), __webpack_require__(53), __webpack_require__(62), __webpack_require__(65), __webpack_require__(15), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, PluginManager_1, PluginManagerDocuments_1, PluginManagerFormulas_1, Tasks_1, TestManager_1, TrainingManager_1, Branching_1, DBCache_1, ItemConfiguration_1, MatrixReq_1, MatrixRequirementsAPI_1, MatrixSession_1, PluginManager_2, PluginManagerDocuments_2, PluginManagerFormulas_2, PushMessages_1, RestConnector_1, RestDB_1, Tasks_2, TestManager_2, TrainingManager_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializeBusinessLogic = void 0;
    __exportStar(Branching_1, exports);
    __exportStar(DBCache_1, exports);
    __exportStar(ItemConfiguration_1, exports);
    __exportStar(MatrixReq_1, exports);
    __exportStar(MatrixRequirementsAPI_1, exports);
    __exportStar(MatrixSession_1, exports);
    __exportStar(PluginManager_2, exports);
    __exportStar(PluginManagerDocuments_2, exports);
    __exportStar(PluginManagerFormulas_2, exports);
    __exportStar(PushMessages_1, exports);
    __exportStar(RestConnector_1, exports);
    __exportStar(RestDB_1, exports);
    __exportStar(Tasks_2, exports);
    __exportStar(TestManager_2, exports);
    __exportStar(TrainingManager_2, exports);
    function InitializeBusinessLogic() {
        // Why: sets up the global plugins
        PluginManager_1.InitializePluginManager();
        // Why: sets up the global mDHF, registers it as a plugin.
        PluginManagerDocuments_1.InitializePluginManagerDocuments();
        // Why: sets up the global mTasks
        Tasks_1.InitializeTasks();
        // Why: sets up the global mTM, registers it as a plugin.
        TestManager_1.InitializeTestManager();
        // Why: sets up the global ContextFrameManager.
        TrainingManager_1.InitializeTrainingManager();
        // Why: sets up the global tableMath.
        PluginManagerFormulas_1.InitializePluginManagerFormulas();
    }
    exports.InitializeBusinessLogic = InitializeBusinessLogic;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 13 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializePluginManager = exports.pluginHooks = exports.plugins = exports.PluginManager = void 0;
    let pluginHooks;
    exports.pluginHooks = pluginHooks;
    exports.pluginHooks = pluginHooks = { shares: 0 };
    class PluginManager {
        constructor() {
            this._plugins = [];
            this.controls = {};
            this.destructors = {};
            this.titles = {};
            this.usesFilters = {};
        }
        /** Called by the main UI handing over a div which can be used inside a plugin
         * to display modal popups
         *
         * @param {jquery object} jui a $("<div />") object
         * @returns {undefined}
         */
        setUI(jui) {
            this._jui = jui;
        }
        /** function to register a plugin for a specific menu (specified by the hook)
         *
         * @param {instance of plugin} plugin
         * @returns {undefined}
         */
        register(plugin) {
            this._plugins.push(plugin);
        }
        /** this method is called from the main UI whenever an item is selected to be
         * displayed. The information is forwarded to all plugins
         *
         * @param {json object} item for example a requirement. see the json documention of item types
         * @returns {undefined}
         */
        init(item) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].initItem) {
                    this._plugins[idx].initItem(item, this._jui);
                }
            }
        }
        /** this method is called after connecting to server using getServer ("")
         *
         * @param {json serverSettings} serverSettings or null after unsucessful login
         * @returns {undefined}
         */
        initServerSettings(serverSettings) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                try {
                    if (this._plugins[idx].initServerSettings) {
                        this._plugins[idx].initServerSettings(serverSettings);
                    }
                }
                catch (e) {
                    console.log("error " + e.toString());
                }
            }
        }
        /** this method is called when creating a menu which has a hook. it allows the plugins to add
         * li's to the ul supplied
         *
         * @param {number} hook identifies the menu
         * @param {jquery object} ul  a $("<ul />) object
         * @returns {undefined}
         */
        updateMenu(hook, ul) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].updateMenu) {
                    this._plugins[idx].updateMenu(ul, hook);
                }
            }
        }
        getFieldConfigOptions() {
            let fco = [];
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].getFieldConfigOptions) {
                    fco = fco.concat(this._plugins[idx].getFieldConfigOptions());
                }
            }
            return fco;
        }
        addFieldSettings(configApp, project, pageId, fieldType, fieldParams, ui, paramChanged, canBePublished) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].addFieldSettings) {
                    this._plugins[idx].addFieldSettings(configApp, project, pageId, fieldType, fieldParams, ui, () => paramChanged(), canBePublished);
                }
            }
        }
        supportsControl(ctrl) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].supportsControl && this._plugins[idx].supportsControl(ctrl)) {
                    return true;
                }
            }
            return false;
        }
        createControl(ctrlObj, settings) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].supportsControl && this._plugins[idx].supportsControl(settings.fieldType)) {
                    this._plugins[idx].createControl(ctrlObj, settings);
                    return;
                }
            }
        }
        initProject(project) {
            // delete all non default plugins === custom 
            for (var idx = this._plugins.length - 1; idx >= 0; idx--) {
                if (!this._plugins[idx].isDefault) {
                    this._plugins.splice(idx, 1);
                }
            }
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].initProject) {
                    this._plugins[idx].initProject(project);
                }
            }
        }
        // to modify db tree after it has been created
        filterProject(db) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].filterProject) {
                    this._plugins[idx].filterProject(db);
                }
            }
        }
        // to modify search panel on left after it has been rendered
        updateSearchPanel() {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].updateSearchPanel) {
                    this._plugins[idx].updateSearchPanel();
                }
            }
        }
        // to modify item on left after it has been rendered
        updateItemPanel() {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].updateItemPanel) {
                    this._plugins[idx].updateItemPanel();
                }
            }
        }
        // notify plugins that links of item changed
        updateItem(updates) {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].updateItem) {
                    this._plugins[idx].updateItem(updates);
                }
            }
        }
        ;
        updateTree() {
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].updateTree) {
                    this._plugins[idx].updateTree();
                }
            }
            return;
        }
        getProjectPages() {
            let that = this;
            let allPages = [];
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].getProjectPages) {
                    $.each(this._plugins[idx].getProjectPages(), function (idx, page) {
                        allPages.push(page);
                        that.controls["_" + page.id] = page.render;
                        that.destructors["_" + page.id] = page.destroy;
                        that.titles["_" + page.id] = page.title;
                        that.usesFilters["_" + page.id] = page.usesFilters;
                    });
                }
            }
            return allPages;
        }
        supportsControlPage(controlType) {
            return !!this.controls[controlType];
        }
        createControlPage(options) {
            options.control.html("");
            document.title = this.titles[options.type] + " - " + globals_1.matrixSession.getProject();
            if (this.usesFilters[options.type]) {
                $("#globalProjectFilter >> button").removeAttr("disabled");
            }
            this.activeControlPage = options.type;
            this.controls[options.type](options);
        }
        destroyActiveControlPage() {
            if (this.activeControlPage) {
                try {
                    const destructor = this.destructors[this.activeControlPage];
                    if (destructor) {
                        destructor();
                    }
                    this.activeControlPage = null;
                }
                catch (e) {
                    console.error("Error removing control page", e);
                }
            }
            else {
                // console.log("No active control page");
            }
        }
        callPreSaveHook(isItem, type, controls) {
            let that = this;
            function callRec(idx) {
                var res = $.Deferred();
                if (idx >= that._plugins.length) {
                    res.resolve();
                    return res;
                }
                if (that._plugins[idx].preSaveHook) {
                    that._plugins[idx].preSaveHook(isItem, type, controls).done(function () {
                        callRec(idx + 1).done(function () {
                            res.resolve();
                        }).fail(function () {
                            res.reject();
                        });
                    }).fail(function () {
                        callRec(idx + 1).always(function () {
                            res.reject();
                        });
                    });
                }
                else {
                    callRec(idx + 1).done(function () {
                        res.resolve();
                    }).fail(function () {
                        res.reject();
                    });
                }
                return res;
            }
            return callRec(0);
        }
        // return true for handled, false for not  handled
        renderActionButtons(options, body, controls) {
            var done = false;
            for (var idx = 0; idx < this._plugins.length; idx++) {
                if (this._plugins[idx].renderActionButtons) {
                    if (this._plugins[idx].renderActionButtons(options, body, controls)) {
                        done = true;
                    }
                }
            }
            // return true if at least on plugin is owner
            return done;
        }
        ;
        /******************** admin function  */
        getPlugins() {
            return this._plugins;
        }
    }
    exports.PluginManager = PluginManager;
    var plugins;
    exports.plugins = plugins;
    function InitializePluginManager() {
        exports.plugins = plugins = new PluginManager(); // plugin manager 
        globalThis.plugins = plugins;
        globalThis.pluginHooks = pluginHooks;
    }
    exports.InitializePluginManager = InitializePluginManager;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 14 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(13), __webpack_require__(4), __webpack_require__(15), __webpack_require__(38), __webpack_require__(36), __webpack_require__(1), __webpack_require__(10), __webpack_require__(20), __webpack_require__(48), __webpack_require__(51), __webpack_require__(52), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, PluginManager_1, index_1, RestDB_1, docBase_1, markAsTemplate_1, matrixlib_1, RefLinkDefines_1, ItemCreationView_1, Layouter_1, Redlining_1, Hidden_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializePluginManagerDocuments = exports.mDHF = exports.ColumnTypesInfo = exports.PluginManagerDocuments = exports.DocumentSectionType = void 0;
    var DocumentSectionType;
    (function (DocumentSectionType) {
        DocumentSectionType[DocumentSectionType["Static"] = 1] = "Static";
        DocumentSectionType[DocumentSectionType["Database"] = 2] = "Database";
        DocumentSectionType[DocumentSectionType["Table"] = 3] = "Table";
        DocumentSectionType[DocumentSectionType["Technical"] = 4] = "Technical";
        DocumentSectionType[DocumentSectionType["CustomTable"] = 5] = "CustomTable";
    })(DocumentSectionType || (DocumentSectionType = {}));
    exports.DocumentSectionType = DocumentSectionType;
    const DOC_NUM_NAME = "Document Number";
    class PluginManagerDocuments {
        constructor() {
            this.COPY_PASTE_BUFFER = "pasteBuffer";
            this.isDefault = true;
            let that = this;
            this.wasInformedTodayAbout = "";
            this.wasInformedToday = "";
            this.sectionFactories = [];
            this.sectionTypeNames = {};
        }
        // **********************
        // plugin interface
        // **********************
        initItem(_item, _jui) {
            this.item = _item;
            this.jui = _jui;
        }
        updateMenu(ul, hook) {
            // no tools
            let that = this;
            if (matrixlib_1.ml.Item.parseRef(this.item.id).isFolder) {
                // find out if there items in buffer
                let pb = localStorage.getItem(this.COPY_PASTE_BUFFER);
                let itemsToPaste = pb ? JSON.parse(pb).items.length : 0;
                if (itemsToPaste && this.isDocumentFormType(this.item.type)) {
                    let s = (itemsToPaste > 1) ? "s" : "";
                    var pasteDoc = $('<li title="paste document' + s + ' from template"><a href="javascript:void(0)">Paste document' + s + '</a></li>').click(function () {
                        that.pasteTemplates(that.item.id);
                    });
                    ul.append(pasteDoc);
                }
            }
            if ((this.isSignedType(this.item.type) || this.isDocumentFormType(this.item.type))) {
                let s = matrixlib_1.ml.Item.parseRef(this.item.id).isFolder ? "s" : "";
                var copyDoc = $('<li title="Copy document' + s + ' as template"><a href="javascript:void(0)">Copy document' + s + '</a></li>').click(function () {
                    that.copyTemplates(that.item.id);
                });
                ul.append(copyDoc);
            }
        }
        supportsControl(ctrl) {
            // should render dhf controls....
            return false;
        }
        createControl(ctrl, options) {
            // should render dhf controls....
        }
        initProject(project) {
            let that = this;
            this.dhf_config = globals_1.globalMatrix.ItemConfig.getDHFConfig();
            if (!this.dhf_config) {
                this.dhf_config = {};
            }
            if (!this.dhf_config.categories) {
                this.dhf_config.categories = {
                    documentTypes: ["DOC", "SIGN", "REPORT"],
                    documentForms: ["DOC"],
                    documentSigned: ["SIGN"],
                    documentTemplates: ["SIGN"],
                    signAs: "SIGN"
                };
            }
            this.ColumnTypes = new ColumnTypesInfo(this.dhf_config);
            // add custom tables for each type
            $.each(this.dhf_config, function (key0, config0) {
                if (typeof config0 === "object") {
                    $.each(config0, function (key1, config1) {
                        if (key1 === "columns") {
                            $.each(config1, function (idx, val) {
                                if (val.columnType) {
                                    val.editor = that.ColumnTypes.getEditorOfType(val.columnType);
                                    var options = that.ColumnTypes.getOptionsOfType(val.columnType);
                                    if (options) {
                                        val.options = options;
                                    }
                                }
                            });
                        }
                    });
                }
            });
        }
        getProjectPages() { return []; }
        renderActionButtons(options, body, controls) {
            if (!globals_1.matrixSession.hasDocs() && (this.isSignedType(options.item.type) || this.isDocumentFormType(options.item.type))) {
                body.append("<span style='color:red'>Document module not licensed</span>");
                return true;
            }
            if (this.dhf_config.categories.documentSigned.indexOf(options.type) !== -1) {
                this.renderControlsSIGN(options, body, controls);
                return true;
            }
            else if (mDHF.isDocumentFormType(options.type)) {
                this.renderControlsDOC(options, body, controls);
                return true;
            }
            return false;
        }
        // *****************************
        // public interface through mDHF
        // *****************************
        /* this renders an empty dhf control. It needs the actual field value to find out
        */
        renderControl(ctrl, ctrlParameter, fieldValue) {
            let that = this;
            // store values in control so that they can be rendered by the controller
            let ctrlDef = ctrl;
            ctrlDef.isDhfType = true;
            var controller = this.dhfFactory("hidden"); // if nothing is configured - nothing to render
            if (fieldValue) { // contains type,value,configuration, and xml for reports
                ctrlDef.dhfValue = JSON.parse(fieldValue);
                // create the controller
                controller = this.dhfFactory(ctrlDef.dhfValue.type);
                ctrlParameter.fieldValue = ctrlDef.dhfValue.fieldValue;
                ctrlParameter.help = ctrlDef.dhfValue.name;
            }
            ctrlParameter.preciseSelection = globals_1.matrixSession.getUISettings().preciseDocSelect ? true : false;
            // render the control
            controller.renderControl(ctrlDef, ctrlParameter);
            if (ctrlParameter.canEdit && ctrlDef.dhfValue && !ctrlParameter.isTooltip && !ctrlParameter.isPrint && ctrlParameter.controlState != globals_1.ControlState.HistoryView && globals_1.matrixSession.isEditor()) {
                let search = $("<button title='Update Selection' style='display:none' class='btn btn-xs btn-default hidden-print refreshButton refreshNeeded'> <span class='fal fa-sync-alt' style='margin-left: -1px;'></span></button>");
                search.click(function (event) {
                    that.runSearch(controller, ctrlDef);
                });
                // get the dhf section type
                let sectionName = "";
                if (ctrlDef && ctrlDef.dhfValue && ctrlDef.dhfValue.type && this.getDhfControls()[ctrlDef.dhfValue.type]) {
                    sectionName = this.getDhfControls()[ctrlDef.dhfValue.type].sectionName;
                }
                // add buttons
                var button = $("<button title='Configure " + sectionName + "' class='btn btn-xs btn-default hidden-print configbutton'> <span class='fal fa-cog'></span></button>");
                if (ctrlDef.dhfValue.type == "checkbox") {
                    $(".baseControl", ctrlDef.control).append(button);
                }
                else if ($(".inlineHelp", ctrlDef.control).length) {
                    $(".inlineHelp", ctrlDef.control).before(search).before(button);
                }
                else {
                    $(".baseControlHelp", ctrlDef.control).append(search).append(button);
                }
                var ctrlParam = ctrlParameter;
                if (ctrlDef.dhfValue.type == "CustomSection") {
                    $("<button title='Layout " + sectionName + "' class='btn btn-xs btn-default hidden-print configbutton'> <span class='fal fa-table'></span></button>")
                        .appendTo($(".baseControlHelp", ctrlDef.control))
                        .click(function () {
                        let layouter = new Layouter_1.Layouter();
                        let froms = "";
                        let tos = "";
                        let currentSelection = globals_1.app.getFieldValue(ctrlDef.fieldId);
                        if (currentSelection) {
                            // get selected items from UI
                            let conf = JSON.parse(currentSelection);
                            froms = (conf.from ? conf.from : []).map(x => x.to).join(",");
                            tos = (conf.to ? conf.to : []).map(x => x.to).join(",");
                        }
                        if (!froms) {
                            matrixlib_1.ml.UI.showError("need input!", "You need to select some items on which to report on");
                            return;
                        }
                        let config = controller.getConfig(ctrlDef);
                        ctrlDef.dhfValue['ctrlConfig'] = config;
                        let labelFilter = globals_1.globalMatrix.ItemConfig.getFieldsOfType("docFilter").length == 1 ? globals_1.app.getFieldValue(globals_1.globalMatrix.ItemConfig.getFieldsOfType("docFilter")[0].field.id) : "";
                        layouter.show(globals_1.app.getCurrentItemId(), ctrlDef.fieldId, matrixlib_1.ml.JSON.clone(Object.assign(Object.assign({}, config), {})), froms, tos, labelFilter, (newCode) => {
                            controller.getConfig(ctrlDef).options = JSON.parse(newCode);
                            ctrl.configTouched = true;
                            ctrlParameter.valueChanged.apply(null);
                        });
                    });
                }
                button.click(function () {
                    that.showConfigDialog(sectionName, controller, ctrlDef, ctrlParam, "Configuration Options", false);
                });
                if (controller.hasSearch && controller.hasSearch(ctrl)) {
                    // show search button
                    $(".baseControlHelp", ctrlDef.control).addClass("refreshNeeded");
                    search.show();
                    if (controller.verifySearch) {
                        controller.verifySearch(ctrlDef);
                    }
                }
                if (controller.verifyContent)
                    controller.verifyContent(ctrlDef);
            }
            return !ctrlDef.dhfValue || ctrlDef.dhfValue.type !== "checkbox";
        }
        // ItemForm
        getValue(ctrl) {
            if (!ctrl.dhfValue) {
                // unused control
                return "";
            }
            // create the controller
            var controller = this.dhfFactory(ctrl.dhfValue.type);
            // udpate the controller values
            ctrl.dhfValue['fieldValue'] = ctrl.control.getController().getValue();
            controller.updateXmlValue(ctrl);
            // define global options
            var controllerConfig = controller.getConfig(ctrl);
            var global = {
                globalOptions: true,
                page_break: controllerConfig['page_break'],
                sub_section: controllerConfig['sub_section'],
                landscape: controllerConfig['landscape'],
                show_section_title: controllerConfig['show_section_title'],
                automation: controllerConfig['automation']
            };
            // get specific options of control and add global as a row
            var options = JSON.parse(ctrl.dhfValue['fieldValueXML']);
            options.push(global);
            // update the xml dump
            ctrl.dhfValue['fieldValueXML'] = JSON.stringify(options);
            ctrl.dhfValue.name = (DOMPurify.sanitize(ctrl.dhfValue.name) + '').replace(/&lt;/g, "<");
            return JSON.stringify(ctrl.dhfValue);
        }
        /* used by ItemForm to figure if item needs to be saved */
        configChanged(ctrl) {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                let allControls = globals_1.matrixApplicationUI.lastMainItemForm.controls;
                for (var idx = 0; idx < allControls.length; idx++) {
                    if (allControls[idx].isDhfType && allControls[idx].dhfValue) {
                        let controller = this.dhfFactory(allControls[idx].dhfValue.type);
                        if (controller.verifyContent)
                            controller.verifyContent(allControls[idx]);
                    }
                }
            }
            return ctrl.configTouched;
        }
        /* return default format for REPORTs and DOCUMENTs, used by ItemForm for REPORTs */
        getDefaultFormat(category) {
            if (this.dhf_config.defaultFormats && this.dhf_config.defaultFormats[category]) {
                return this.dhf_config.defaultFormats[category].toLowerCase();
            }
            return (category === "REPORT") ? "html" : "docx";
        }
        // DB Cache
        showInProjectFolder(category) {
            return !(this.dhf_config && this.dhf_config.renderInTree && this.dhf_config.renderInTree.indexOf(category) !== -1);
        }
        // ItemForm, toolbar, ... (default DOC, SIGN, REPORT)
        isDocumentType(category) {
            return this.getDocumentTypes().indexOf(category) !== -1;
        }
        // used from different document sections (default DOC, SIGN, REPORT)
        getDocumentTypes() {
            return this.dhf_config ? matrixlib_1.ml.JSON.clone(this.dhf_config.categories.documentTypes) : [];
        }
        // DOC
        getDocumentFormTypes() {
            return this.dhf_config ? this.dhf_config.categories.documentForms : [];
        }
        // SIGN (could be DOC and SIGN)
        getDocumentTemplatesTypes() {
            return this.dhf_config ? this.dhf_config.categories.documentTemplates : [];
        }
        // KeyboardManager (default DOC)
        isDocumentFormType(category) {
            return mDHF.getDocumentFormTypes().indexOf(category) !== -1;
        }
        // ItemReference, MatrixReq, PluginManager, RestDb (default SIGN)
        isSignedType(category) {
            return this.dhf_config.categories.documentSigned.indexOf(category) !== -1;
        }
        // docSIGN
        // get all SIGN of an doc, maybe with a specific filter
        getSignedAsync(docId, labelFilter) {
            let that = this;
            function addChildren(children, ids) {
                $.each(children, function (cidx, child) {
                    if (child.isUnselected == 0) {
                        if (typeof child.children !== "undefined") {
                            addChildren(child.children, ids);
                        }
                        else {
                            ids.push(child.id);
                        }
                    }
                });
            }
            let res = $.Deferred();
            // get the document details which has a list of all downlinks
            globals_1.app.getItemAsync(docId).done(function (doc) {
                if (labelFilter) {
                    // get the tree with a label filter which shows which items have the label
                    var cmd = "/tree?fancy&filter=" + labelFilter;
                    globals_1.restConnection.getServer(globals_1.matrixSession.getProject() + cmd).done(function (tree) {
                        // build a list of item ids which are not filters
                        tree = RestDB_1.RestDB.filterLegacyReportCat(tree);
                        let signs = [];
                        $.each(tree, function (catidx, cat) {
                            if (that.dhf_config.categories.documentSigned.indexOf(cat.type) !== -1) {
                                addChildren(cat.children, signs);
                            }
                        });
                        let refs = [];
                        // check for each downlink if it has the label or not
                        $.each(doc.downLinks, function (dlidx, dl) {
                            if (signs.indexOf(dl.to) !== -1) {
                                refs.push(dl);
                            }
                        });
                        res.resolve(refs);
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
                else {
                    // return all downlinks
                    res.resolve(doc.downLinks);
                }
            }).fail(function (jqxhr, textStatus, error) {
                res.reject(jqxhr, textStatus, error);
            });
            return res;
        }
        // all different document sections
        registerSection(sectionType, sectionId, sectionName, creator, hidden) {
            this.registerSection2(sectionType, true, sectionId, sectionName, creator, hidden);
        }
        registerSection2(sectionType, dynamic, sectionId, sectionName, creator, hidden) {
            this.sectionFactories[sectionId] = creator;
            if (sectionName) {
                this.sectionTypeNames[sectionId] = {
                    sectionName: sectionName,
                    sectionType: sectionType,
                    hidden: hidden,
                    dynamic: dynamic
                };
            }
        }
        getSections(dynamic) {
            let that = this;
            let sections = Object.keys(this.sectionTypeNames);
            return sections.filter(section => that.sectionTypeNames[section].dynamic == dynamic);
        }
        // in case the user wants to delete a DOC which happens to be a DOC from which a SIGN has been created which is used as template, ask
        isUsedAsTemplate(itemId) {
            let type = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (type == "DOC" || type == "SIGN") {
                let templates = globals_1.globalMatrix.ItemConfig.getSettingJSON(markAsTemplate_1.MarkAsTemplateImpl.PROJECT_SETTING);
                if (templates && templates.templates) {
                    let filter = templates.templates.filter(function (td) { return (type == "DOC") ? td.fromDOC == itemId : td.fromSign == itemId; });
                    if (filter.length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        // in case the user wants to delete a DOC which happens to be a DOC from which a SIGN has been created which is used as template, remove the templates
        removeAsTemplate(itemId) {
            let type = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (type == "DOC" || type == "SIGN") {
                let templates = globals_1.globalMatrix.ItemConfig.getSettingJSON(markAsTemplate_1.MarkAsTemplateImpl.PROJECT_SETTING);
                templates.templates = templates.templates.filter(function (td) { return (type == "DOC") ? td.fromDOC != itemId : td.fromSign != itemId; });
                globals_1.app.setSettingJSON(markAsTemplate_1.MarkAsTemplateImpl.PROJECT_SETTING, templates);
            }
        }
        runSearch(controller, ctrl) {
            if (controller.executeSearch) {
                controller.executeSearch(ctrl);
            }
        }
        //show config dialog for section, some part like title are available for all, rest is provided by sections itself
        showConfigDialog(sectionName, _controller, _ctrl, _ctrlParameter, title, hideStandardOptions) {
            var controller = _controller;
            var ctrl = _ctrl;
            var ctrlParameter = _ctrlParameter;
            var controllerConfig = controller.getConfig(ctrl);
            if (typeof controllerConfig.show_section_title == 'undefined') {
                // default show title and apply numbering if wanted
                controllerConfig.show_section_title = "auto";
            }
            let isCheckbox = ctrl && ctrl.dhfValue && ctrl.dhfValue.type == "checkbox";
            let isRichtext = ctrl && ctrl.dhfValue && ctrl.dhfValue.type == "richtext";
            let isRisk = ctrl && ctrl.dhfValue && ctrl.dhfValue.type == "riskstats";
            let isFirstSection = globals_1.globalMatrix.ItemConfig.getFieldsOfType("dhf", "DOC")[0].field.id == ctrlParameter.fieldId;
            var ui = $("<div>");
            if (!hideStandardOptions) {
                // add common stuff (like name change)
                var name = $("<div>").refLink({
                    folder: false,
                    id: "Name" + (sectionName ? (" of " + sectionName) : "") + ":",
                    title: ctrl.dhfValue.name,
                    style: RefLinkDefines_1.refLinkStyle.edit,
                    tooltip: RefLinkDefines_1.refLinkTooltip.none,
                    callback: function () {
                    }
                });
                ui.append(name);
                if (!isCheckbox) {
                    var globalOptionShowSectionTitle = $('<select class="docOptionSelect p_show_section_title form-control" style="">' +
                        '<option value="auto">Show section title</option>' +
                        '<option value="nonumber">Show section title without numbers</option>' +
                        ((!isRichtext && !isRisk) ? '<option value="notitle">Do not show section title</option>' : '') +
                        (isRichtext ? '<option value="notitle">Do not show section title (note: do not use headings in the text box)</option>' : '') +
                        '</select>');
                    ui.append($(globalOptionShowSectionTitle));
                    globalOptionShowSectionTitle.val(controllerConfig.show_section_title);
                }
                var globalOptionNewPage = '<div class="checkbox" ><label><input type="checkbox" class="p_newpage" ' + (controllerConfig.page_break ? 'checked' : '') + '> Add page break after this section (word and pdf)</label></div>';
                ui.append($(globalOptionNewPage));
                if (!isCheckbox) {
                    let isFirstSection = globals_1.globalMatrix.ItemConfig.getFieldsOfType("dhf", "DOC")[0].field.id == ctrlParameter.fieldId;
                    var globalOptionSubSection = `<div class="checkbox" ><label><input type="checkbox" class="p_subsection" ${controllerConfig.sub_section ? 'checked' : ''} ${(isFirstSection && !controllerConfig.sub_section) ? 'disabled' : ''}> Make it a sub-section${isFirstSection ? " (note: first section cannot be a sub-section!)" : ""}</label></div>`;
                    ui.append($(globalOptionSubSection));
                }
                var globalOptionLandscape = '<div class="checkbox" ><label><input type="checkbox" class="p_landscape" ' + (controllerConfig.landscape ? 'checked' : '') + '> Print this section in landscape</label></div>';
                ui.append($(globalOptionLandscape));
                var globalOptionAutomation = $('<input autocomplete="off" style="height: 20px;width: 420px;float: right;" class="form-control p_automation" type="text" name="automation" value="" /> ');
                var sp = $("<span>XSLT processing: </span>").append(globalOptionAutomation);
                ui.append(sp);
                ui.append("<div style='padding:4px'>");
                globalOptionAutomation.val(controllerConfig.automation ? controllerConfig.automation : '');
            }
            // per function stuff
            var custom = $("<div>");
            ui.append(custom);
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.append(ui);
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            let searchBefore = controllerConfig["search"] + "," + controllerConfig["searchFrom"] + "," + controllerConfig["searchTo"];
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: title,
                height: 580,
                width: 680,
                modal: true,
                open: function () {
                    controller.showSpecificSettings(ctrl, ctrlParameter, custom);
                },
                resizeStop: function () {
                },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            // common settings
                            if (!hideStandardOptions && ctrl.dhfValue.name !== name.getValue()) {
                                ctrl.dhfValue.name = name.getValue();
                                ctrl.configTouched = true;
                                if (isCheckbox) {
                                    ctrl.control.find(".checkboxLabel").html(ctrl.dhfValue.name);
                                }
                                else {
                                    let bcs = ctrl.control.find(".baseControlHelp").contents();
                                    $.each(bcs, function (bcIdx, bc) {
                                        if (bc.nodeName == "#text") {
                                            bc.textContent = ctrl.dhfValue.name;
                                        }
                                    });
                                }
                            }
                            controllerConfig = controller.getConfig(ctrl);
                            if (!isCheckbox) {
                                // save controls
                                var showHide = $("input:first", ctrl.control);
                                showHide.detach();
                                var label = $("label:first", ctrl.control);
                                label.detach();
                                // specific settings
                                if (controller.saveSpecificSettings(ctrl, ctrlParameter, custom)) {
                                    ctrl.configTouched = true;
                                }
                                // remove 'normal' help and add doc stuff again
                                $(".baseControlHelp", ctrl.control).remove();
                                ctrl.control.prepend(label);
                                ctrl.control.prepend(showHide);
                                let searchAfter = controllerConfig["search"] + "," + controllerConfig["searchFrom"] + "," + controllerConfig["searchTo"];
                                if (searchAfter.replace(/undefined/g, "").length == 2) {
                                    $(".refreshButton", ctrl.control).removeClass("refreshNeeded").hide();
                                    $(".baseControlHelp", ctrl.control).removeClass("refreshNeeded");
                                }
                                else {
                                    $(".refreshButton", ctrl.control).show();
                                    if (searchAfter != searchBefore) {
                                        $(".refreshButton", ctrl.control).addClass("refreshNeeded");
                                        $(".baseControlHelp", ctrl.control).addClass("refreshNeeded");
                                    }
                                }
                                if (!hideStandardOptions && controllerConfig.show_section_title != $(ui.find(".p_show_section_title")[0]).val()) {
                                    controllerConfig.show_section_title = $(ui.find(".p_show_section_title")[0]).val();
                                    // save the checkbox change!
                                    ctrl.dhfValue['ctrlConfig'] = controllerConfig;
                                    ctrl.configTouched = true;
                                }
                                if (!hideStandardOptions && controllerConfig['sub_section'] != $(ui.find(".p_subsection")[0]).prop('checked')) {
                                    controllerConfig['sub_section'] = $(ui.find(".p_subsection")[0]).prop('checked');
                                    // save the checkbox change!
                                    ctrl.dhfValue['ctrlConfig'] = controllerConfig;
                                    ctrl.configTouched = true;
                                }
                            }
                            if (!hideStandardOptions && controllerConfig['page_break'] != $(ui.find(".p_newpage")[0]).prop('checked')) {
                                controllerConfig['page_break'] = $(ui.find(".p_newpage")[0]).prop('checked');
                                // save the checkbox change!
                                ctrl.dhfValue['ctrlConfig'] = controllerConfig;
                                ctrl.configTouched = true;
                            }
                            if (!hideStandardOptions && controllerConfig['landscape'] != $(ui.find(".p_landscape")[0]).prop('checked')) {
                                controllerConfig['landscape'] = $(ui.find(".p_landscape")[0]).prop('checked');
                                // save the checkbox change!
                                ctrl.dhfValue['ctrlConfig'] = controllerConfig;
                                ctrl.configTouched = true;
                            }
                            if (!hideStandardOptions && controllerConfig['automation'] != $(ui.find(".p_automation")[0]).val()) {
                                controllerConfig['automation'] = $(ui.find(".p_automation")[0]).val();
                                // save the checkbox change!
                                ctrl.dhfValue['ctrlConfig'] = controllerConfig;
                                ctrl.configTouched = true;
                            }
                            if (ctrl.configTouched && ctrlParameter.valueChanged) {
                                ctrlParameter.valueChanged.apply(null);
                            }
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            });
        }
        // ContextFrames (Help Tool)
        getArchiveButtonName() {
            if (this.dhf_config && this.dhf_config.archiveButtonName) {
                return this.dhf_config.archiveButtonName;
            }
            return "Ready to Sign / Release";
        }
        getToolFolderName() {
            if (this.dhf_config && this.dhf_config.toolFolderName) {
                return this.dhf_config.toolFolderName;
            }
            return null;
        }
        // ItemControl
        showCreateFromDocx(options) {
            let that = this;
            function doImport(params) {
                // show spinning wait
                globals_1.app.dlgForm.html("").append(matrixlib_1.ml.UI.getSpinningWait("Converting document ..."));
                matrixlib_1.ml.UI.setEnabled($('button', globals_1.app.dlgForm.parent()), false);
                // convert document
                let fileId = JSON.parse(params.template)[0].fileId;
                let fileNo = Number(fileId.split("?")[0]);
                globals_1.app.convertDocAsync(fileNo, options.parent).done(function (docId) {
                    // patch the document
                    globals_1.app.getItemAsync(docId).done(function (newDoc) {
                        let changes = { id: docId, onlyThoseFields: 1, onlyThoseLabels: 1 };
                        changes.title = params.dhfName;
                        let type = matrixlib_1.ml.Item.parseRef(docId).type;
                        let docNumberField = globals_1.globalMatrix.ItemConfig.getFieldId(type, DOC_NUM_NAME);
                        $.each(newDoc, function (fieldId, fieldValue) {
                            let fieldType = globals_1.globalMatrix.ItemConfig.getFieldType(type, fieldId);
                            if (fieldType === "dhf") {
                                if (fieldValue) {
                                    let parsed = JSON.parse(fieldValue);
                                    if (parsed.type === "richtext" && parsed.fieldValue) {
                                        parsed.fieldValue = new index_1.HTMLCleaner(parsed.fieldValue, false).getClean(index_1.HTMLCleaner.CleanLevel.Strict, false);
                                        parsed.fieldValueXML = JSON.stringify([{ "globalOptions": true }]);
                                        changes[fieldId] = JSON.stringify(parsed);
                                    }
                                }
                            }
                            else if (fieldType === "textline" && "" + fieldId == "" + docNumberField && params.dhfNumber) {
                                changes[fieldId] = params.dhfNumber;
                            }
                        });
                        if (params.dhfGUID) {
                            let guid = globals_1.globalMatrix.ItemConfig.getFieldsOfType("guid", type);
                            if (guid.length == 1) {
                                changes[guid[0].field.id] = params.dhfGUID;
                            }
                        }
                        let fileAttachmentControl = globals_1.globalMatrix.ItemConfig.getFieldsOfType("fileManager", type);
                        if (fileAttachmentControl.length > 0) {
                            changes[fileAttachmentControl[0].field.id] = params.template;
                        }
                        globals_1.app.updateItemInDBAsync(changes, "post docx conversion").always(function (newItem) {
                            let createdItem = {
                                parent: options.parent,
                                position: 100000,
                                item: newItem
                            };
                            globals_1.app.insertInTree(createdItem);
                            globals_1.app.updateCache(createdItem);
                            globals_1.app.treeSelectionChangeAsync(docId);
                            matrixlib_1.ml.UI.setEnabled($('button', globals_1.app.dlgForm.parent()), true);
                            globals_1.app.dlgForm.dialog("close");
                        });
                    });
                });
            }
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Import and Convert Word Document",
                height: 400,
                width: 720,
                modal: true,
                open: function () {
                    var okButton = $('.btnDoIt', globals_1.app.dlgForm.parent());
                    that.showDHFCreateWizard(options.type, globals_1.app.dlgForm, $('.btnDoIt', globals_1.app.dlgForm.parent()), doImport, true);
                },
                resizeStop: function () {
                },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            });
        }
        // docReview control
        loadDocument(jobId, onLoad) {
            let that = this;
            globals_1.app.getReportDetails(jobId).done(function (progress) {
                if (progress.status === "Error" || progress.status.indexOf("Report generation error") === 0) {
                    matrixlib_1.ml.UI.showError("Error creating document", "");
                }
                else if (progress.status !== "Done" || progress.progress < 100) {
                    window.setTimeout(function () {
                        that.loadDocument(jobId, onLoad);
                    }, 500);
                }
                else {
                    globals_1.app.downloadInMemory(jobId, progress.jobFile[progress.jobFile.length - 1].jobFileId.toString()).done(function (htmlpage) {
                        var htmlDOM = $.parseHTML(htmlpage);
                        if (!htmlDOM) {
                            matrixlib_1.ml.Logger.log("error", "Received report is no (valid) HTML.");
                        }
                        else {
                            for (var idx = 0; idx < htmlDOM.length; idx++) {
                                if (htmlDOM[idx].id === "report") {
                                    onLoad(htmlDOM[idx]);
                                }
                            }
                        }
                    });
                }
            });
        }
        getSignatureMeanings() {
            if (this.dhf_config) {
                return this.dhf_config.signatureMeanings;
            }
            return null;
        }
        // *****************
        // private interface 
        // *****************
        /* returns sections from a pre-configure document, e.g. report, plan, sop, ... */
        getDefaultFields(option) {
            var fields = [];
            if (this.dhf_config.controlledDocs[option]) {
                $.each(this.dhf_config.controlledDocs[option].fields, function (index, value) {
                    $.each(value, function (key, val) {
                        fields.push({ type: key, name: val });
                    });
                });
            }
            return fields;
        }
        getDhfControls() {
            let that = this;
            mDHF.dhf_config;
            let sn = {};
            let keys = Object.keys(this.sectionTypeNames);
            keys.sort();
            $.each(keys, function (idx, key) {
                sn[key] = that.sectionTypeNames[key];
            });
            // add custom columns to section options
            if (this.dhf_config.customTables) {
                $.each(this.dhf_config.customTables, function (index, table) {
                    sn[table.id] = {
                        sectionName: table.name, sectionType: DocumentSectionType.CustomTable, hidden: false, dynamic: false
                    };
                });
            }
            return sn;
        }
        // for admin client
        setConfig(config) {
            this.dhf_config = config;
        }
        appendConfigTool(creationButtons, _config, _item) {
            let that = this;
            if (!globals_1.matrixSession.isEditor() || !globals_1.globalMatrix.ItemConfig.canEdit(_item.type)) {
                return;
            }
            var itemId = _item.id;
            var buttonHolder = $("<button id='documentConfig' title='Document Sections' class='btn btn-xs btn-default hidden-print'> <span class='fal fa-cog'></span></button>");
            creationButtons.append(" ").append(buttonHolder);
            buttonHolder.click(function () {
                if (globals_1.app.getNeedsSave()) {
                    matrixlib_1.ml.UI.showError("Save Item", "Please save before modifying document options.");
                    return;
                }
                globals_1.app.getItemAsync(itemId).done(function (item) {
                    var added = false;
                    var update = { onlyThoseFields: 1, onlyThoseLabels: 1 };
                    $.each(item, function (key, val) {
                        if (key === "type" || key === "title" || key === "id" || globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key)) {
                            if (!added && globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === 'dhf' && !val) {
                                added = true;
                                update[key] = JSON.stringify({ "type": "document_options", "name": "Document Options", "fieldValue": "", "ctrlConfig": { "auto_number": false, "omit_title": false } });
                            }
                            else {
                                update[key] = val;
                            }
                        }
                    });
                    if (!added) {
                        matrixlib_1.ml.UI.showError("Cannot add document options!", "");
                        return;
                    }
                    globals_1.app.updateItemInDBAsync(update, "report update").done(function (result) {
                        globals_1.app.renderItem(result);
                        $("#buttonDocOptions").click();
                    }).fail(function (error) {
                        matrixlib_1.ml.UI.showError("Failed to save changes!", error);
                    });
                });
            });
            var button = $("<button title='Document Sections' class='btn btn-xs btn-default hidden-print dhfConfigureSections'> <span class='fal fa-list'></span></button>");
            creationButtons.append(" ").append(button);
            button.click(function () {
                if (globals_1.app.getNeedsSave()) {
                    matrixlib_1.ml.UI.showError("Save Item", "Please save before modifying document sections.");
                    return;
                }
                matrixlib_1.ml.UI.setEnabled(button, false);
                globals_1.app.getItemAsync(itemId).done(function (item) {
                    matrixlib_1.ml.UI.setEnabled(button, true);
                    that.reorderDialog(item);
                });
            });
        }
        getSignatures(allControls) {
            var signatures = [];
            for (var idx = 0; idx < allControls.length; idx++) {
                if (allControls[idx].isDhfType && allControls[idx].dhfValue) {
                    let controller = this.dhfFactory(allControls[idx].dhfValue.type);
                    controller.addSignatures(signatures, allControls[idx], true);
                }
            }
            return signatures;
        }
        showDHFCreateWizard(category, dlgInner, nextButton, endWizard, importDocx) {
            let that = this;
            function enableNext() {
                var enabled = (documentName.getController().getValue() && documentName.getController().getValue() !== "");
                if (importDocx) {
                    let val = createTemplate.getController().getValue();
                    if (val && JSON.parse(val).length > 0) {
                        if (!enabled) {
                            documentName.getController().setValue(JSON.parse(val)[0].fileName.replace(".docx", ""));
                        }
                        enabled = true;
                    }
                    else {
                        enabled = false;
                    }
                }
                matrixlib_1.ml.UI.setEnabled(nextButton, enabled);
            }
            // create wizard
            matrixlib_1.ml.UI.setEnabled(nextButton, false);
            var documentName = $("<div>");
            documentName.plainText({
                controlState: globals_1.ControlState.DialogCreate,
                canEdit: true,
                // TODO(modules): field dummyData wasn't in the original definition, why is it here?
                dummyData: false,
                help: 'Document Name',
                fieldValue: "",
                valueChanged: function () {
                    enableNext();
                },
                parameter: {
                    rows: 1,
                    allowResize: false
                }
            });
            dlgInner.append(documentName);
            let documentId = null;
            if (globals_1.globalMatrix.ItemConfig.getFieldId(category, DOC_NUM_NAME)) {
                documentId = $("<div>");
                documentId.plainText({
                    controlState: globals_1.ControlState.DialogCreate,
                    canEdit: true,
                    dummyData: false,
                    help: DOC_NUM_NAME,
                    fieldValue: "",
                    valueChanged: function () {
                    },
                    parameter: {
                        rows: 1,
                        allowResize: false
                    }
                });
                dlgInner.append(documentId);
            }
            let documentGUID = null;
            let createTemplate = $("<div>");
            /* prepare pre-configured document types, e.g. report, plan, sop... to be used in a drop down */
            var options = [];
            for (var opt in this.dhf_config.controlledDocs) {
                options.push({ id: opt, label: opt });
            }
            var dhfConfig = $("<div>");
            dlgInner.append(dhfConfig);
            if (importDocx) {
                createTemplate.fileManager({
                    controlState: globals_1.ControlState.DialogCreate,
                    canEdit: true,
                    help: "Word Document",
                    fieldValue: "",
                    valueChanged: function () {
                        enableNext();
                    },
                    parameter: {
                        readonly: false,
                        replace: "type_auto",
                        autohide: false,
                        manualOnly: true,
                        titleBarControl: null,
                        extensions: ["docx"],
                        textTodo: "Upload word document",
                        single: true
                    }
                });
            }
            else {
                // alow user to choose default layout
                createTemplate.mxDropdown({
                    controlState: globals_1.ControlState.DialogCreate,
                    canEdit: true,
                    dummyData: false,
                    help: 'Document Sections',
                    fieldValue: "Empty",
                    valueChanged: function () {
                    },
                    parameter: {
                        placeholder: "choose field preset",
                        create: false,
                        options: options,
                        maxItems: 1,
                        sort: false
                    }
                });
            }
            dlgInner.append(createTemplate);
            // execute the next only once
            nextButton.one("click", function (event) {
                if (importDocx) {
                    endWizard({
                        template: createTemplate.getController().getValue(),
                        dhfName: documentName.getController().getValue() ? documentName.getController().getValue() : "no name",
                        dhfNumber: (documentId && documentId.getController().getValue()) ? documentId.getController().getValue() : "no id",
                        dhfGUID: documentGUID ? documentGUID.getController().getGuid() : ""
                    });
                    if (event.preventDefault)
                        event.preventDefault();
                    return false;
                }
                documentName.hide();
                if (documentId)
                    documentId.hide();
                if (documentGUID)
                    documentGUID.hide();
                createTemplate.hide();
                var dhfDefaultFields = mDHF.getDefaultFields(createTemplate.getController().getValue());
                let sectionSelect = [];
                $.each(mDHF.getDhfControls(), function (key, val) {
                    if (key !== 'document_options' && !val.hidden) {
                        sectionSelect.push({ id: key, label: val.sectionName, class: val.sectionType.toString() });
                    }
                });
                // sort by group + alphabet
                var sortedSectionTypes = [DocumentSectionType.Static.toString(), DocumentSectionType.Technical.toString(), DocumentSectionType.Database.toString(), DocumentSectionType.Table.toString(), DocumentSectionType.CustomTable.toString()];
                sectionSelect.sort(function (a, b) {
                    if (sortedSectionTypes.indexOf(a.class) < sortedSectionTypes.indexOf(b.class))
                        return -1;
                    if (sortedSectionTypes.indexOf(a.class) > sortedSectionTypes.indexOf(b.class))
                        return 1;
                    return a.label < b.label ? -1 : 1;
                });
                // insert separators
                // sectionSelect.splice(0,0 ,{id:"CUSTOMSECTION", label:"CUSTOM SECTION", disabled:true});
                var pos = sectionSelect.map(function (ss) { return ss.class; }).indexOf(DocumentSectionType.Static.toString());
                if (pos != -1)
                    sectionSelect.splice(pos, 0, { id: "Static", label: "Static", disabled: true });
                pos = sectionSelect.map(function (ss) { return ss.class; }).indexOf(DocumentSectionType.Database.toString());
                if (pos != -1)
                    sectionSelect.splice(pos, 0, { id: "Static", label: "Dynamic (Database)", disabled: true });
                pos = sectionSelect.map(function (ss) { return ss.class; }).indexOf(DocumentSectionType.Table.toString());
                if (pos != -1)
                    sectionSelect.splice(pos, 0, { id: "Static", label: "TOCs and Indexes", disabled: true });
                pos = sectionSelect.map(function (ss) { return ss.class; }).indexOf(DocumentSectionType.CustomTable.toString());
                if (pos != -1)
                    sectionSelect.splice(pos, 0, { id: "Static", label: "Custom Tables", disabled: true });
                dhfConfig.tableCtrl({
                    controlState: globals_1.ControlState.DialogCreate,
                    canEdit: true,
                    dummyData: false,
                    help: 'Configure Sections',
                    fieldValue: JSON.stringify(dhfDefaultFields),
                    valueChanged: function () {
                    },
                    parameter: {
                        maxRows: that.getNumberOfDHFSections(category),
                        canBeModified: true,
                        columns: [{ name: "Section Title", field: "name", editor: "textline" },
                            { name: "Type", field: "type", editor: "select", options: sectionSelect }
                        ]
                    }
                });
                // prepare next step
                // disable next for one second
                nextButton.prop("disabled", true);
                nextButton.addClass("ui-state-disabled");
                window.setTimeout(function () {
                    nextButton.prop("disabled", false);
                    nextButton.removeClass("ui-state-disabled");
                    $("span", nextButton).html("Create");
                }, 1000);
                nextButton.click(function (event) {
                    matrixlib_1.ml.UI.setEnabled(nextButton, false);
                    let dhfItems = (dhfConfig.getController().getValue() ? JSON.parse(dhfConfig.getController().getValue()) : []);
                    dhfItems = dhfItems.filter(function (row) {
                        return !!row.type;
                    }).map(function (row) {
                        if (!row.name) {
                            row.name = row.type;
                        }
                        return row;
                    });
                    endWizard({
                        dhfItems: dhfItems,
                        dhfName: documentName.getController().getValue() ? documentName.getController().getValue() : "no name",
                        dhfNumber: (documentId && documentId.getController().getValue()) ? documentId.getController().getValue() : "no id",
                        dhfGUID: documentGUID ? documentGUID.getController().getGuid() : ""
                    });
                    if (event.preventDefault)
                        event.preventDefault();
                    return false;
                });
                if (event.preventDefault)
                    event.preventDefault();
                return false;
            });
        }
        getBaseDOCofSIGN(project, itemSigned) {
            let res = $.Deferred();
            let parents = itemSigned.upLinkList ? itemSigned.upLinkList.filter(ul => matrixlib_1.ml.Item.parseRef(ul.itemRef).type == "DOC") : [];
            if (parents.length == 0) {
                matrixlib_1.ml.Logger.warning("there's a SIGN without a parent DOC - cannot fill sign Info");
                res.reject();
                return res;
            }
            let signCreationDate = new Date(itemSigned.history[itemSigned.history.length - 1].date);
            let vl = parents[0].itemRef;
            let theDoc = matrixlib_1.ml.Item.parseRef(vl);
            globals_1.app.getProjectItemAsync(project, theDoc.id).done(function (docWithHistory) {
                // go through history of DOC and find the version which existed just before creating the SIGN
                let docIdx = docWithHistory.history.length - 1;
                while (docIdx >= 0 && new Date(docWithHistory.history[docIdx].date) <= signCreationDate) {
                    docIdx--;
                }
                // that's the version used to create the SIGN
                let docVersion = docWithHistory.history[docIdx + 1].version;
                // get that version of the DOC
                globals_1.app.getProjectItemAsync(project, theDoc.id, docVersion).done(function (itemDoc) {
                    res.resolve(itemDoc);
                }).fail(() => {
                    res.reject();
                });
            }).fail(() => {
                res.reject();
            });
            return res;
        }
        createFromTemplate(project, signId, title, options) {
            let that = this;
            globals_1.app.getProjectCatFields(project).done(function (categories) {
                globals_1.app.getProjectItemAsync(project, signId).done(function (itemSigned) {
                    if (itemSigned.isDeleted) {
                        matrixlib_1.ml.UI.showError("Instantiating Template Failed", "SIGN has been deleted.");
                        return;
                    }
                    let signType = matrixlib_1.ml.Item.parseRef(signId).type;
                    if (that.isDocumentFormType(signType)) {
                        that.transformTemplate(signId, categories, itemSigned, itemSigned.title, project, options);
                    }
                    else {
                        that.getBaseDOCofSIGN(project, itemSigned).done((itemDoc) => {
                            that.transformTemplate(signId, categories, itemDoc, itemSigned.title ? itemSigned.title : title, project, options);
                        }).fail(() => {
                            matrixlib_1.ml.UI.showError("Instantiating Template Failed", "The DOC has been deleted.");
                        });
                    }
                });
            }).fail(function (jqxhr, textStatus, error) {
                matrixlib_1.ml.UI.showError("Instantiating Template Failed", "You have no access to this template");
            });
        }
        transformTemplate(signId, categories, itemDoc, title, project, options) {
            let that = this;
            let pasteBuffer = [];
            let guidFieldId = 0;
            $.each(categories, function (cidx, cat) {
                if (cat.category.shortLabel === itemDoc.type) {
                    let fields = cat.fieldList.field;
                    $.each(fields, function (fidx, f) {
                        pasteBuffer.push({
                            def: f,
                            val: itemDoc[f.id]
                        });
                        if (f.fieldType === "guid") {
                            guidFieldId = f.id;
                        }
                    });
                }
            });
            var itemJson = {};
            itemJson.title = title;
            const docfields = globals_1.globalMatrix.ItemConfig.getItemConfiguration(matrixlib_1.ml.Item.parseRef(options.parent).type).fieldList;
            const pastebufferDHF = pasteBuffer.filter(pb => pb.def.fieldType === "dhf");
            const pastebufferNonDHF = pasteBuffer.filter(pb => pb.def.fieldType !== "dhf");
            $.each(docfields, function (fidx, f) {
                for (let idx = 0; idx < pastebufferNonDHF.length; idx++) {
                    if (pastebufferNonDHF[idx].def.label === f.label) {
                        itemJson[f.id] = pastebufferNonDHF[idx].val;
                    }
                }
            });
            const dhfDocFields = docfields.filter(df => df.fieldType === "dhf");
            if (dhfDocFields.length < pastebufferDHF.length) {
                matrixlib_1.ml.UI.showError("Template does not match target project", "The target project DOCs don't have enough section fields. Please contact your admin to increase the number of sections in the DOC category");
            }
            else {
                for (let it = 0; it < pastebufferDHF.length; it++) {
                    itemJson[dhfDocFields[it].id] = pastebufferDHF[it].val;
                }
                itemJson.title = title;
                that.pasteTemplate({ tree: null, items: [] }, 0, options.parent, true, itemJson, guidFieldId ? itemDoc[guidFieldId] : "", project, signId);
            }
        }
        // itemId:  an item : an item or folder
        copyTemplates(itemId) {
            let res = $.Deferred();
            let tree = globals_1.app.getSubTree(itemId);
            let items = globals_1.app.getChildrenIdsRec(itemId);
            this.preparePasteBuffer(tree);
            let showProgressBar = items.length > 1;
            if (showProgressBar) {
                matrixlib_1.ml.UI.BlockingProgress.Init([{ name: "Copying Documents" }]);
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 1);
            }
            this.copyTemplate(items, 0, !showProgressBar).done(function () {
                if (showProgressBar) {
                    matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100);
                }
            }).fail(function (error) {
                if (showProgressBar) {
                    matrixlib_1.ml.UI.BlockingProgress.SetProgressError(0, error);
                }
            }).always(function () {
                res.resolve();
            });
            return res;
        }
        copyTemplate(items, itemIdx, quiet) {
            let that = this;
            let res = $.Deferred();
            if (items.length == itemIdx) {
                res.resolve();
                return res;
            }
            let itemId = items[itemIdx];
            if (!quiet) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100 * itemIdx / items.length);
            }
            globals_1.app.getItemAsync(itemId).done(function (item) {
                if (that.isDocumentFormType(matrixlib_1.ml.Item.parseRef(itemId).type)) {
                    globals_1.app.getItemAsync(itemId, item.history[0].version).done(function (item_h) {
                        that.addToPasteBuffer(item_h, item.title, itemId + "-v" + item.history[0].version, itemId);
                        that.copyTemplate(items, itemIdx + 1, quiet).done(function () {
                            res.resolve();
                        }).fail(function (error) {
                            res.reject(error);
                        });
                    }).fail(function (error) {
                        res.reject(error);
                    });
                }
                else if (item.upLinkList && item.upLinkList.length && that.isDocumentFormType(matrixlib_1.ml.Item.parseRef(item.upLinkList[0].itemRef).type)) {
                    let vl = item.upLinkList[0].itemRef;
                    let docVersion = matrixlib_1.ml.Item.parseRef(vl);
                    globals_1.app.getItemAsync(docVersion.id, docVersion.version).done(function (item) {
                        that.addToPasteBuffer(item, item.title, vl, itemId);
                        that.copyTemplate(items, itemIdx + 1, quiet).done(function () {
                            res.resolve();
                        }).fail(function (error) {
                            res.reject(error);
                        });
                    }).fail(function (error) {
                        res.reject(error);
                    });
                }
            });
            return res;
        }
        pasteTemplates(folderId) {
            let that = this;
            let currentBufferString = localStorage.getItem(this.COPY_PASTE_BUFFER);
            let pasteBuffers = (currentBufferString ? JSON.parse(currentBufferString) : { items: [] });
            if (pasteBuffers.items.length > 1) {
                matrixlib_1.ml.UI.BlockingProgress.Init([{ name: "Pasting Documents" }]);
            }
            this.pasteTemplate(pasteBuffers, 0, folderId, pasteBuffers.items.length == 1);
        }
        pasteTemplate(pasteBuffers, pasteIdx, folderId, quiet, itemSource, sourceGUID, sourceProject, sourceItem) {
            let that = this;
            if (!quiet) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100 * pasteIdx / pasteBuffers.items.length);
            }
            let targetCategory = matrixlib_1.ml.Item.parseRef(folderId).type;
            let sourceref = 0;
            let srfs = globals_1.globalMatrix.ItemConfig.getFieldsOfType("sourceref", targetCategory);
            if (srfs.length) {
                sourceref = srfs.length ? srfs[0].field.id : 0;
            }
            // prepare the item to be created
            var itemJson = {};
            if (itemSource) {
                itemJson = itemSource;
                if (sourceref) {
                    itemJson[sourceref] = sourceProject + "/" + sourceItem;
                }
            }
            else {
                let pasteBuffer = pasteBuffers.items[pasteIdx];
                itemJson.title = pasteBuffer.title;
                if (sourceref) {
                    itemJson[sourceref] = pasteBuffer.sourceProject + "/" + pasteBuffer.sourceItem;
                }
                var fields = globals_1.globalMatrix.ItemConfig.getItemConfiguration(targetCategory).fieldList;
                $.each(fields, function (fidx, f) {
                    for (var idx = 0; idx < pasteBuffer.item.length; idx++) {
                        if (pasteBuffer.item[idx].def.label === f.label && sourceref != f.id) {
                            itemJson[f.id] = pasteBuffer.item[idx].val;
                        }
                    }
                });
            }
            globals_1.app.createItemOfTypeAsync(targetCategory, itemJson, "instantiated template", folderId).done(function (result) {
                if (pasteBuffers.items.length > pasteIdx + 1) {
                    that.pasteTemplate(pasteBuffers, pasteIdx + 1, folderId, quiet, itemSource, sourceGUID);
                }
                else {
                    if (!quiet) {
                        matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100);
                    }
                    globals_1.app.treeSelectionChangeAsync(result.item.id);
                }
            }).fail(function (error) {
                if (!quiet) {
                    matrixlib_1.ml.UI.BlockingProgress.SetProgressError(0, error);
                }
            });
        }
        // returns first field of a given 
        getFieldByType(fieldType, controls) {
            for (var idx = 0; idx < controls.length; idx++) {
                if (controls[idx].ctrlType === fieldType) {
                    return controls[idx].control.getController();
                }
            }
            return null;
        }
        /** requires sectionName or sectionType to identify field(s) */
        getDHFFieldValuesFromItem(sectionName, sectionType) {
            let that = this;
            let value = [];
            $.each(this.item, function (key, val) {
                if (val && globals_1.globalMatrix.ItemConfig.getFieldType(that.item.type, key) === "dhf") {
                    var fieldVal = JSON.parse(val);
                    if ((sectionName && fieldVal.name.toLocaleLowerCase() === sectionName.toLocaleLowerCase()) ||
                        (sectionType && fieldVal.type.toLocaleLowerCase() === sectionType.toLocaleLowerCase())) {
                        value.push(fieldVal);
                    }
                }
            });
            return value;
        }
        /** requires sectionName or sectionType to identify field */
        setDHFFieldValueOfItem(sectionName, sectionType, newValue) {
            let that = this;
            $.each(this.item, function (key, val) {
                if (val && globals_1.globalMatrix.ItemConfig.getFieldType(that.item.type, key) === "dhf") {
                    var fieldVal = JSON.parse(val);
                    if ((sectionName && fieldVal.name.toLocaleLowerCase() === sectionName.toLocaleLowerCase()) ||
                        (sectionType && fieldVal.type.toLocaleLowerCase() === sectionType.toLocaleLowerCase())) {
                        fieldVal.fieldValue = newValue;
                        let change = { id: that.item.id, onlyThoseFields: 1, onlyThoseLabels: 1 };
                        change[key] = JSON.stringify(fieldVal);
                        globals_1.app.updateItemInDBAsync(change, "edit").done(function () {
                            globals_1.app.renderItem();
                        });
                        return;
                    }
                }
            });
        }
        preparePasteBuffer(tree) {
            let pasteBuffer = { tree: tree, items: [] };
            localStorage.setItem(this.COPY_PASTE_BUFFER, JSON.stringify(pasteBuffer));
        }
        addToPasteBuffer(item, title, pasteSource, sourceItem) {
            var fields = globals_1.globalMatrix.ItemConfig.getItemConfiguration(item.type).fieldList;
            var pasteBuffer = [];
            $.each(fields, function (fidx, f) {
                pasteBuffer.push({
                    def: f,
                    val: item[f.id]
                });
            });
            let currentBuffer = JSON.parse(localStorage.getItem(this.COPY_PASTE_BUFFER));
            currentBuffer.items.push({
                sourceItem: sourceItem,
                sourceProject: globals_1.matrixSession.getProject(),
                pasteSource: pasteSource,
                title: title,
                item: pasteBuffer
            });
            localStorage.setItem(this.COPY_PASTE_BUFFER, JSON.stringify(currentBuffer));
        }
        docHasContent(controls) {
            // check if a doc would be empty int hat case: explain and return false
            var isEmpty = true;
            var sectionCount = 0;
            var noContentSections = 0;
            $.each(controls, function (cidx, control) {
                if (control.isDhfType && control.dhfValue) {
                    sectionCount++;
                    if (control.dhfValue.fieldValueXML && control.dhfValue.type != "document_options") {
                        isEmpty = false;
                    }
                    if (control.dhfValue.type === "terms_abbreviations") {
                        noContentSections++;
                    }
                }
            });
            if (sectionCount > 0 && globals_1.app.getNeedsSave()) {
                return true;
            }
            isEmpty = isEmpty && !(sectionCount > 0 && noContentSections === sectionCount);
            if (isEmpty) {
                var message = sectionCount ? "You need to add some content into the sections:<br><ul>" +
                    "<li>To edit a section's content click on the <span class='cbimg'></span> before the section name.</li>" +
                    "<li>To change how the content is rendered click on the <span class='fal fa-cog'></span> behind the section name." :
                    "First you need to add some sections. To do this click on the <span class='fal fa-list'></span> icon behind '" + this.getArchiveButtonName() + "'";
                var dlg = '<div class="modal fade bs-example-modal-sm" role="dialog" >' +
                    '    <div class="modal-dialog modal-sm">' +
                    '        <div class="modal-content">' +
                    '            <div class="modal-header">' +
                    '                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>' +
                    '                <h4 class="modal-title">Your document is still empty</h4>' +
                    '            </div>' +
                    '            <div class="modal-body" id="message_ack_content" >' + message +
                    '                <br><br>Find more info here <a href="https://urlshort.matrixreq.com/d23/manual/docs" target="blank">here</a>.' +
                    '            </div>' +
                    '            <div class="modal-footer">' +
                    '                <button id="message_ack_ok" type="button" class="btn btn-default" data-dismiss="modal">Ok</button>' +
                    '            </div>' +
                    '        </div>' +
                    '    </div>' +
                    '</div>';
                $(dlg).modal();
            }
            return !isEmpty;
        }
        dhfFactory(dhfType) {
            if ((typeof this.sectionFactories[dhfType]) !== "undefined") {
                let creator = this.sectionFactories[dhfType];
                return creator(this.dhf_config, dhfType, this.ColumnTypes);
            }
            else {
                var isTable = false;
                if (this.dhf_config.customTables) {
                    $.each(this.dhf_config.customTables, function (index, table) {
                        if (dhfType === table.id) {
                            isTable = true;
                        }
                    });
                }
                if (isTable) {
                    let creator = this.sectionFactories["dhf_table"];
                    return creator(this.dhf_config, dhfType, this.ColumnTypes);
                }
                return new Hidden_1.Hidden();
            }
        }
        getNumberOfDHFSections(type) {
            var maxRows = 0;
            var fields = globals_1.globalMatrix.ItemConfig.getFieldsOfType("dhf", type);
            for (var idx = 0; idx < fields.length; idx++) {
                maxRows++;
            }
            return maxRows;
        }
        getControlFieldName(type) {
            var name = type;
            $.each(this.getDhfControls(), function (key, val) {
                if (key === type) {
                    name = val.sectionName;
                }
            });
            return name;
        }
        reorderDialog(_item) {
            let that = this;
            var item = _item;
            var td;
            var dhfTable = [];
            var idx = 0;
            $.each(item, function (key, val) {
                if (globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                    if (val) {
                        var fieldVal = JSON.parse(val);
                        if (fieldVal.type !== 'document_options') {
                            dhfTable.push({ idx: idx, id: key, name: fieldVal.name, type: that.getControlFieldName(fieldVal.type) });
                        }
                        idx++;
                    }
                }
            });
            var ui = $("<div style='position: absolute;top: 12px;bottom: 12px;left: 12px;right: 12px;'>");
            var nst = $('<div class="newSectionType">');
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.append(ui);
            globals_1.app.dlgForm.removeClass("dlg-v-scroll");
            globals_1.app.dlgForm.addClass("dlg-no-scroll");
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Configure Document Sections",
                height: 600,
                width: 650,
                modal: true,
                open: function () {
                    var enableAdd = function () {
                        var table = matrixlib_1.ml.JSON.fromString(td.getController().getValue());
                        var count = table.status === "ok" ? matrixlib_1.ml.JSON.fromString(td.getController().getValue()).value.length : 0;
                        var type = nst.getController().getValue();
                        var name = nsn.val();
                        // leave 1 spare for document config
                        let cannotAddSection = (!type || !name || count + 1 >= that.getNumberOfDHFSections(item.type));
                        button.prop('disabled', cannotAddSection);
                        matrixlib_1.ml.UI.setEnabled($(".btnSectionAdd"), cannotAddSection);
                    };
                    var addRow = $("<tr>").appendTo("<table style='width:100%'>");
                    ui.append($("<table style='position: absolute;top: 0;left: 0;right: 0;'>").append(addRow));
                    var nsn = $('<input  class="newSectionName form-control" placeholder="enter section name" style="height:34px;width:200px" />');
                    nsn.on('input propertychange', function () {
                        enableAdd();
                    });
                    addRow.append($("<td style='padding-right:2px'>").append(nsn));
                    var sorted = [];
                    $.each(mDHF.getDhfControls(), function (key, val) {
                        if (key !== 'document_options' && !val.hidden) {
                            sorted.push({ id: key, label: val.sectionName, class: val.sectionType.toString() });
                        }
                    });
                    sorted.sort(function (a, b) {
                        if (a.label < b.label)
                            return -1;
                        if (a.label > b.label)
                            return 1;
                        return 0;
                    });
                    addRow.append($("<td style='width:100%;padding-top: 10px;padding-right: 12px;'>").append(nst));
                    nst.mxDropdown({
                        controlState: globals_1.ControlState.DialogCreate,
                        canEdit: true,
                        dummyData: false,
                        help: '',
                        fieldValue: "Empty",
                        valueChanged: function () {
                            enableAdd();
                        },
                        parameter: {
                            placeholder: "select section type",
                            create: false,
                            options: sorted,
                            groups: [
                                { "value": DocumentSectionType.Static.toString(), "label": "Static" },
                                { "value": DocumentSectionType.Database.toString(), "label": "Dynamic (Database)" },
                                { "value": DocumentSectionType.Table.toString(), "label": "TOCs and Indexes" },
                                { "value": DocumentSectionType.CustomTable.toString(), "label": "Custom Tables" },
                                { "value": DocumentSectionType.Technical.toString(), "label": "Static" }
                            ],
                            maxItems: 1,
                            sort: false,
                            maxHeight: "400px"
                        },
                        noMarkup: true
                    });
                    $(".selectize-input", nst).css("width", "100%");
                    var button = $("<button title class='newSectionAdd btn btn-success hidden-print'> Add </span></button>");
                    addRow.append($("<td>").append(button));
                    td = $("<div style='position: absolute;top: 65px;bottom: 0;left: 0;right: 0; overflow-x:hidden;overflow-y:auto;'>");
                    ui.append(td);
                    td.tableCtrl({
                        help: "Re-order or delete sections",
                        controlState: globals_1.ControlState.DialogCreate,
                        parameter: {
                            canBeModified: true,
                            columns: [
                                { name: "Section name", field: "name", editor: "none" },
                                { name: "Section Type", field: "type", editor: "none" }
                            ],
                            create: false
                        },
                        canEdit: true,
                        create: false,
                        fieldValue: JSON.stringify(dhfTable)
                    });
                    enableAdd();
                    button.click(function () {
                        var type = nst.getController().getValue();
                        var name = nsn.val();
                        if (name == "insertall") {
                            $.each(that.getDhfControls(), function (key, val) {
                                td.insertLine({ idx: -1, id: key, type: key, name: key });
                            });
                            return;
                        }
                        var typeName = that.getControlFieldName(type);
                        td.insertLine({ idx: -1, id: type, type: typeName, name: name });
                        nsn.val("");
                        enableAdd();
                    });
                },
                resizeStop: function () {
                    globals_1.app.dlgForm.width(globals_1.app.dlgForm.parent().width() - 30);
                    td.getController().resizeItem(globals_1.app.dlgForm.parent().width(), true);
                },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt btnSectionAdd',
                        click: function () {
                            // save old values
                            var old = {};
                            var oidx = 0;
                            var document_options = "";
                            $.each(item, function (key, val) {
                                if (globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                                    old[oidx] = val;
                                    oidx++;
                                    try {
                                        var js = JSON.parse(val);
                                        if (js.type === "document_options") {
                                            document_options = val;
                                        }
                                    }
                                    catch (Exception) {
                                        // nous nous
                                    }
                                }
                            });
                            let newTable = JSON.parse(td.getController().getValue());
                            newTable = newTable.filter(function (row) {
                                return !!row.type;
                            }).map(function (row) {
                                if (!row.name) {
                                    row.name = row.type;
                                }
                                return row;
                            });
                            var nidx = 0;
                            $.each(item, function (key, val) {
                                if (globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                                    if (nidx < newTable.length) {
                                        var line = newTable[nidx];
                                        if (line.idx === -1) {
                                            // get default settings / value of item
                                            var sectionCtrl = { dhfValue: { fieldValueXML: "" } };
                                            var section = that.dhfFactory(line.id);
                                            try {
                                                section.updateXmlValue(sectionCtrl);
                                            }
                                            catch (Exception) {
                                                // nous nous (this could be legacy doc section plugins)
                                            }
                                            // new section
                                            var dhfField = { type: line.id, name: line.name, fieldValueXML: sectionCtrl.dhfValue.fieldValueXML };
                                            item[key] = JSON.stringify(dhfField);
                                        }
                                        else {
                                            item[key] = old[line.idx];
                                        }
                                    }
                                    else {
                                        // store the remembered document options (once)/clean the rest
                                        item[key] = document_options;
                                        document_options = "";
                                    }
                                    nidx++;
                                }
                            });
                            let update = { onlyThoseFields: 1, onlyThoseLabels: 1 };
                            $.each(item, function (key, val) {
                                if (key === "type" || key === "title" || key === "id" || globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key)) {
                                    update[key] = val;
                                }
                            });
                            // compare old with new
                            let changed = false;
                            let newIdx = 0;
                            $.each(update, function (key, val) {
                                if (globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                                    if ((old[newIdx] || val) && old[newIdx] != val) {
                                        changed = true;
                                    }
                                    newIdx++;
                                }
                            });
                            if (changed) {
                                globals_1.app.updateItemInDBAsync(update, "edit").done(function (result) {
                                    globals_1.app.renderItem(result);
                                    globals_1.app.dlgForm.dialog("close");
                                }).fail(function (error) {
                                    matrixlib_1.ml.UI.showError("Failed to save changes!", error);
                                });
                            }
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            });
        }
        // check if SIGN or DOC has a file attachment control and file attachments
        hasFileAttachments(type, controls, item) {
            var hfa = false;
            $.each(controls, function (ci, c) {
                if (globals_1.globalMatrix.ItemConfig.getFieldType(type, c.fieldId) === "fileManager") {
                    var iv = item[c.fieldId];
                    if (iv && JSON.parse(iv).length > 0) {
                        hfa = true;
                    }
                }
            });
            return hfa;
        }
        hideFileOption(category, format) {
            let hide = false;
            if (this.dhf_config && this.dhf_config.hideFileFormats) {
                $.each(this.dhf_config.hideFileFormats, function (hfoidx, hfo) {
                    if (hfo.category === category && hfo.format === format) {
                        hide = true;
                    }
                });
            }
            return hide;
        }
        renderControlsSIGN(options, body, controls) {
            if (options.isItem) {
                if (options.controlState !== globals_1.ControlState.Print && options.controlState !== globals_1.ControlState.Tooltip) {
                    $("<div style='padding: 12px 0' class='baseControlHelp'>Manage Documents</div>").appendTo(body);
                    let rt = $("<div style='margin-bottom:12px'>").appendTo(body);
                    this.showPreviewSign(rt, options);
                    this.renderSignDownload(options, rt, controls);
                }
            }
            else {
                if (options.controlState === globals_1.ControlState.FormEdit) {
                    body.append($("<span class='baseControlHelp'>Tools</span>"));
                    var folderEdit = $("<div class='hidden-print baseControl'></div>");
                    body.append(folderEdit);
                    var createTools = new ItemCreationView_1.ItemCreationTools();
                    createTools.renderButtons({
                        parent: options.item.id,
                        control: folderEdit,
                        linkTypes: [
                            { type: options.item.type, name: "Folder", buttonName: "Create", folder: true }
                        ],
                        type: options.type,
                        dontOpenNewItem: false
                    });
                }
            }
        }
        getFilterCtrl(type, allControls) {
            for (var idx = 0; idx < allControls.length; idx++) {
                if (globals_1.globalMatrix.ItemConfig.getFieldType(type, allControls[idx].fieldId) === "docFilter") {
                    return allControls[idx].control;
                }
            }
            return null;
        }
        getFilterValue(filterControl) {
            if (filterControl) {
                var v = matrixlib_1.ml.JSON.fromString(filterControl.getController().getValue());
                if (v.status === "ok") {
                    var list = v.value.join(",");
                    return list;
                }
            }
            return null;
        }
        showPreviewDoc(anchor, id, controls) {
            let that = this;
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                return;
            }
            // handle ACL
            if (!globals_1.globalMatrix.ItemConfig.canReport("DOC")) {
                return;
            }
            $("<span class='fal fa-eye inlineView' title='View'></span>").appendTo(anchor).click(() => {
                let frame = $(`<div class="inlineViewer">`).appendTo("body");
                let spinning = matrixlib_1.ml.UI.getSpinningWait("loading document: <span class='dprogress'></span> done").appendTo(frame);
                $(`<div class='message_close_big'><i class='fal fa-window-close'></i></div>`).appendTo(frame).click(function () {
                    frame.remove();
                });
                let params = { format: "pdf", inline: true };
                let labelFilter = that.getFilterValue(that.getFilterCtrl("DOC", controls));
                if (labelFilter) {
                    params.filter = labelFilter;
                }
                matrixlib_1.ml.ReportGenerator.SaveAndCreate(id, params, "viewing pdf", (lastCreatedObject, path) => {
                    spinning.remove();
                    frame.append(`<embed src="${path + "?disposition=inline"}" width="100%" height="100%">`);
                }, (error) => {
                    spinning.remove();
                    frame.append(`document creation failed with error: ${error}`);
                }, (progress) => {
                    $(".dprogress", spinning).html(progress + "%");
                });
            });
        }
        showPreviewSign(anchor, options) {
            let that = this;
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                return;
            }
            if (!globals_1.globalMatrix.ItemConfig.canReport("SIGN")) {
                return;
            }
            $("<span class='fal fa-eye inlineView' title='View'></span>").appendTo(anchor).click(() => {
                let frame = $(`<div class="inlineViewer">`).appendTo("body");
                let spinning = matrixlib_1.ml.UI.getSpinningWait("loading document: <span class='dprogress'></span> done").appendTo(frame);
                $(`<div class='message_close_big'><i class='fal fa-window-close'></i></div>`).appendTo(frame).click(function () {
                    frame.remove();
                });
                let params = { format: "pdf", inline: true };
                let signCache = that.getCached(options);
                if (signCache["pdf"]) {
                    // signCache["pdf"] is a file attachment url like "5745?key\u003dkey_2d6a3cju4dr5qnm9ogvstfqkn2"
                    let clean = signCache["pdf"].replace("\u003d", "=");
                    let path = globals_1.globalMatrix.matrixRestUrl + "/" + globals_1.matrixSession.getProject() + "/file/" + clean + "&disposition=inline";
                    spinning.remove();
                    frame.append(`<embed src="${path}" width="100%" height="100%">`);
                }
                else {
                    if (globals_1.app.getNeedsSave()) {
                        matrixlib_1.ml.UI.showError("Save Item", "Please save before downloading the signed item.");
                        frame.remove();
                        return;
                    }
                    matrixlib_1.ml.ReportGenerator.SaveAndCreate(options.id, params, "viewing pdf", (lastCreatedObject, path) => {
                        spinning.remove();
                        frame.append(`<embed src="${path}?disposition=inline" width="100%" height="100%">`);
                    }, (error) => {
                        spinning.remove();
                        frame.append(`document creation failed with error: ${error}`);
                    }, (progress) => {
                        $(".dprogress", spinning).html(progress + "%");
                    });
                }
            });
        }
        renderControlsDOC(options, body, controls) {
            let that = this;
            let category = options.type; // default type for creation
            if (options.item && options.item.type) {
                category = options.item.type;
            }
            var id = options.item ? options.item.id : "";
            var config = globals_1.globalMatrix.ItemConfig.getItemConfiguration(options.isItem ? category : "FOLDER");
            var showTools = true;
            if (options.controlState === globals_1.ControlState.Print || options.controlState === globals_1.ControlState.Tooltip ||
                options.controlState === globals_1.ControlState.DialogCreate || options.controlState === globals_1.ControlState.HistoryView) {
                showTools = false;
            }
            var signedDocuments; // in case of signed report this is a list of instances (SIGN) created
            // main logic to create UI
            if (options.isItem) {
                if (options.controlState === globals_1.ControlState.DialogCreate) {
                    if (this.dhf_config.categories.documentForms.indexOf(category) !== -1) {
                        // start wizard to create new controlled doc 
                        RenderDocDefinitionWizard(body, controls);
                    }
                }
                else if (showTools) {
                    // show tools to preview and generate signed doc
                    $("<div style='padding: 12px 0;' class='baseControlHelp'>Manage Documents</div>").appendTo(body);
                    let rt = $("<div style='margin-bottom:12px'>").appendTo(body);
                    that.showPreviewDoc(rt, options.id, controls);
                    if (globals_1.globalMatrix.ItemConfig.canReport(options.type)) {
                        rt.append(createPreviewReportButton(category, controls, options.item));
                        rt.append(createExcelButton(category, controls, options.item));
                        this.createCompareButton(rt, options, controls);
                        if (globals_1.matrixSession.isEditor()) {
                            // can create signed doc
                            var dhfConfigTool = createSignatureButton(category, controls, this.getArchiveButtonName());
                            rt.append(dhfConfigTool);
                            if (globals_1.app.canEditItem(options.item) && !options.locked) {
                                var x = $("<div class='btn-group'>");
                                rt.append(x);
                                this.appendConfigTool(x, config, options.item);
                            }
                        }
                    }
                    else {
                        rt.append("<div class='inlineHelp'>You have no rights to download documents</div>");
                    }
                    var linkTypes = [];
                    $.each(this.dhf_config.categories.documentSigned, function (idx, cat) {
                        linkTypes.push({ type: cat });
                    });
                    // show previously created signed docs
                    signedDocuments = $("<div>").linkCollection({
                        // TODO(modules): I added item to the definition -- error?
                        item: options.item,
                        parameter: {
                            "linkTypes": linkTypes,
                            "readonly": true,
                            "none": "no signed documents have been created so far"
                        },
                        fieldValue: options.item.downLinks,
                        help: "Previously created signed documents"
                    });
                    body.append(signedDocuments);
                }
            }
            else if (options.controlState === globals_1.ControlState.FormEdit) {
                body.append($("<span class='baseControlHelp'>Tools</span>"));
                var folderEdit = $("<div class='hidden-print baseControl'></div>");
                body.append(folderEdit);
                var createTools = new ItemCreationView_1.ItemCreationTools();
                var createButtons = [
                    { type: options.item.type, name: "Folder", folder: true },
                    { type: options.item.type, name: "DOCX", import: true, buttonName: "Import" },
                    { type: options.item.type, name: globals_1.globalMatrix.ItemConfig.getCategoryLabel(category), }
                ];
                createTools.renderButtons({
                    parent: options.item.id,
                    control: folderEdit,
                    linkTypes: createButtons,
                    dontOpenNewItem: false
                });
                let templateProjects = globals_1.matrixSession.getCustomerSettingJSON(markAsTemplate_1.MarkAsTemplateImpl.PROJECT_SETTING_Projects);
                if (templateProjects && templateProjects.projects && templateProjects.projects.length) {
                    let accessibleProjects = globals_1.matrixSession.getProjectList(true).map(function (ap) { return ap.shortLabel; });
                    let templateSources = templateProjects.projects.filter(function (p) { return accessibleProjects.indexOf(p) != -1; });
                    let templateErrors = templateProjects.projects.filter(function (p) { return accessibleProjects.indexOf(p) == -1; });
                    appendTemplates(folderEdit, templateSources, 0, [], templateErrors);
                }
            }
            function appendTemplates(folderEdit, projects, next, templateOptions, errors) {
                if (next >= projects.length) {
                    if (templateOptions.length) {
                        let ddb = matrixlib_1.ml.UI.createDropDownButton("Create from <b>Template</b>", templateOptions, false, false, "createByTemplateId", true);
                        folderEdit.append(ddb);
                        ddb.addClass("ddAlignBottom");
                    }
                    if (errors.length) {
                        folderEdit.append($("<div style='padding: 12px 0;font-style: italic;'>").html("There are also templates in some projects where you have no read access: " + errors.join()));
                    }
                    return;
                }
                globals_1.app.readSettingJSONAsync(markAsTemplate_1.MarkAsTemplateImpl.PROJECT_SETTING, projects[next], true).done(function (templates) {
                    if (templates && templates.templates) {
                        // find templates for this project
                        $.each(templates.templates, function (idx, ps) {
                            if (ps.canUseIn.indexOf(globals_1.matrixSession.getProject()) != -1) {
                                templateOptions.push({
                                    name: ps.fromProject + "/" + ps.fromSign + " " + ps.fromName,
                                    click: function () { that.createFromTemplate(ps.fromProject, ps.fromSign, ps.fromName, { parent: globals_1.app.getCurrentItemId() }); }
                                });
                            }
                        });
                    }
                    appendTemplates(folderEdit, projects, next + 1, templateOptions, errors);
                }).fail(function () {
                    matrixlib_1.ml.UI.hideError();
                    errors.push(projects[next]);
                    appendTemplates(folderEdit, projects, next + 1, templateOptions, errors);
                });
            }
            function addFileOption(type, controls, formats, name, format) {
                var pos = (mDHF.getDefaultFormat(type) === format) ? 0 : formats.length;
                formats.splice(pos, 0, {
                    name: name,
                    click: function () {
                        that.createConfirmedDownloadOrSIGN(controls, function () {
                            matrixlib_1.ml.ReportGenerator.CreateDoc(id, { format: format }, that.getFilterValue(that.getFilterCtrl(type, controls)));
                        });
                        return false;
                    }
                });
            }
            function createPreviewReportButton(type, controls, item) {
                var formats = [];
                if (!that.hideFileOption(type, "docx")) {
                    addFileOption(type, controls, formats, "Word", "docx");
                    if (that.hasFileAttachments(type, controls, item)) {
                        addFileOption(type, controls, formats, "Word with attachments", "zipdocx");
                    }
                }
                if (!that.hideFileOption(type, "pdf")) {
                    addFileOption(type, controls, formats, "PDF", "pdf");
                    if (that.hasFileAttachments(type, controls, item)) {
                        addFileOption(type, controls, formats, "PDF with attachments", "zippdf");
                    }
                }
                if (!that.hideFileOption(type, "html")) {
                    addFileOption(type, controls, formats, "HTML", "html");
                }
                if (that.hasPackage(controls, item)) {
                    addFileOption(type, controls, formats, "Package", "package");
                }
                return matrixlib_1.ml.UI.createDropDownButton("Download document", formats, false, false, "btnDownload");
            }
            function createExcelButton(type, controls, item) {
                if (!that.hideFileOption(type, "xlsx")) {
                    if (PluginManagerDocuments.hasCustomSection(item)) {
                        return PluginManagerDocuments.excelButtonControl(() => {
                            that.createConfirmedDownloadOrSIGN(controls, function () {
                                matrixlib_1.ml.ReportGenerator.CreateDoc(id, { format: "xlsx" }, that.getFilterValue(that.getFilterCtrl(type, controls)));
                            });
                            return false;
                        });
                    }
                }
            }
            function createSignatureButton(type, controls, btnName) {
                var filterControl = that.getFilterCtrl(type, controls);
                var formats = [{
                        name: "SIGN",
                        click: function () {
                            that.createSIGN(id, signedDocuments, filterControl, controls);
                        },
                    }];
                return matrixlib_1.ml.UI.createDropDownButton(btnName, formats, false, false, "archiveBtnId");
            }
            function RenderDocDefinitionWizard(body, controls) {
                var dlgInner = body.parent();
                var dlgOuter = dlgInner.parent();
                var createButton;
                var nextButton = $('<button type="button" class="btnDoIt2 ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only btn" role="button" aria-disabled="false">');
                // hide all controls
                for (var idx = 0; idx < controls.length; idx++) {
                    controls[idx].control.hide();
                }
                window.setTimeout(function () {
                    var niceSize = matrixlib_1.ml.UI.getNiceDialogSize(730, 550);
                    dlgOuter.dialog("option", "height", niceSize.height);
                    dlgOuter.dialog("option", "width", niceSize.width);
                    $(".dlgCreateMultiple", dlgOuter.parent()).hide();
                    nextButton.append('<span class="ui-button-text">Next</span>');
                    createButton = $(".ui-dialog-buttonpane button:contains('Create')", globals_1.app.dlgForm.parent());
                    createButton.hide();
                    createButton.after(nextButton);
                }, 1);
                function updateControls(wizardData) {
                    var dhfItemIdx = 0;
                    for (var idx = 0; idx < controls.length; idx++) {
                        if (globals_1.globalMatrix.ItemConfig.getFieldType(category, controls[idx].fieldId) === "dhf") {
                            // this has been configured before...
                            if (dhfItemIdx < wizardData.dhfItems.length) {
                                controls[idx].control.getController().setValue(JSON.stringify(wizardData.dhfItems[dhfItemIdx]));
                                dhfItemIdx++;
                            }
                            else if (dhfItemIdx === wizardData.dhfItems.length) {
                                var dhfField = { type: "document_options", name: "Document Options", fieldValue: "", ctrlConfig: { auto_number: true, omit_title: true } };
                                controls[idx].control.getController().setValue(JSON.stringify(dhfField));
                                dhfItemIdx++;
                            }
                        }
                        else if (controls[idx].name === DOC_NUM_NAME) {
                            controls[idx].control.getController().setValue(wizardData.dhfNumber);
                        }
                        else if (controls[idx].ctrlType === "guid") {
                            controls[idx].control.getController().setValue(wizardData.dhfGUID);
                        }
                        else if (controls[idx].name === "Title") {
                            controls[idx].control.getController().setValue(wizardData.dhfName, true);
                        }
                        else if (controls[idx].name === "reportId") {
                            controls[idx].control.getController().setValue("dhf_generic");
                        }
                    }
                    createButton.trigger("click");
                }
                that.showDHFCreateWizard(category, dlgInner, nextButton, updateControls, false);
            }
        }
        static hasCustomSection(item) {
            for (const keyString in item) {
                const key = parseInt(keyString);
                if (isNaN(key)) {
                    // skip, something's wrong with the key
                }
                else {
                    const value = item[key];
                    if (typeof value === "string") {
                        try {
                            const section = JSON.parse(value);
                            if (section != null && section.type === "CustomSection") {
                                return true;
                            }
                        }
                        catch (e) {
                            // Not JSON, next...
                        }
                    }
                }
            }
            return false;
        }
        createSIGN(id, signedDocuments, filterControl, controls) {
            let that = this;
            function fill0(sn, len) {
                let sns = sn.toString();
                while (sns.length < len) {
                    sns = "0" + sns;
                }
                return sns;
            }
            function last2(x) {
                return x.substr(x.length - 2);
            }
            let versionFromTable = "";
            function createSignDoc(signatures) {
                var transfer = [];
                // build name of signed doc
                let hasTitle = false;
                let hasHideTitle = false;
                var signName = "";
                var signDocNumber = "";
                // if document has a DOC NUMBER field, create the title of the SIGN
                var dnid = globals_1.globalMatrix.ItemConfig.getFieldId(that.item.type, DOC_NUM_NAME);
                if (that.item[dnid] && that.item[dnid] !== "no id") {
                    let docNumber = that.item[dnid];
                    let sn = parseInt(that.item.id.split("-")[1]);
                    hasTitle = docNumber.indexOf("_title_") !== -1;
                    hasHideTitle = docNumber.indexOf("_notitle_") !== -1;
                    signDocNumber = docNumber
                        .replace("_notitle_", "") // just a dummy placeholder to ignore the DOC's title
                        .replace("_id_", that.item.id)
                        .replace("_revision_", versionFromTable)
                        .replace("_serial_", fill0(sn, 3)) // serial XX -> 0XX
                        .replace("_serial1_", fill0(sn, 1)) // serial XX -> XX
                        .replace("_serial2_", fill0(sn, 2)) // serial XX -> XX
                        .replace("_serial3_", fill0(sn, 3)) // serial XX -> 0XX
                        .replace("_serial4_", fill0(sn, 4)) // serial XX -> 00XX
                        .replace("_project_", globals_1.matrixSession.getProject())
                        .replace("_title_", that.item.title)
                        .replace("_YYYY_", new Date().getFullYear().toString())
                        .replace("_YY_", last2("00" + (new Date().getFullYear() - 2000).toString()))
                        .replace("_MM_", last2("00" + (new Date().getMonth() + 1).toString()))
                        .replace("_DD_", last2("00" + (new Date().getDate()).toString()))
                        .replace("_YYYYMMDD_", new Date().getFullYear().toString() +
                        last2("00" + (new Date().getMonth() + 1).toString()) + last2("00" + (new Date().getDate()).toString()));
                    signName = signDocNumber;
                }
                // add / use item title to SIGN item name 
                if (!hasTitle && !hasHideTitle) {
                    signName = signName ? (signName + " " + that.item.title) : that.item.title;
                }
                // find values which need to be transferred (they need to have same label and copyfromdoc set to true
                var signConfig = globals_1.globalMatrix.ItemConfig.getItemConfiguration(that.dhf_config.categories.signAs);
                var docConfig = globals_1.globalMatrix.ItemConfig.getItemConfiguration(that.item.type);
                $.each(signConfig.fieldList, function (configIdx, config) {
                    if (config.parameterJson && config.parameterJson.copyfromdoc) {
                        var toId = config.id;
                        $.each(docConfig.fieldList, function (docIdx, docConfig) {
                            if (docConfig.label.toLowerCase() === config.label.toLowerCase()) {
                                var fromId = docConfig.id;
                                transfer.push({ fromId: fromId.toString(), toId: toId.toString() });
                            }
                        });
                    }
                });
                matrixlib_1.ml.ReportGenerator.CreateSignedDoc(id, signatures, signedDocuments, that.getFilterValue(filterControl), signName, transfer, [], function (signID) { var signatureInfo = that.getSignatureInfo(); });
            }
            let revisionTableControl = null;
            let revisionTableColumn = null;
            for (let control of controls) {
                if (control.dhfValue && control.dhfValue && control.dhfValue.ctrlConfig && control.dhfValue.ctrlConfig.columns) {
                    for (let column of control.dhfValue.ctrlConfig.columns) {
                        if (column.columnType == "type12") {
                            revisionTableControl = control;
                            revisionTableColumn = column.field;
                        }
                    }
                }
            }
            if (revisionTableControl) {
                that.verifyVersionInfo(id, revisionTableControl, revisionTableColumn).done((version) => {
                    versionFromTable = version;
                    that.verifyVersionTableComplete(revisionTableControl).done(() => {
                        that.createConfirmedDownloadOrSIGN(controls, createSignDoc);
                    });
                });
            }
            else {
                that.createConfirmedDownloadOrSIGN(controls, createSignDoc);
            }
        }
        // make sure all values are set
        verifyVersionTableComplete(revisionTableControl) {
            let that = this;
            let res = $.Deferred();
            let table = (revisionTableControl.dhfValue.fieldValue ? JSON.parse(revisionTableControl.dhfValue.fieldValue) : null);
            if (!table || !table.length) {
                matrixlib_1.ml.UI.showConfirm(-1, { title: `The table '${revisionTableControl.dhfValue.name}' with the revision field is empty!`, ok: "Create SIGN", nok: "Cancel" }, () => { res.resolve(""); }, () => { res.reject(); });
                return res;
            }
            else {
                let lastRow = table[table.length - 1];
                for (let column of revisionTableControl.dhfValue.ctrlConfig.columns) {
                    if (!lastRow[column.field]) {
                        matrixlib_1.ml.UI.showConfirm(-1, { title: `The field '${column.name}' in table '${revisionTableControl.dhfValue.name}' is empty!`, ok: "Create SIGN", nok: "Cancel" }, () => { res.resolve(""); }, () => { res.reject(); });
                        return res;
                    }
                }
            }
            // no problem!
            res.resolve();
            return res;
        }
        // compares the current Revision from the table with the one from the SIGN with the highest id
        verifyVersionInfo(docId, revisionTableControl, revisionTableColumn) {
            let that = this;
            let res = $.Deferred();
            let currentRevision = revisionTableControl.dhfValue ? this.getVersionFromTable(revisionTableControl.dhfValue.fieldValue, revisionTableColumn) : "";
            let revisionTable = revisionTableControl.dhfValue ? revisionTableControl.dhfValue.name : "";
            if (!currentRevision) {
                matrixlib_1.ml.UI.showConfirm(-1, { title: `There is no revision defined in table '${revisionTable}'!`, ok: "Create SIGN", nok: "Cancel" }, () => { res.resolve(""); }, () => { res.reject(); });
            }
            else {
                this.getOtherSigns("", docId).done((otherSIGNs) => {
                    if (!otherSIGNs.length) {
                        // first sign... to be created so all is good
                        res.resolve(currentRevision);
                    }
                    else {
                        let highest = matrixlib_1.ml.Item.parseRef(otherSIGNs[0]).number;
                        for (let next of otherSIGNs) {
                            highest = Math.max(matrixlib_1.ml.Item.parseRef(next).number, highest);
                        }
                        let highestSIGNId = matrixlib_1.ml.Item.parseRef(otherSIGNs[0]).type + "-" + highest;
                        globals_1.app.getItemAsync(highestSIGNId).done(function (signItem) {
                            // get the date the sign was created
                            let signCreationDate = new Date(signItem.history[signItem.history.length - 1].date);
                            // go through history of DOC and find the version which existed just before creating the SIGN
                            let docRevisionBeforeSign = that.item.history.length - 1;
                            while (docRevisionBeforeSign >= 0 && new Date(that.item.history[docRevisionBeforeSign].date) <= signCreationDate) {
                                docRevisionBeforeSign--;
                            }
                            docRevisionBeforeSign = that.item.history[docRevisionBeforeSign + 1].version;
                            globals_1.app.getItemAsync(docId, docRevisionBeforeSign).done(function (docBeforeSign) {
                                // now we have the old doc. The revision table might anywhere in one of the properties
                                let previousRevision = "";
                                for (let prop in docBeforeSign) {
                                    let valStr = docBeforeSign[prop];
                                    if (valStr && valStr.length > 2 && valStr[0] == "{") {
                                        try {
                                            let valJson = JSON.parse(valStr); // this might be a table
                                            if (valJson.ctrlConfig && valJson.ctrlConfig.columns && valJson.ctrlConfig.columns.length) { // pretty sure this is a table 
                                                let revisionColumns = valJson.ctrlConfig.columns.filter(column => column.columnType == "type12");
                                                if (revisionColumns.length > 0) { // this is a table with a revision column! we take this
                                                    let valFieldStr = valJson.fieldValue; // check if there is a value stored in the table
                                                    if (valFieldStr && valFieldStr.length > 2 && valFieldStr[0] == "[") {
                                                        previousRevision = that.getVersionFromTable(valFieldStr, revisionColumns[0].field);
                                                    }
                                                }
                                            }
                                        }
                                        catch (e) {
                                        }
                                    }
                                }
                                if (currentRevision != previousRevision) {
                                    // we assume all is good... 
                                    res.resolve(currentRevision);
                                    return res;
                                }
                                else {
                                    matrixlib_1.ml.UI.showConfirm(-1, { title: `The current revision in table '${revisionTable}' is the same as it was in the last created SIGN!`, ok: "Create SIGN", nok: "Cancel" }, () => {
                                        res.resolve(currentRevision);
                                        return res;
                                    }, () => {
                                        res.reject();
                                        return res;
                                    });
                                }
                            }).fail(function (error) {
                                res.reject(error);
                            });
                        });
                    }
                });
            }
            return res;
        }
        getVersionFromTable(table, column) {
            if (!table)
                return "";
            let currentTable = JSON.parse(table);
            if (currentTable.length) {
                let lastRow = currentTable[currentTable.length - 1];
                return lastRow[column];
            }
            return "";
        }
        hasPackage(controls, item) {
            for (var idx = 0; idx < controls.length; idx++) {
                if (controls[idx].fieldId && item[controls[idx].fieldId] && globals_1.globalMatrix.ItemConfig.getFieldType(item.type, controls[idx].fieldId) === "dhf") {
                    // this is a configured dhf field
                    let parsed = matrixlib_1.ml.JSON.fromString(item[controls[idx].fieldId]);
                    if (parsed.status == "ok") {
                        if (parsed.value.type == "package") {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        createConfirmedDownloadOrSIGN(controls, createFct) {
            let that = this;
            if (!that.docHasContent(controls)) {
                return;
            }
            // check if the document contains smart text and the user needs to verify that it's correct
            var config = globals_1.globalMatrix.ItemConfig.getSmartText();
            if (!config || !config.replacements) {
                config = { "replacements": [] };
            }
            var table = $("<table class='table table-bordered text-left'>");
            $.each(config.replacements, function (optIdx, opt) {
                if (opt.warn) {
                    var tr = $("<tr>");
                    tr.append($("<td>").html(opt.what));
                    tr.append($("<td>").html(opt.with));
                    table.append(tr);
                }
            });
            let dateNow = (new Date()).toDateString();
            let allSignatures = that.getSignatures(controls);
            let signatures = allSignatures.filter(function (user) {
                return user && (globals_1.globalMatrix.ItemConfig.getUserIds().indexOf(user) != -1);
            });
            let msgs = [];
            if (signatures.length != allSignatures.length) {
                msgs.push("There are missing users or users without access in a signature table!");
            }
            if ($(".refreshNeeded:visible").length != 0) {
                msgs.push("Some item selections based on search expressions have not been updated!");
            }
            if ($("tr", table).length > 0 && (that.wasInformedToday !== dateNow || that.wasInformedTodayAbout !== table.html())) {
                msgs.push("Verify whether the following smart text blocks are correct<br/>" + $('<div>').append(table.clone()).html());
            }
            if (msgs.length != 0) {
                matrixlib_1.ml.UI.showConfirm(6, { title: msgs.join("<br><br>"), ok: "Yes, continue" }, function () {
                    // remember that user was informed about something today
                    that.wasInformedToday = dateNow;
                    that.wasInformedTodayAbout = table.html();
                    createFct(signatures);
                }, function () {
                });
            }
            else {
                createFct(signatures);
            }
        }
        // return number of required signatures (in SIGN docs) and number of given signatures
        getSignatureInfo(item) {
            if (!item) {
                item = this.item;
            }
            return docBase_1.DocBaseImpl.readSignatureInfo(item);
        }
        getCached(options) {
            let signCache = {};
            let signCacheFields = globals_1.globalMatrix.ItemConfig.getFieldsOfType("signCache", options.type);
            if (signCacheFields.length == 1) {
                let signCacheField = options.item[signCacheFields[0].field.id];
                if (signCacheField) {
                    let cached = JSON.parse(signCacheField);
                    $.each(cached, function (idx, cache) {
                        let key = cache.fileName.split('.').pop().toLowerCase();
                        signCache[key] = cache.fileId;
                    });
                }
            }
            return signCache;
        }
        renderSignDownload(options, body, controls) {
            let that = this;
            // if there's a control to cache signs, get it (note at this time it's not yet rendered, so no need to read it's content)
            let signCache = this.getCached(options);
            // the sign cache is now a lookup per extensions, e.g. signCache["pdf"] = "5745?key\u003dkey_2d6a3cju4dr5qnm9ogvstfqkn2";
            if (options.controlState === globals_1.ControlState.Print || options.controlState === globals_1.ControlState.HistoryView || options.controlState === globals_1.ControlState.Tooltip) {
                return;
            }
            var defaultFormat = mDHF.getDefaultFormat(options.type);
            var formats = [];
            function addOption(format, name, signCache) {
                var pos = (defaultFormat === format) ? 0 : formats.length;
                formats.splice(pos, 0, {
                    name: name,
                    click: function () {
                        if (signCache[format]) {
                            startDownloadCached(signCache[format]);
                        }
                        else {
                            // create and download the file
                            startDownload(format);
                        }
                    }
                });
            }
            if (!that.hideFileOption(options.type, "docx")) {
                addOption("docx", "Word", signCache);
                if (this.hasFileAttachments(options.type, controls, options.item)) {
                    addOption("zipdocx", "Word with attachments", {});
                }
            }
            if (!that.hideFileOption(options.type, "pdf")) {
                addOption("pdf", "PDF", signCache);
                if (this.hasFileAttachments(options.type, controls, options.item)) {
                    addOption("zippdf", "PDF with attachments", {});
                }
            }
            if (!that.hideFileOption(options.type, "html")) {
                addOption("html", "HTML", signCache);
            }
            if (options.item.docHasPackage) {
                addOption("package", "Package", {});
            }
            var signatureInfo = this.getSignatureInfo();
            // default buttons
            if (signatureInfo.missingSignatures) {
                var request = $("<button class='btn btn-default' style='margin-right:5px !important'>Request Signatures</button>");
                body.append(request);
                request.click(function () {
                    var message = matrixlib_1.ml.Mail.getCannedMessage("please_sign", "", options.item.id);
                    matrixlib_1.ml.Mail.sendMailDlg(signatureInfo.missing.join(","), null, "Please review and sign " + options.item.id, message, "");
                });
            }
            else {
                let markAsTemplates = globals_1.globalMatrix.ItemConfig.getFieldsOfType("markAsTemplate", this.item.type);
                let can = "release_note";
                let subject = "A document has been released ";
                let button = "Send Release Mail";
                let users = globals_1.globalMatrix.ItemConfig.getUserIds();
                if (markAsTemplates.length == 1 && markAsTemplate_1.MarkAsTemplateImpl.getRequiredApprovals(this.item[markAsTemplates[0].field.id]).length > 0) {
                    can = "approve_note";
                    subject = "Approval for template ";
                    button = "Ask for approval ";
                    users = markAsTemplate_1.MarkAsTemplateImpl.getRequiredApprovals(this.item[markAsTemplates[0].field.id]);
                }
                // normal document which has been approved and completely signed
                var request = $("<button class='btn btn-default' style='margin-right:5px !important'>" + button + "</button>");
                body.append(request);
                request.click(function () {
                    var message = matrixlib_1.ml.Mail.getCannedMessage(can, "", options.item.id);
                    var to = users.filter(function (user) { return user != globals_1.matrixSession.getUser(); });
                    matrixlib_1.ml.Mail.sendMailDlg(to.join(), null, subject + options.item.id, message, "");
                });
            }
            if (globals_1.globalMatrix.ItemConfig.canReport(options.type)) {
                var download = matrixlib_1.ml.UI.createDropDownButton("Download document", formats, false, false, "btnDownload");
                body.append(download);
                if (!that.hideFileOption(options.type, "xlsx")) {
                    that.getBaseDOCofSIGN(globals_1.matrixSession.getProject(), options.item)
                        .done(doc => {
                        if (PluginManagerDocuments.hasCustomSection(doc)) {
                            download.after(PluginManagerDocuments.excelButtonControl(() => {
                                startDownload("xlsx");
                                return false;
                            }));
                        }
                    });
                }
            }
            else {
                body.append("<div class='inlineHelp'>You have no rights to download documents</div>");
            }
            this.createCompareButton(body, options, controls);
            function startDownload(format) {
                // MATRIX-3721 if user modified title (or something else), ask to save first
                if (globals_1.app.getNeedsSave()) {
                    matrixlib_1.ml.UI.showError("Save Item", "Please save before downloading the signed item.");
                    return;
                }
                // MATRIX-4863 wrap in function for use in async download
                function performDownload() {
                    // MATRIX-3721 force the item to be readonly, this prevents tampering while the server (silently creates a new version)
                    // unless the user selects something else and comes back (that we need to catch somewhere else...)
                    globals_1.matrixApplicationUI.forceReadonly(options.item.id);
                    matrixlib_1.ml.ReportGenerator.DownloadSignedDoc(options.item.id, { format: format });
                    var signatureInfo = that.getSignatureInfo();
                    if (signatureInfo.missingSignatures && that.dhf_config.warnMissingSign) {
                        matrixlib_1.ml.UI.showAck(-1, "There are still some signatures missing");
                    }
                }
                if (format == "xlsx") {
                    that.getBaseDOCofSIGN(globals_1.matrixSession.getProject(), options.item)
                        .done(doc => {
                        if (PluginManagerDocuments.hasCustomSection(doc)) {
                            performDownload();
                        }
                        else {
                            matrixlib_1.ml.UI.showError("No Custom section", "Only DOC/SIGN with a Custom section can be downloaded as an Excel file.");
                        }
                    })
                        .fail(error => {
                        matrixlib_1.ml.UI.showError("Error checking DOC", "Unable to load original DOC to check for Excel data");
                    });
                }
                else {
                    performDownload();
                }
            }
            function startDownloadCached(target) {
                // target is a file attachment url like "5745?key\u003dkey_2d6a3cju4dr5qnm9ogvstfqkn2"
                let clean = target.replace("\u003d", "=");
                let param = (clean.split("?")[1]).split("="); // ["key", "key_2d6a3cju4dr5qnm9ogvstfqkn2"]
                let params = {};
                params[param[0]] = param[1]; // params= {key:"key_2d6a3cju4dr5qnm9ogvstfqkn2"}
                globals_1.app.downloadFromUrl("file/" + clean.split("?")[0], params); // 5745, para,s
            }
        }
        getOtherSigns(thisSign, thisDoc) {
            let that = this;
            let res = $.Deferred();
            let otherSigns = [];
            globals_1.app.getItemAsync(thisDoc).done(function (doc) {
                $.each(doc.downLinks, function (idx, sign) {
                    let ref = matrixlib_1.ml.Item.parseRef(sign.to).id;
                    if (that.isDocumentType(matrixlib_1.ml.Item.parseRef(sign.to).type) && ref !== thisSign) {
                        otherSigns.push(ref);
                    }
                });
                res.resolve(otherSigns);
            });
            return res;
        }
        createCompareButton(rt, options, controls) {
            let that = this;
            // add button for redlining
            let placeHolderRL = $("<div class='btnCompare'>");
            rt.append(placeHolderRL);
            var versionSelectRL = [];
            let thisSign;
            let thisDoc;
            // find the mother DOC or use as mother DOC if it is already a doc
            if (options.type === "SIGN" && options.item.upLinkList && options.item.upLinkList.length > 0) {
                let ref = matrixlib_1.ml.Item.parseRef(options.item.upLinkList[0].itemRef).id;
                thisDoc = ref;
                thisSign = options.id;
                versionSelectRL.push({ name: "Current DOC", click: function () { that.redlineDocuments(ref); } });
            }
            else {
                thisDoc = options.id;
            }
            this.getOtherSigns(thisSign, thisDoc).done(function (otherSigns) {
                $.each(otherSigns, function (idx, otherSign) {
                    versionSelectRL.splice(0, 0, { name: otherSign + " " + globals_1.app.getItemTitle(otherSign), click: function () { that.redlineDocuments(otherSign); } });
                });
                if (versionSelectRL.length === 1) {
                    placeHolderRL.replaceWith(matrixlib_1.ml.UI.createDropDownButton("Redline against " + versionSelectRL[0].name, versionSelectRL, false, false, "btnCompare"));
                }
                else if (versionSelectRL.length > 0) {
                    placeHolderRL.replaceWith(matrixlib_1.ml.UI.createDropDownButton("Redline against ...", versionSelectRL, false, false, "btnCompare"));
                }
                else {
                    // nothing released yet
                    placeHolderRL.remove();
                }
            });
            // add button for side by side compare
            var extras = globals_1.globalMatrix.ItemConfig.getExtrasConfig();
            if (extras && matrixlib_1.ml.JSON.isTrue(extras.compareInsideX)) {
                let placeHolder = $("<div class='btnCompare'>");
                rt.append(placeHolder);
                var versionSelect = [];
                let thisSign;
                let thisDoc;
                // find the mother DOC or use as mother DOC if it is already a doc
                if (that.isDocumentFormType(options.item.type)) {
                    thisDoc = options.id;
                }
                else if (options.item.upLinkList) {
                    let docsInList = options.item.upLinkList.filter(function (ul) { return that.isDocumentFormType(matrixlib_1.ml.Item.parseRef(ul.itemRef).type); });
                    if (docsInList.length) {
                        let ref = matrixlib_1.ml.Item.parseRef(docsInList[0].itemRef).id;
                        thisDoc = ref;
                        thisSign = options.id;
                        versionSelect.push({ name: thisDoc + " " + globals_1.app.getItemTitle(thisDoc), click: function () { that.compareDocuments(thisDoc, controls); } });
                    }
                }
                if (!thisDoc) {
                    // no more history
                    placeHolder.remove();
                    return;
                }
                that.getOtherSigns(thisSign, thisDoc).done(function (otherSigns) {
                    $.each(otherSigns, function (idx, otherSign) {
                        versionSelect.push({ name: otherSign + " " + globals_1.app.getItemTitle(otherSign), click: function () { that.compareDocuments(otherSign, controls); } });
                    });
                    if (versionSelect.length === 1) {
                        placeHolder.replaceWith(matrixlib_1.ml.UI.createDropDownButton("Compare with " + versionSelect[0].name, versionSelect, false, false, "btnCompare"));
                    }
                    else if (versionSelect.length > 0) {
                        placeHolder.replaceWith(matrixlib_1.ml.UI.createDropDownButton("Compare to ...", versionSelect, false, false, "btnCompare"));
                    }
                    else {
                        // nothing released yet
                        placeHolder.remove();
                    }
                });
            }
        }
        compareDocuments(target, otherControls) {
            let that = this;
            let reportProc;
            let ui = $("<div style='width:100%'>");
            ui.append(matrixlib_1.ml.UI.getSpinningWait("retrieving documents..."));
            let left;
            let right;
            // show dialog
            globals_1.app.dlgForm.html("").append(ui);
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Compare documents",
                height: globals_1.app.itemForm.height() * 0.9,
                width: $(document).width() * 0.9,
                modal: true,
                close: function () {
                    globals_1.app.dlgForm.removeClass("forcePrint");
                    $(".compareTools").remove();
                },
                open: function () {
                    globals_1.app.dlgForm.addClass("forcePrint");
                },
                resizeStop: function (event, ui) {
                    globals_1.app.dlgForm.resizeDlgContent([]);
                },
                buttons: [{
                        text: 'Ok',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            }).resizeDlgContent([], false);
            let otherType = matrixlib_1.ml.Item.parseRef(target).type;
            if (this.isDocumentFormType(otherType)) {
                // the other document is a DOC need to retrieve it to know if there's any label filters to take into account
                globals_1.app.getItemAsync(target).done(function (otherDOC) {
                    let docFilter = globals_1.globalMatrix.ItemConfig.getFields(otherType).filter(function (field) { return field.fieldType == "docFilter"; });
                    let otherOptions = { format: "html" };
                    if (docFilter.length && otherDOC[docFilter[0].id]) {
                        let filter = JSON.parse(otherDOC[docFilter[0].id]);
                        if (filter.length) {
                            otherOptions.filter = filter.join(",");
                        }
                    }
                    globals_1.app.startCreateDocumentAsync(target, otherOptions).done(function (result) {
                        mDHF.loadDocument(result.jobId, function (htmlDOM) {
                            right = htmlDOM;
                            that.compareDocumentsContent(that.item.id, target, left, right, ui);
                        });
                    });
                });
            }
            else {
                globals_1.app.startCreateDocumentAsync(target, { format: "html" }).done(function (result) {
                    mDHF.loadDocument(result.jobId, function (htmlDOM) {
                        right = htmlDOM;
                        that.compareDocumentsContent(that.item.id, target, left, right, ui);
                    });
                });
            }
            // start report generation for this DOC or SIGN, if it is a DOC make sure label filters are active
            let thisOptions = { format: "html" };
            if (this.isDocumentFormType(this.item.type) && otherControls && otherControls.length) {
                let labels = that.getFilterValue(that.getFilterCtrl(this.item.type, otherControls));
                if (labels)
                    thisOptions.filter = labels;
            }
            globals_1.app.startCreateDocumentAsync(this.item.id, thisOptions).done(function (result) {
                mDHF.loadDocument(result.jobId, function (htmlDOM) {
                    left = htmlDOM;
                    that.compareDocumentsContent(that.item.id, target, left, right, ui);
                });
            });
        }
        redlineDocuments(target) {
            let that = this;
            if (globals_1.app.needsSave()) {
                matrixlib_1.ml.UI.showError("Please Save", "Plase save before redlining documents.");
                return;
            }
            let ui = $("<div style='width:100%'>");
            ui.append(matrixlib_1.ml.UI.getSpinningWait("examining documents..."));
            // show dialog
            let dlg = $("<div class='forcePrint'>").appendTo($("body"));
            let redlining = new Redlining_1.Redlining();
            matrixlib_1.ml.UI.showDialog(dlg, "Redline", ui, $(document).width() * 0.9, globals_1.app.itemForm.height() * 0.9, [{
                    text: 'Ok',
                    class: 'btnCancelIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { redlining.cancelCompare(); dlg.remove(); }, () => { }, () => { dlg.resizeDlgContent([]); });
            redlining.compareDocuments(ui, that.item.id, target);
        }
        filterAlignItems(showDifferent, showSorted) {
            // hide all
            $(".compareItem").hide();
            if (showDifferent && showSorted) {
                // not sorted AND not identical 
                //  show sorted                 show different
                $(".compareItem").not(".compareItemOriginal").not(".compareItemSame").show();
            }
            else if (showDifferent && !showSorted) {
                // not sorted AND not identical 
                //  show original         show different
                $(".compareItemOriginal").not(".compareItemSame").show();
            }
            else if (!showDifferent && showSorted) {
                $(".compareItem").not(".compareItemOriginal").show();
            }
            else {
                $(".compareItem.compareItemOriginal").show();
            }
        }
        compareDocumentsContent(thisId, otherId, left, right, ui) {
            let that = this;
            let itemHideIdentical = false;
            let itemSortAlign = false;
            if (!left || !right) {
                return;
            }
            left = new index_1.HTMLCleaner($(left).html(), false).getClean(index_1.HTMLCleaner.CleanLevel.Strict, true);
            right = new index_1.HTMLCleaner($(right).html(), false).getClean(index_1.HTMLCleaner.CleanLevel.Strict, true);
            let param = {
                arg: JSON.stringify({ versions: [left, right] })
            };
            globals_1.app.compareHTML(param).done(function (result) {
                ui.html("");
                let ctrls = $("<div class='compareTools'>").appendTo(globals_1.app.dlgForm.parent().find(".ui-dialog-titlebar"));
                let sectionTools = $("<div class='compareToolsGroup'>").appendTo(ctrls);
                let itemTools = $("<div class='compareToolsGroup'>").appendTo(ctrls);
                $('<span class="compareToolsHeader">Sections:</span>').appendTo(sectionTools);
                $('<div class="checkbox compareTool" ><label><input type="checkbox">hide identical sections</label></div>').appendTo(sectionTools).click(function (event) {
                    $("input", $(event.delegateTarget)).prop('checked') ? $(".compareRowSame").hide() : $(".compareRowSame").show();
                });
                $(`<div class="checkbox compareTool" ><label><input type="checkbox">hide sections only in ${thisId}</label></div>`).appendTo(sectionTools).click(function (event) {
                    $("input", $(event.delegateTarget)).prop('checked') ? $(".compareLeftOnly").hide() : $(".compareLeftOnly").show();
                });
                $(`<div class="checkbox compareTool" ><label><input type="checkbox">hide sections only in ${otherId}</label></div>`).appendTo(sectionTools).click(function (event) {
                    $("input", $(event.delegateTarget)).prop('checked') ? $(".compareRightOnly").hide() : $(".compareRightOnly").show();
                });
                $('<span class="compareToolsHeader">Items:</span>').appendTo(itemTools);
                $('<div class="checkbox compareTool" ><label><input type="checkbox">hide identical items</label></div>').appendTo(itemTools).click(function (event) {
                    itemHideIdentical = $("input", $(event.delegateTarget)).prop('checked');
                    that.filterAlignItems(itemHideIdentical, itemSortAlign);
                });
                $('<div class="checkbox compareTool" ><label><input type="checkbox">sort and align items</label></div>').appendTo(itemTools).click(function (event) {
                    itemSortAlign = $("input", $(event.delegateTarget)).prop('checked');
                    that.filterAlignItems(itemHideIdentical, itemSortAlign);
                });
                let headers = $("<div class='compareHeaders'>").appendTo(ui);
                $("<div class='compareHeader'>").appendTo(headers).html(`This document (${thisId})`);
                $("<div class='compareHeader'>").appendTo(headers).html(`Other document (${otherId})`);
                that.fillSideBySide($(result.html[0]), $(result.html[1]), ui);
            });
        }
        fillSideBySide(left, right, ui) {
            let buffer = $("<div style='display:none'>").appendTo("body");
            buffer.append(left);
            let row = $("<div>");
            let leftUI = $("<div>");
            let rightUI = $("<div>");
            // add left report - each section one row
            let ssc = $($(".subchapter", buffer)[0]);
            while (ssc && ssc.length > 0) {
                if (ssc.hasClass("subchapter")) {
                    row = $("<div class='compareRow compareLeftOnly'>").appendTo(ui);
                    leftUI = $("<div class='compareLeft'>").appendTo(row);
                    rightUI = $("<div class='compareRight'>").appendTo(row);
                }
                let next = ssc.next();
                leftUI.append(ssc);
                ssc = next;
            }
            ;
            // add right report - if same section (title) exists in left only match it, if not append
            buffer.html("");
            buffer.append(right);
            ssc = $($(".subchapter", buffer)[0]);
            while (ssc && ssc.length > 0) {
                if (ssc.hasClass("subchapter")) {
                    row = null;
                    $(".compareRow.compareLeftOnly", ui).each(function (lri, lr) {
                        if ($.trim($(".subchapter", lr).text()) == $.trim(ssc.text())) {
                            row = $(lr);
                            row.removeClass("compareLeftOnly");
                            rightUI = $(".compareRight", row);
                            return;
                        }
                        ;
                    });
                    if (!row) {
                        row = $("<div class='compareRow compareRightOnly'>").appendTo(ui);
                        leftUI = $("<div class='compareLeft'>").appendTo(row);
                        rightUI = $("<div class='compareRight'>").appendTo(row);
                    }
                }
                let next = ssc.next();
                rightUI.append(ssc);
                ssc = next;
            }
            ;
            // find sections which match
            $(".compareRow", ui).each(function (ridx, row) {
                // remove all itemspacers (these are added by report engine to have space between items)
                $(".compareRow .itemspacer").remove();
                if (!$(row).hasClass("compareRightOnly") && !$(row).hasClass("compareLeftOnly")) {
                    leftUI = $(row).find(".compareLeft");
                    rightUI = $(row).find(".compareRight");
                    if (leftUI.html() === rightUI.html()) {
                        $(row).addClass("compareRowSame");
                    }
                    // build lists of all items in sections left and right
                    let sortLeft = [];
                    let sortRight = [];
                    // buffer with name
                    $.each($(".wide_item_title", leftUI), function (lii, leftItem) {
                        let lt = $(leftItem).closest("table");
                        lt.addClass("compareItem");
                        sortLeft.push({ itemId: $("a", $(leftItem)).text(), item: lt, existsInBoth: false });
                    });
                    $.each($(".wide_item_title", rightUI), function (lii, rightItem) {
                        let rt = $(rightItem).closest("table");
                        rt.addClass("compareItem");
                        sortRight.push({ itemId: $("a", $(rightItem)).text(), item: rt, existsInBoth: false });
                    });
                    // if there are any items either left or right, mark everything in both sections
                    if (sortLeft.length > 0 || sortRight.length > 0) {
                        leftUI.children().each(function (idx, c) {
                            $(c).addClass("compareItemOriginal");
                        });
                        rightUI.children().each(function (idx, c) {
                            $(c).addClass("compareItemOriginal");
                        });
                    }
                    // mark matching and identical items
                    $.each(sortLeft, function (lii, lt) {
                        $.each(sortRight, function (rii, rt) {
                            if (lt.itemId == rt.itemId) {
                                lt.existsInBoth = true;
                                rt.existsInBoth = true;
                            }
                            if (lt.item.html() == rt.item.html()) {
                                lt.item.addClass("compareItemSame");
                                rt.item.addClass("compareItemSame");
                            }
                        });
                    });
                    // sort: first matching in top, than by item id
                    sortLeft = sortLeft.sort(function (a, b) {
                        if (a.existsInBoth && !b.existsInBoth) {
                            return -1;
                        }
                        if (b.existsInBoth && !a.existsInBoth) {
                            return 1;
                        }
                        let an = matrixlib_1.ml.Item.parseRef(a.itemId);
                        let bn = matrixlib_1.ml.Item.parseRef(b.itemId);
                        let at = an.type + an.isFolder ? "-F" : "";
                        let bt = bn.type + bn.isFolder ? "-F" : "";
                        return at < bt || (at == bt && an.number < bn.number) ? -1 : 1; // there should not be doubles
                    });
                    sortRight = sortRight.sort(function (a, b) {
                        if (a.existsInBoth && !b.existsInBoth) {
                            return -1;
                        }
                        if (b.existsInBoth && !a.existsInBoth) {
                            return 1;
                        }
                        let an = matrixlib_1.ml.Item.parseRef(a.itemId);
                        let bn = matrixlib_1.ml.Item.parseRef(b.itemId);
                        let at = an.type + an.isFolder ? "-F" : "";
                        let bt = bn.type + bn.isFolder ? "-F" : "";
                        return at < bt || (at == bt && an.number < bn.number) ? -1 : 1; // there should not be doubles
                    });
                    // insert copies of sorted items
                    $.each(sortLeft, function (idx, sl) {
                        if (sl.existsInBoth) {
                            // find right idx
                            let rightIdx = 0;
                            // identical id in right must exist
                            while (sortRight[rightIdx].itemId != sl.itemId) {
                                rightIdx++;
                            }
                            let nl = sl.item.clone();
                            nl.removeClass("compareItemOriginal");
                            nl.addClass("compareItemSorted");
                            leftUI.append(nl);
                            let nr = sortRight[rightIdx].item.clone();
                            nr.removeClass("compareItemOriginal");
                            nr.addClass("compareItemSorted");
                            rightUI.append(nr);
                            if (nl.height() > nr.height()) {
                                nr.css("cssText", "margin-bottom:" + (6 + nl.height() - nr.height()) + "px !important");
                                // 10 is the margin of compareitem (which is not part of hight calculation) - 4 pixels magic...
                            }
                            else if (nl.height() < nr.height()) {
                                nl.css("cssText", "margin-bottom:" + (6 + nr.height() - nl.height()) + "px !important");
                            }
                            nl.hide();
                            nr.hide();
                        }
                        else {
                            let nl = sl.item.clone();
                            nl.removeClass("compareItemOriginal");
                            nl.addClass("compareItemSorted");
                            leftUI.append(nl);
                            let nr = $("<div class='compareItem compareItemSorted'>");
                            rightUI.append(nr);
                            nr.height(nl.height());
                            nl.hide();
                            nr.hide();
                        }
                    });
                    $.each(sortRight, function (idx, sr) {
                        if (sr.existsInBoth) {
                            // did this already
                        }
                        else {
                            let nr = sr.item.clone();
                            nr.removeClass("compareItemOriginal ");
                            nr.addClass("compareItemSorted");
                            rightUI.append(nr);
                            let nl = $("<div class='compareItem compareItemSorted'>");
                            leftUI.append(nl);
                            nl.height(nr.height());
                            nl.hide();
                            nr.hide();
                        }
                    });
                }
            });
            buffer.html("");
        }
        getDocumentStatus(item) {
            let status = {};
            let markAsTemplates = globals_1.globalMatrix.ItemConfig.getFieldsOfType("markAsTemplate", item.type);
            let requiredTemplateApprovals = [];
            let templateApprovalStatus = {};
            if (markAsTemplates.length == 1) {
                requiredTemplateApprovals = markAsTemplate_1.MarkAsTemplateImpl.getRequiredApprovals(item[markAsTemplates[0].field.id]);
                templateApprovalStatus = markAsTemplate_1.MarkAsTemplateImpl.getTemplateSignatureStatus(item[markAsTemplates[0].field.id]);
            }
            let signatureStatus = docBase_1.DocBaseImpl.readSignatureInfo(item);
            if (this.isDocumentFormType(item.type)) {
                status.isDoc = true;
                if (requiredTemplateApprovals.length > 0) {
                    status.isDocWithTemplate = true;
                }
                else if (markAsTemplates.length == 1 && requiredTemplateApprovals.length == 0) {
                    status.isDocWithEmptyTemplate = true;
                }
                // check if there's a signature table and that the status is
                $.each(item, function (key, val) {
                    if (val && globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                        // special dhf control
                        var fieldVal = JSON.parse(val);
                        if (fieldVal.type.toLocaleLowerCase() === "signaturebox") {
                            if (fieldVal.fieldValue && JSON.parse(fieldVal.fieldValue).length) {
                                status.isDocWithFilledSignatureTable = true;
                            }
                            else {
                                status.isDocWithEmptySignatureTable = true;
                            }
                        }
                    }
                });
                if (!status.isDocWithFilledSignatureTable && !status.isDocWithEmptySignatureTable) {
                    status.isDocWithoutSignatureTable = true;
                }
            }
            else if (this.isSignedType(item.type)) {
                status.isSign = true;
                if (requiredTemplateApprovals.length > 0) {
                    status.isSignNeedingTemplateApproval = true;
                    if (requiredTemplateApprovals.indexOf(globals_1.matrixSession.getUser()) != -1) {
                        status.isSignNeedingTemplateMyApproval = true;
                    }
                }
                else if (templateApprovalStatus.givenSignatures) {
                    status.isSignApprovedTemplate = true;
                }
                else if (signatureStatus.hasSignature && signatureStatus.missingSignatures) {
                    status.isSignNeedingSignature = true;
                }
                else if (signatureStatus.hasSignature) {
                    status.isSignCompletlySigned = true;
                }
                if (!status.isSignNeedingTemplateApproval && !status.isSignApprovedTemplate && !status.isSignNeedingSignature && !status.isSignCompletlySigned) {
                    status.isSignNoSignatureNoTemplate = true;
                }
            }
            else {
                // not a doc not a sign
            }
            return status;
        }
        static excelButtonControl(click) {
            const tooltip = `Export Custom sections to an Excel file.\nThis only works with Custom sections, other parts of the document are ignored.\nThe Custom sections should ideally be tables.`;
            return $(`<button class='btn btn-default' title='${tooltip}' style='margin-right:5px'>Excel Export</button>`)
                .click(click);
        }
    }
    exports.PluginManagerDocuments = PluginManagerDocuments;
    class ColumnTypesInfo {
        constructor(config) {
            this.editorOfType = {
                type0: "textline",
                type1: "text",
                type2: "versionletter",
                type3: "none",
                type4: "user",
                type5: "none",
                type6: "signaturemeaning",
                type7: "eco",
                type8: "ecocapa",
                type9: "date",
                //        type10: "groupuser", // allow user to select a group or a user to sign
                type11: "group",
                type12: "revision",
                type13: "date_today",
                type14: "number"
            };
            this.nameOfType = {
                type0: "Text Line",
                type14: "Number",
                type1: "Rich Text",
                type4: "Name",
                type9: "Date",
                type13: "Date (auto)",
                type2: "Version Letter",
                type6: "Signature Meaning",
                type3: "eSignature Signature",
                type5: "eSignature Date",
                type7: "ECO",
                type8: "ECO/CAPA",
                //        type10: "Name / Group",
                type11: "Group / Role",
                type12: "Revision"
            };
            this.config = config;
        }
        getCustomTypeDef(type) {
            if (this.config.customColumns) {
                for (var idx = 0; idx < this.config.customColumns.length; idx++) {
                    if (this.config.customColumns[idx].type === type) {
                        return this.config.customColumns[idx];
                    }
                }
            }
            return null;
        }
        getCustomDropDownOptions(type) {
            if (this.config.customColumns) {
                for (var idx = 0; idx < this.config.customColumns.length; idx++) {
                    if (this.config.customColumns[idx].type === type) {
                        return this.config.customColumns[idx].options;
                    }
                }
            }
            return null;
        }
        getNames(currentColumns) {
            let names = matrixlib_1.ml.JSON.clone(this.nameOfType);
            //type7: "ECO", // don't show as option
            //type8: "ECO/CAPA",// don't show as option
            if (currentColumns.indexOf("type7") == -1) {
                delete names.type7;
            }
            if (currentColumns.indexOf("type8") == -1) {
                delete names.type8;
            }
            if (this.config.customColumns) {
                for (var idx = 0; idx < this.config.customColumns.length; idx++) {
                    names[this.config.customColumns[idx].type] = this.config.customColumns[idx].name;
                }
            }
            return names;
        }
        getEditorOfType(type) {
            var colDef = this.getCustomTypeDef(type);
            if (colDef) {
                return (colDef.editor ? colDef.editor : "select");
            }
            return (this.editorOfType[type]);
        }
        getOptionsOfType(type) {
            var colDef = this.getCustomTypeDef(type);
            if (colDef) {
                return colDef.options;
            }
            return [];
        }
        getNameOfType(type) {
            var colDef = this.getCustomTypeDef(type);
            if (colDef) {
                return colDef.name;
            }
            return this.nameOfType[type];
        }
    }
    exports.ColumnTypesInfo = ColumnTypesInfo;
    var mDHF;
    exports.mDHF = mDHF;
    function InitializePluginManagerDocuments() {
        exports.mDHF = mDHF = new PluginManagerDocuments();
        PluginManager_1.plugins.register(mDHF);
    }
    exports.InitializePluginManagerDocuments = InitializePluginManagerDocuments;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 15 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(16), __webpack_require__(1), __webpack_require__(14), __webpack_require__(13), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, DBCache_1, matrixlib_1, PluginManagerDocuments_1, PluginManager_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.RestDB = void 0;
    class RestDB {
        constructor(init) {
            this.restConnection = init;
        }
        setProject(project) {
            this._project = project;
            this.restConnection.setProject(project);
        }
        setSettingJSON(key, valueJSON) {
            let that = this;
            var res = $.Deferred();
            var newSetting = JSON.stringify(valueJSON);
            try {
                var check = JSON.parse(newSetting);
                let setSetting = {
                    value: newSetting,
                    key: key,
                    reason: "setting change"
                };
                this.restConnection.postServer(this._project + "/setting", setSetting).done(function () {
                    globals_1.globalMatrix.ItemConfig.setSettingJSON(key, valueJSON);
                    res.resolve();
                }).fail(function (jqxhr, textStatus, error) {
                    that.showRestError(jqxhr, textStatus, error);
                    res.reject();
                });
            }
            catch (err) {
                matrixlib_1.ml.UI.showError("Bad value of setting.", "Error was:" + err);
                res.reject();
            }
            return res;
        }
        readSettingJSONAsync(key, otherProject, noRetry) {
            var res = $.Deferred();
            this.restConnection.getServer((otherProject ? otherProject : globals_1.matrixSession.getProject()) + "/setting", noRetry).done(function (settings) {
                var found = false;
                if (settings.settingList) {
                    $.each(settings.settingList, function (idx, setting) {
                        if (setting.key === key && setting.value && setting.value.indexOf('{') !== -1) {
                            // assume it a json
                            var val = matrixlib_1.ml.JSON.fromString(setting.value);
                            if (val.status === "ok") {
                                found = true;
                                res.resolve(val.value);
                            }
                        }
                    });
                }
                if (!found) {
                    res.resolve({});
                }
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        setSettingCustomerJSON(settingId, valueJSON) {
            let that = this;
            let res = $.Deferred();
            globals_1.restConnection.postServer("all/setting", {
                key: settingId,
                value: JSON.stringify(valueJSON),
                reason: "setting change"
            }).done(function (result) {
                res.resolve();
            }).fail(function (jqxhr, textStatus, error) {
                that.showRestError(jqxhr, textStatus, error);
                res.reject();
            });
            return res;
        }
        readSettingCustomerJSONAsync(key) {
            var res = $.Deferred();
            this.restConnection.getServer("all/setting").done(function (settings) {
                var found = false;
                if (settings.settingList) {
                    $.each(settings.settingList, function (idx, setting) {
                        if (setting.key === key && setting.value && setting.value.indexOf('{') !== -1) {
                            // assume it a json
                            var val = matrixlib_1.ml.JSON.fromString(setting.value);
                            if (val.status === "ok") {
                                found = true;
                                res.resolve(val.value);
                            }
                        }
                    });
                }
                if (!found) {
                    res.resolve({});
                }
            });
            return res;
        }
        // set or overwrite the default cache: used by jira addon to avoid caching
        setCache(externalCache) {
            this.dbCache = externalCache;
        }
        retrieveTreeAsync() {
            let that = this;
            var res = $.Deferred();
            let date = matrixlib_1.ml.URL.getParameterByName(window.location.href, "atDate");
            let dp = date ? ("&atDate=" + date) : "";
            if (date) {
                globals_1.globalMatrix.ItemConfig.activateTimewarp(date);
            }
            this.retrieveConfigAsync().done(function () {
                that.restConnection.getProject("tree?fancy" + dp).done(function (result) {
                    result = RestDB.filterLegacyReportCat(result);
                    PluginManager_1.plugins.initProject(that._project);
                    matrixlib_1.ml.ContextFrames.init();
                    that.dbCache = new DBCache_1.DBCache();
                    that.dbCache.initMatrixTree(result, globals_1.app.isMedical());
                    res.resolve(result);
                });
            });
            return res;
        }
        retrieveTreeAndItem(itemId) {
            let that = this;
            var res = $.Deferred();
            let date = matrixlib_1.ml.URL.getParameterByName(window.location.href, "atDate");
            let dp = date ? ("&atDate=" + date) : "";
            if (date) {
                globals_1.globalMatrix.ItemConfig.activateTimewarp(date);
            }
            this.retrieveConfigAsync().done(function () {
                if (itemId) {
                    // check whether to show an item / folder (and not a dashboard or something)
                    let isItem = (globals_1.globalMatrix.ItemConfig.getCategories(true).indexOf(matrixlib_1.ml.Item.parseRef(itemId).type) != -1);
                    let itemToGet = isItem ? itemId : "F-DOC-1";
                    let history = "?history=true";
                    that.restConnection.getProject("item/" + itemToGet + history + "&withTree=1", false).done(function (result) {
                        // init tree
                        let tree = RestDB.filterLegacyReportCat(result.contextTree.children);
                        for (let t of tree) {
                            if (t.id.startsWith("F-") && !t.children) {
                                t.children = [];
                            }
                        }
                        PluginManager_1.plugins.initProject(that._project);
                        matrixlib_1.ml.ContextFrames.init();
                        that.dbCache = new DBCache_1.DBCache();
                        that.dbCache.initMatrixTree(tree, globals_1.app.isMedical());
                        let item = that.parseItemJSON(itemId, result);
                        if (that.dbCache.isFolder(itemId)) {
                            item['children'] = [];
                        }
                        res.resolve(isItem ? item : null);
                    }).fail(function (error) {
                        res.resolve(null);
                    });
                }
                else {
                    that.restConnection.getProject("tree?fancy" + dp).done(function (result) {
                        result = RestDB.filterLegacyReportCat(result);
                        PluginManager_1.plugins.initProject(that._project);
                        matrixlib_1.ml.ContextFrames.init();
                        that.dbCache = new DBCache_1.DBCache();
                        that.dbCache.initMatrixTree(result, globals_1.app.isMedical());
                        res.resolve(null);
                    });
                }
            });
            return res;
        }
        static filterLegacyReportCat(result) {
            let enableLegacyReport = globals_1.globalMatrix.ItemConfig != undefined ? globals_1.globalMatrix.ItemConfig.getExtrasConfig().enableLegacyReport : undefined;
            if (enableLegacyReport == undefined || enableLegacyReport == "0") {
                //Let remove legacy report cat from the tree
                let fReport1Index = result.findIndex((o) => { return o.id == "F-REPORT-1"; });
                if (fReport1Index != -1) {
                    result[fReport1Index].children = [];
                }
            }
            if (enableLegacyReport == "1") {
                result = result.filter((item) => { return item.id != "F-REPORT-1"; });
            }
            return result;
        }
        doesExist(itemId) {
            return this.dbCache.doesExist(itemId);
        }
        getChildrenIds(parentId) {
            return this.dbCache.getChildrenIds(parentId);
        }
        getItemFromTree(itemId) {
            return this.dbCache.getItemFromCache(itemId);
        }
        getItemAsync(itemId, ignoreErrors, includeHistory) {
            let that = this;
            var res = $.Deferred();
            let history = includeHistory ? "?history=true" : "";
            if (this.dbCache.isFolder(itemId)) {
                this.restConnection.getProject("item/" + itemId + history, ignoreErrors).done(function (result) {
                    var item = that.parseItemJSON(itemId, result);
                    item['children'] = [];
                    res.resolve(item);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            else {
                this.restConnection.getProject("item/" + itemId + history, ignoreErrors).done(function (result) {
                    //TODO update tree (e.g if title changed or parent?)
                    var item = that.parseItemJSON(itemId, result);
                    res.resolve(item);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            return res;
        }
        getNeedlesAsync(searchExpr, up, down, fields, labels, ignoreFilters) {
            var res = $.Deferred();
            let links = up && down ? "&links=down,up" : up ? "&links=up" : down ? "&links=down" : "";
            let fieldsOut = fields ? "&fieldsOut=" + fields : "";
            let label = labels ? "&labels=1" : "";
            let items = [];
            globals_1.restConnection.getProject("needle?search=mrql:" + searchExpr + links + fieldsOut + label, false, ignoreFilters).done(function (results) {
                $.each(results.needles, function (idx, needle) {
                    var item = {
                        id: matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id,
                        title: needle.title,
                        type: matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).type,
                        downLinks: [],
                        upLinks: [],
                        modDate: needle.lastModDate,
                        isUnselected: 0,
                        labels: needle.labels ? needle.labels.split(",").map(function (label) { return label.substr(1, label.length - 2); }) : []
                    };
                    if (needle.fieldVal) {
                        $.each(needle.fieldVal, function (jdx, fieldVal) {
                            item[fieldVal.id.toString()] = fieldVal.value;
                        });
                    }
                    for (var idx = 0; needle.downLinkList && idx < needle.downLinkList.length; idx++) {
                        var tol = needle.downLinkList[idx].itemRef;
                        item.downLinks.push({ to: matrixlib_1.ml.Item.parseRef(tol).id, title: needle.downLinkList[idx].title, modDate: needle.downLinkList[idx].modDate });
                    }
                    for (var idx = 0; needle.upLinkList && idx < needle.upLinkList.length; idx++) {
                        var tol = needle.upLinkList[idx].itemRef;
                        item.upLinks.push({ to: matrixlib_1.ml.Item.parseRef(tol).id, title: needle.upLinkList[idx].title, modDate: needle.upLinkList[idx].modDate });
                    }
                    items.push(item);
                });
                res.resolve(items);
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        getItemProjectAsync(project, itemId, ignoreErrors, includeHistory) {
            let that = this;
            var res = $.Deferred();
            let history = includeHistory ? "?history=true" : "";
            this.restConnection.getServer(project + "/item/" + itemId + history, ignoreErrors).done(function (result) {
                var item = that.parseItemJSON(itemId, result);
                res.resolve(item);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        getProjectItemAsync(project, itemId, includeHistory) {
            let that = this;
            var res = $.Deferred();
            let history = includeHistory ? "?history=true" : "";
            this.restConnection.getServer(project + "/item/" + itemId + history).done(function (result) {
                var item = that.parseItemJSON(itemId, result);
                res.resolve(item);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        startReportAsync(itemId, reportOptions) {
            var res = $.Deferred();
            reportOptions["url"] = globals_1.globalMatrix.matrixBaseUrl;
            reportOptions["resturl"] = globals_1.globalMatrix.matrixRestUrl;
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                reportOptions["atDate"] = globals_1.globalMatrix.ItemConfig.getTimeWarp();
            }
            let isSign = PluginManagerDocuments_1.mDHF.isSignedType(matrixlib_1.ml.Item.parseRef(itemId).type);
            this.restConnection.postProject(((reportOptions.inline && isSign) ? "signedreport/" : "report/") + itemId, reportOptions).done(function (result) {
                res.resolve(result);
            });
            return res;
        }
        canLaunchReport() {
            return this.restConnection.getServer("all/job");
        }
        startCreateDocumentAsync(itemId, reportOptions) {
            var res = $.Deferred();
            reportOptions["url"] = globals_1.globalMatrix.matrixBaseUrl;
            reportOptions["resturl"] = globals_1.globalMatrix.matrixRestUrl;
            let isSign = PluginManagerDocuments_1.mDHF.isSignedType(matrixlib_1.ml.Item.parseRef(itemId).type);
            this.restConnection.postProject((isSign ? "signedreport/" : "report/") + itemId, reportOptions).done(function (result) {
                res.resolve(result);
            });
            return res;
        }
        getReportDetails(jobId) {
            var res = $.Deferred();
            var fileparam = "";
            this.restConnection.getProject("job/" + jobId + fileparam).done(function (result) {
                res.resolve(result);
            });
            return res;
        }
        compareHTML(compareParams) {
            return this.restConnection.postServer("all/compareHtml", compareParams);
        }
        download(jobId, file, param) {
            var fileparam = "/" + file;
            this.restConnection.download("job/" + jobId + fileparam, param);
        }
        downloadFromUrl(url, param) {
            this.restConnection.download(url, param);
        }
        downloadInMemory(jobId, file, dataType) {
            var res = $.Deferred();
            var fileparam = "/" + file;
            this.restConnection.getFile("job/" + jobId + fileparam, dataType).done(function (result) {
                res.resolve(result);
            });
            return res;
        }
        downloadInMemoryFromUrl(url) {
            var res = $.Deferred();
            this.restConnection.getFile(url).done(function (result) {
                res.resolve(result);
            });
            return res;
        }
        getType(itemId) {
            if (this.dbCache) {
                return this.dbCache.getType(itemId);
            }
            return "_";
        }
        touchAsync(itemId, depth, comment) {
            return this.restConnection.putProject("touch/" + itemId, { reason: comment, nbLayers: depth }, itemId);
        }
        getIcon(itemId) {
            return this.dbCache.getIcon(itemId);
        }
        parseSearchResult(needle, fieldList) {
            let fullitem = matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef);
            let sr = {
                itemId: fullitem.id, version: fullitem.version, title: needle.title, downlinks: [], uplinks: [], labels: []
            };
            if (fieldList && fieldList.length > 0) {
                sr.fieldVal = needle.fieldVal;
            }
            if (needle.downLinkList) {
                $.each(needle.downLinkList, function (idx, link) {
                    sr.downlinks.push(matrixlib_1.ml.Item.parseRef(link.itemRef).id);
                });
            }
            if (needle.upLinkList) {
                $.each(needle.upLinkList, function (idx, link) {
                    sr.uplinks.push(matrixlib_1.ml.Item.parseRef(link.itemRef).id);
                });
            }
            if (needle.labels) {
                let labels = needle.labels.split(",");
                $.each(labels, function (idx, label) {
                    sr.labels.push(label.substr(1, label.length - 2));
                });
            }
            return sr;
        }
        searchAsyncMinimalOutput(term, filter, ignoreFilters, crossProject) {
            var res = $.Deferred();
            // Add the minimal outputMode flag
            var searchExpression = [];
            if (term && term.length > 0) {
                searchExpression.push("search=" + encodeURIComponent(term));
            }
            if (filter && filter.length > 0) {
                searchExpression.push("filter=" + filter);
            }
            if (searchExpression.length > 0) {
                if (crossProject) {
                    this.restConnection.getServer(crossProject + "/needleminimal?" + searchExpression.join("&"), false).done(function (result) {
                        res.resolve(result);
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
                else {
                    this.restConnection.getProject("needleminimal?" + searchExpression.join("&"), false, ignoreFilters).done(function (result) {
                        res.resolve(result);
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
            }
            else {
                res.reject();
            }
            return res;
        }
        searchAsync(term, filter, ignoreFilters, fieldList, crossProject, labels, down, up, treeOrder) {
            let that = this;
            var res = $.Deferred();
            var sex = [];
            if (term && term.length > 0) {
                sex.push("search=" + encodeURIComponent(term));
            }
            if (filter && filter.length > 0) {
                sex.push("filter=" + filter);
            }
            if (fieldList && fieldList.length > 0) {
                sex.push("fieldsOut=" + fieldList);
            }
            if (treeOrder) {
                sex.push("treeOrder=1");
            }
            if (labels) {
                sex.push("labels=1");
            }
            if (down && up) {
                sex.push("links=up,down");
            }
            else if (down) {
                sex.push("links=down");
            }
            else if (up) {
                sex.push("links=up");
            }
            if (sex.length > 0) {
                if (crossProject) {
                    this.restConnection.getServer(crossProject + "/needle?" + sex.join("&"), false).done(function (result) {
                        var hoi = [];
                        for (var idx = 0; idx < result.needles.length; idx++) {
                            hoi.push(that.parseSearchResult(result.needles[idx], fieldList));
                        }
                        res.resolve(hoi);
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
                else {
                    this.restConnection.getProject("needle?" + sex.join("&"), false, ignoreFilters).done(function (result) {
                        var hoi = [];
                        for (var idx = 0; idx < result.needles.length; idx++) {
                            hoi.push(that.parseSearchResult(result.needles[idx], fieldList));
                        }
                        res.resolve(hoi);
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
            }
            else {
                res.reject();
            }
            return res;
        }
        getVersionAsync(itemId, version, includeHistory) {
            let that = this;
            var res = $.Deferred();
            if (this.dbCache.isFolder(itemId)) {
                res.resolve();
            }
            else {
                let history = includeHistory ? "?history=true" : "";
                this.restConnection.getProject("item/" + itemId + "-v" + version + history).done(function (result) {
                    //TODO update tree (e.g if title changed or parent?)
                    var item = that.parseItemJSON(itemId, result);
                    res.resolve(item);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            return res;
        }
        // get an item from another project 
        getProjectVersionAsync(project, itemId, version, includeHistory) {
            let that = this;
            var res = $.Deferred();
            if (this.dbCache.isFolder(itemId)) {
                res.resolve();
            }
            else {
                let history = includeHistory ? "?history=true" : "";
                this.restConnection.getServer(project + "/item/" + itemId + "-v" + version + history).done(function (result) {
                    var item = that.parseItemJSON(itemId, result);
                    res.resolve(item);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            return res;
        }
        // get /cat from another project 
        getProjectCat(project) {
            var res = $.Deferred();
            this.restConnection.getServer(project + "/cat").done(function (result) {
                res.resolve(result);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        getAuditLogAsync(startAt, maxResults, param) {
            if (!param) {
                param = {};
            }
            param.startAt = startAt;
            param.maxResults = maxResults;
            return this.restConnection.getProject("audit" + "?" + $.param(param, true));
        }
        getAuditDetailsAsync(auditId) {
            var res = $.Deferred();
            let param = {
                auditIdMin: auditId,
                auditIdMax: auditId,
                tech: "yes",
                resolveRef: 1
            };
            this.restConnection.getProject("audit" + "?" + $.param(param, true)).done(function (auditDetails) {
                if (auditDetails.audit && auditDetails.audit.length === 1) {
                    res.resolve(auditDetails.audit[0]);
                }
                else {
                    res.reject("no audit details with this number");
                }
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        getAvailableReportsAsync() {
            return this.restConnection.getServer("all/reports");
        }
        getTree(subtreeFilter) {
            return this.dbCache.getTree(subtreeFilter);
        }
        getParentId(itemId) {
            return this.dbCache.getParentId(itemId);
        }
        // return a list of parents of category root
        getCategoryBreadcrumbs(category) {
            return this.dbCache.getCategoryBreadcrumbs(category);
        }
        // return a list of item, parent of item, parent of parent of item...
        getBreadcrumbs(itemId) {
            return this.dbCache.getBreadcrumbs(itemId);
        }
        /* set style of item / folder
            computeFolder: 0=look (folder style from lookup)
            computeFolder: 1=all (all children in folder have style: folder has style)
            computeFolder: 2=any (any of the children has style: folder has style) */
        setStyle(itemIds, style, computeFolder) {
            return this.dbCache.setStyle(itemIds, style, computeFolder);
        }
        getRootOfType(type) {
            return this.dbCache.getRootOfType(type);
        }
        hasChildren(itemId) {
            return this.dbCache.hasChildren(itemId);
        }
        isFolder(itemId) {
            return this.dbCache.isFolder(itemId);
        }
        getItemTitle(itemId) {
            return this.dbCache.getItemTitle(itemId);
        }
        isHiddenLink(itemId) {
            return this.dbCache.isHiddenLink(itemId);
        }
        setHiddenLink(itemId, hidden) {
            this.dbCache.setHiddenLink(itemId, hidden);
        }
        createItemAsync(itemJson, comment, actions, parentId, dontFailOnCleanup) {
            let that = this;
            var res2 = $.Deferred();
            if (itemJson.children) {
                let postItFolder = {
                    label: itemJson.title,
                    parent: parentId,
                    reason: comment
                };
                for (var par in itemJson) {
                    if (!itemJson.hasOwnProperty(par))
                        continue;
                    if (postItFolder.hasOwnProperty(par))
                        continue;
                    if (par === "type")
                        continue;
                    if (par === "children")
                        continue;
                    if (par === "title")
                        continue;
                    if (par === "labels" || par === "linksUp" || par === "linksDown") {
                        continue;
                    }
                    let c = par;
                    postItFolder["fx" + par] = itemJson[par];
                }
                if (dontFailOnCleanup) {
                    postItFolder.failOnCleanup = 0;
                }
                this.restConnection.postProject("folder", postItFolder).done(function (result) {
                    //TODO GET not serial BUT complete number like REQ-4 from rest
                    itemJson.id = "F-" + itemJson.type + "-" + result.serial;
                    res2.resolve(that.dbCache.insertItem(itemJson, parentId));
                });
            }
            else {
                let postItItem = {
                    title: itemJson.title,
                    folder: parentId,
                    reason: comment,
                    linksUp: "",
                    linksDown: ""
                };
                for (var par in itemJson) {
                    if (!itemJson.hasOwnProperty(par))
                        continue;
                    if (postItItem.hasOwnProperty(par))
                        continue;
                    if (par === "type")
                        continue;
                    if (par === "labels") {
                        postItItem.labels = itemJson.labels;
                        continue;
                    }
                    if (par === "linksUp") {
                        postItItem.linksUp = itemJson.linksUp;
                        continue;
                    }
                    if (par === "linksDown") {
                        postItItem.linksDown = itemJson.linksDown;
                        continue;
                    }
                    postItItem["fx" + par] = itemJson[par];
                }
                if (dontFailOnCleanup) {
                    postItItem.failOnCleanup = 0;
                }
                this.restConnection.postProject("item", postItItem).done(function (result) {
                    itemJson.id = itemJson.type + "-" + result.serial;
                    var idbparent = that.dbCache.insertItem(itemJson, parentId);
                    res2.resolve(idbparent);
                });
            }
            return res2;
        }
        signItemAsync(itemId, password, comment, meaning) {
            var res = $.Deferred();
            let signature = {
                password: password
            };
            if (meaning) {
                signature.acceptComments = meaning;
            }
            this.restConnection.postProject("sign/" + itemId, signature).done(function (result) {
                res.resolve(result);
            }).fail(function (jqxhr, textStatus, error) {
                res.reject(error);
            });
            return res;
        }
        checkPassword(password) {
            return this.restConnection.postServer("/user/" + globals_1.matrixSession.getUser() + "/check", { password: password });
        }
        convertDocAsync(fileNo, comment, targetDocumentFolder, useOriginal) {
            let that = this;
            var res = $.Deferred();
            let convert = {
                fileNo: fileNo,
                reason: comment,
            };
            if (useOriginal) {
                convert.useAsField = 1;
            }
            if (targetDocumentFolder) {
                convert.targetDocumentFolder = targetDocumentFolder;
            }
            this.restConnection.postProject("wordconvert", convert).done(function (result) {
                res.resolve(result);
            }).fail(function (jqxhr, textStatus, error) {
                res.reject(error);
            });
            return res;
        }
        restoreItemAsync(itemId, title, version, comment) {
            let that = this;
            var res = $.Deferred();
            var postIt = {
                reason: comment
            };
            var arg = itemId;
            if (version) {
                postIt.at = version;
            }
            this.restConnection.postProject("item/" + arg, postIt).done(function (result) {
                that.dbCache.deleteItem(itemId);
                var itemJson = { title: title, id: itemId, type: matrixlib_1.ml.Item.parseRef(itemId).type };
                that.dbCache.insertItem(itemJson, result.newParent);
                res.resolve({ itemId: itemId, version: version, response: result });
            });
            return res;
        }
        updateItemAsync(itemJson, comment, auditAction, requireVersion) {
            let that = this;
            var res = $.Deferred();
            var putIt = { reason: comment };
            if (typeof itemJson.title !== "undefined") {
                putIt.title = itemJson.title;
            }
            if (auditAction) {
                putIt["auditAction"] = auditAction;
            }
            if (requireVersion) {
                putIt["currentVersion"] = requireVersion;
            }
            for (var par in itemJson) {
                if (!itemJson.hasOwnProperty(par))
                    continue;
                if (putIt.hasOwnProperty(par))
                    continue;
                if (par === "type")
                    continue;
                if (par === "category")
                    continue;
                if (par === "links")
                    continue;
                if (par === "title")
                    continue;
                if (par === "id")
                    continue;
                if (isNaN(par)) {
                    // it's attribute other than a field
                    putIt[par] = itemJson[par];
                }
                else {
                    // it's a number so we assume it's a field
                    putIt["fx" + par] = itemJson[par];
                }
            }
            this.restConnection.putProject("item/" + itemJson.id, putIt, itemJson.id).done(function (result) {
                if (result !== "putEditItem | You need to set a title argument") {
                    var item = that.parseItemJSON(itemJson.id, result);
                    if (that.dbCache.isFolder(itemJson.id)) {
                        item['children'] = [];
                    }
                    that.dbCache.updateItem(itemJson);
                    res.resolve(item);
                }
                else {
                    matrixlib_1.ml.Logger.log("error", "PUT of " + itemJson.id + " FAILED. Error was: putEditItem | You need to set a title argument");
                }
            }).fail(function () {
                // MATRIX-3815
                res.reject("saving failed");
            });
            return res;
        }
        moveItemsAsync(itemIds, newFolder, newPosition, comment) {
            let that = this;
            var res = $.Deferred();
            if (itemIds.indexOf(",") == -1) {
                var putIt = {
                    reason: comment,
                    newFolder: newFolder,
                    newPosition: newPosition + 1
                };
                this.restConnection.putProject("item/" + itemIds, putIt).done(function () {
                    that.dbCache.moveItem(itemIds, newFolder, newPosition);
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }
            else {
                let moveIt = {
                    items: itemIds,
                    reason: comment
                };
                this.restConnection.postProject("movein/" + newFolder, moveIt).done(function () {
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }
            return res;
        }
        updateCache(newItem) {
            this.dbCache.insertItem(newItem.item, newItem.parent);
        }
        // replaces the target, a child inside the target or creates a new child with source
        copyFrom(target, source) {
            return this.dbCache.copyFrom(target, source);
        }
        deleteItemAsync(itemId, comment, force) {
            let that = this;
            var res = $.Deferred();
            var par = {
                reason: comment,
                confirm: "no"
            };
            if (force) {
                par.confirm = 'yes';
            }
            this.restConnection.deleteProjectAsync("item/" + itemId, par).done(function () {
                var parentItem = that.dbCache.getParentId(itemId);
                that.dbCache.deleteItem(itemId);
                res.resolve(parentItem);
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        uploadFileProjectAsync(file, progress) {
            return this.restConnection.uploadFileProjectAsync(file, progress);
        }
        fetchFileAsync(url, progress) {
            return this.restConnection.fetchFileAsync(url, progress);
        }
        addDownLinkAsync(fromId, toId, comment) {
            var res = $.Deferred();
            this.restConnection.postProject("itemlink/" + fromId + "/" + toId, { reason: comment }).done(function () {
                res.resolve();
            }).fail(function (jqxhr, textStatus, error) {
                res.reject(jqxhr, textStatus, error);
            });
            return res;
        }
        removeDownLinkAsync(fromId, toId, comment) {
            var res = $.Deferred();
            this.restConnection.deleteProjectAsync("itemlink/" + fromId + "/" + toId, { reason: comment }).done(function () {
                res.resolve();
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        retrieveConfigAsync() {
            var res = $.Deferred();
            this.restConnection.getProject("").done(function (result) {
                matrixlib_1.ml.UI.DateTime.initDateTimeSettings();
                globals_1.globalMatrix.ItemConfig.init(result);
                globals_1.matrixSession.setNotifications(result.todos.filter(function (todo) { return todo.login == globals_1.matrixSession.getUser(); }));
                res.resolve();
            });
            return res;
        }
        showRestError(jqxhr, textStatus, error) {
            matrixlib_1.ml.UI.showError("Server connection error!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
        }
        parseItemJSON(itemId, result) {
            var item = {
                id: itemId,
                title: result.title,
                type: this.dbCache.getType(itemId),
                downLinks: [],
                upLinks: [],
                modDate: result.modDate,
                isUnselected: result.isUnselected,
                labels: result.labels ? result.labels : [],
                maxVersion: result.maxVersion
            };
            if (result.docHasPackage) {
                item.docHasPackage = result.docHasPackage;
            }
            if (!result.maxVersion) {
                item.isDeleted = true;
            }
            if (result.fieldValList) {
                for (var fieldVal in result.fieldValList.fieldVal) {
                    item[result.fieldValList.fieldVal[fieldVal].id.toString()] = result.fieldValList.fieldVal[fieldVal].value;
                }
            }
            for (var idx = 0; result.downLinkList && idx < result.downLinkList.length; idx++) {
                var tol = result.downLinkList[idx].itemRef;
                item.downLinks.push({ to: matrixlib_1.ml.Item.parseRef(tol).id, title: result.downLinkList[idx].title, modDate: result.downLinkList[idx].modDate });
            }
            for (var idx = 0; result.upLinkList && idx < result.upLinkList.length; idx++) {
                var tol = result.upLinkList[idx].itemRef;
                item.upLinks.push({ to: matrixlib_1.ml.Item.parseRef(tol).id, title: result.upLinkList[idx].title, modDate: result.upLinkList[idx].modDate });
            }
            // copy original up list
            item.upLinkList = result.upLinkList;
            if (result.availableFormats) {
                item["availableFormats"] = result.availableFormats;
            }
            if (result.selectSubTree) {
                item["selectSubTree"] = result.selectSubTree;
            }
            if (result.requireSubTree) {
                item["requireSubTree"] = result.requireSubTree;
            }
            if (result.crossLinks) {
                item.crossLinks = result.crossLinks;
            }
            var hoi = [];
            for (var idx = 0; result.itemHistoryList && idx < result.itemHistoryList.itemHistory.length; idx++) {
                var theAction = result.itemHistoryList.itemHistory[idx];
                var historyInfo = {
                    id: itemId,
                    user: theAction.createdByUserLogin,
                    action: theAction.auditAction,
                    version: theAction.version,
                    date: theAction.createdAt,
                    dateUserFormat: theAction.createdAtUserFormat,
                    title: theAction.title,
                    comment: theAction.reason
                };
                // now use the information that undeleted items have been deleted just before
                if (theAction.auditAction === "undelete") {
                    if (result.itemHistoryList.itemHistory.length > idx + 1) {
                        var theDelete = result.itemHistoryList.itemHistory[idx + 1];
                        if (theDelete.auditAction !== "delete") {
                            historyInfo["deletedate"] = theDelete.deletedAtUserFormat;
                        }
                    }
                }
                hoi.push(historyInfo);
            }
            item['history'] = hoi;
            return item;
        }
    }
    exports.RestDB = RestDB;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 16 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(13), __webpack_require__(14), __webpack_require__(3), __webpack_require__(17), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, PluginManager_1, PluginManagerDocuments_1, MatrixLibInterfaces_1, Components_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DBCache = void 0;
    class DBCache {
        constructor() {
            this.db = [];
            this.activities = [];
            this.breadCrumbs = {};
        }
        createVirtualFolder(id, title, icon, color) {
            let folder = { children: [],
                iconClass: icon ? icon : "",
                id: id,
                title: title,
                type: "_" + id
            };
            let cst = {
                settingList: [{
                        key: "texticon",
                        value: JSON.stringify({
                            color: color ? color : MatrixLibInterfaces_1.UIToolsConstants.CIColorsGrey.G3_GreyDark.color,
                            text: id
                        }),
                        secret: false
                    }],
                categoryId: id,
                categoryShort: "_" + id
            };
            globals_1.globalMatrix.ItemConfig.addCategorySetting(cst);
            return folder;
        }
        createVirtualItem(order, id, title, icon) {
            let item = {
                iconClass: icon ? icon : "",
                id: id,
                title: title,
                type: "_" + id,
                order: order
            };
            return item;
        }
        sortChildren(itemId) {
            let obj = this.findInDB(this.db, itemId);
            if (!obj || !obj.children || obj.children.length == 0) {
                // nothing to sort
                return;
            }
            obj.children.sort(function (a, b) { return a.title < b.title ? -1 : 1; });
        }
        initMatrixTree(init, includeActivity) {
            let that = this;
            // a cache for breadcrumbs
            this.breadCrumbs = {};
            // create the nodes for the WORK tab
            let myWork = this.createVirtualFolder("MYWORK", "My Work");
            let dashboards = this.createVirtualFolder("DASHBOARDS", "Dashboards");
            let tools = this.createVirtualFolder("TOOLS", "Tools", "fal fa-tools");
            let qms = this.createVirtualFolder("QMS", "QMS");
            let auditTools = this.createVirtualFolder("AUDIT", "Audit Tools");
            let connectionTools = this.createVirtualFolder("ADDONS", "Add Ons");
            let branches = this.createVirtualFolder("BRANCHES", "Branching");
            let imports = this.createVirtualFolder("IMPORTS", "Imports");
            let otherTools = this.createVirtualFolder("OTHER", "Other");
            let drawers = [myWork, auditTools, branches, imports, dashboards, connectionTools, tools, otherTools, qms];
            //
            if (includeActivity) {
                if (!globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                    auditTools.children.push(this.createVirtualItem(2000, "DELETED", "Deleted Items", "fal fa-trash"));
                }
                if (globals_1.matrixSession.hasAgileSync() && !globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                    connectionTools.children.push(this.createVirtualItem(1000, "SYNC", "Agile Sync", "fal fa-sync-alt"));
                }
                ;
                if (globals_1.app.auditTrailAvailable()) {
                    auditTools.children.push(this.createVirtualItem(4000, "TAGS", "Tags", "fal fa-tags"));
                    auditTools.children.push(this.createVirtualItem(1000, "CHANGES", "Changes", "fal fa-calendar-alt"));
                    if (globals_1.matrixSession.hasDocs() && !globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                        auditTools.children.push(this.createVirtualItem(5000, "DOCS", "Document Changes and Downloads", "fal fa-file-alt"));
                    }
                    if (globals_1.matrixSession.hasDocs() && !globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                        myWork.children.push(this.createVirtualItem(3000, "MYDOCS", "My Signatures", "fal fa-file-signature"));
                    }
                }
                let toolIcons = ["utensil-knife", "shovel-snow", "hammer", "screwdriver", "axe", "shovel", "knife-kitchen"];
                $.each(PluginManager_1.plugins.getProjectPages(), function (idx, page) {
                    // default place for addons = TOOLS
                    page.folder = page.folder ? page.folder : "OTHER";
                    page.folderTitle = page.folderTitle ? page.folderTitle : "Other Tools";
                    let targets = drawers.filter(function (d) { return d.id == page.folder; });
                    if (targets.length == 0) {
                        let targetFolder = that.createVirtualFolder(page.folder, page.folderTitle);
                        drawers.push(targetFolder);
                        targets = [targetFolder];
                    }
                    targets[0].children.push(that.createVirtualItem(page.order, page.id, page.title, page.icon ? page.icon : ("fal fa-" + toolIcons[idx % toolIcons.length])));
                });
            }
            if ((typeof PluginManagerDocuments_1.mDHF !== "undefined" || includeActivity) && globals_1.app) {
                // remove the empty drawers
                drawers = drawers.filter(function (d) { return d.children.length > 0; });
                // sort the items in the drawer
                $.each(drawers, function (dIdx, drawer) {
                    drawer.children.sort(function (tool1, tool2) {
                        if (tool1.order < tool2.order)
                            return -1;
                        if (tool1.order > tool2.order)
                            return 1;
                        if (tool1.id < tool2.id)
                            return -1;
                        if (tool1.id > tool2.id)
                            return 1;
                        return 0;
                    });
                });
                // add to navbar
                if (Components_1.NavBar.isEnabled()) {
                    let folderNames = [];
                    $.each(drawers, function (dIdx, drawer) {
                        that.db.push(drawer);
                        folderNames.push(drawer.id);
                    });
                    Components_1.NavBar.setWorkFolders(folderNames);
                }
                else {
                    let work = this.createVirtualFolder("TOOLS", "Tools");
                    work.children = drawers;
                    // add to project folder
                    this.db.push({ children: [work],
                        icon: "projectw.png",
                        id: "F-PROJECT",
                        title: (PluginManagerDocuments_1.mDHF && PluginManagerDocuments_1.mDHF.getToolFolderName()) ? PluginManagerDocuments_1.mDHF.getToolFolderName() : "Project, Reports & Controlled Documents",
                        type: "_PROJECT" });
                }
            }
            this.groupDefintion = globals_1.globalMatrix.ItemConfig ? globals_1.globalMatrix.ItemConfig.getCategoryGroupConfig() : null;
            if (this.groupDefintion) {
                $.each(this.groupDefintion.groups, function (gidx, group) {
                    // MATRIX-1557 delete group kids cache
                    group.kids = null;
                });
            }
            this.groupPos = this.db.length; // default pos for groups
            // add all items not in a group
            for (var idx = 0; idx < init.length; idx++) {
                if (typeof PluginManagerDocuments_1.mDHF !== "undefined" && PluginManagerDocuments_1.mDHF.isDocumentType(init[idx].type) && PluginManagerDocuments_1.mDHF.showInProjectFolder(init[idx].type) && !Components_1.NavBar.isEnabled()) {
                    this.db[0].children.push(init[idx]);
                }
                else {
                    var inGroup = false;
                    if (this.groupDefintion) {
                        // casting group from definition to allow to add kids
                        $.each(this.groupDefintion.groups, function (gidx, group) {
                            // [{"name":"Design Input", "color":"brown","text":"DI", "categories":["DI1","DI2","DI3","DI3"]}]
                            if (!group.kids) {
                                group.kids = [];
                            }
                            if (group.categories.indexOf(init[idx].type) !== -1) {
                                inGroup = true;
                                group.kids.push(init[idx]);
                            }
                        });
                    }
                    if (!inGroup) {
                        this.db.push(init[idx]);
                    }
                }
            }
            // insert groups
            if (this.groupDefintion) {
                var autoPos = 0; // in case there is no position specified
                // casting group to allow to add DB items
                $.each(this.groupDefintion.groups, function (gidx, group) {
                    //         [{"name":"Design Input", "color":"brown","text":"DI", "categories":["DI1","DI2","DI3","DI3"],"helpPage":"www.matrixreq.com"}]
                    var gi = { children: group.kids,
                        icon: "project.png",
                        id: "F-" + group.text,
                        title: group.name,
                        type: "_" + group.text
                    };
                    var position = that.groupPos + (group.position ? group.position : autoPos);
                    autoPos++;
                    if (position >= that.db.length) {
                        that.db.push(gi);
                    }
                    else {
                        that.db.splice(position, 0, gi);
                    }
                    let cst = {
                        settingList: [{
                                key: "texticon",
                                value: JSON.stringify({
                                    color: group.color,
                                    text: group.text
                                }),
                                secret: false
                            }],
                        categoryId: "_" + group.text,
                        categoryShort: "_" + group.text
                    };
                    globals_1.globalMatrix.ItemConfig.addCategorySetting(cst);
                });
            }
            PluginManager_1.plugins.filterProject(this.db);
        }
        initConfigTree(init) {
            let that = this;
            // add all items not in a group
            for (var idx = 0; idx < init.length; idx++) {
                this.db.push(init[idx]);
            }
        }
        /** getTree returns a tree or a sub tree of the project.
         * this call is synchronous. The database tree is created once during the
         * initialization and filtered after as needed.
         *
         * @param {type} subtreeFilter
         * @returns tree object
         */
        getTree(subtreeFilter) {
            if ((typeof subtreeFilter) === 'undefined' || subtreeFilter.length === 0) {
                return this.db;
            }
            var st = [];
            for (var idx = 0; idx < this.db.length; idx++) {
                if (subtreeFilter.indexOf(this.db[idx].type) !== -1) {
                    st.push(this.db[idx]);
                }
                if (this.db[idx].type[0] === "_") {
                    // also look in project filter. There are some 'hidden' trees like REPORT, ECO, CAPA, SIGN...
                    // examples of these meta folders are _PROJECT
                    var stree = this.db[idx].children;
                    for (var sdx = 0; sdx < stree.length; sdx++) {
                        if (subtreeFilter.indexOf(stree[sdx].type) !== -1) {
                            st.push(stree[sdx]);
                        }
                    }
                }
            }
            return st;
        }
        getParentId(itemId) {
            return this.findParentId(this.db, itemId);
        }
        // this is actually really expensive (it's a depth first search, so for category roots we cache the results) 
        getCategoryBreadcrumbs(category) {
            if (!this.breadCrumbs[category]) {
                this.breadCrumbs[category] = this.getBreadcrumbs("F-" + category + "-1");
            }
            return this.breadCrumbs[category];
        }
        // this is actually really expensive (it's a depth first search, so for category roots we cache the results) 
        getBreadcrumbs(itemId) {
            let all = [itemId];
            this.findParentId(this.db, itemId, all);
            return all;
        }
        getType(itemId) {
            var ir = matrixlib_1.ml.Item.parseRef(itemId);
            if (ir.type !== "") {
                return ir.type;
            }
            // otherwise the id is not a normal id, but something special, like "-1" for "Deleted items... ask the DB
            var obj = this.findInDB(this.db, itemId);
            if (obj && obj.type) {
                return obj.type;
            }
            // no idea... 
            return "";
        }
        getIcon(itemId) {
            var obj = this.findInDB(this.db, itemId);
            if (obj && obj.icon) {
                return obj.icon;
            }
            return null;
        }
        /* set style of item / folder
            computeFolder: 0=look (folder style from lookup)
            computeFolder: 1=all (all children in folder have style: folder has style)
            computeFolder: 2=any (any of the children has style: folder has style) */
        setStyle(itemIds, style, computeFolder) {
            this.setStyleRec(this.db, itemIds, style, computeFolder);
        }
        setStyleRec(folder, itemIds, style, computeFolder) {
            let that = this;
            let allOrAny = computeFolder == 1 ? true : false;
            $.each(folder, function (idx, idb) {
                if (idb.children) {
                    if (idb.children.length == 0 && computeFolder == 1) {
                        allOrAny = false;
                    }
                    else {
                        // a folder
                        let children = that.setStyleRec(idb.children, itemIds, style, computeFolder);
                        let color = false;
                        switch (computeFolder) {
                            case 0:
                                color = itemIds.indexOf(idb.id) != -1;
                                break;
                            case 1:
                                allOrAny = allOrAny && children;
                                color = children;
                                break;
                            case 2:
                                allOrAny = allOrAny || children;
                                color = children;
                                break;
                        }
                        if (color && (idb.children.length || computeFolder == 0)) {
                            idb.extraStyle = style;
                        }
                        ;
                    }
                }
                else {
                    // an item
                    if (itemIds.indexOf(idb.id) != -1) {
                        idb.extraStyle = style;
                        if (computeFolder == 2) {
                            allOrAny = true;
                        }
                    }
                    else if (computeFolder == 1) {
                        allOrAny = false;
                    }
                }
            });
            return allOrAny;
        }
        isFolder(itemId) {
            var obj = this.findInDB(this.db, itemId);
            if (!obj)
                return false;
            return obj.children ? true : false;
        }
        getItemTitle(itemId) {
            var obj = this.findInDB(this.db, itemId);
            if (!obj)
                return globals_1.globalMatrix.ITEM_DOES_NOT_EXIST;
            return obj.title;
        }
        getItemType(itemId) {
            var obj = this.findInDB(this.db, itemId);
            if (!obj)
                return globals_1.globalMatrix.ITEM_DOES_NOT_EXIST;
            return obj.type;
        }
        isHiddenLink(itemId) {
            var obj = this.findInDB(this.db, itemId);
            if (!obj)
                return true;
            return obj.isUnselected && obj.isUnselected === 1;
        }
        setHiddenLink(itemId, hidden) {
            var obj = this.findInDB(this.db, itemId);
            if (obj)
                obj.isUnselected = hidden;
        }
        hasChildren(itemId) {
            var children = this.findInDB(this.db, itemId).children;
            return (children && children.length > 0);
        }
        doesExist(itemId) {
            var obj = this.findInDB(this.db, itemId);
            return obj ? true : false;
        }
        insertItem(itemJson, parentId) {
            if (typeof parentId !== 'undefined') {
                var parent = this.findInDB(this.db, parentId);
                if (!itemJson.type) {
                    itemJson.type = parent.type;
                }
                parent.children.push(itemJson);
                return { parent: parentId, position: parent.children.length - 1, item: itemJson };
            }
            for (var idx = 0; idx < this.db.length; idx++) {
                if (this.db[idx].type === itemJson.type) {
                    this.db[idx].children.push(itemJson);
                    return { parent: this.db[idx].id, position: this.db[idx].children.length - 1, item: itemJson };
                }
            }
            return null;
        }
        // replaces the target, a child inside the target or creates a new child with source
        copyFrom(target, source) {
            var parent = this.findInDB(this.db, target);
            // check if other tree already exists... if so replace it
            if (!parent) {
                matrixlib_1.ml.Logger.log("error", "cannot find parent folder in tree replacement.");
                return false;
            }
            if (parent.id === source.id) {
                this.internalReplace(parent, source);
                return true;
            }
            if (!parent.children) {
                matrixlib_1.ml.Logger.log("error", "parent is not a folder.");
                return false;
            }
            for (var idx = 0; idx < parent.children.length; idx++) {
                if (parent.children[idx].id === source.id) {
                    // replace child
                    this.internalReplace(parent.children[idx], source);
                    return true;
                }
            }
            // create a new child and replace
            var newChild = { id: source.id, title: "", type: "" };
            parent.children.push(newChild);
            this.internalReplace(newChild, source);
            return true;
        }
        getRootOfType(category) {
            var groups = [];
            var gdef = globals_1.globalMatrix.ItemConfig.getCategoryGroupConfig();
            if (gdef) {
                $.each(gdef.groups, function (gi, g) {
                    groups.push("_" + g.text);
                });
            }
            for (var idx = 0; idx < this.db.length; idx++) {
                if (this.db[idx].type === category) {
                    return this.db[idx].id;
                }
                if (groups.indexOf(this.db[idx].type) !== -1) {
                    for (var j = 0; j < this.db[idx].children.length; j++) {
                        if (this.db[idx].children[j].type === category) {
                            return this.db[idx].children[j].id;
                        }
                    }
                }
            }
            return null;
        }
        deleteItem(itemId) {
            return this.deleteItemRec(this.db, itemId);
        }
        moveItem(itemId, newFolder, newPosition) {
            var item = this.findInDB(this.db, itemId);
            if (item) {
                this.deleteItemRec(this.db, itemId);
                this.insertAtRec(this.db, newFolder, newPosition, item);
            }
        }
        updateItem(itemJson) {
            if (typeof itemJson.title == "undefined") {
                // can happen if item is only partially udpated (lables or some fields only)
                return;
            }
            var item = this.findInDB(this.db, itemJson.id);
            if (item) {
                item.title = itemJson.title;
            }
        }
        getChildrenIds(parentId) {
            var ids = [];
            var parent = this.findInDB(this.db, parentId);
            for (var idx = 0; idx < parent.children.length; idx++) {
                ids.push(parent.children[idx].id);
            }
            return ids;
        }
        getItemFromCache(itemId) {
            return this.findInDB(this.db, itemId);
        }
        internalReplace(oldItem, newItem) {
            oldItem.children = newItem.children;
            oldItem.icon = newItem.icon;
            oldItem.isUnselected = newItem.isUnselected;
            oldItem.title = newItem.title;
            oldItem.type = newItem.type;
        }
        findInChildren(node, itemId) {
            if (typeof node.children === 'undefined') {
                return null;
            }
            for (var child = 0; child < node.children.length; child++) {
                var res = this.findInDB(node.children[child], itemId);
                if (res !== null) {
                    return res;
                }
            }
            return null;
        }
        findInDB(tree, itemId) {
            if (tree.id === itemId) {
                return tree;
            }
            var res = this.findInChildren(tree, itemId);
            if (res) {
                return res;
            }
            for (var idx = 0; idx < tree.length; idx++) {
                if (tree[idx].id === itemId) {
                    return tree[idx];
                }
                res = this.findInChildren(tree[idx], itemId);
                if (res) {
                    return res;
                }
            }
            return null;
        }
        findParentId(tree, itemId, all) {
            if (tree.id === itemId) { // in case it is a leaf
                return null; // should have found parent!
            }
            if (tree.children) { // in case it is a folder
                for (var idx = 0; idx < tree.children.length; idx++) {
                    if (tree.children[idx].id === itemId) {
                        if (all) {
                            all.push(tree.id);
                        }
                        return tree.id;
                    }
                    // maybe it is a child of it's children
                    var res = this.findParentId(tree.children[idx], itemId, all);
                    if (res) {
                        if (all) {
                            all.push(tree.id);
                        }
                        return res;
                    }
                }
            }
            if (tree.length) { // in case it is a collection of folders
                for (var idx = 0; idx < tree.length; idx++) {
                    if (tree[idx].id === itemId) {
                        return null;
                    }
                    var res = this.findParentId(tree[idx], itemId, all);
                    if (res) {
                        return res;
                    }
                }
            }
            return null;
        }
        deleteItemRec(tree, itemId) {
            if (typeof tree.children !== 'undefined') {
                for (var idx = 0; idx < tree.children.length; idx++) {
                    if (tree.children[idx].id === itemId) {
                        tree.children.splice(idx, 1);
                        return tree;
                    }
                    var res = this.deleteItemRec(tree.children[idx], itemId);
                    if (res) {
                        return res;
                    }
                }
            }
            else if (typeof tree.length !== 'undefined') {
                for (var idx = 0; idx < tree.length; idx++) {
                    var res = this.deleteItemRec(tree[idx], itemId);
                    if (res) {
                        return res;
                    }
                }
            }
            return null;
        }
        insertAtRec(tree, newFolder, newPosition, item) {
            //moveDetails:
            // "parentId":sourceNode.parent.key,
            // "index":sourceNode.getIndex()
            if (tree.id === newFolder) {
                if (typeof tree.children !== 'undefined') {
                    tree.children.splice(newPosition, 0, item);
                    return true;
                }
                else {
                    // something went wrong...
                    return false;
                }
            }
            else if (typeof tree.children !== 'undefined') {
                // this is a folder
                for (var idx = 0; idx < tree.children.length; idx++) {
                    var res = this.insertAtRec(tree.children[idx], newFolder, newPosition, item);
                    if (res) {
                        return res;
                    }
                }
                return false;
            }
            else if (typeof tree.length !== 'undefined') {
                for (var idx = 0; idx < tree.length; idx++) {
                    var res = this.insertAtRec(tree[idx], newFolder, newPosition, item);
                    if (res) {
                        return res;
                    }
                }
                return false;
            }
            return false;
        }
    }
    exports.DBCache = DBCache;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(18), __webpack_require__(46), __webpack_require__(24), __webpack_require__(25), __webpack_require__(23), __webpack_require__(19), __webpack_require__(22), __webpack_require__(27), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ItemForm_1, KeyboardShortcuts_1, NavigationBar_1, ProjectTree_1, ProjectList_1, ProjectViewDefines_1, ProjectView_1, SearchBox_1, ViewModeSelector_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    __exportStar(ItemForm_1, exports);
    __exportStar(KeyboardShortcuts_1, exports);
    __exportStar(NavigationBar_1, exports);
    __exportStar(ProjectTree_1, exports);
    __exportStar(ProjectList_1, exports);
    __exportStar(ProjectViewDefines_1, exports);
    __exportStar(ProjectView_1, exports);
    __exportStar(SearchBox_1, exports);
    __exportStar(ViewModeSelector_1, exports);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 18 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -----------------------------------------------------------
// A normal item control such as a requirements
// -----------------------------------------------------------
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(19), __webpack_require__(1), __webpack_require__(20), __webpack_require__(34), __webpack_require__(12), __webpack_require__(12), __webpack_require__(6), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, ProjectViewDefines_1, matrixlib_1, ItemCreationView_1, Cleanup_1, index_2, index_3, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ItemControl = void 0;
    class ItemControl {
        constructor(options) {
            this.defaultOptions = {
                control: null,
                type: null,
                controlState: globals_1.ControlState.FormView,
                item: null,
                dummyData: false,
                parent: null,
                changed: function () {
                } // callback to call if value changes
            };
            this.controls = [];
            this._title = $("<div>");
            this._riders = $("<div>");
            this._outerbody = $("<div>"); // outerbody will contain title and body of the item.  the title might be inside the item (e.g. for print rendering)
            this._body = $("<div>");
            let that = this;
            this.settings = matrixlib_1.ml.JSON.mergeOptions(this.defaultOptions, options);
            this.title = "";
            if (this.settings.item) {
                try {
                    this.title = decodeURIComponent(this.settings.item.title);
                }
                catch (err) {
                    this.title = this.settings.item.title;
                }
                if (this.settings.item.type) {
                    this.settings.type = this.settings.item.type; // overwrite,if an item has been passed
                }
            }
            this.orginalControlState = this.settings.controlState;
            // check if a locking label is set
            let canUnlock = false;
            this.restrictUnlockTo = [];
            if (this.settings.controlState === globals_1.ControlState.FormEdit) {
                let ll = globals_1.globalMatrix.ItemConfig.getLabelLockConfig();
                if (ll && this.settings.item.labels) {
                    let ldefs = matrixlib_1.ml.LabelTools.getLabelDefinitions([this.settings.type]).map(function (ld) { return ld.label; });
                    $.each(ll.locks, function (idx, lock) {
                        if (that.settings.item.labels.indexOf(lock.label) !== -1 && ldefs.indexOf(lock.label) != -1) {
                            // locking label is set...
                            that.settings['allowlinkedit'] = that.settings.controlState == globals_1.ControlState.FormEdit && globals_1.matrixSession.getUISettings().allowAddLinkToLocked;
                            that.settings.controlState = globals_1.ControlState.FormView;
                            that.settings['locked'] = lock.label;
                            that.settings['unlockers'] = lock.lockKeeper ? lock.lockKeeper.map(function (keeper) { return matrixlib_1.ml.UI.SelectUserOrGroup.getGroupDisplayNameFromId(keeper); }).join(", ") : "";
                            let canUnlockThis = globals_1.matrixSession.amIAllowedUser(lock.lockKeeper);
                            if (canUnlockThis) {
                                canUnlock = true;
                                that.restrictUnlockTo.push(lock.label);
                            }
                        }
                    });
                }
            }
            // initialize object
            // once a SIGN has it's first signature it cannot be changed anymore 
            this.settings['isDialog'] = this.settings.controlState === globals_1.ControlState.DialogCreate || this.settings.controlState === globals_1.ControlState.DialogEdit;
            this.settings['isForm'] = this.settings.controlState === globals_1.ControlState.FormEdit || this.settings.controlState === globals_1.ControlState.HistoryView || this.settings.controlState === globals_1.ControlState.FormView;
            // signed docs cannot be changed as soon as one signature was given
            this.settings['canEditLinks'] = (this.settings.controlState === globals_1.ControlState.FormEdit || this.settings.controlState === globals_1.ControlState.DialogCreate || this.settings.controlState === globals_1.ControlState.DialogEdit);
            this.settings['canEdit'] = this.settings['canEditLinks'];
            // besides labels....
            this.settings['canEditLabels'] = (canUnlock || (this.settings.controlState === globals_1.ControlState.FormEdit || this.settings.controlState === globals_1.ControlState.DialogCreate));
            // special rule for title and title bar functions: it should for example be possible to delete already signed docs if the user role allows it...
            this.settings['canEditTitle'] = (this.settings.controlState === globals_1.ControlState.FormEdit || this.settings.controlState === globals_1.ControlState.DialogCreate);
            this.settings['canDelete'] = (this.settings.controlState === globals_1.ControlState.FormEdit);
            this.settings['isPrint'] = this.settings.controlState === globals_1.ControlState.Print;
            this.settings['isTooltip'] = this.settings.controlState === globals_1.ControlState.Tooltip;
            this.settings['id'] = this.settings.item ? this.settings.item.id : "";
            this.links = this.settings.item ? this.settings.item.downLinks : [];
            this.config = globals_1.globalMatrix.ItemConfig.getItemConfiguration(this.settings.isItem ? this.settings.type : "FOLDER");
            // prepare rendering
            if (this.settings.isForm && this.settings.controlState != globals_1.ControlState.HistoryView) {
                $(this.settings.control).addClass("panel panel-default");
            }
            // add title control to correct place and prepare it for printing
            this.controls.push({ control: this._title, name: 'Title' });
            if (this.settings.isPrint) {
                var header = $("<table class='table-bordered printheader'></table>");
                var d = new Date();
                header.append("<tr><td>" +
                    "<img class='brandLogo'>" +
                    "</td>" +
                    "<td id='iph'></td>" +
                    "<td class='reportheaderdate'>printed: " + matrixlib_1.ml.UI.DateTime.renderHumanDate(d) + "</td></tr>");
                var logo = globals_1.globalMatrix.ItemConfig.getSetting("projectLogo");
                if (logo && logo.indexOf("{") !== -1) {
                    var rjs = matrixlib_1.ml.JSON.fromString(logo);
                    if (rjs.status === 'ok') {
                        logo = rjs.value.fileId;
                    }
                    header.find(".brandLogo").attr("src", globals_1.globalMatrix.matrixRestUrl + "/" + globals_1.matrixSession.getProject() + "/file/" + logo);
                }
                else {
                    header.find(".brandLogo").attr("src", globals_1.globalMatrix.matrixBaseUrl + "/static/img/logo_report.png");
                }
                if (this.settings.item && !globals_1.app.isFolder(this.settings.id)) {
                    header.append("<tr><td>version: " + this.settings.item.history[0].version + " (" +
                        this.settings.item.history[0].user + ")</td>" +
                        "<td>comment: " + this.settings.item.history[0].comment + "</td>" +
                        "<td class='reportheaderdate'>created: " + this.settings.item.history[0].dateUserFormat + "</td></tr>");
                }
                $("#iph", header).append(this._title);
                this.settings.control.append(header);
            }
            if (this.settings.isForm && this.settings.controlState != globals_1.ControlState.HistoryView) {
                this._title.addClass("panel-heading");
                this.settings.control.append(this._title);
                this.settings.control.append(this._outerbody);
                this._outerbody.on("scroll", () => { $(".tox-pop").remove(); });
                this._outerbody.addClass("panel-body-v-scroll").addClass("enabledd");
                this._body.addClass("panel-body");
            }
            else { // isDialog or isPrint
                this.settings.control.append(this._outerbody);
                if (this.settings.controlState == globals_1.ControlState.HistoryView) {
                    this._outerbody.append($("<div class='baseControlHelp'>Title</div>"));
                }
                if (!this.settings.isPrint) {
                    this._outerbody.append(this._title);
                }
                this._outerbody.on("scroll", () => { $(".tox-pop").remove(); });
                this._outerbody.addClass("panel-body-v-scroll").addClass("enabledd");
                this._body.addClass("dialog-body");
            }
            this.addTabs();
            this._outerbody.append(this._body);
            // create content controls
            let lastIsDropDown = false;
            var list = this.config.fieldList;
            for (var idx = 0; idx < list.length; idx++) {
                var ctrl = $("<div>");
                ctrl.css("margin-right", "15px");
                this._body.append(ctrl);
                this.controls.push({ control: ctrl, name: list[idx].label, fieldId: list[idx].id });
                lastIsDropDown = list[idx].fieldType == "dropdown";
            }
            // add special this.controls, e.g. to create items in folders, or reference list or report buttons
            // these exist only if these are not special items
            if (this.settings.controlState != globals_1.ControlState.HistoryView) {
                var handled = index_3.plugins.renderActionButtons(this.settings, this._body, this.controls);
                if (!handled) {
                    if (this.settings.type.toLowerCase() === "report") {
                        this.renderActionButtonsReport();
                    }
                    else if (!this.settings.isItem && this.settings.controlState === globals_1.ControlState.FormEdit &&
                        !globals_1.globalMatrix.ItemConfig.getCategorySetting(this.settings.type, "syncInfo")) // createf from 'outside' scripts
                     {
                        // a normal folder
                        // add button to create a new folder of this kind
                        var lt = [{ type: this.settings.item.type, name: "Folder", folder: true }];
                        // add button to create an item of this kind
                        var itemTypeName = globals_1.globalMatrix.ItemConfig.getItemConfiguration(this.settings.item.type).label;
                        lt.push({ type: this.settings.item.type, name: itemTypeName });
                        // add buttons to UI
                        this._body.append($("<span class='baseControlHelp'>Tools</span>"));
                        var folderEdit = $("<div class='hidden-print baseControl'></div>");
                        this._body.append(folderEdit);
                        var createTools = new ItemCreationView_1.ItemCreationTools();
                        createTools.renderButtons({
                            parent: this.settings.item.id,
                            dontOpenNewItem: false,
                            control: folderEdit,
                            linkTypes: lt,
                            type: that.settings.type
                        });
                    }
                }
            }
            this.fillControls();
            if (!this.settings.isPrint && !this.settings.isTooltip) {
                this.sendNeedsSave();
                if (lastIsDropDown && this.settings.canEdit) {
                    this._body.css("padding-bottom", "200px");
                }
            }
            // hide stuff and after a little timeout to allow to show richtext2, hide again
            that.showTab();
            window.setTimeout(function () {
                that.showTab();
            }, 501);
            // to enable dropdown menus at end to open completely
            this.resizeItem();
        }
        // initialize options
        // public interface
        destroy() {
            for (var idx = 0; idx < this.controls.length; idx++) {
                if (this.controls[idx].control.getController().destroy) {
                    this.controls[idx].control.getController().destroy();
                }
            }
        }
        getValues(update, latest) {
            for (var idx = 0; idx < this.controls.length; idx++) {
                if (this.controls[idx].fieldId && this.getFieldType(this.controls[idx].fieldId) !== "links") {
                    if (this.controls[idx].isDhfType) {
                        update[this.controls[idx].fieldId] = index_2.mDHF.getValue(this.controls[idx]);
                    }
                    else if (this.controls[idx].ctrlType === "labels") {
                        if (this.settings.id && !globals_1.app.isFolder(this.settings.id)) {
                            if (this.controls[idx].control.getController().getValue(latest)) {
                                var non_review_labels = JSON.parse(this.controls[idx].control.getController().getValue(latest));
                                non_review_labels = matrixlib_1.ml.LabelTools.resetReviewLabels(non_review_labels, this.settings.type, false);
                                update.labels = non_review_labels.join(",");
                            }
                        }
                    }
                    else {
                        update[this.controls[idx].fieldId] = this.controls[idx].control.getController().getValue(latest);
                    }
                }
            }
            return update;
        }
        saveAsync(category, auditAction, valueOverwrites) {
            let that = this;
            let canSaveProceed = true;
            this.controls.forEach(control => {
                const internalController = control.control.getController();
                if (category != "DOC" && internalController.requiresContent && internalController.requiresContent() && internalController.getValue() == "") {
                    matrixlib_1.ml.UI.showError(`Field "${control.name}" is empty!`, `The Project configuration requires the field ${control.name} to have a value.`);
                    canSaveProceed = false;
                }
                if (!Cleanup_1.Cleanup.textOk(internalController.getValue())) {
                    matrixlib_1.ml.UI.showError(`Field "${control.name}" has an invalid character!`, `Remove invalid character to save - they will look probably be rendered as boxes, like \u0002`);
                    canSaveProceed = false;
                }
            });
            if (!canSaveProceed) {
                return $.Deferred().reject("Can't save");
            }
            matrixlib_1.ml.SmartText.updateCaptionsAndReferences();
            function performSaveAsync(latest) {
                var res = $.Deferred();
                let type = that.settings.type ? that.settings.type : matrixlib_1.ml.Item.parseRef(that.settings.parent).type;
                index_3.plugins.callPreSaveHook(that.settings.isItem, type, that.controls).done(function () {
                    // create links and labels and save
                    let linksToCreate = { up: [], down: [] };
                    let labelsToSet = [];
                    for (var idx = 0; idx < that.controls.length; idx++) {
                        if (that.controls[idx].control.getController().linksToCreate) {
                            var lc = that.controls[idx].control.getController().linksToCreate();
                            linksToCreate.up = linksToCreate.up.concat(lc.up);
                            linksToCreate.down = linksToCreate.down.concat(lc.down);
                        }
                        // if a control decides it can trigger labels to be set
                        if (that.controls[idx].control.getController().labelsToSet && that.controls[idx].control.getController().labelsToSet() && that.controls[idx].control.getController().labelsToSet().length > 0) {
                            labelsToSet = labelsToSet.concat(that.controls[idx].control.getController().labelsToSet());
                        }
                    }
                    if ((that.settings.isForm && that.settings.controlState != globals_1.ControlState.HistoryView)
                        || that.settings.controlState === globals_1.ControlState.DialogEdit) { // an item was modified
                        for (var idx = 0; idx < that.controls.length; idx++) {
                            if (valueOverwrites && that.controls[idx].fieldId && valueOverwrites.hasOwnProperty(that.controls[idx].fieldId.toString())) {
                                that.controls[idx].control.getController().setValue(valueOverwrites[that.controls[idx].fieldId]);
                            }
                        }
                        var update = {
                            id: that.settings.id,
                            title: that._title.data("new"),
                            type: that.settings.item.type
                        };
                        if (linksToCreate.up.length > 0) {
                            update["linksUp"] = linksToCreate.up.join();
                        }
                        if (linksToCreate.down.length > 0) {
                            update["linksDown"] = linksToCreate.down.join();
                        }
                        update = that.getValues(update, latest);
                        if (that.settings.isItem) {
                            if (valueOverwrites && valueOverwrites.labels) {
                                update.labels = valueOverwrites.labels.join(",");
                            }
                        }
                        // now update labels if there is something to update
                        if (labelsToSet.length) {
                            update.labels = matrixlib_1.ml.LabelTools.setLabels(update.labels, labelsToSet);
                        }
                        index_1.MR1.triggerBeforeSaveAsync(that, that.settings.item, update).done(function () {
                            globals_1.app.updateItemInDBAsync(update, auditAction, latest ? latest.history.length : that.settings.item.history.length).done(function (result) {
                                update.maxVersion = result.maxVersion;
                                index_1.MR1.triggerAfterSave(that, that.settings.item, update);
                                res.resolve(result);
                            }).fail(function (error) {
                                res.reject(error);
                            });
                        }).fail(function () {
                            matrixlib_1.ml.Logger.log("info", "save cancelled by MR1 script");
                            res.reject("MR1 cancelled");
                        });
                    }
                    else { // an item was created
                        var actions = [];
                        actions.push("Created");
                        var itemJson = {};
                        if (!that.settings.isItem) {
                            itemJson["children"] = []; // make it a folder
                        }
                        for (var idx = 0; idx < that.controls.length; idx++) {
                            if (that.controls[idx].ctrlType === "labels" && that.settings.isItem) {
                                itemJson.labels = "";
                                var valj = matrixlib_1.ml.JSON.fromString(that.controls[idx].control.getController().getValue());
                                if (valj.status === "ok") {
                                    itemJson.labels = valj.value.join();
                                }
                            }
                            else if (that.controls[idx].fieldId) {
                                itemJson[that.controls[idx].fieldId] = that.controls[idx].control.getController().getValue();
                            }
                        }
                        itemJson.title = that._title.data("new");
                        if (linksToCreate.up.length > 0) {
                            itemJson.linksUp = linksToCreate.up.join();
                        }
                        if (linksToCreate.down.length > 0) {
                            itemJson.linksDown = linksToCreate.down.join();
                        }
                        if (labelsToSet.length) {
                            itemJson.labels = matrixlib_1.ml.LabelTools.setLabels(itemJson.labels, labelsToSet);
                        }
                        globals_1.app.createItemOfTypeAsync(category, itemJson, actions.join(), that.settings.parent).done(function (result) {
                            index_1.MR1.triggerAfterItemCreate(result);
                            res.resolve(result);
                        }).fail(function () {
                            res.reject();
                        });
                    }
                }).fail(function () {
                    matrixlib_1.ml.Logger.log("warning", "plugin prevented save!");
                    res.reject("plugin prevented save!");
                    return res;
                });
                return res;
            }
            let needsLatest = false;
            if (this.settings.id) {
                // otherwise this is save during create
                for (var idx = 0; idx < this.controls.length; idx++) {
                    if (this.controls[idx].control.getController().needsLatest) {
                        needsLatest = true;
                    }
                }
            }
            if (needsLatest) {
                var reso = $.Deferred();
                globals_1.app.getItemAsync(this.settings.id).done(function (latest) {
                    performSaveAsync(latest).done(function (result) {
                        reso.resolve(result);
                    }).fail(function (error) {
                        reso.reject(error);
                    });
                }).fail(function (error) {
                    reso.reject(error);
                });
                return reso;
            }
            else {
                return performSaveAsync();
            }
        }
        addMove(itemId, newVersion) {
            // fakes a history change without reloading the item, avoiding merge dialog when saving
            if (this.settings && this.settings.id == itemId && this.settings.item && this.settings.item.history) {
                if (this.settings.item.history.filter(function (he) { return he.version == newVersion; }).length == 0) {
                    // someone else moved it
                    this.settings.item.history.push({ action: "move", comment: "", date: "", dateUserFormat: "", id: itemId, title: "", user: "",
                        version: newVersion });
                }
            }
        }
        resizeItem(force) {
            clearTimeout(this.resizeItTimer);
            this.resizeItTimer = window.setTimeout(() => this.resizeIt(force), 299);
        }
        refreshLinks() {
            for (var cid = 0; cid < this.controls.length; cid++) {
                if (this.controls[cid].control.getController().refreshLinks) {
                    this.controls[cid].control.getController().refreshLinks();
                }
            }
        }
        fillControls() {
            let that = this;
            this.duringFill = true;
            // prepare gate functions
            let gateTitle = false;
            let gated = {}; // if set to true the field will be disabled 
            for (var idx = 0; idx < this.config.fieldList.length; idx++) {
                var fieldType = this.config.fieldList[idx].fieldType;
                if (fieldType === "gateControl") {
                    // get the fields value (for existing items)
                    let fv = this.settings.item ? this.settings.item[this.config.fieldList[idx].id] : "{}";
                    let fvj = (fv ? JSON.parse(fv) : {});
                    let allPassed = fvj.passed;
                    let gateConfig = this.config.fieldList[idx].parameterJson;
                    if (gateConfig && gateConfig.allPass) {
                        if (allPassed && gateConfig.allPass.lockAbove) {
                            // if passed the above will be disabled
                            for (var k = 0; k < idx; k++)
                                gated[this.config.fieldList[k].id] = true;
                        }
                        if (allPassed && gateConfig.allPass.lockTitle) {
                            gateTitle = true;
                        }
                        if (!allPassed && gateConfig.allPass.enableBelow) {
                            // needs to be passed to enable the below
                            for (var k = idx + 1; k < this.config.fieldList.length; k++)
                                gated[this.config.fieldList[k].id] = true;
                        }
                    }
                    else {
                        matrixlib_1.ml.Logger.log("warning", "badly configured gate control in " + this.settings.type);
                    }
                }
            }
            /** in case up or downlinks would be locked because of gate allow them */
            if (globals_1.matrixSession.getUISettings().allowAddLinkToLocked) {
                for (var k = 0; k < this.config.fieldList.length; k++) {
                    if (this.config.fieldList[k].fieldType == "uplinkinfo" || this.config.fieldList[k].fieldType == "links") {
                        gated[this.config.fieldList[k].id] = false;
                    }
                }
            }
            // render title
            var th = globals_1.globalMatrix.ItemConfig.getCategorySetting(this.settings.type, "title");
            let tops = matrixlib_1.ml.JSON.mergeOptions(this.settings, {
                help: (th && th.create) ? th.create : "Title",
                title: this.title,
                valueChanged: () => that.sendNeedsSave(),
                isFolder: globals_1.app.isFolder(this.settings.id),
                dummyData: this.settings.dummyData,
                parameter: {
                    placeholder: (th && th.placeholder) ? th.placeholder : "enter title"
                }
            });
            if (gateTitle) {
                tops.canEditTitle = false;
                tops.canDelete = false;
                tops.canEdit = false;
            }
            if (!globals_1.globalMatrix.ItemConfig.canEditTitle(this.settings.type)) {
                tops.canEditTitle = false;
            }
            if (!globals_1.globalMatrix.ItemConfig.canDelete(this.settings.type)) {
                tops.canDelete = false;
            }
            this._title.html("").titleToolbar(tops);
            // draw UI
            let closeControls = [];
            // make a lookup with controls
            let mapControls = {};
            for (var cid = 0; cid < this.controls.length; cid++) {
                mapControls[this.controls[cid].fieldId] = this.controls[cid];
            }
            // go through all configured fields
            // for performance hide
            if (globals_1.matrixSession.getUISettings().largeFormRender && this.config.fieldList.length > globals_1.matrixSession.getUISettings().largeFormRender) {
                this.settings.control.hide();
            }
            for (var idx = 0; idx < this.config.fieldList.length; idx++) {
                let ui = mapControls[this.config.fieldList[idx].id];
                if (!ui) {
                    matrixlib_1.ml.Logger.log("warn", "field " + this.config.fieldList[idx].id + " is weird...");
                    break;
                }
                var fieldValue = "";
                var fieldType = this.config.fieldList[idx].fieldType;
                var fieldHelp = this.config.fieldList[idx].label;
                ui.isDhfType = false;
                ui.ctrlType = fieldType;
                if (this.settings.item && this.settings.item[this.config.fieldList[idx].id]) {
                    fieldValue = this.settings.item[this.config.fieldList[idx].id];
                }
                var ctrlParameter;
                // prepare parameter for rendering
                (function (cid, clabel) {
                    ctrlParameter = matrixlib_1.ml.JSON.mergeOptions(that.settings, {
                        parameter: that.config.fieldList[idx].parameterJson,
                        fieldId: ui.fieldId,
                        canEdit: that.settings.canEdit && globals_1.app.canEditField(that.settings.type, ui.fieldId) && !gated[ui.fieldId],
                        help: fieldHelp,
                        fieldValue: fieldValue,
                        fieldType: fieldType,
                        valueChanged: function () {
                            that.sendNeedsSave(cid, clabel);
                        }
                    });
                    ctrlParameter.canEdit = ctrlParameter.canEdit && !ctrlParameter.parameter.readonlyACL;
                    if ((that.config.fieldList[idx].fieldType == "uplinkinfo" || that.config.fieldList[idx].fieldType == "links") && !ctrlParameter.canEdit) {
                        // maybe links can still be added even though the item is readonly
                        if (globals_1.matrixSession.getUISettings().allowAddLinkToLocked && that.settings['allowlinkedit'] && !ctrlParameter.parameter.readonlyACL) {
                            ctrlParameter.canEdit = true;
                        }
                        if (that.settings["canEditLinks"]) {
                            ctrlParameter.canEdit = true;
                        }
                    }
                })(ui.fieldId, fieldHelp);
                // whether there should a > to open / close section
                let canCloseSection = that.settings.item && ctrlParameter.isItem && !ctrlParameter.isPrint && ctrlParameter.controlState != globals_1.ControlState.HistoryView && ctrlParameter.isForm && index_2.mDHF && index_2.mDHF.isDocumentType(that.settings.item.type)
                    && !ctrlParameter.parameter.forceOpen;
                if (typeof ctrlParameter.parameter.visibleOption !== 'undefined') {
                    if (matrixlib_1.ml.JSON.isTrue(ctrlParameter.parameter.visibleOption)) {
                    }
                    else if (ctrlParameter.parameter.visibleOption === this.settings.type) {
                    }
                    else {
                        ui.control.hide();
                    }
                }
                if (!globals_1.app.canSeeField(this.settings.type, ui.fieldId)) {
                    ui.control.hide();
                }
                ui.control.html("").addClass("ft_" + fieldType).attr("id", "fid_" + ui.fieldId);
                if (index_3.plugins.supportsControl(fieldType)) {
                    index_3.plugins.createControl(ui.control, ctrlParameter);
                }
                else if (fieldType === "report") {
                    ui.control.plainText(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { rows: 1 } }));
                    globals_1.globalMatrix.EmbeddedReport(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { control: ui.control }));
                }
                else if (fieldType === "richtext") {
                    ui.control.richText(ctrlParameter, this);
                }
                else if (fieldType === "publishedItemList") {
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "publishedFilesList") {
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "publishedContent") {
                    ui.control.publishedContent(ctrlParameter);
                }
                else if (fieldType === "text") {
                    ui.control.plainText(ctrlParameter);
                }
                else if (fieldType === "section") {
                    ui.control.section(ctrlParameter);
                }
                else if (fieldType === "fileManager" || fieldType === "signCache") {
                    ui.control.fileManager(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { titleBarControl: this._title } }));
                }
                else if (fieldType === "docFilter") {
                    ui.control.docFilter(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { help: "Document Filter" }));
                }
                else if (fieldType === "workflow") {
                    ui.control.workflowControl(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { titleBarControl: this._title } }));
                }
                else if (fieldType === "sourceRef") {
                    // type should not exist 
                    matrixlib_1.ml.Logger.log("warning", "Found obsolete type sourceRef");
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "textline" || fieldType === "publishedTitle") {
                    ui.control.plainText(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { rows: 1, allowResize: false } }));
                }
                else if (fieldType === "signatureControl") {
                    canCloseSection = false;
                    ui.control.docSign(ctrlParameter);
                }
                else if (fieldType === "docTraining") {
                    ui.control.docTraining(ctrlParameter);
                }
                else if (fieldType === "docReview") {
                    ui.control.docReview(ctrlParameter);
                }
                else if (fieldType === "user") {
                    let params = ctrlParameter;
                    let userDropdown = matrixlib_1.ml.UI.SelectUserOrGroup.getUserDropDownOptions(!matrixlib_1.ml.JSON.isFalse(params.parameter.showUsers), // by default show users, if not specified
                    matrixlib_1.ml.JSON.isTrue(params.parameter.showGroups), // by default do not show groups
                    undefined, params.fieldValue); // special treatment for deleted users
                    let groups = null;
                    if (!matrixlib_1.ml.JSON.isFalse(params.parameter.showUsers) && matrixlib_1.ml.JSON.isTrue(params.parameter.showGroups)) {
                        groups = [];
                        groups.push({ value: "groups", label: "groups" });
                        groups.push({ value: "users", label: "users" });
                    }
                    ui.control.mxDropdown(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        parameter: {
                            placeholder: params.parameter.placeholder ? params.parameter.placeholder : "select user",
                            // allow only users in project!
                            create: false,
                            options: userDropdown,
                            maxItems: params.parameter.maxItems ? params.parameter.maxItems : 1,
                            groups: groups
                        }
                    }));
                }
                else if (fieldType === "date") {
                    ui.control.dateselect(ctrlParameter);
                }
                else if (fieldType === "dropdown") {
                    ui.control.mxDropdown(ctrlParameter);
                }
                else if (fieldType === "links") {
                    let linkTypes = globals_1.app.getLinkCategories(this.settings.item, ctrlParameter);
                    ui.control.linkCollection(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        parameter: {
                            linkTypes: linkTypes
                        },
                        fieldValue: this.links
                    }));
                }
                else if (fieldType === "crosslinks") {
                    ui.control.itemSelection(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        parameter: {
                            linkTypes: ctrlParameter.parameter.linkTypes ? ctrlParameter.parameter.linkTypes : [],
                            crossProject: true,
                            prefix: ctrlParameter.parameter.prefix ? ctrlParameter.parameter.prefix : "Links",
                        }
                    }));
                }
                else if (fieldType === "steplist") {
                    ui.control.tableCtrl(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        columns: [{ name: "Action", field: "action" }, { name: "Expected Behaviour", field: "expected" }]
                    }));
                }
                else if (fieldType === "risk") {
                    ui.control.riskCtrl(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        links: this.links ? this.links : [] // these are the really existing downlinks (i.e. if someone deleted and item it needs to be removed as mitigation)
                    }));
                }
                else if (fieldType === "risk2") {
                    ui.control.riskCtrl2(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        links: this.links ? this.links : [] // these are the really existing downlinks (i.e. if someone deleted and item it needs to be removed as mitigation)
                    }));
                }
                else if (fieldType === "checkbox") {
                    canCloseSection = false;
                    ui.control.checkBox(ctrlParameter);
                }
                else if (fieldType === "htmlForm") {
                    ui.control.htmlform(ctrlParameter);
                }
                else if (fieldType === "hidden" || fieldType === "filter_file" || fieldType === "signature") {
                    canCloseSection = false;
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "hyperlink") {
                    ui.control.hyperlink(ctrlParameter);
                }
                else if (fieldType === "colorPicker") {
                    ui.control.colorPicker(ctrlParameter);
                }
                else if (fieldType === "reportId") {
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "dhf") {
                    canCloseSection = index_2.mDHF.renderControl(ui, ctrlParameter, fieldValue);
                }
                else if (fieldType === "sourceref") {
                    canCloseSection = !ctrlParameter.parameter.readonly;
                    ui.control.sourceRef(ctrlParameter);
                }
                else if (fieldType === "markAsTemplate") {
                    canCloseSection = !ctrlParameter.parameter.readonly;
                    ui.control.markAsTemplate(ctrlParameter);
                }
                else if (fieldType === "guid") {
                    canCloseSection = false;
                    ui.control.docGUID(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { titleBarControl: this._title } }));
                }
                else if (fieldType === "oid") {
                    canCloseSection = false;
                    ui.control.docOID(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { parameter: { titleBarControl: this._title } }));
                }
                else if (fieldType === "versionLive") {
                    canCloseSection = false;
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "version") {
                    canCloseSection = false;
                    ui.control.hidden(ctrlParameter);
                }
                else if (fieldType === "currentVersion") {
                    ui.control.docVersionInfo(ctrlParameter);
                }
                else if (fieldType === "uplinkinfo") {
                    ui.control.uplinkinfo(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        parameter: {
                            linkTypes: globals_1.app.getLinkCategories(that.settings.item, ctrlParameter)
                        },
                        fieldValue: that.settings.item ? that.settings.item.upLinks : []
                    }));
                }
                else if (fieldType === "labels") {
                    canCloseSection = false;
                    ctrlParameter.fieldValue = (this.settings.item && this.settings.item.labels) ? JSON.stringify(this.settings.item.labels) : "";
                    ui.control.labelsControl(matrixlib_1.ml.JSON.setOptions(ctrlParameter, {
                        restrictEditTo: (that.restrictUnlockTo.length ? that.restrictUnlockTo : null),
                        canEdit: ctrlParameter.canEditLabels && globals_1.globalMatrix.ItemConfig.canModifyLabels(that.settings.type),
                        parameter: { titleBarControl: this._title }
                    }));
                }
                else if (fieldType === "syncStatus") {
                    ui.control.syncStatus(matrixlib_1.ml.JSON.setOptions(ctrlParameter, { controlState: this.orginalControlState }));
                }
                else if (fieldType === "syncSourceInfo") {
                    ui.control.syncSourceInfo(ctrlParameter);
                }
                else if (fieldType === "cascadingSelect") {
                    ui.control.cascadingSelect(ctrlParameter);
                }
                else if (fieldType === "gateControl") {
                    ui.control.gateControl(ctrlParameter);
                }
                else {
                    canCloseSection = false;
                    ui.control.errorControl(ctrlParameter);
                }
                if (ctrlParameter.parameter.invisible) {
                    canCloseSection = false;
                    ui.control.hide();
                }
                if (ctrlParameter.parameter.hide_UI) {
                    if (globals_1.globalMatrix.globalShiftDown && globals_1.matrixSession.isAdmin()) {
                        $(".baseControl", ui.control).css("opacity", "0.8");
                        $(".baseControlHelp", ui.control).css("opacity", "0.8");
                        $(".baseControlHelp", ui.control).text($(".baseControlHelp", ui.control).text() + " (Hidden for normal user)");
                    }
                    else {
                        canCloseSection = false;
                        $(".baseControl", ui.control).hide();
                        $(".baseControlHelp", ui.control).hide();
                    }
                }
                if ((that.settings.isHistory == undefined || that.settings.isHistory < 1) && canCloseSection && that.allowSectionClose(ui, ctrlParameter)) {
                    closeControls.push($(".baseControl", ui.control));
                    $(".baseControl", ui.control).hide();
                }
            }
            // undo performance hide
            this.settings.control.show();
            setTimeout(function (ctrlsToHide) {
                for (var idx = 0; idx < ctrlsToHide.length; idx++) {
                    // weird if controls are hidden only once tables like audit trail are fcked up
                    ctrlsToHide[idx].hide();
                    ctrlsToHide[idx].show();
                    ctrlsToHide[idx].hide();
                }
            }, 10, closeControls);
            setTimeout(function () {
                if (that.settings.item && that.settings.isForm && that.settings.controlState != globals_1.ControlState.HistoryView) {
                    index_1.MR1.triggerItemDisplayed(that.settings.item, that);
                }
                if (!that.settings.item && that.settings.isDialog) {
                    index_1.MR1.triggerItemCreate(that, that.settings.isItem, that.settings.type);
                }
            }, 20);
            this.duringFill = false;
        }
        needsSave() {
            return this.needsSaveImpl();
        }
        hasTitle() {
            return this._title.getController().getValue() && this._title.getController().getValue() != "";
        }
        updateItem(newItem) {
            if (this.settings.id === newItem.id) {
                for (var cid = 0; cid < this.controls.length; cid++) {
                    if (this.controls[cid].control.getController().updateItem) {
                        this.controls[cid].control.getController().updateItem(newItem);
                    }
                }
            }
        }
        setFieldValue(fieldId, newValue) {
            for (var cid = 0; cid < this.controls.length; cid++) {
                if (this.controls[cid].fieldId == fieldId) {
                    this.controls[cid].control.getController().setValue(newValue);
                    this.sendNeedsSave();
                }
            }
        }
        getFieldValue(fieldId) {
            for (var cid = 0; cid < this.controls.length; cid++) {
                if (this.controls[cid].fieldId == fieldId) {
                    return this.controls[cid].control.getController().getValue();
                }
            }
            return null;
        }
        getCurrentTitle() {
            return this._title.getController().getValue();
        }
        setViewers(viewers) {
            return this._title.getController().setViewers(viewers);
        }
        getControls(fieldType) {
            var result = [];
            for (var idx = 0; idx < this.config.fieldList.length; idx++) {
                for (var cid = 0; cid < this.controls.length; cid++) {
                    if (this.controls[cid].fieldId === this.config.fieldList[idx].id) {
                        if (!fieldType || this.config.fieldList[idx].fieldType === fieldType) {
                            result.push(this.controls[cid].control);
                        }
                    }
                }
            }
            return result;
        }
        /** returns (first) control with a given title */
        getControlByName(name) {
            for (var cid = 0; cid < this.controls.length; cid++) {
                if (this.controls[cid].name.toLowerCase() == name.toLowerCase()) {
                    return this.controls[cid].control;
                }
            }
            return null;
        }
        /** returns control with a given id */
        getControlById(fieldId) {
            for (var cid = 0; cid < this.controls.length; cid++) {
                if (this.controls[cid].fieldId == fieldId) {
                    return this.controls[cid].control;
                }
            }
            return null;
        }
        // check if the version displayed is older than the current one
        wasUpdated(itemId, historyLength) {
            if (this.settings && this.settings.item && this.settings.item.id == itemId && this.settings.item.history && this.settings.item.history.length < historyLength) {
                return true;
            }
            return false;
        }
        // private functions
        addTabs() {
            let that = this;
            if (!this.settings.isForm || this.settings.isHistory) {
                return;
            }
            let tabDefinition = globals_1.globalMatrix.ItemConfig.getCategorySetting(this.settings.type, "tabs");
            if (!tabDefinition || !tabDefinition.tabs || tabDefinition.tabs.length <= 1) {
                return;
            }
            let tabs = $('<div id="itemTabs" style="color: #333333; background-color: var(--Grey8); margin-top: -4px; padding: 4px; border-top: 1px solid lightgray;">').insertAfter(this._title);
            $.each(tabDefinition.tabs, function (tabIdx, tab) {
                $("<span style='padding:4px;cursor:pointer'>").html(tab.name).appendTo(tabs).click(function () {
                    that.showTab(tabIdx);
                });
            });
        }
        showTab(active) {
            if (!this.settings.isForm || this.settings.isHistory) {
                return;
            }
            let tabDefinition = globals_1.globalMatrix.ItemConfig.getCategorySetting(this.settings.type, "tabs");
            if (!tabDefinition || !tabDefinition.tabs || tabDefinition.tabs.length <= 1) {
                return;
            }
            if (active == undefined) {
                // get favorite tab in this session in this project
                active = 0;
                let lasttab = ItemControl.lastTab[globals_1.matrixSession.getProject() + ":" + this.settings.type];
                if (lasttab) {
                    active = lasttab;
                }
            }
            // remember favorite tab in this session in this project
            ItemControl.lastTab[globals_1.matrixSession.getProject() + ":" + this.settings.type] = active;
            $("#itemTabs span").css("font-weight", "100");
            $($("#itemTabs span")[active]).css("font-weight", "600");
            $.each(this.controls, function (cidx, control) {
                if (tabDefinition.tabs.filter(function (tab) { return tab.fields.indexOf("" + control.fieldId) != -1; }).length == 0) {
                    // field not in a specific tab so don'T hide it (like title bar or labels)
                }
                else if (tabDefinition && tabDefinition.tabs && tabDefinition.tabs.length && control.fieldId && tabDefinition.tabs[active].fields.indexOf("" + control.fieldId) != -1) {
                    control.control.show();
                }
                else {
                    control.control.hide();
                }
            });
        }
        allowSectionClose(ctrl, ctrlParameter) {
            let isClosed = ctrlParameter.item && globals_1.globalMatrix.projectStorage.getItem('visible' + ctrlParameter.item.id + "_" + ctrl.fieldId) !== 'true';
            // add > control open and close section
            let helpLabel = $("<label for='docfield" + ctrl.fieldId + "'>");
            let baseControlHelp = $(".baseControlHelp", ctrl.control);
            let checkbox = $("<input id='docfield" + ctrl.fieldId + "' class='showHideAdmin' type='checkbox' " + (isClosed ? "" : "checked") + ">");
            // put checkbox before label
            baseControlHelp.parent().prepend(checkbox);
            // put help into label
            baseControlHelp.wrap(helpLabel);
            // put triangle before help text
            baseControlHelp.before("<span class='cbimg'>");
            checkbox.change(function (e) {
                var visibility = $(e.delegateTarget).is(':checked');
                globals_1.globalMatrix.projectStorage.setItem('visible' + ctrlParameter.item.id + "_" + ctrl.fieldId, visibility ? 'true' : 'false');
                if (!visibility) {
                    $(".baseControl", $(e.delegateTarget).closest("div")).hide();
                    $(".inlineHelp", $(e.delegateTarget).closest("div")).hide();
                }
                else {
                    $(".baseControl", $(e.delegateTarget).closest("div")).show();
                    $(".inlineHelp", $(e.delegateTarget).closest("div")).show();
                    // make sure table this.controls are nice shown
                    if (ctrl.control.getController().redraw) {
                        ctrl.control.getController().redraw();
                    }
                }
            });
            return isClosed;
        }
        resizeIt(forceRedraw) {
            // add a scrollbar to the form if needed
            if (this.settings.isForm && this.settings.controlState != globals_1.ControlState.HistoryView) {
                this._outerbody.height(this.settings.control.height() - this._title.outerHeight() - 8 - ($(".labelBar").height() ? $(".labelBar").height() : 0));
            }
            else {
                forceRedraw = true; // dialogs should always completely redraw tables otherwise they are badly rendered
            }
            var hasScrollbar = this._outerbody.height() < this._body.height();
            // beautify widths if needed
            for (var idx = 0; idx < this.controls.length; idx++) {
                if (this.controls[idx].control.getController().resizeItem) {
                    this.controls[idx].control.getController().resizeItem(this._outerbody.width() - (hasScrollbar ? 15 : 0), forceRedraw);
                }
            }
        }
        needsSaveImpl() {
            // label change while readonly..
            let labelChange = false;
            for (var idx = 0; idx < this.controls.length; idx++) {
                if (this.controls[idx] && this.controls[idx].ctrlType == "labels" && this.controls[idx].control && this.controls[idx].control.getController && this.controls[idx].control.getController().hasChanged()) {
                    labelChange = true;
                }
            }
            if (!this.settings.canEdit && !labelChange) {
                return false;
            }
            for (var idx = 0; idx < this.controls.length; idx++) {
                if (this.controls[idx] && this.controls[idx].control && this.controls[idx].control.getController && this.controls[idx].control.getController().hasChanged() ||
                    (this.controls[idx].isDhfType && index_2.mDHF.configChanged(this.controls[idx]))) {
                    if (!this.startEdit && !this.duringFill && !this.settings.isDialog) {
                        this.startEdit = true;
                    }
                    return true;
                }
            }
            return false;
        }
        getFieldType(fieldId) {
            return globals_1.globalMatrix.ItemConfig.getFieldType(this.settings.isItem ? this.settings.type : "FOLDER", fieldId);
        }
        sendNeedsSave(fieldId, fieldName) {
            if (this.settings.changed) {
                this.settings.changed(this.needsSave());
            }
            // give the gates a chance to reset themselves
            if (fieldId) {
                for (var idx = 0; idx < this.controls.length; idx++) {
                    if (this.controls[idx] && this.controls[idx].ctrlType == "gateControl") {
                        this.controls[idx].control.getController().changed(fieldId, fieldName);
                    }
                }
            }
        }
        renderActionButtonsReport() {
            let that = this;
            var id = this.settings.item ? this.settings.item.id : "";
            if (globals_1.globalMatrix.ItemConfig.getExtrasConfig().enableLegacyReport == undefined || globals_1.globalMatrix.ItemConfig.getExtrasConfig().enableLegacyReport == "0") {
                that._body.html(`<p>REPORT is a legacy feature since MatrixReq v2.3. If required, ask your administrator to reactivate it.</p>             
            <ul><li>Use <span class="link" id="EXPORTDOC">DOC (documents)</span> to create printable reports</li>
            <li>You can export data as EXCEL or XML in here: <span class="link" id="EXPORTURL">EXPORT</span></li>
            <li>You can export the data also in the admin client, selecting the project</li>
            </ul>`);
                $("#EXPORTURL").click(() => globals_1.app.treeSelectionChangeAsync("EXPORT"));
                $("#EXPORTDOC").click(() => globals_1.app.treeSelectionChangeAsync("F-DOC-1"));
                return;
            }
            var showTools = true;
            if (this.settings.controlState === globals_1.ControlState.Print || this.settings.controlState === globals_1.ControlState.Tooltip ||
                this.settings.controlState === globals_1.ControlState.DialogCreate || this.settings.controlState === globals_1.ControlState.HistoryView) {
                showTools = false;
            }
            var inputRestriction = false; // by default use input as specified in report
            var inputFilter; // by default no filter
            var inputItems;
            var requiredItems;
            if (this.settings.item && this.settings.item.selectSubTree && this.settings.item.selectSubTree.length) {
                inputRestriction = true;
                inputFilter = [];
                inputItems = [];
                for (var idx = 0; idx < this.settings.item.selectSubTree.length; idx++) {
                    var cat = this.settings.item.selectSubTree[idx].category;
                    if (globals_1.globalMatrix.ItemConfig.getCategories().indexOf(cat) !== -1) {
                        inputFilter.push(cat);
                        inputItems.push({ to: this.settings.item.selectSubTree[idx].rootFolder });
                    }
                }
            }
            if (this.settings.item && this.settings.item.requireSubTree) {
                requiredItems = [];
                for (var idx = 0; idx < this.settings.item.requireSubTree.length; idx++) {
                    var cat = this.settings.item.requireSubTree[idx].category;
                    if (globals_1.globalMatrix.ItemConfig.getCategories().indexOf(cat) !== -1) {
                        requiredItems.push({ to: this.settings.item.requireSubTree[idx].rootFolder });
                    }
                }
            }
            function showInputSelectDialog() {
                function saveAndCloseDialog() {
                    var inputItems = tree.getController().getValue();
                    //MATRIX-3722 Local (browser) storage of REPORT selections is screwed and make the REPORT unusable --> Change of the localstorage item and disable the sanitize
                    if (rememberCheckbox.prop("checked")) {
                        globals_1.globalMatrix.projectStorage.setItem('remember_items_selection_' + id, JSON.stringify(inputItems), true);
                    }
                    else {
                        globals_1.globalMatrix.projectStorage.setItem('remember_items_selection_' + id, "", true);
                    }
                    dlg.dialog("close");
                }
                matrixlib_1.ml.Search.searchInDialog();
                var preferred = (typeof index_2.mDHF !== "undefined") ? index_2.mDHF.getDefaultFormat("REPORT") : "docx";
                var formats = [];
                for (var idx = 0; idx < that.settings.item.availableFormats.length; idx++) {
                    var pos = (preferred === that.settings.item.availableFormats[idx]) ? 0 : formats.length;
                    switch (that.settings.item.availableFormats[idx]) {
                        case "html":
                            formats.splice(pos, 0, {
                                name: "HTML",
                                click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "html" }, tree.getController().getValue(), requiredItems);
                                    saveAndCloseDialog();
                                    return false;
                                }
                            });
                            break;
                        case "docx":
                            formats.splice(pos, 0, {
                                name: "Word",
                                click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "docx" }, tree.getController().getValue(), requiredItems);
                                    saveAndCloseDialog();
                                    return false;
                                }
                            });
                            break;
                        case "pdf":
                            formats.splice(pos, 0, {
                                name: "PDF",
                                click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "pdf" }, tree.getController().getValue(), requiredItems);
                                    saveAndCloseDialog();
                                    return false;
                                }
                            });
                            break;
                        case "xml":
                            formats.splice(pos, 0, {
                                name: "XML",
                                click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "xml" }, tree.getController().getValue(), requiredItems);
                                    saveAndCloseDialog();
                                    return false;
                                }
                            });
                            break;
                        default:
                            break;
                    }
                }
                var linkTypes = [];
                for (var idx = 0; idx < inputFilter.length; idx++) {
                    linkTypes.push(inputFilter[idx]);
                }
                var selectedItems = matrixlib_1.ml.JSON.clone(inputItems);
                // check if selection was stored
                //MATRIX-3722 Local (browser) storage of REPORT selections is screwed and make the REPORT unusable --> Change of the localstorage item and disable the sanitize
                var selectionStored = globals_1.globalMatrix.projectStorage.getItem('remember_items_selection_' + id, true);
                if (selectionStored && selectionStored !== "") {
                    selectedItems = JSON.parse(selectionStored);
                }
                // build tree with default (root nodes) or selected items
                var tree = $("<div>").projectView({
                    tree: globals_1.app.getTree(linkTypes),
                    controlState: globals_1.ControlState.DialogCreate,
                    selectedItems: selectedItems,
                    canSelectItems: true,
                    selectMode: ProjectViewDefines_1.SelectMode.auto,
                    collectionChanged: function (count) {
                    }
                });
                var rememberCheckbox;
                let dlg = $("#selectItemDlg");
                dlg.html("");
                dlg.removeClass("dlg-v-scroll");
                dlg.addClass("dlg-no-scroll");
                dlg.append(tree);
                var niceSize = matrixlib_1.ml.UI.getNiceDialogSize(500, 400);
                dlg.dialog({
                    autoOpen: true,
                    title: that.settings.item.title + " Report - Select Input",
                    height: niceSize.height,
                    width: niceSize.width,
                    modal: true,
                    close: function () {
                        dlg.parent().html('');
                        dlg.css('display', "none");
                        // dlg is gone, remove highlights and back to global highlighting
                        matrixlib_1.ml.Search.endSearchInDialog();
                    },
                    resizeStop: function () {
                        dlg.resizeDlgContent([tree]);
                    },
                    open: function () {
                        if (formats.length > 0) {
                            $(".ui-dialog-buttonpane button:contains('Ok')", dlg.parent()).replaceWith(matrixlib_1.ml.UI.createDropDownButton("Create", formats, true, true));
                        }
                        rememberCheckbox = $('<input type="checkbox" name="remember" ' + (selectionStored ? "checked" : "") + '>');
                        $('.ui-dialog-buttonpane button:contains(Remember)', dlg.parent()).replaceWith($('<label class="dlgCreateMultiple">').append(rememberCheckbox).append('Remember Selection'));
                    },
                    buttons: [{
                            text: 'Remember',
                            class: '',
                            click: function () { }
                        }, {
                            text: 'Ok',
                            class: 'btnDoIt',
                            click: function () { }
                        }, {
                            text: 'Cancel',
                            class: 'btnCancelIt',
                            click: function () {
                                dlg.dialog("close");
                            }
                        }]
                }).resizeDlgContent([tree], false);
            }
            function createReportButton(name) {
                var formats = [];
                var preferred = (typeof index_2.mDHF !== "undefined") ? index_2.mDHF.getDefaultFormat("REPORT") : "docx";
                for (var idx = 0; idx < that.settings.item.availableFormats.length; idx++) {
                    var pos = (preferred === that.settings.item.availableFormats[idx]) ? 0 : formats.length;
                    switch (that.settings.item.availableFormats[idx]) {
                        case "html":
                            formats.splice(pos, 0, { name: "HTML", click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "html" }, inputRestriction ? inputItems : null, requiredItems);
                                    return false;
                                } });
                            break;
                        case "docx":
                            formats.splice(pos, 0, { name: "Word", click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "docx" }, inputRestriction ? inputItems : null, requiredItems);
                                    return false;
                                } });
                            break;
                        case "pdf":
                            formats.splice(pos, 0, { name: "PDF", click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "pdf" }, inputRestriction ? inputItems : null, requiredItems);
                                    return false;
                                } });
                            break;
                        case "xml":
                            formats.splice(pos, 0, { name: "XML", click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "xml" }, inputRestriction ? inputItems : null, requiredItems);
                                    return false;
                                } });
                            break;
                        case "zip":
                            formats.splice(pos, 0, { name: "Word with attachments", click: function () {
                                    matrixlib_1.ml.ReportGenerator.CreateReport(id, { format: "zipdocx" }, inputRestriction ? inputItems : null, requiredItems);
                                    return false;
                                } });
                            break;
                        default:
                            break;
                    }
                }
                return matrixlib_1.ml.UI.createDropDownButton(name, formats, false, false);
            }
            function RenderReportDefinitionDialog(body, controls) {
                var selectedReport = null;
                var dlgInner = body.parent();
                var dlgOuter = dlgInner.parent();
                var titleCtrl;
                var decriptionCtrl;
                var decriptionCtrlValue;
                var reportIdCtrl;
                for (var idx = 0; idx < controls.length; idx++) {
                    if (controls[idx].name === "Title") {
                        titleCtrl = controls[idx].control;
                        titleCtrl.hide();
                    }
                    else if (controls[idx].name === "Description") {
                        decriptionCtrl = controls[idx].control;
                    }
                    else if (controls[idx].name === "reportId") {
                        reportIdCtrl = controls[idx].control;
                        reportIdCtrl.hide();
                    }
                }
                setTimeout(function () {
                    dlgOuter.dialog("option", "height", 500);
                    dlgOuter.dialog("option", "width", 730);
                    $(".dlgCreateMultiple", dlgOuter.parent()).hide();
                }, 1);
                globals_1.app.getAvailableReportsAsync().done(function (availableReports) {
                    var reportSelection = [];
                    var groups = [];
                    var groupList = [];
                    for (var idx = 0; idx < availableReports.reportList.length; idx++) {
                        var group = availableReports.reportList[idx].group;
                        group = group ? group : "hidden"; // by default do not show 1.5 and earlier reports
                        if (group.indexOf("MR_") === 0) {
                            var dhf_config = globals_1.globalMatrix.ItemConfig.getDHFConfig();
                            if (dhf_config && dhf_config.customReports && dhf_config.customReports.group === group) {
                                group = "Custom";
                            }
                            else {
                                group = "hidden";
                            }
                        }
                        if (availableReports.reportList[idx].label.toLowerCase() !== "legacy" &&
                            availableReports.reportList[idx].id.toLowerCase() !== "dhf_generic" &&
                            group !== "hidden") {
                            reportSelection.push({
                                id: availableReports.reportList[idx].id,
                                label: availableReports.reportList[idx].label,
                                class: group
                            });
                            if (groups.indexOf(group) === -1) {
                                groups.push(group);
                                groupList.push({ value: group, label: group });
                            }
                        }
                    }
                    function selectReport(selId) {
                        for (var idx = 0; idx < availableReports.reportList.length; idx++) {
                            if (availableReports.reportList[idx].id === selId) {
                                selectedReport = availableReports.reportList[idx];
                            }
                        }
                        titleCtrl.getController().titleCreationMode();
                        titleCtrl.getController().setValue(selectedReport.label, true);
                        if (!decriptionCtrlValue || decriptionCtrlValue === $($("<div>").html(decriptionCtrl.getController().getValue())).text()) {
                            // not changed, set to selected item
                            decriptionCtrl.getController().setValue(selectedReport.description);
                            decriptionCtrlValue = $($("<div>").html(decriptionCtrl.getController().getValue())).text();
                        }
                        reportIdCtrl.getController().setValue(selectedReport.id);
                    }
                    var reportSelector = $("<div>");
                    reportSelector.mxDropdown({
                        controlState: globals_1.ControlState.DialogCreate,
                        canEdit: true,
                        dummyData: false,
                        help: 'Select Report Template',
                        fieldValue: "",
                        valueChanged: function () {
                            selectReport(reportSelector.getController().getValue());
                        },
                        parameter: {
                            placeholder: 'select report',
                            readonly: false,
                            maxItems: 1,
                            options: reportSelection,
                            groups: groupList,
                            create: false,
                            sort: true // true sort options
                        }
                    });
                    dlgInner.prepend(reportSelector);
                });
            }
            if (that.settings.isItem) {
                if (that.settings.controlState === globals_1.ControlState.DialogCreate) {
                    RenderReportDefinitionDialog(that._body, that.controls);
                }
                else if (showTools) {
                    var rt = $("<div style='padding-top:12px;padding-bottom:12px;'>");
                    that._body.append(rt);
                    if (globals_1.globalMatrix.ItemConfig.canReport("REPORT")) {
                        if (inputRestriction) {
                            // user can select input items from tree -> pop up a dialog an let choose
                            var inputSelectionGroup = $("<div  class='hidden-print inputSelectionGroup'></div>");
                            rt.append(inputSelectionGroup);
                            inputSelectionGroup.append($("<button id='createReportButton' class='btn btn-default'>").html("Create Report").click(function () {
                                showInputSelectDialog();
                            }));
                        }
                        else {
                            // uses all input let's create report
                            rt.append(createReportButton("Create Report"));
                        }
                    }
                    else {
                        rt.append("<div class='inlineHelp'>You have no rights to download documents</div>");
                    }
                }
            }
            else if (that.settings.controlState === globals_1.ControlState.FormEdit && globals_1.app.canCreateItemType("REPORT")) {
                that._body.append($("<span class='baseControlHelp'>Tools</span>"));
                var folderEdit = $("<div class='hidden-print baseControl'></div>");
                that._body.append(folderEdit);
                var createTools = new ItemCreationView_1.ItemCreationTools();
                var createButtons = [{ type: that.settings.item.type, name: "Folder", folder: true }, { type: that.settings.item.type, name: "Report Template" }];
                createTools.renderButtons({
                    parent: that.settings.item.id,
                    dontOpenNewItem: false,
                    control: folderEdit,
                    linkTypes: createButtons,
                    type: that.settings.type
                });
            }
        }
    }
    exports.ItemControl = ItemControl;
    ItemControl.lastTab = {};
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 19 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SearchUpdate = exports.SearchState = exports.SelectMode = void 0;
    var SelectMode;
    (function (SelectMode) {
        /*** DO NOT CHANGED numbers use from baseControl */
        SelectMode[SelectMode["none"] = 0] = "none";
        SelectMode[SelectMode["items"] = 1] = "items";
        SelectMode[SelectMode["folders"] = 2] = "folders";
        SelectMode[SelectMode["singleItem"] = 3] = "singleItem";
        SelectMode[SelectMode["singleFolder"] = 4] = "singleFolder";
        SelectMode[SelectMode["independent"] = 5] = "independent";
        SelectMode[SelectMode["auto"] = 6] = "auto";
        SelectMode[SelectMode["independentAuto"] = 7] = "independentAuto";
        SelectMode[SelectMode["autoPrecise"] = 8] = "autoPrecise"; //  if you select a folder it select everything within, if you unselect something it unselects all parents
    })(SelectMode || (SelectMode = {}));
    exports.SelectMode = SelectMode;
    var SearchState;
    (function (SearchState) {
        SearchState[SearchState["NoSearch"] = 0] = "NoSearch";
        SearchState[SearchState["FilterDone"] = 1] = "FilterDone";
        SearchState[SearchState["ServerRunning"] = 2] = "ServerRunning";
        SearchState[SearchState["ServerDone"] = 3] = "ServerDone"; // the search results returned
    })(SearchState || (SearchState = {}));
    exports.SearchState = SearchState;
    var SearchUpdate;
    (function (SearchUpdate) {
        SearchUpdate[SearchUpdate["inserted_node"] = 1] = "inserted_node";
        SearchUpdate[SearchUpdate["updated_rec"] = 2] = "updated_rec";
        SearchUpdate[SearchUpdate["filter_status_changed"] = 3] = "filter_status_changed";
        SearchUpdate[SearchUpdate["title_changed"] = 4] = "title_changed";
        SearchUpdate[SearchUpdate["item_dropped"] = 5] = "item_dropped"; // an item was draged and dropped to a new place (if this happens after creating it , it must be refreshed)
    })(SearchUpdate || (SearchUpdate = {}));
    exports.SearchUpdate = SearchUpdate;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 20 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(18), __webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, index_1, index_2, matrixlib_1, ItemForm_1, MainTree_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ItemCreationTools = void 0;
    class ItemCreationTools {
        // pops up a dialog to create one or more items of the given type
        showDialog(options) {
            this.showCreateDialog(options);
        }
        renderButtons(options) {
            let that = this;
            if (options.type && !globals_1.globalMatrix.ItemConfig.canCreate(options.type)) {
                options.control.append("<div class='inlineHelp'>You have no rights to create items or folders in this category</div>");
                return;
            }
            // save on open callback if there is any
            this.onOpenDlg = options.open;
            for (var idx = 0; idx < options.linkTypes.length; idx++) {
                var disabled = globals_1.app.canCreateItemType(options.linkTypes[idx].type, options.linkTypes[idx].folder) ? "" : "disabled";
                var seleniumClass = "";
                var name = options.linkTypes[idx].buttonName ? options.linkTypes[idx].buttonName : "Create";
                name += " <b>" + options.linkTypes[idx].name + "<b>";
                seleniumClass = "sel_create_" + (options.linkTypes[idx].folder ? "Folder" : options.linkTypes[idx].type);
                if (options.linkTypes[idx].buttonName == "Import") {
                    seleniumClass = "sel_import_" + options.linkTypes[idx].name;
                }
                var riskFormat = options.isRiskControl ? "btn-sm " + (idx === 0 ? "rcb0" : "rcbn") : "";
                if (options.tinybuttons) { // overwrite style
                    riskFormat = options.isRiskControl ? "btn-xs rcbn" : "btn-xs";
                    name = "+" + options.linkTypes[idx].type;
                }
                var button = $("<button class='" + riskFormat + " buttonCreateSelect btn btn-default " + seleniumClass + "' " + disabled + ">" + name + "</button>");
                var parent = globals_1.app.getRootOfType(options.linkTypes[idx].type);
                if (options.parent) {
                    parent = options.parent;
                }
                let btnInfo = {
                    type: options.linkTypes[idx].type,
                    name: options.linkTypes[idx].name,
                    folder: options.linkTypes[idx].folder,
                    created: options.created,
                    parent: parent,
                    singleCreate: options.singleCreate,
                    dontOpenNewItem: options.dontOpenNewItem
                };
                if (options.linkTypes[idx].import) {
                    button.click(() => index_2.mDHF.showCreateFromDocx(btnInfo));
                }
                else {
                    button.click(() => this.showCreateDialog(btnInfo));
                }
                options.control.append(button);
                if (!globals_1.globalMatrix.ItemConfig.canCreate(options.linkTypes[idx].type)) {
                    matrixlib_1.ml.UI.setEnabled(button, false);
                }
            }
        }
        showCreateDialog(options) {
            let that = this;
            // options.type -> the type of item to create
            // options.name -> the name of item type to create
            // options.created callback called after item was created
            // options.closed callback called after dialog was closed
            // options.multiple NYI (allow to create several
            // options.parent -> needed for folder tools (undefinef for root folders)
            // options.folder -> true for folder tools
            // prepare dialog - nice and clean..
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            // render form
            // The boolean {controlInitialized} is necessary because otherwise we can get
            // a JavaScript error in {reviewSaveState} below, if ctrl is not defined.
            let controlInitialized = false;
            let ctrl = new ItemForm_1.ItemControl({
                control: globals_1.app.dlgForm,
                controlState: globals_1.ControlState.DialogCreate,
                parent: options.parent,
                type: options.type,
                isItem: !options.folder,
                changed: function () {
                    reviewSaveState();
                }
            });
            controlInitialized = true;
            function reviewSaveState() {
                if (controlInitialized) {
                    changeSaveState(ctrl.needsSave() && ctrl.hasTitle());
                }
            }
            var createdMultiple = false;
            index_1.MR1.onItemCreateDlgOpen().subscribe(this, this.onDialogOpen);
            let ok = false;
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Create new " + options.name,
                height: 300,
                width: 900,
                modal: true,
                closeOnEscape: false,
                open: function () {
                    if (options.singleCreate) {
                        $('.ui-dialog-buttonpane button:eq(0)', globals_1.app.dlgForm.parent()).hide();
                    }
                    else {
                        $('.ui-dialog-buttonpane button:eq(0)', globals_1.app.dlgForm.parent()).replaceWith('<label class="dlgCreateMultiple"><input type="checkbox" name="createMultiple">' +
                            'Create multiple</label>');
                    }
                    // needs to be after line above (changes the first button;-)
                    changeSaveState(false);
                    globals_1.matrixSession.startCommitTransaction();
                },
                close: function () {
                    index_1.MR1.onItemCreateDlgOpen().unsubscribe(that.onDialogOpen);
                    index_1.MR1.triggerItemCreateClose(ok);
                    ctrl.destroy();
                    globals_1.app.dlgForm.parent().html('');
                    globals_1.app.dlgForm.css('display', "none");
                    if (options.closed) {
                        options.closed();
                    }
                    globals_1.matrixSession.stopCommitTransaction();
                },
                resizeStop: function () {
                    globals_1.app.dlgForm.resizeDlgContent([ctrl]);
                },
                buttons: [{
                        text: 'Create multiple',
                        class: 'btnCreateMultiple',
                        click: function () {
                        }
                    }, {
                        text: 'Create',
                        class: 'btnDoIt',
                        click: function () {
                            ok = true;
                            window.setTimeout(function () {
                                // disable button during creation
                                // this needs to be done as soon as the create callback was handled
                                changeSaveState(false);
                            }, 1);
                            window.setTimeout(function () {
                                save();
                            }, 200);
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.matrixSession.stopCommitTransaction();
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            }).resizeDlgContent([ctrl], true);
            // disable create button
            function changeSaveState(enabled) {
                var saveButton = $('.ui-dialog-buttonpane button:eq(0)', globals_1.app.dlgForm.parent());
                matrixlib_1.ml.UI.setEnabled(saveButton, enabled);
            }
            var save = function () {
                if (ctrl.needsSave()) {
                    ctrl.saveAsync(options.type, null).done(function (result) {
                        if (!createdMultiple) {
                            // make sure the item is visible, open the folder 
                            MainTree_1.NavigationPanel.openFolder(options.parent);
                        }
                        if (options.created) {
                            options.created({ to: result.item.id, title: result.item.title });
                        }
                        if (!$("input[name=createMultiple]", globals_1.app.dlgForm.parent()).is(':checked')) {
                            globals_1.app.dlgForm.dialog("close");
                            if (!createdMultiple && !options.dontOpenNewItem && (options.folder || !globals_1.matrixSession.getUISettings().legacyKeepFolder && !globals_1.app.needsSave())) {
                                // just one folder was created: select it in tree
                                globals_1.app.treeSelectionChangeAsync(result.item.id);
                            }
                        }
                        else {
                            createdMultiple = true;
                            changeSaveState(false);
                            ctrl.destroy();
                            ctrl.fillControls();
                        }
                    }).fail(function () {
                        changeSaveState(true);
                    });
                }
            };
            return this;
        }
        ;
        onDialogOpen(event) {
            let that = event.caller;
            if (that.onOpenDlg) {
                that.onOpenDlg(event.view);
            }
        }
        showCreateDialogEvent(event) {
            this.showCreateDialog({
                type: event.data.type,
                name: event.data.name,
                folder: event.data.folder,
                created: event.data.created,
                parent: event.data.parent,
                singleCreate: event.data.singleCreate,
                dontOpenNewItem: false
            });
        }
        ;
    }
    exports.ItemCreationTools = ItemCreationTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 21 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -----------------------------------------------------------
// Project tree (on left of default layout)
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(12), __webpack_require__(17), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, index_1, Components_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.NavigationPanel = exports.MainTreeImpl = void 0;
    class MainTreeImpl {
        constructor() {
            let that = this;
            // define default settings
            this.settings = {
                noAnimation: false,
                highlight: true,
                canFilter: true,
                serverSearch: true,
                expand: 0,
                canSelectItems: false,
                canFilterExclusiv: true,
                selectedItems: [],
                controlState: globals_1.ControlState.FormEdit,
                dropCallback: (moveDetails) => {
                    if (moveDetails.itemId === globals_1.app.getCurrentItemId() &&
                        globals_1.app.getNeedsSave()) {
                        matrixlib_1.ml.UI.showError("Save First", "Please save the changes before moving the item.");
                        return false;
                    }
                    globals_1.app.moveItemsAsync(moveDetails.itemId, moveDetails.parentId, moveDetails.index).done(function () {
                        if (moveDetails.updateUI) {
                            moveDetails.updateUI();
                        }
                    }).fail(function () {
                    });
                    return true;
                },
                selectionChanged: (id) => {
                    if (that.triggerSelectionChange) {
                        globals_1.app.treeSelectionChangeAsync(id).done(function () {
                        }).fail(function () {
                        });
                    }
                }
            };
            this.init($("#projectTree"));
            this.triggerSelectionChange = true;
        }
        init(control) {
            this._jui = control;
        }
        render(treeSettings) {
            // Register with search tools.
            let that = this;
            matrixlib_1.ml.Search.OnCancelSearch.subscribe(that, function (arg) {
                that.clearFilter();
            });
            if (treeSettings) {
                this.settings = treeSettings;
            }
            this.settings["tree"] = globals_1.app.getTree();
            this.settings.isMainTree = true;
            this._jui.html("");
            this._jui.projectView(this.settings);
            window.setTimeout(function () {
                $(".ui-fancytree").focus();
            }, 200);
            index_1.plugins.updateSearchPanel();
        }
        update(item) {
            // if the node changed, it might be the title: update in tree
            if (typeof item.title == "undefined") {
                // a partial update (only some fields or labels) will not change label
                return;
            }
            // avoid 'malicious' item titles...
            item.title = item.title.replace(/</g, "&lt;");
            this._jui.getController().setTitle(item.id, item.title);
        }
        remove(itemId) {
            this._jui.getController().removeNode(itemId);
        }
        // open a folder (optionally also parent folders)
        openFolder(itemId, expandToRoot) {
            this._jui.getController().openTree(itemId);
            if (expandToRoot) {
                var parent = globals_1.app.getParentId(itemId);
                if (parent && parent != "F-PROJECT") {
                    NavigationPanel.openFolder(itemId, true);
                }
            }
        }
        // open a folder (optionally also parent folders)
        closeFolder(itemId) {
            this._jui.getController().closeTree(itemId);
        }
        select(itemId) {
            this.triggerSelectionChange = false;
            try {
                Components_1.NavBar.activateItemsTab(itemId);
                this._jui.getController().select(itemId);
            }
            catch (ex) {
                // the change of selection can fail if the tree is filtered (so the item is not shown)
            }
            this.triggerSelectionChange = true;
        }
        isSelected(itemId) {
            return this._jui.getController().isSelected(itemId);
        }
        insertInTree(newItem, noEscape) {
            // the parameter new item contains information about the new item
            // newitem = {parent: ID of (parent) folder, position: position inside folder, item: json object defining the item 
            // the item itself has ("title", "type", "id", and "children" if it is a folder
            if (newItem && newItem.item && !noEscape)
                newItem.item.title = newItem.item.title.replace(/</g, "&lt;");
            this._jui.getController().insertNode(newItem.parent, newItem.item, { at: newItem.position });
        }
        moveInTree(itemId, newParentId, newPosition) {
            this._jui.getController().moveNode(newParentId, itemId, newPosition);
        }
        insertUpdateTreeRec(target, source) {
            // this function either replaces the target and or a child of the target with the new database stuff, if the source does not exists it's added
            if (target === source.id) {
                this._jui.getController().updateRec(source);
            }
            else {
                this._jui.getController().insertRec(target, source);
            }
        }
        destroy() {
            this._jui.html("");
        }
        clearFilter() {
            // called if the user starts searching in a selection dialog to remove highlights from NavigationPanel
            if (this._jui && this._jui.getController)
                this._jui.getController().clearFilter();
        }
        updateItemIsUnselected(itemId, isUnselected) {
            if (this._jui && this._jui.getController)
                this._jui.getController().updateItemIsUnselected(itemId, isUnselected);
        }
        updateNotificationCounters() {
            if (this._jui && this._jui.getController)
                this._jui.getController().updateNotificationCounters();
        }
    }
    exports.MainTreeImpl = MainTreeImpl;
    var NavigationPanel = new MainTreeImpl();
    exports.NavigationPanel = NavigationPanel;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 22 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(23), __webpack_require__(25), __webpack_require__(27), __webpack_require__(28), __webpack_require__(1), __webpack_require__(10), __webpack_require__(29), __webpack_require__(12), __webpack_require__(19), __webpack_require__(33)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, ProjectList_1, ProjectTree_1, SearchBox_1, ViewModeSelector_1, matrixlib_1, RefLinkDefines_1, Notifications_1, index_1, ProjectViewDefines_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ProjectView = void 0;
    $.fn.projectView = function (options) {
        let baseControl = new ProjectView(this);
        this.getController = () => { return baseControl; };
        baseControl.init(options);
        return this;
    };
    class ProjectView {
        constructor(control) {
            this._root = control;
        }
        init(options) {
            var _a;
            let that = this;
            var defaultOptions = {
                controlState: globals_1.ControlState.FormView,
                highlight: true,
                canFilter: true,
                serverSearch: true,
                expand: 0,
                selectedItems: [],
                dragAndDrop: (options.controlState === globals_1.ControlState.FormEdit),
                tree: [],
                tooltips: true,
                selectionChanged: function () { },
                dropCallback: function () { },
                collectionChanged: function (count) { },
                selectMode: 0,
                autoScroll: true
            };
            this.settings = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, options);
            this.settings.dragAndDrop = this.settings.dragAndDrop && globals_1.matrixSession.isEditor();
            // render and search
            var ctrlDiv = $("<div class='treeCtrl'>");
            this._root.append(ctrlDiv);
            this.projectTree = new ProjectTree_1.ProjectTree(this, this.settings.canFilter);
            this.listView = new ProjectList_1.ListView(this);
            this.searchBox = new SearchBox_1.SearchBox(this);
            this.viewModeSelector = new ViewModeSelector_1.ViewModeSelector(this);
            // let expandMinLevel = 2;
            // if ( this.settings.tree.length > 1 ) {
            //     this.settings.expand = 0;
            //     expandMinLevel = 0;
            // }
            // initialize object
            if (this.settings.controlState === globals_1.ControlState.Print || this.settings.controlState === globals_1.ControlState.Tooltip) {
                return; // nothing to do
            }
            // add ui for filter and search
            if (this.settings.canFilter) {
                // tree/list filter method
                var filter = $(`<div id="searchFilter" data-cy='searchFilter' class="" style="position:relative;width:100%"></div>`);
                ctrlDiv.append(filter);
                filter.append(this.viewModeSelector.getVizModeControl(function () {
                    that.searchBox.render();
                }));
                // search field
                this.searchBox.renderSearchField(filter, this.settings.serverSearch, that.settings.highlight, (_a = that.settings.isConfigSearch) !== null && _a !== void 0 ? _a : false);
            }
            // add ui for tree
            this.tree = $('<div name="ftree" data-cy="tree" class="treeContent"></div>');
            this._root.append(this.tree);
            var doNotTriggerSelectionChange = false; // if true the client will not be informed,
            var rememberLastActivation; // to avoid double activations (which can arrive if one saves while it gets activated again)
            // determine native select mode of tree
            var sm = 0;
            switch (this.settings.selectMode) {
                case ProjectViewDefines_1.SelectMode.none: //(later we must hide checkboxes)
                case ProjectViewDefines_1.SelectMode.singleItem:
                case ProjectViewDefines_1.SelectMode.singleFolder:
                    sm = 1; // checking one item will uncheck other checked
                    break;
                case ProjectViewDefines_1.SelectMode.items:
                case ProjectViewDefines_1.SelectMode.folders:
                case ProjectViewDefines_1.SelectMode.independent:
                case ProjectViewDefines_1.SelectMode.independentAuto:
                case ProjectViewDefines_1.SelectMode.autoPrecise:
                    sm = 2; // checkboxes for items and/or folders, checking one does not influence other
                    break;
                case ProjectViewDefines_1.SelectMode.auto:
                    sm = 3;
                    break;
            }
            let fireUpdates = true;
            var fto = {
                checkbox: this.settings.selectMode != ProjectViewDefines_1.SelectMode.none,
                selectMode: sm,
                clickFolderMode: 4,
                autoActivate: false,
                autoCollapse: false,
                imagePath: globals_1.globalMatrix.matrixBaseUrl + "/img/",
                autoScroll: this.settings.autoScroll,
                keyboard: true,
                tabbable: true,
                minExpandLevel: 1,
                focus: function (e, data) {
                    var ctree = $(e.delegateTarget).find(".ui-fancytree");
                    if (!ctree.is(":focus")) {
                        ctree.focus();
                    }
                },
                expand: function (e, data) {
                    if (that.settings.onExpand) {
                        that.settings.onExpand(data.node.key);
                    }
                    index_1.plugins.updateTree();
                },
                blur: function (e, data) {
                    data.node.scheduleAction("cancel", 0);
                },
                select: function (e, data) {
                    if (fireUpdates) {
                        that.saveSelection("new");
                    }
                },
                activate: function (e, data) {
                    var node = data.node;
                    if (!doNotTriggerSelectionChange && that.settings.selectionChanged && rememberLastActivation !== node.key) { // call app 
                        rememberLastActivation = node.key;
                        that.settings.selectionChanged.apply(null, [node.key]);
                    }
                },
                click: function (e, data) {
                    // TODO(modules): not sure how to fix this. There is a namespace declaration in
                    // externals-fancytree, but it doesn't work.
                    var tt = ($.ui).fancytree.getEventTargetType(e.originalEvent);
                    if (tt !== "expander" && tt !== "checkbox" && data.node && !data.node.expanded) {
                        data.node.setExpanded();
                    }
                    // now follows a workaround for MATRIX-634 label filtering tree kaput
                    // the jquery toggle function (with a nice event) gets somehow screwed in fancy tree
                    // so I just wait a little and after 220 ms I make sure the item is actually toggled
                    if (tt === "expander" || (data.node && !data.node.expanded)) {
                        var node = data.node;
                        var x = $(node.ul);
                        var y = data.node.expanded;
                        window.setTimeout(function () {
                            y ? x.hide() : x.show();
                        }, 220);
                    }
                    if (that.settings.selectMode == ProjectViewDefines_1.SelectMode.independentAuto && tt === "checkbox" && data.node.folder && !data.node.isSelected()) {
                        fireUpdates = false;
                        that.projectTree.selectChildren(data.node);
                        fireUpdates = true;
                    }
                    if (that.settings.selectMode == ProjectViewDefines_1.SelectMode.autoPrecise && tt === "checkbox") {
                        if (data.node.folder && !data.node.isSelected()) {
                            fireUpdates = false;
                            that.projectTree.selectChildren(data.node);
                            fireUpdates = true;
                        }
                        if (data.node.isSelected()) {
                            fireUpdates = false;
                            that.projectTree.unselectParents(data.node);
                            if (data.node.folder) {
                                that.projectTree.unSelectChildren(data.node);
                            }
                            fireUpdates = true;
                        }
                        // set partial selection status after click
                        window.setTimeout(() => { that.projectTree.forcePartial(); }, 1);
                    }
                    return true;
                },
                renderNode: function (event, data) {
                    var _a;
                    // Optionally tweak data.node.span
                    var node = data.node;
                    var myNodeData = node.data;
                    if (myNodeData.cstrender) {
                        node.unselectable = that.settings.selectMode == ProjectViewDefines_1.SelectMode.none
                            || (node.folder && (that.settings.selectMode == ProjectViewDefines_1.SelectMode.items || that.settings.selectMode == ProjectViewDefines_1.SelectMode.singleItem))
                            || (!node.folder && (that.settings.selectMode == ProjectViewDefines_1.SelectMode.folders || that.settings.selectMode == ProjectViewDefines_1.SelectMode.singleFolder));
                        var $span = $(node.span);
                        let dataCy = (_a = myNodeData.shortTitle) !== null && _a !== void 0 ? _a : myNodeData.title;
                        if (dataCy != undefined) {
                            dataCy = $(`<span>${dataCy}</span>`).text().replace(" ", "-");
                            $span.attr("data-cy", dataCy);
                        }
                        if (node.unselectable) {
                            $(".fancytree-checkbox", $span).remove();
                        }
                        if (myNodeData.background) {
                            $span.css("background-color", myNodeData.background);
                        }
                        if (myNodeData.border) {
                            $span.css("border", myNodeData.border);
                        }
                        if (node.parent.parent === null) {
                            // grey borders around root nodes 
                            // $span.css("background-color", "#e5e5e5").css("border", "1px solid rgb(204, 204, 204)");
                        }
                        if (that.settings.selectionChanged) { // call app 
                            $span.find("> span.fancytree-title").refLink({
                                id: node.key,
                                folder: node.folder,
                                title: myNodeData.shortTitle,
                                css: myNodeData.extraStyle,
                                style: RefLinkDefines_1.refLinkStyle.show,
                                tooltip: that.settings.tooltips ? RefLinkDefines_1.refLinkTooltip.html : RefLinkDefines_1.refLinkTooltip.none,
                                crossProject: that.settings.crossProject,
                                callback: function () {
                                    if (that.settings.canSelectItems) {
                                        node.toggleSelected();
                                    }
                                    // prevent second round trip in activate
                                    rememberLastActivation = node.key;
                                    var ret = that.settings.selectionChanged.apply(null, [node.key]);
                                    return ret;
                                }
                            });
                        }
                        else {
                            $span.find("> span.fancytree-title").refLink({
                                id: node.key,
                                folder: node.folder,
                                title: myNodeData.shortTitle,
                                style: RefLinkDefines_1.refLinkStyle.link,
                                css: myNodeData.extraStyle,
                                crossProject: that.settings.crossProject,
                                tooltip: that.settings.tooltips ? RefLinkDefines_1.refLinkTooltip.html : RefLinkDefines_1.refLinkTooltip.none
                            });
                        }
                    }
                },
                extensions: ["dnd", "filter"],
                dnd: {
                    preventVoidMoves: true,
                    preventRecursiveMoves: true,
                    autoExpandMS: 400,
                    focusOnClick: true,
                    dragStart: function (node) {
                        return that.settings.dragAndDrop && globals_1.app.canDragDrop(node.data.type, node.key);
                    },
                    dragEnter: function (node, dddata) {
                        if (dddata === null || dddata.otherNode === null || dddata.otherNode.data === null) {
                            return false;
                        }
                        if (globals_1.app.dragEnter) {
                            return globals_1.app.dragEnter(dddata.otherNode, node);
                        }
                        if (dddata.otherNode.data.type !== node.data.type) {
                            return false;
                        }
                        if (node.folder) {
                            if (node.parent.data.type !== dddata.otherNode.data.type) {
                                return ["after"];
                            }
                            return true;
                        }
                        if (node.parent === null || node.parent.data.type !== dddata.otherNode.data.type) {
                            return false;
                        }
                        return ["before", "after"];
                    },
                    dragOver: function (node, dddata, hitMode) {
                        /** Return false to disallow dropping this node.
                         *
                         */
                        // Prevent dropping a parent below it's own child
                        if (!dddata || node.isDescendantOf(dddata.otherNode)) {
                            matrixlib_1.ml.Logger.log("error", "FALSE node.isDescendantOf(dddata)");
                            return false;
                        }
                        // Prohibit creating childs in non-folders (only sorting allowed)
                        if (!node.data.isFolder && hitMode === "over") {
                            matrixlib_1.ml.Logger.log("error", "after !node.data.isFolder && hitMode ==='over'");
                            return "after";
                        }
                    },
                    dragDrop: function (node, dddata) {
                        if (that.settings.dragAndDrop) {
                            var target = that.calculateDropTarget(node, dddata.hitMode);
                            that.settings.dropCallback.apply(null, [{
                                    parentId: target.key,
                                    itemId: dddata.otherNode.key,
                                    index: target.index,
                                    updateUI: function () {
                                        dddata.otherNode.moveTo(node, dddata.hitMode);
                                        var key = dddata.otherNode.key;
                                        that.render(ProjectViewDefines_1.SearchUpdate.item_dropped, key);
                                    }
                                }]);
                        }
                    },
                    dragStop: function (node, dddata) {
                        // after a drag and drop the selection in the tree changes (no idea why)
                        // to prevent the client to do this the following lines are required
                        // the timeout ensures that all triggers started by the drag finished when resetting
                        // doNotTriggerSelectionChange 
                        doNotTriggerSelectionChange = true;
                        var selectionBeforeDrag = globals_1.app.getCurrentItemId();
                        window.setTimeout(function () {
                            that.tree.fancytree("getTree").options.autoScroll = false;
                            that.tree.fancytree("getTree").activateKey(selectionBeforeDrag);
                            that.tree.fancytree("getTree").options.autoScroll = true;
                            doNotTriggerSelectionChange = false;
                        }, 1);
                    }
                } //dnd: {
            };
            if (this.settings.canFilter) {
                fto["filter"] = {
                    mode: "dimm",
                    autoApply: true
                };
            }
            if (this.settings.noAnimation) {
                fto["toggleEffect"] = false;
            }
            if (Notifications_1.NotificationList.isEnabled() && this.settings.isMainTree) {
                if (fto.extensions) {
                    fto.extensions.push("notificationCounter");
                }
                else {
                    fto["extensions"] = ["notificationCounter"];
                }
            }
            this.tree.fancytree(fto); // $("#tree").fancytree({
            this.projectTree.treeFromDb(this.settings.tree);
            if (!globals_1.matrixSession.isConfigClient()) {
                // do the initial filtering: maybe there are some project labels
                this.searchBox.resetSearch();
            }
            // select items
            $.each(this.settings.selectedItems, function (index, key) {
                var item = that.tree.fancytree("getTree").getNodeByKey(key.to);
                if (item) {
                    item.setSelected();
                    if (that.settings.selectMode == ProjectViewDefines_1.SelectMode.autoPrecise && matrixlib_1.ml.Item.parseRef(key.to).isFolder) {
                        that.forceSelectChildren(key.to);
                    }
                }
            });
            if (that.settings.selectMode == ProjectViewDefines_1.SelectMode.autoPrecise) {
                // set partial selection for special precision mode
                that.projectTree.forcePartial();
            }
            if (this.settings.expand && this.settings.expand > 0) {
                this.tree.fancytree("getRootNode").visit(function (node) {
                    if (node.getLevel() <= that.settings.expand)
                        node.setExpanded(true);
                });
            }
            this.resizeItem();
            this.saveSelection("original");
            this.saveSelection("new");
        }
        forceSelectChildren(id) {
            let that = this;
            for (let child of globals_1.app.getChildrenIds(id)) {
                let item = that.tree.fancytree("getTree").getNodeByKey(child);
                if (item) {
                    item.setSelected();
                    if (matrixlib_1.ml.Item.parseRef(child).isFolder) {
                        that.forceSelectChildren(child);
                    }
                }
            }
        }
        // public interface
        hasChanged() {
            return JSON.stringify(this._root.data("original")) !== JSON.stringify(this._root.data("new"));
        }
        getValue() {
            return this._root.data("new");
        }
        setValue(selectedItems) {
            this.projectTree.setSelectedItems(selectedItems);
            this.listView.setSelectedItems(selectedItems);
        }
        toggleSelection(selected) {
            if (this.viewModeSelector.showAsList()) {
                this.listView.selectAll(selected);
            }
            else {
                this.projectTree.selectAll(selected);
            }
        }
        destroy() {
        }
        resizeItem() {
            this.searchBox.updateHeights();
        }
        clearFilter() {
            this.searchBox.resetSearch();
        }
        filterStatusChanged(itemId) {
            this.render(ProjectViewDefines_1.SearchUpdate.filter_status_changed, itemId);
        }
        // tree creation
        insertNode(parentKey, item, position) {
            var nn = this.projectTree.addNode(this.projectTree.getNode(parentKey), item, position);
            this.render(ProjectViewDefines_1.SearchUpdate.inserted_node, item.id, item);
        }
        moveNode(parentId, itemId, position) {
            var nn = this.projectTree.moveNode(parentId, itemId, position);
            this.render(ProjectViewDefines_1.SearchUpdate.inserted_node, itemId);
            this.projectTree.openTree(parentId);
        }
        refresh() {
            this.render(ProjectViewDefines_1.SearchUpdate.inserted_node);
        }
        updateRec(item) {
            this.projectTree.updateRec(item);
            this.searchBox.render();
        }
        insertRec(parentKey, item) {
            this.projectTree.insertRec(parentKey, item);
            this.searchBox.render();
        }
        updateTopPosition(top) {
            if (!this.settings.canFilter) {
                $(".treeContent", this._root).css("top", "4px");
                $(".listContent", this._root).css("top", "4px");
            }
            else {
                $(".treeContent", this._root).css("top", top + "px");
                $(".listContent", this._root).css("top", top + "px");
            }
        }
        appendController(controller) {
            this._root.append(controller);
        }
        render(subtree, itemId, item) {
            if (subtree === ProjectViewDefines_1.SearchUpdate.inserted_node ||
                subtree === ProjectViewDefines_1.SearchUpdate.filter_status_changed ||
                subtree === ProjectViewDefines_1.SearchUpdate.item_dropped ||
                subtree === ProjectViewDefines_1.SearchUpdate.title_changed) {
                this.listView.redrawItem(item ? item.id : itemId);
                if (subtree === ProjectViewDefines_1.SearchUpdate.inserted_node ||
                    subtree === ProjectViewDefines_1.SearchUpdate.filter_status_changed ||
                    subtree === ProjectViewDefines_1.SearchUpdate.title_changed) { // MATRIX-1378
                    this.projectTree.applyFilter();
                }
            }
        }
        openTree(key) {
            this.projectTree.openTree(key);
        }
        closeTree(key) {
            this.projectTree.closeTree(key);
        }
        setTitle(key, title) {
            if (this.projectTree.setTitle(key, title)) {
                this.render(ProjectViewDefines_1.SearchUpdate.title_changed, key);
            }
        }
        removeNode(key) {
            this.projectTree.removeNode(key);
        }
        select(key) {
            this.projectTree.select(key);
        }
        isSelected(key) {
            return this.projectTree.isSelected(key);
        }
        updateItemIsUnselected(itemId, isUnselected) {
            if (this.projectTree.updateItemIsUnselected(itemId, isUnselected)) {
                this.filterStatusChanged(itemId);
            }
        }
        updateNotificationCounters() {
            this.projectTree.updateNotificationCounters();
        }
        saveSelection(target) {
            var sel = this.tree.fancytree("getTree").getSelectedNodes(this.settings.selectMode == ProjectViewDefines_1.SelectMode.auto || this.settings.selectMode == ProjectViewDefines_1.SelectMode.autoPrecise);
            var selKey = [];
            for (var idx = 0; idx < sel.length; idx++) {
                let myNodeData = sel[idx].data;
                let title = (sel[idx].folder && sel[idx].title) ? sel[idx].title : (myNodeData && myNodeData.shortTitle) ? myNodeData.shortTitle : sel[idx].title;
                selKey.push({ to: sel[idx].key, title: title });
            }
            this._root.data(target, selKey);
            this.settings.collectionChanged.apply(null, [sel.length]);
        }
        calculateDropTarget(targetNode, mode) {
            // simulate fancy tree to check where it would go
            if (mode === undefined || mode === "over") {
                mode = "child";
            }
            var targetParent = (mode === "child") ? targetNode : targetNode.parent;
            var pos = 0;
            if (targetParent.hasChildren()) {
                switch (mode) {
                    case "child":
                        // Append to existing target children
                        pos = targetParent.children.length;
                        break;
                    case "before":
                        // Insert this node before target node
                        pos = $.inArray(targetNode, targetParent.children);
                        break;
                    case "after":
                        // Insert this node after target node
                        pos = 1 + $.inArray(targetNode, targetParent.children);
                        break;
                }
            }
            return {
                key: targetParent.key,
                index: pos
            };
        }
    }
    exports.ProjectView = ProjectView;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 23 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(19), __webpack_require__(1), __webpack_require__(24), __webpack_require__(10), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ProjectViewDefines_1, matrixlib_1, NavigationBar_1, RefLinkDefines_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ListView = void 0;
    class ListView {
        constructor(panel) {
            // results from the last search
            this.hits = [];
            this.selected = [];
            this.projectWarn = false;
            this.sRoot = $("<div>"); // a list with all selected nodes
            this.uRoot = $("<div>"); // a list with all search results
            this.nodes = {}; // a lookup from id to ui node to show / hide search results
            this.panel = panel;
            this.control = $("<div class='listContent'>");
            this.panel.appendController(this.control);
            if (panel.settings.glueToBottom) {
                this.control.css("bottom", 0);
            }
            this.control.hide();
        }
        // show the list
        show() {
            this.control.show();
        }
        // hide the list
        hide() {
            this.control.hide();
        }
        setSelectedItems(selectedItems) {
            let that = this;
            $.each(selectedItems, function (hidx, hit) {
                if (that.selected.indexOf(hit) === -1) {
                    that.selected.push(hit);
                    var node = that.getFancyTree().getNodeByKey(hit);
                    if (node) {
                        node.setSelected(true);
                    }
                }
            });
            this.showNodes();
        }
        redrawItem(itemId) {
            let newNode = this.getFancyTree().getNodeByKey(itemId);
            // this can be called if the visibility status changed or the item was renamed
            $.each($(".node_" + itemId, this.control), function (idx, ui_node) {
                if (!newNode) {
                    $(ui_node).hide();
                }
                else {
                    newNode.data.isUnselected ? $(ui_node).hide() : $(ui_node).show();
                    let title = newNode.title;
                    if (title.indexOf(newNode.key + " ") == 0) {
                        // that's a weird hack -> in items the newNode.title has the item ID inside, in folders the newNode.data.title
                        // we need to have just the title
                        title = title.replace(newNode.key + " ", "");
                    }
                    $(".refTitle", $(ui_node)).html(title);
                }
            });
        }
        filterList(match) {
            let that = this;
            this.projectWarn = false;
            this.selected = [];
            this.hits = [];
            var hitCount = 0;
            if (match) {
                var treeMatch = (match + "").replace(/([.?*+\^\$\[\]\\(){}|-])/g, "\\$1"); // make sure a '.' is treated literally
                var treeMatchRegEx = new RegExp(".*" + treeMatch + ".*", "i");
                this.getFancyRootNode().visit(function (node) {
                    if ((!that.panel.prefixCategory || matrixlib_1.ml.Item.parseRef(node.key).type == that.panel.prefixCategory) && !!treeMatchRegEx.exec(node.title)) {
                        if (node.data.isUnselected) {
                            // project label filter
                            that.projectWarn = true;
                        }
                        else {
                            that.hits.push(node.key);
                            hitCount++;
                        }
                    }
                    if (node.selected) {
                        that.selected.push(node.key);
                    }
                });
            }
            else {
                // project label filter
                this.getFancyRootNode().visit(function (node) {
                    if (node.data.isUnselected) {
                        // project label filter
                        that.projectWarn = true;
                    }
                    else {
                        hitCount++;
                    }
                    if (node.selected) {
                        that.selected.push(node.key);
                    }
                });
            }
            return this.showNodes();
        }
        ;
        showSearchResults(serverSearchResults) {
            let that = this;
            this.projectWarn = false;
            this.selected = [];
            this.hits = [];
            // only show items in list which would be in (subtree)
            $.each(serverSearchResults, function (idx, key) {
                var node = that.getFancyTree().getNodeByKey(key);
                if (node) {
                    that.hits.push(key);
                }
            });
            this.getFancyRootNode().visit(function (node) {
                if (node.data.isUnselected) {
                    // project label filter
                    that.projectWarn = true;
                }
                if (node.selected) {
                    that.selected.push(node.key);
                }
            });
            return this.showNodes(); //serverSearchResults, this.selected, this.projectWarn );  
        }
        ;
        selectAll(setSelected) {
            let that = this;
            if (setSelected) {
                $.each(this.hits, function (hidx, hit) {
                    if (that.selected.indexOf(hit) === -1 && (that.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.auto || !matrixlib_1.ml.Item.parseRef(hit).isFolder)) {
                        that.selected.push(hit);
                        var node = that.getFancyTree().getNodeByKey(hit);
                        if (node) {
                            node.setSelected(true);
                        }
                    }
                });
            }
            else {
                $.each(this.selected, function (sidx, sel) {
                    var node = that.getFancyTree().getNodeByKey(sel);
                    if (node) {
                        node.setSelected(false);
                    }
                });
                this.selected = [];
            }
            this.showNodes();
        }
        getTitleFromTree(itemId) {
            let title = "";
            this.getFancyRootNode().visit(function (node) {
                if (node.key == itemId) {
                    title = node.data.shortTitle;
                }
            });
            return title;
        }
        showNodes(all) {
            let that = this;
            function divider(text) {
                var x = $("<div style='position:relative'>");
                x.append($("<div>").append($("<hr style='margin-top:10px;margin-bottom:10px;border-color: lightgrey;'>")));
                x.append($("<div style='color:lightgrey;position:absolute;right:0;margin-top:-10px'>").html(text));
                return x;
            }
            // maybe remove folders if checkboxes should be shown
            var hitsDisplay = [];
            if (!this.panel.settings.canSelectItems || this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.auto) {
                hitsDisplay = this.hits;
            }
            else {
                $.each(this.hits, function (hidx, hit) {
                    if (!matrixlib_1.ml.Item.parseRef(hit).isFolder) {
                        hitsDisplay.push(hit);
                    }
                });
            }
            ;
            let counts = {
                current: hitsDisplay.length,
                total: hitsDisplay.length,
                perTab: that.panel.settings.crossProject ? [] : NavigationBar_1.NavBar.countPerTab(hitsDisplay)
            };
            if (this.panel.settings.isMainTree) {
                hitsDisplay = hitsDisplay.filter(function (itemId) {
                    return NavigationBar_1.NavBar.isInCurrentTab(itemId);
                });
                counts.current = hitsDisplay.length;
            }
            // split list in checked and unchecked
            this.sRoot = $("<div>");
            this.uRoot = $("<div>");
            this.nodes = {};
            this.noSelected = $("<span style='color:grey;width:100%;text-align:center;padding-top:20px'>nothing selected</span>");
            this.control.html("");
            if (this.panel.settings.canSelectItems) {
                this.control.append(divider("selected"));
                this.control.append(this.sRoot);
                this.control.append(divider("search results"));
            }
            this.control.append(this.uRoot);
            this.sRoot.append(this.noSelected);
            if (this.selected.length > 0) {
                this.noSelected.hide();
                $.each(this.selected, function (sn, n) {
                    that.sRoot.append(that.createNode(n, true));
                });
            }
            // decide how many items to show in list view -> by default 200
            let ui = globals_1.matrixSession.getCustomerSettingJSON("ui", {});
            let maxShow = ui.maxHits ? ui.maxHits : 200;
            let actualShow = all ? hitsDisplay.length : Math.min(hitsDisplay.length, maxShow);
            for (let sn = 0; sn < actualShow; sn++) {
                let n = hitsDisplay[sn];
                let node = that.createNode(n, false);
                that.uRoot.append(node);
                that.nodes[n] = node;
                if (that.selected.indexOf(n) !== -1) {
                    node.hide();
                }
            }
            ;
            // if not allow were shown, allow user to show the rest
            if (hitsDisplay.length > actualShow) {
                let showRest = $(`<div class='showMore' >show ${hitsDisplay.length - actualShow} remaining...</div>`);
                that.uRoot.append(showRest);
                showRest.on("click", () => {
                    showRest.replaceWith(matrixlib_1.ml.UI.getSpinningWait("please wait..."));
                    window.setTimeout(() => {
                        that.showNodes(true);
                    }, 1);
                });
            }
            return counts;
        }
        createNode(itemId, checked) {
            let that = this;
            function toggleSelect(checkbox) {
                var id = checkbox.data("itemId");
                if (checkbox.prop("checked")) { // now it has been checked
                    if (that.panel.settings.singleSelect) {
                        // unselect the current 
                        that.panel.toggleSelection(false);
                    }
                    // hide it
                    if (that.nodes[id]) {
                        checkbox.prop("checked", "");
                        that.nodes[id].hide();
                    }
                    // add it to the  list of hits
                    that.sRoot.append(that.createNode(id, true));
                    // add it to global selection
                    var node = that.getFancyTree().getNodeByKey(id);
                    if (node) {
                        node.setSelected(true);
                    }
                }
                else {
                    // uncheck it, 
                    checkbox.parent().remove();
                    // show it in search results (if it is a hit)
                    if (that.nodes[id]) {
                        that.nodes[id].show();
                    }
                    // remove from global selection
                    var node = that.getFancyTree().getNodeByKey(id);
                    if (node) {
                        node.setSelected(false);
                    }
                }
                if (that.sRoot.children().length > 1) {
                    that.noSelected.hide();
                }
                else {
                    that.noSelected.show();
                }
            }
            var cnode = $("<div class='search-list-node node_" + itemId + "'>");
            if (this.panel.settings.canSelectItems) {
                var cb = $('<input type="checkbox" ' + (checked ? 'checked' : '') + ' class="listSelect" >');
                cnode.append(cb);
                cb.click(function (event) {
                    // this is the item
                    toggleSelect($(event.delegateTarget));
                }).data("itemId", itemId);
            }
            var node = $("<span>");
            cnode.append(node);
            if (this.panel.settings.selectionChanged && !this.panel.settings.canSelectItems) { // call app 
                node.refLink({
                    id: itemId,
                    folder: false,
                    title: this.panel.settings.crossProject ? that.getTitleFromTree(itemId) : globals_1.app.getItemTitle(itemId),
                    style: globals_1.app.isHiddenLink(itemId) ? RefLinkDefines_1.refLinkStyle.show : RefLinkDefines_1.refLinkStyle.select,
                    tooltip: this.panel.settings.tooltips ? RefLinkDefines_1.refLinkTooltip.html : RefLinkDefines_1.refLinkTooltip.none,
                    crossProject: this.panel.settings.crossProject,
                    callback: function () {
                        $(".search-list-node-selected", cnode.parent()).removeClass("search-list-node-selected");
                        cnode.addClass("search-list-node-selected");
                        globals_1.app.treeSelectionChangeAsync(itemId);
                    }
                });
                node.addClass("search-list-node");
                $(".refTitle", cnode).click(function () {
                    $(".search-list-node-selected", cnode.parent()).removeClass("search-list-node-selected");
                    cnode.addClass("search-list-node-selected");
                    globals_1.app.treeSelectionChangeAsync(itemId);
                });
            }
            else {
                node.refLink({
                    id: itemId,
                    folder: false,
                    title: this.panel.settings.crossProject ? that.getTitleFromTree(itemId) : globals_1.app.getItemTitle(itemId),
                    style: RefLinkDefines_1.refLinkStyle.link,
                    crossProject: this.panel.settings.crossProject,
                    tooltip: this.panel.settings.tooltips ? RefLinkDefines_1.refLinkTooltip.html : RefLinkDefines_1.refLinkTooltip.none
                });
                node.click(function (event) {
                    var checkbox = $(event.delegateTarget).parent().find("input");
                    checkbox.prop("checked", !checkbox.prop("checked"));
                    toggleSelect(checkbox);
                });
            }
            return cnode;
        }
        getFancyRootNode() {
            return this.panel.tree.fancytree("getRootNode");
        }
        getFancyTree() {
            return this.panel.tree.fancytree("getTree");
        }
    }
    exports.ListView = ListView;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 24 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// bar left side of screen
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.initialize = exports.NavBar = exports.NavigationBar = exports.TabMode = void 0;
    var TabMode;
    (function (TabMode) {
        TabMode[TabMode["ShowAsDefault"] = 1] = "ShowAsDefault";
        TabMode[TabMode["HideAsDefault"] = 2] = "HideAsDefault";
    })(TabMode || (TabMode = {}));
    exports.TabMode = TabMode;
    class NavigationBar {
        constructor() {
            this.rootTabMap = {};
            this.workFolders = [];
            this.enabled = false;
            let that = this;
            $(window).resize(function () {
                that.resizeBarItems();
            });
        }
        static getDefaultBar(project) {
            return {
                disableTabs: false,
                tabs: [
                    {
                        name: globals_1.matrixSession.isQMSProject(project) ? "Quality Manual" : "Design",
                        icon: "fal fa-paint-brush",
                        mode: TabMode.ShowAsDefault,
                        other: ["F-DOC-1", "F-SIGN-1", "_", "F-REPORT-1", "F-PUB-1"],
                    },
                    {
                        name: "Documents",
                        icon: "fal fa-book",
                        mode: TabMode.HideAsDefault,
                        other: ["F-DOC-1", "F-SIGN-1"],
                    },
                    {
                        name: "Tools",
                        icon: "fal fa-tools",
                        mode: TabMode.HideAsDefault,
                        other: ["_", "F-REPORT-1"],
                    },
                    {
                        name: "Publish",
                        icon: "fal fa-upload",
                        mode: TabMode.HideAsDefault,
                        other: ["F-PUB-1"],
                    }
                ]
            };
        }
        static getConfig() {
            let setting = globals_1.globalMatrix.ItemConfig.getNavigationBarConfig();
            if (!setting || JSON.stringify(setting) == "{}" || !setting.tabs) {
                const project = globals_1.matrixSession.getProject();
                return NavigationBar.getDefaultBar(project);
            }
            return setting;
        }
        // navigation bar left
        init() {
            let that = this;
            if (!globals_1.app.mainApp)
                return;
            $("#navLeft").remove();
            // unless there's a project / server specific bar
            let projectSetting = NavigationBar.getConfig();
            this.enabled = !projectSetting.disableTabs;
            if (!this.enabled) {
                NavigationBar.navbarWidth = 0;
                $("#sidebar").css("left", 0);
                $('#main').css("left", $("#sidebar").width() + "px");
                $(".mainHelp").show();
                return;
            }
            NavigationBar.navbarWidth = 30;
            $(".mainHelp").hide();
            $("#sidebar").css("left", NavigationBar.navbarWidth + "px");
            $('#main').css("left", (NavigationBar.navbarWidth + $("#sidebar").width()) + "px");
            this.bar = matrixlib_1.ml.JSON.clone(projectSetting);
            $.each(this.bar.tabs, function (tabIdx, tab) {
                let tools = tab.other.indexOf("_");
                if (tools != -1) {
                    // replace this by tools
                    tab.other.splice(tools, 1, ...that.workFolders);
                }
            });
            this.createTabs();
            this.drawNavigationBar();
            //Delay the resize
            setTimeout(() => { that.resizeBarItems(); }, 100);
            this.activateTab(this.bar.tabs[0]);
            this.updateNotificationCounters();
        }
        isEnabled() {
            let projectSetting = NavigationBar.getConfig();
            return !projectSetting.disableTabs;
        }
        // check if a certain item of the tree is in the current tab
        isInCurrentTab(itemId) {
            if (!this.enabled)
                return true; // there's only 1 tab, kind off
            if (!globals_1.app.mainApp)
                return true;
            let tab = this.getTab(itemId);
            return tab ? tab.isActive : true;
        }
        getCurrentTab() {
            for (let tab of this.bar.tabs) {
                if (tab.isActive)
                    return tab.name;
            }
        }
        countPerTab(itemIds) {
            if (!this.enabled)
                return []; // no tabs
            if (!globals_1.app.mainApp)
                return []; // no tabs
            let result = [];
            let resultMap = {};
            for (let item of itemIds) {
                let tab = this.getTab(item);
                if (!resultMap[tab.name]) {
                    resultMap[tab.name] = 0;
                }
                resultMap[tab.name]++;
            }
            for (let key in resultMap) {
                result.push({ tabName: key, count: resultMap[key] });
            }
            return result;
        }
        // activates a tab with a specific item
        activateItemsTab(itemId) {
            if (!this.enabled)
                return;
            if (!globals_1.app.mainApp)
                return;
            let tab = this.getTab(itemId);
            if (!tab) {
                return; // some non existing item
            }
            if (tab.isActive) {
                // nothing to do
                return;
            }
            this.activateTab(tab);
        }
        // show badges for the tab
        updateNotificationCounters() {
            if (!this.enabled)
                return;
            $(".navBarNotification").remove();
            $.each(this.bar.tabs, function (tabIdx, tab) {
                let count = 0;
                $.each(tab.trees, function (liIdx, li) {
                    count += li.data("notifications") ? li.data("notifications") : 0;
                });
                if (count) {
                    $('<span class="notificationCounter navBarNotification">').html("" + count).appendTo(tab.node);
                }
            });
        }
        // create the bar on the left side
        drawNavigationBar() {
            let that = this;
            let navLeft = $("<div id='navLeft' class='hidden-print'>").appendTo("#highlightContext");
            // help button
            this.helpButton = $("<div class='navLeftHelp dropup'><i class='fal fa-question-circle dropdown-toggle' data-toggle='dropdown'></i>" + globals_1.matrixSession.getHelpButton() + "</div>").appendTo(navLeft);
            // tabs
            $.each(this.bar.tabs, function (tabIdx, tab) {
                let node = $(`<div class="navLeftTab">
                            <div class="navLeftIcon" title="${tab.name}"> 
                                <i class="${tab.icon}"></i>
                            </div>
                            <div class="navLeftText">${tab.name}</div>
                        </div>`)
                    .appendTo(navLeft)
                    .click(function () {
                    that.activateTab(tab);
                });
                tab.node = node;
            });
        }
        // that's all the pages from third party plugins
        setWorkFolders(folders) {
            this.workFolders = folders;
        }
        // resize 
        resizeBarItems() {
            if (!this.enabled || this.bar.tabs.length == 0)
                return;
            $(".navLeftText").show();
            let lastTab = this.bar.tabs[this.bar.tabs.length - 1].node;
            let lastPos = lastTab.position().top + lastTab.height() + 20; // some margin 20
            let showText = this.helpButton.position().top > lastPos;
            if (showText) {
                $(".navLeftText").show();
            }
            else {
                $(".navLeftText").hide();
            }
        }
        // sort all items from the tree into the tabs, remove the tabs which are empty
        createTabs() {
            let that = this;
            let leftOvers = [];
            $.each(that.bar.tabs, function (tabIdx, tab) {
                tab.trees = [];
            });
            that.bar.tabs.push({
                name: "Other",
                icon: "far fa-window-alt",
                mode: TabMode.ShowAsDefault,
                other: [],
                trees: [] // the content
            });
            $.each($("#projectTree .treeContent > ul").children(), function (idx, li) {
                $.each(that.bar.tabs, function (tabIdx, tab) {
                    let show = true;
                    if (tab.mode == TabMode.HideAsDefault) {
                        show = false;
                        $.each(tab.other, function (otherIdx, other) {
                            if ($(".key-" + other, $(li)).length) {
                                show = true;
                            }
                        });
                    }
                    else if (tab.mode == TabMode.ShowAsDefault) {
                        show = true;
                        $.each(tab.other, function (otherIdx, other) {
                            if ($(".key-" + other, $(li)).length) {
                                show = false;
                            }
                        });
                    }
                    if (show) {
                        // add the node to the tab
                        tab.trees.push($(li));
                        // remember that the node for that key is in the tab
                        let keys = $(".refTitle", $(li))[0].className.split(/\s+/).filter(function (cls) { return cls.indexOf("key-") == 0; });
                        if (keys.length == 1) {
                            that.rootTabMap[keys[0].replace("key-", "")] = tab;
                        }
                        return false;
                    }
                    else {
                        // continue to search
                        return true;
                    }
                });
            });
            // now remove all the empty ones
            this.bar.tabs = this.bar.tabs.filter(function (tab) { return tab.trees.length > 0; });
        }
        // switch tab (from search)
        switchTab(tabName) {
            if (!this.enabled || !this.bar.tabs.length)
                return false; // nothing to do
            let tab = this.bar.tabs.filter(tab => tab.name == tabName);
            if (tab.length == 0)
                return; // should not happen
            $(".navLeftIcon").css("background-color", "");
            $(".navLeftIcon", tab[0].node).css("background-color", MatrixLibInterfaces_1.UIToolsConstants.CIColorsPrimary.P0_LogoGreenYellow.color);
            $(".navLeftTabActive").removeClass("navLeftTabActive");
            tab[0].node.addClass("navLeftTabActive");
            // hide all
            $.each($("#projectTree .treeContent > ul").children(), function (idx, li) {
                $(li).hide();
            });
            // deactivate others
            $.each(this.bar.tabs, function (tabIdx, t) {
                t.isActive = false;
            });
            // activate the one
            tab[0].isActive = true;
            $.each(tab[0].trees, function (liIdx, li) {
                li.show();
            });
        }
        // user clicks on tab
        activateTab(tab) {
            if (tab.isActive)
                return;
            // make sure there's no filter
            matrixlib_1.ml.Search.cancelSearch();
            $(".navLeftIcon").css("background-color", "");
            $(".navLeftIcon", tab.node).css("background-color", MatrixLibInterfaces_1.UIToolsConstants.CIColorsPrimary.P0_LogoGreenYellow.color);
            $(".navLeftTabActive").removeClass("navLeftTabActive");
            tab.node.addClass("navLeftTabActive");
            // hide all
            $.each($("#projectTree .treeContent > ul").children(), function (idx, li) {
                $(li).hide();
            });
            // deactivate others
            $.each(this.bar.tabs, function (tabIdx, t) {
                t.isActive = false;
            });
            // activate the one
            tab.isActive = true;
            $.each(tab.trees, function (liIdx, li) {
                li.show();
            });
        }
        getTab(itemId) {
            // check if it is a 'normal database item' if so take it's category
            let category = matrixlib_1.ml.Item.parseRef(itemId).type;
            // skip the line when getting the breadcrumb
            let bread = category ? globals_1.app.getCategoryBreadcrumbs(category) : globals_1.app.getBreadcrumbs(itemId);
            let butter = bread[bread.length - 1];
            return this.rootTabMap[butter];
        }
    }
    exports.NavigationBar = NavigationBar;
    NavigationBar.navbarWidth = 0;
    var NavBar;
    exports.NavBar = NavBar;
    function initialize() {
        exports.NavBar = NavBar = new NavigationBar();
    }
    exports.initialize = initialize;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 25 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference types="matrixrequirements-type-declarations" />
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(19), __webpack_require__(12), __webpack_require__(24), __webpack_require__(6), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, ProjectViewDefines_1, index_1, NavigationBar_1, globals_1, ComponentImport_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ProjectTree = void 0;
    class ProjectTree {
        constructor(panel, canBeFiltered) {
            this.hits = [];
            this.allHits = [];
            this.legacyColors = {
                REQ: "#0000a4",
                UC: "#4646e3",
                SPEC: "#00a600",
                DOC: "#000",
                SIGN: "#000",
                REPORT: "#222222",
                RISK: "#a90000",
                TC: "#3b4d32",
                TRUN: "#181810" // special case for legacy TRUN folder icons
            };
            this.panel = panel;
            this.canBeFiltered = canBeFiltered;
        }
        // show the tree
        show() {
            this.panel.tree.show();
        }
        ;
        // hide the tree
        hide() {
            this.panel.tree.hide();
        }
        setSelectedItems(selectedItems) {
            let that = this;
            $.each(selectedItems, function (index, key) {
                var item = that.getNode(key);
                if (item) {
                    item.setSelected();
                }
            });
        }
        applyFilter() {
            let that = this;
            if (this.canBeFiltered && this.lastFilterFct) {
                clearTimeout(this.delayedFilter);
                that.delayedFilter = window.setTimeout(() => {
                    this.getFancyTree().filterNodes((node) => this.lastFilterFct(node));
                }, 100);
            }
        }
        // hotfix one item - not good after the next change in the tree it will be rendered again wrongly
        redrawItem(itemId) {
            var node = this.getNode(itemId);
            if (node) {
                node.render();
                var span = $(node.span);
                if (node.data.isUnselected) {
                    span.removeClass("fancytree-match");
                }
                else {
                    span.addClass("fancytree-match");
                }
            }
        }
        openTree(key) {
            this.getNode(key).setExpanded(true);
        }
        closeTree(key) {
            this.getNode(key).setExpanded(false);
        }
        selectAll(isSelected) {
            let that = this;
            if (isSelected) {
                $.each(this.hits, function (hi, hit) {
                    if (that.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.auto || !matrixlib_1.ml.Item.parseRef(hit).isFolder) {
                        var item = that.getNode(hit);
                        if (item) {
                            item.setSelected();
                        }
                    }
                });
            }
            else {
                this.getFancyTree().visit(function (node) {
                    node.setSelected(false);
                });
            }
        }
        ;
        // this selects children and in case a folder is selected also the children of the folder
        selectChildren(node) {
            let children = node.getChildren();
            if (!children) {
                return;
            }
            for (let child of children) {
                if (!child.isSelected()) {
                    child.setSelected(true);
                }
                if (child.isFolder()) {
                    this.selectChildren(child);
                }
            }
        }
        unSelectChildren(node) {
            let children = node.getChildren();
            if (!children) {
                return;
            }
            for (let child of children) {
                if (child.isSelected()) {
                    child.setSelected(false);
                }
                if (child.isFolder()) {
                    this.unSelectChildren(child);
                }
            }
        }
        // this unselects all parents of a item or folder
        unselectParents(node) {
            let parent = node.getParent();
            if (!parent) {
                return;
            }
            if (parent.isSelected()) {
                parent.setSelected(false);
                this.unselectParents(parent);
            }
        }
        setHideMismatches(hideMismatches) {
            var currentMode = this.getFancyTree().options.filter.mode;
            var nextMode = hideMismatches ? "hide" : "dimm";
            if (currentMode === nextMode) {
                return;
            }
            this.getFancyTree().options.filter.mode = nextMode;
            this.getFancyTree().clearFilter();
        }
        forcePartial() {
            function _walk(node) {
                let i, l, child, someSelected, children = node.children;
                if (children && children.length) {
                    // check all children recursively
                    someSelected = false;
                    for (i = 0, l = children.length; i < l; i++) {
                        child = children[i];
                        // the selection state of a node is not relevant; we need the end-nodes
                        if (_walk(child)) {
                            someSelected = true;
                        }
                    }
                    if (someSelected && !node.selected) {
                        $(node.span).addClass("fancytree-partsel");
                        node.extraClasses = "fancytree-partsel";
                    }
                    else {
                        $(node.span).removeClass("fancytree-partsel");
                        node.extraClasses = "";
                    }
                }
                return someSelected || !!node.selected;
            }
            let tree = this.getFancyTree();
            _walk(tree.rootNode);
        }
        filterTree(match) {
            let that = this;
            this.hits = [];
            this.allHits = [];
            let total = 0;
            if (match) {
                var treeMatch = (match + "").replace(/([.?*+\^\$\[\]\\(){}|-])/g, "\\$1"); // make sure a '.' is treated literally
                var treeMatchRegEx = new RegExp(".*" + treeMatch + ".*", "i");
                this.lastFilterFct = function treeFilter(node) {
                    if (node.data.isUnselected) {
                        // project label filter
                        return false;
                    }
                    var sel = (!that.panel.prefixCategory || matrixlib_1.ml.Item.parseRef(node.key).type == that.panel.prefixCategory) && !!treeMatchRegEx.exec(node.title);
                    if (sel) {
                        this.allHits.push(node.key);
                        total++;
                        if (that.panel.settings.isMainTree) {
                            sel = NavigationBar_1.NavBar.isInCurrentTab(node.key);
                        }
                        if (sel) {
                            that.hits.push(node.key);
                        }
                    }
                    return sel;
                };
                this.canBeFiltered && this.getFancyTree().filterNodes((node) => this.lastFilterFct(node));
                // after rendering the tree: maybe open to see all leafs
                if (this.panel.viewModeSelector.isExpandTree()) {
                    this.getFancyRootNode().visit(function (node) {
                        if (node.isFolder() && node.subMatch || !that.panel.viewModeSelector.hideMismatches()) {
                            node.setExpanded(node.subMatch ? true : false, { noAnimation: true, noEvents: true, scrollIntoView: false });
                        }
                    });
                }
                return { current: this.hits.length, total: total, perTab: NavigationBar_1.NavBar.countPerTab(this.allHits) };
            }
            else {
                // just in case
                let total = this.removeFilter();
                return { current: total, total: total, perTab: NavigationBar_1.NavBar.countPerTab(this.hits) };
            }
        }
        removeFilter() {
            let that = this;
            this.hits = [];
            // just apply global filters (no expanding)
            this.lastFilterFct = function treeFilter(node) {
                if (node.data.isUnselected) {
                    // project label filter
                    return false;
                }
                that.hits.push(node.key);
                return true;
            };
            this.canBeFiltered && this.getFancyTree().filterNodes((node) => this.lastFilterFct(node));
            return this.hits.length;
        }
        showSearchResults(serverSearchResults) {
            let that = this;
            this.hits = [];
            let countAll = 0;
            this.lastFilterFct = function treeFilter(node) {
                if (node.data.isUnselected) {
                    return false;
                }
                if (serverSearchResults.length > 0) {
                    let sel = serverSearchResults.indexOf(node.key) !== -1;
                    if (sel) {
                        countAll++;
                        if (that.panel.settings.isMainTree) {
                            sel = NavigationBar_1.NavBar.isInCurrentTab(node.key);
                        }
                        if (sel) {
                            that.hits.push(node.key);
                        }
                    }
                    return sel;
                }
                return false;
            };
            this.canBeFiltered && this.getFancyTree().filterNodes((node) => this.lastFilterFct(node));
            // after rendering the tree: maybe open to see all leafs
            if (this.panel.viewModeSelector.isExpandTree()) {
                this.getFancyRootNode().visit(function (node) {
                    node.setExpanded(node.subMatch ? true : false);
                });
            }
            return { current: this.hits.length, total: countAll, perTab: NavigationBar_1.NavBar.countPerTab(serverSearchResults) };
        }
        ;
        getFancyRootNode() {
            return this.panel.tree.fancytree("getRootNode");
        }
        getFancyTree() {
            return this.panel.tree.fancytree("getTree");
        }
        getNode(key) {
            return this.getFancyTree().getNodeByKey(key);
        }
        removeNode(key) {
            this.getNode(key).remove();
        }
        setTitle(key, title) {
            try {
                var node = this.getNode(key);
                if (node) {
                    var changed = title !== node.shortTitle;
                    if (node.data) {
                        if (title == node.data.shortTitle) {
                            changed = false;
                        }
                        var foldertext = $(".refTitle span:not(.highlight)", node.span);
                        if (node.folder && foldertext.length !== 0) {
                            node.data.shortTitle = foldertext[0].outerHTML + title;
                        }
                        else {
                            node.data.shortTitle = title;
                        }
                    }
                    node.shortTitle = title;
                    node.title = node.folder ? title : (node.key + " " + title);
                    return changed;
                }
            }
            catch (exp) {
            }
            return false;
        }
        select(key) {
            var ft = this.getFancyTree();
            NavigationBar_1.NavBar.activateItemsTab(key);
            if (this.panel.tree.is(":visible")) {
                // if the tree is not visible it throws an exception, because of option to auto activate
                ft.activateKey(key);
            }
            else {
                ft.options.autoScroll = false;
                ft.activateKey(key);
                ft.options.autoScroll = true;
            }
        }
        isSelected(key) {
            let treeNode = this.getNode(key);
            return treeNode.isActive();
        }
        // private functions
        updateRec(item) {
            let treeNode = this.getNode(item.id);
            treeNode.title = item.title;
            if (item.children) {
                // recreate children
                treeNode.children = [];
                this.addNodes(treeNode, item.children);
            }
        }
        insertRec(parentKey, item) {
            let parent = this.getNode(parentKey);
            if (!parent.children) {
                parent.children = [];
            }
            for (var idx = 0; idx < parent.children.length; idx++) {
                if (parent.children[idx].key === item.id) {
                    // replace child
                    this.updateRec(item);
                    return;
                }
            }
            // create a new child and replace
            var nn = this.addNode(parent, item);
            this.updateRec(item);
        }
        moveNode(parentId, itemId, position) {
            let parentNode = this.getNode(parentId);
            let itemNode = this.getNode(itemId);
            // remove from current parent
            let oldParent = itemNode.parent;
            oldParent.children = oldParent.children.filter(function (child) {
                return child.key != itemId;
            });
            // insert in new place
            if (!parentNode.children) {
                parentNode.children = [];
            }
            if (position >= parentNode.children.length) {
                parentNode.children.push(itemNode);
            }
            else {
                parentNode.children.splice(position, 0, itemNode);
            }
            itemNode.parent = parentNode;
        }
        addNode(treeNode, item, position) {
            var newNode;
            if (item.hasOwnProperty("children") === true) { // a folder
                if (item.type !== this.lt) {
                    this.lit = "";
                    var icontext = "";
                    var param = globals_1.globalMatrix.ItemConfig.getCategorySetting(item.type, 'texticon');
                    if (param) {
                        param = matrixlib_1.ml.JSON.mergeOptions({ color: 'black', text: item.type }, param);
                        this.lit = '<span class="fancytree-icontext" style="color: ' + param.color + ';">' + param.text + '</span>';
                    }
                }
                var icontext = this.lit;
                let hasIconText = icontext;
                // hack for test runs of type TRUN
                if (typeof index_1.mTM !== 'undefined' && index_1.mTM.isXTC(item.type)) { // this is a XTC type
                    if (treeNode.parent) {
                        // not the top level TRUN but a TRUN,...
                        icontext = icontext ? icontext : ('<span class="fancytree-icontext fancytree-iconxtc"  style="color: ' + 'grey' + ';">' + 'RUN' + '</span>');
                        var tp = item.title.indexOf("(F-"); // e.g. The system is delivered (F-TC-6)
                        if (!hasIconText && tp !== -1) {
                            // most likely this is an executed folder... try to get information from where it comes from
                            var te = item.title.indexOf("-", tp + 3);
                            if (te !== -1) {
                                let category = item.title.substr(tp + 3, te - tp - 3); // -> TC 
                                var source = globals_1.app.getTree([category]);
                                if (source && source.length === 1) {
                                    item.icon = source[0].icon;
                                    icontext = "";
                                    var param = globals_1.globalMatrix.ItemConfig.getCategorySetting(category, 'texticon');
                                    if (param) {
                                        param = matrixlib_1.ml.JSON.mergeOptions({ color: 'black', text: category }, param);
                                        icontext = '<span class="fancytree-icontext fancytree-iconxtc" style="color: ' + param.color + ';">' + param.text + '</span>';
                                    }
                                }
                            }
                        }
                    }
                    else {
                        icontext = icontext ? icontext : ('<span class="fancytree-icontext fancytree-iconxtc" style="color: ' + this.legacyColors["TRUN"] + ';">' + "TRUN" + '</span>');
                    }
                }
                else if (!hasIconText && item.type && this.legacyColors[item.type]) {
                    icontext = '<span class="fancytree-icontext fancytree-iconxtc" style="color: ' + this.legacyColors[item.type] + ';">' + item.type + '</span>';
                }
                let nodeData = {
                    shortTitle: icontext + item.title,
                    title: item.title,
                    key: item.id,
                    type: item.type,
                    background: item.background,
                    border: item.border,
                    cstrender: true,
                    folder: true,
                    hideCheckbox: this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.none
                        || (this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.items || this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.singleItem),
                    isUnselected: item.isUnselected,
                    icon: icontext ? false : item.icon,
                    extraStyle: item.extraStyle
                };
                if (item.iconClass) {
                    nodeData.icon = true;
                    nodeData.iconclass = item.iconClass + " fancy-icon";
                }
                if (item.mode == ComponentImport_1.EImportMode.Include || item.mode == "recipient_folder_" + ComponentImport_1.EImportMode.Include) {
                    nodeData.shortTitle = `<i class="fal fa-external-link-alt importedFolder"></i>` + nodeData.shortTitle;
                }
                newNode = treeNode.addChildren(nodeData);
                this.addNodes(newNode, item.children);
                let hasNotLatest = false;
                $.each(newNode.children, function (cidx, child) {
                    if (child.extraClasses && child.extraClasses.indexOf("notLatest") != -1) {
                        hasNotLatest = true;
                    }
                });
                if (hasNotLatest) {
                    newNode.extraClasses = newNode.extraClasses ? (newNode.extraClasses + "notLatest") : "notLatest";
                }
            }
            else {
                let fn = {
                    shortTitle: item.title,
                    title: item.id + " " + item.title,
                    key: item.id,
                    cstrender: true,
                    type: item.type,
                    isUnselected: item.isUnselected,
                    extraStyle: item.extraStyle
                };
                if (item.icon) {
                    fn.icon = item.icon;
                    fn.extraClasses = "fancy-icon";
                }
                if (item.iconClass) {
                    fn.iconclass = item.iconClass + " fancy-icon";
                }
                if (item.mode == ComponentImport_1.EImportMode.Include) {
                    fn.icon = true;
                    fn.iconclass = "fal fa-external-link-alt importedItem";
                }
                if (item.version && item.version.split("/")[0] != item.version.split("/")[1]) {
                    fn.extraClasses = fn.extraClasses ? (fn.extraClasses + "notLatest") : "notLatest";
                }
                newNode = treeNode.addChildren(fn);
            }
            if (position && position.at < treeNode.children.length) {
                var newChild = treeNode.children[treeNode.children.length - 1];
                treeNode.children.splice(treeNode.children.length - 1, 1);
                treeNode.children.splice(position.at, 0, newChild);
            }
            return newNode;
        }
        treeFromDb(dbTree) {
            this.lt = "";
            this.addNodes(this.getFancyRootNode(), dbTree);
        }
        updateItemIsUnselected(itemId, isUnselected) {
            try {
                var node = this.getNode(itemId);
                if (node) { // sometimes the node does not yet exist, e.g. when creating a signed doc
                    if (node.data.isUnselected !== isUnselected) {
                        node.data.isUnselected = isUnselected;
                        return true;
                    }
                }
            }
            catch (exp) {
                // mobile client has no tree...
            }
            return false;
        }
        updateNotificationCounters() {
            this.getFancyTree().updateNotificationCounters();
        }
        addNodes(treeNode, obj) {
            let that = this;
            $.each(obj, function (idx, idb) {
                that.addNode(treeNode, idb);
            });
        }
    }
    exports.ProjectTree = ProjectTree;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 26 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.EImportMode = void 0;
    var EImportMode;
    (function (EImportMode) {
        EImportMode["Include"] = "include";
        EImportMode["Copy"] = "copy";
    })(EImportMode || (EImportMode = {}));
    exports.EImportMode = EImportMode;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 27 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(19), __webpack_require__(3), __webpack_require__(24), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, ProjectViewDefines_1, MatrixLibInterfaces_1, NavigationBar_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SearchBox = void 0;
    class SearchBox {
        constructor(panel) {
            this.savedSearchIndex = -1;
            this.panel = panel;
            this.currentStatus = ProjectViewDefines_1.SearchState.NoSearch;
            this.currentResults = []; // results from server (
            this.currentSearchExpression = ""; // no search expression
            this.delayedAction = null;
            this.isEnabled = false;
            this.isConfigSearch = false;
        }
        // after a resize fix display...
        updateHeights() {
            this.isEnabled && this.updateSearchStatusHeights();
        }
        renderSearchField(filter, enableServerSearch, highlightResults, isConfigSearch) {
            let that = this;
            this.isEnabled = true;
            that.isConfigSearch = isConfigSearch;
            var inputSpace = $('<div style="position:absolute;left:50px;right:0px;">');
            var inputCtrl = $('<input  data-cy="mrqlSearchInput" autocomplete="off" type="text" autofocus="autofocus" name="search" placeholder="Search..." class="form-control searchNoX">');
            filter.append(inputSpace.append(inputCtrl));
            // clear input field
            inputSpace.append('<span data-cy="searchClear" name="clear" class="far fa-times-circle filter-clear-x"></spans>');
            $("span[name=clear]", filter).click(function (evt) {
                matrixlib_1.ml.Search.hideHighlight();
                $("input[name=search]", filter).val("").focus();
                that.resetSearch();
            }); // icon left of search server button inside the text input field
            // add box for server search
            if (enableServerSearch) {
                var ss = this.getMiracleControl(inputCtrl);
                filter.append(ss);
                inputSpace.css("right", "50px");
            }
            // handle filter / search input field
            $("input[name=search]", filter).keyup(function (e) {
                clearTimeout(that.filterSearch_timeout);
                clearTimeout(that.filterHighlight_timeout);
                // get search string 
                let untrimmed = $(e.delegateTarget).val();
                let trimmed = $.trim($(e.delegateTarget).val());
                if (that.setPrefixCategory(untrimmed)) {
                    untrimmed = untrimmed.substr(that.panel.prefixCategory.length + 1);
                    trimmed = trimmed.substr(that.panel.prefixCategory.length + 1);
                    if (trimmed.length == 0) {
                        // just a prefix has been type, e.g. REQ:
                        return;
                    }
                }
                // user hit return
                if (e && e.keyCode === 13 && !isConfigSearch) {
                    // run fulltext search
                    that.savedSearchIndex = -1;
                    that.search(trimmed, highlightResults);
                    that.addToSavedSearch(trimmed, filter);
                    return;
                }
                if (e && e.keyCode === 38) {
                    let savedSearchLength = $(".savedSearch").length;
                    if (savedSearchLength > 0) {
                        that.savedSearchIndex++;
                        let newVal = $(".savedSearch", filter)[that.savedSearchIndex % savedSearchLength].innerText;
                        let textField = $(".searchNoX", filter);
                        $(document).ready(() => {
                            textField.val(newVal);
                        });
                    }
                }
                if (e && e.keyCode === 40) {
                    let savedSearchLength = $(".savedSearch").length;
                    if (savedSearchLength > 0) {
                        e.preventDefault();
                        that.savedSearchIndex--;
                        if (that.savedSearchIndex < 0) {
                            that.savedSearchIndex = savedSearchLength - 1;
                        }
                        console.log(that.savedSearchIndex);
                        let newVal = $(".savedSearch", filter)[that.savedSearchIndex % savedSearchLength].innerText;
                        let textField = $(".searchNoX", filter);
                        $(document).ready(() => {
                            textField.val(newVal);
                        });
                    }
                }
                if (e && e.keyCode === 32 && trimmed.toLowerCase().indexOf("mrql") === -1 && globals_1.app.getItemTitle(trimmed.toUpperCase())) {
                    if (filter.closest("#projectTree").length === 1) {
                        that.panel.select(trimmed.toUpperCase());
                        $("input[name=search]", filter).val("");
                        matrixlib_1.ml.Search.hideHighlight();
                        that.resetSearch();
                        return;
                    }
                }
                if (e && e.which === $.ui.keyCode.ESCAPE || trimmed === "") {
                    $("input[name=search]", filter).val("");
                    that.resetSearch();
                    matrixlib_1.ml.Search.hideHighlight();
                    that.panel.resizeItem();
                    return;
                }
                // Pass text as filter string (will be matched as substring in the node title)
                if (untrimmed.indexOf("mrql:") != 0) {
                    that.filterSearch_timeout = window.setTimeout(function () {
                        that.filter(untrimmed);
                        that.panel.resizeItem();
                        if (highlightResults) {
                            // highlight again (the filtering above removes the highlights from the tree)
                            clearTimeout(that.filterHighlight_timeout);
                            that.filterHighlight_timeout = window.setTimeout(function () {
                                matrixlib_1.ml.Search.highlight(trimmed);
                            }, 100);
                        }
                        // instead of hard coded timeouts allow to overwrite per pc
                        // serverStorage.setItem("timeoutSearch1",2000)) less than 2 letters entered. default 3000ms
                        // serverStorage.setItem("timeoutSearch2",4000)) 2+ letters entered . default 3000ms
                    }, (trimmed && trimmed.length > 2) ? Number(globals_1.globalMatrix.serverStorage.getItemDefault("timeoutSearch2", "600")) : Number(globals_1.globalMatrix.serverStorage.getItemDefault("timeoutSearch1", "1200")));
                    if (highlightResults) {
                        // wait a bit and highlight in main page
                        clearTimeout(that.filterHighlight_timeout);
                        that.filterHighlight_timeout = window.setTimeout(function () {
                            matrixlib_1.ml.Search.highlight(trimmed);
                        }, 300);
                    }
                }
            }).focus();
            // add search status info
            // checkbox to select all 
            this.searchMetaInfo = $("<div class='searchMetaInfo'>");
            this.searchMetaInfo.append($('<div class="searchResultInfo">'));
            if (!this.panel.settings.singleSelect)
                this.searchMetaInfo.append($("<div class='searchResultSelect'>")
                    .append('<label><input data-cy="searchSelectAll" type="checkbox"><span style="font-weight:normal;text-decoration:italic;padding-left:10px">Un/Select all</span></label>'));
            this.searchMetaInfo.append($("<div class='searchResultWaiting'>").append(matrixlib_1.ml.UI.getSpinningWait("searching...")));
            this.searchMetaInfo.children().hide();
            filter.append(this.searchMetaInfo);
            $("input", this.searchMetaInfo).click(function (event) {
                that.panel.toggleSelection($(event.delegateTarget).prop("checked"));
            });
        }
        setPrefixCategory(searchExpression) {
            let that = this;
            that.panel.prefixCategory = "";
            $.each(globals_1.globalMatrix.ItemConfig.getCategories(), function (idx, cat) {
                if (searchExpression.toUpperCase().indexOf(cat.toUpperCase() + ":") == 0) {
                    that.panel.prefixCategory = cat;
                }
            });
            return that.panel.prefixCategory != "";
        }
        // renders a tree or a list, with or without checkboxes
        // refresh only is set if the tree changes, rather than the search
        render() {
            let that = this;
            if (!this.isEnabled) {
                return;
            }
            if (this.currentStatus === ProjectViewDefines_1.SearchState.NoSearch) {
                this.showSearchStatus(-1, true);
                // render as tree control 
                this.panel.listView.hide();
                this.panel.projectTree.show();
                // make sure nothing is hidden or dimmed
                this.panel.projectTree.setHideMismatches(false);
                // render the tree without any filters
                this.panel.projectTree.removeFilter();
            }
            else if (this.currentStatus === ProjectViewDefines_1.SearchState.ServerRunning) {
                // user might click faster than server can react
                this.delayedAction = {
                    type: "render",
                    expression: null
                };
                return;
            }
            else if (this.currentStatus === ProjectViewDefines_1.SearchState.FilterDone) {
                // this is a local filtering: do it
                if (this.panel.viewModeSelector.showAsList()) {
                    // render as list control 
                    this.panel.listView.show();
                    this.panel.projectTree.hide();
                    // show results
                    let matches = this.panel.listView.filterList(this.currentSearchExpression);
                    that.showMatches(matches, true);
                }
                else {
                    // render as tree control 
                    this.panel.listView.hide();
                    this.panel.projectTree.show();
                    // hide or dim
                    this.panel.projectTree.setHideMismatches(this.panel.viewModeSelector.hideMismatches());
                    // render the tree with current filter
                    var matches = this.panel.projectTree.filterTree(this.currentSearchExpression);
                    that.showMatches(matches, true);
                }
            }
            else if (this.currentStatus === ProjectViewDefines_1.SearchState.ServerDone) {
                // this is a local filtering: do it
                if (this.panel.viewModeSelector.showAsList()) {
                    // render as list control 
                    this.panel.listView.show();
                    this.panel.projectTree.hide();
                    // show results
                    let actualResults = this.panel.listView.showSearchResults(this.currentResults);
                    that.showMatches(actualResults, false);
                }
                else {
                    // render as tree control 
                    this.panel.listView.hide();
                    this.panel.projectTree.show();
                    // hide or dim
                    this.panel.projectTree.setHideMismatches(this.panel.viewModeSelector.hideMismatches());
                    // render the tree with current filter
                    let actualResults = this.panel.projectTree.showSearchResults(this.currentResults);
                    that.showMatches(actualResults, false);
                }
            }
        }
        ;
        showMatches(matches, localSearch) {
            let diff = matches.total - matches.current;
            let details = "";
            if (diff) {
                details = "There are " + diff + " hits in other tabs:";
                details += "<ul>";
                for (let tab of matches.perTab) {
                    if (tab.tabName == NavigationBar_1.NavBar.getCurrentTab()) {
                        details += `<li><span class="" data-tab="${tab.tabName}">${tab.tabName} ${tab.count} matches</span></li>`;
                    }
                    else {
                        details += `<li><span class="searchResultTabLink" data-tab="${tab.tabName}">${tab.tabName} ${tab.count} matches</span></li>`;
                    }
                }
                details += "</ul>";
            }
            this.showSearchStatus(matches.current, localSearch, details);
        }
        // resets the search
        resetSearch() {
            this.panel.viewModeSelector.setEnabled(false);
            this.currentResults = []; // No results
            this.currentSearchExpression = "";
            // always render as tree:
            this.currentStatus = ProjectViewDefines_1.SearchState.NoSearch;
            this.render();
        }
        ;
        getMiracleControl(textField) {
            let that = this;
            let btn_grp = $('<div class="" style="position:absolute;right:0px">');
            let mir_btn = $('<span class="btn btn-sssearch" type="button" data-toggle="tooltip" data-placement="bottom" title="Fulltext search on server"><i style="margin-left:-7px" class="fal fa-search"></span>');
            btn_grp.append(mir_btn);
            btn_grp.append('<span class="btn btn-ssearch" data-cy="searchBoxMrqlDP"  type="button" data-toggle="dropdown"><span class="caret"></span></span>');
            let config = globals_1.globalMatrix.ItemConfig.getSearchConfig();
            if (!config || !config.searches || config.searches.length === 0) {
                config = { searches: [{ name: "outdated links", expr: "mrql:outdated=1" },
                        { name: "last week", expr: "mrql:updated<1w" },
                        { name: "failed tests", expr: 'mrql:"test run result"~"error"' }] };
            }
            else {
                // sort
                $.each(config.searches, function (idx, st) {
                    st.name = st.name.split("'").join('"');
                    st.expr = st.expr.split("'").join('"');
                });
            }
            let ul = $(' <ul id="savedSearches" class="dropdown-menu dropdown-menu-sub pull-right role="menu"> ');
            for (let idx = 0; idx < config.searches.length; idx++) {
                let li = $('<li data-cy="serverSearchExp" title="' + config.searches[idx].expr + '"><a href="javascript:void(0)">' + config.searches[idx].name + '</a></li>');
                ul.append(li);
                li.click(function (event) {
                    if (that.panel.settings.highlight) {
                        // wait a bit and highlight 
                        window.setTimeout(function () {
                            matrixlib_1.ml.Search.highlight($(event.delegateTarget).data("mrql"));
                        }, 50);
                    }
                    textField.val($(event.delegateTarget).data("mrql"));
                    that.search($(event.delegateTarget).data("mrql"));
                }).data("mrql", config.searches[idx].expr);
            }
            let help = $('<li class="miracleHelp" title="Miracle Help" ><a class="documentationLink" href="javascript:void(0)">Miracle Help</a></li>');
            ul.append(help);
            help.click(function () {
                window.open("https://urlshort.matrixreq.com/d23/manual/miracle");
            });
            let items = that.getSavedSearches();
            items.forEach((item) => {
                item = decodeURIComponent(item);
                let li = $("<li/>").attr("title", item).append($('<a class="savedSearch" href="javascript:void(0)"/>').text(item));
                ul.append(li);
                li.click(function (event) {
                    textField.val(event.currentTarget.textContent);
                    var e = $.Event('keyup');
                    e.keyCode = 13; // Enter key
                    textField.trigger(e);
                }).data("mrql", item);
            });
            ul.css("max-width", $('#sidebar').width() - 10 + "px");
            btn_grp.append(ul);
            $("i", mir_btn).click(function () {
                let searchExpression = textField.val();
                if (that.setPrefixCategory(searchExpression)) {
                    searchExpression = searchExpression.substr(that.panel.prefixCategory.length + 1);
                }
                that.search(searchExpression);
                that.addToSavedSearch(searchExpression, textField.parent().parent());
            });
            return btn_grp;
        }
        addToSavedSearch(str, filter) {
            let that = this;
            let items = that.getSavedSearches();
            str = str.trim();
            let strEncoded = encodeURIComponent(str);
            if (str.length == 0) {
                return;
            }
            let strIndex = items.indexOf(strEncoded);
            let decodedStr = decodeURIComponent(str);
            let def = $.Deferred();
            if (strIndex != -1) {
                items.splice(strIndex, 1);
                $().ready(() => {
                    $("li[title='" + decodedStr + "']", filter).remove();
                });
            }
            items.unshift(strEncoded);
            items.splice(10);
            globals_1.globalMatrix.projectStorage.setItem("savedSearches", JSON.stringify(items), false);
            $().ready(() => {
                let li = $("<li/>").attr("title", decodedStr).append($('<a class="savedSearch" data-cy="localSearchExp" href="javascript:void(0)"/>').text(decodedStr));
                li.insertAfter($(".miracleHelp", filter));
                li.click(function (event) {
                    let textField = $(".searchNoX", filter);
                    textField.val(decodeURIComponent(str));
                    textField.val($(event.delegateTarget).data("mrql"));
                    var e = $.Event('keyup');
                    e.keyCode = 13; // Enter key
                    textField.trigger(e);
                }).data("mrql", decodedStr);
            });
        }
        getSavedSearches() {
            let items = undefined;
            if (globals_1.globalMatrix.projectStorage) {
                let itemsString = globals_1.globalMatrix.projectStorage.getItem("savedSearches", true);
                if (itemsString && itemsString != "") {
                    items = JSON.parse(itemsString);
                    if (items != undefined) {
                        return items;
                    }
                }
            }
            return items !== null && items !== void 0 ? items : [];
        }
        filter(filterExpression) {
            this.filterAgainExpression = filterExpression;
            this.filterAgain();
        }
        filterAgain() {
            if (this.currentStatus === ProjectViewDefines_1.SearchState.ServerRunning) {
                // user might click faster than server can react
                this.delayedAction = {
                    type: "filter",
                    expression: this.filterAgainExpression
                };
                return;
            }
            if (this.filterAgainExpression === "") {
                this.resetSearch();
                return;
            }
            this.panel.viewModeSelector.setEnabled(true);
            this.currentStatus = ProjectViewDefines_1.SearchState.FilterDone;
            this.currentSearchExpression = this.filterAgainExpression;
            this.render();
        }
        ;
        // runs a server search
        search(searchExpression, highlightResults) {
            var that = this;
            searchExpression = searchExpression.replace(/_me_/g, globals_1.matrixSession.getUser());
            searchExpression = searchExpression.replace(/_this_/g, globals_1.app.getCurrentItemId());
            if (this.currentStatus === ProjectViewDefines_1.SearchState.ServerRunning) {
                // user might click faster than server can react
                this.delayedAction = {
                    type: "server",
                    expression: searchExpression
                };
                return;
            }
            this.delayedAction = null;
            this.panel.viewModeSelector.setEnabled(true);
            if (searchExpression === "") {
                this.resetSearch();
                return;
            }
            this.currentResults = [];
            this.currentStatus = ProjectViewDefines_1.SearchState.ServerRunning;
            this.showSearchStatus(-3, true);
            globals_1.app.searchAsyncMinimalOutput(searchExpression
                .replace("descendant=*", "descendant=" + globals_1.app.getCurrentItemId())
                .replace("ancestor=*", "ancestor=" + globals_1.app.getCurrentItemId())
                .replace("parent=*", "parent=" + globals_1.app.getCurrentItemId())
                .replace("child=*", "child=" + globals_1.app.getCurrentItemId()), null, false, this.panel.settings.crossProject).done(function (results) {
                if (that.panel.prefixCategory) {
                    results = results.filter(function (result) { return matrixlib_1.ml.Item.parseRef(result).type == that.panel.prefixCategory; });
                }
                /*
                this is potentially n2 if the results is the whole tree ....
    
                for (var idx = 0; idx < results.length; idx++) {
                    // verify that the tree is not filtered otherwise
                    var node = that.panel.tree.fancytree("getTree").getNodeByKey(results[idx]);
                    if (node) {
                        // if not add it to results
                        that.currentResults.push(results[idx]);
                    }
                }
                */
                // that's the same but indexOf is much faster
                that.panel.tree.fancytree("getTree").visit(function (node) {
                    if (results.indexOf(node.key) != -1) {
                        that.currentResults.push(node.key);
                    }
                });
                that.showSearchStatus(that.currentResults.length, false);
                // search done
                that.currentStatus = ProjectViewDefines_1.SearchState.ServerDone;
                if (that.delayedAction) {
                    that.doDelayed();
                    return;
                }
                let filtered = that.render();
                if (highlightResults) {
                    // highlight again (the filtering above removes the highlights from the tree)
                    window.clearTimeout(that.filterHighlight_timeout);
                    that.filterHighlight_timeout = window.setTimeout(function () {
                        matrixlib_1.ml.Search.highlight(searchExpression);
                    }, 100);
                }
            }).fail(function (jqxhr, textStatus, error) {
                if (jqxhr) {
                    let errorText = "unknown error";
                    if (jqxhr && jqxhr.responseJSON) {
                        if (jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 0) {
                            errorText = jqxhr.responseJSON.detailsList[0];
                        }
                        if (jqxhr.responseJSON.displayError) {
                            errorText = jqxhr.responseJSON.displayError;
                        }
                        matrixlib_1.ml.UI.showError("Search failed", errorText);
                    }
                    // error in search
                    that.showSearchStatus(-2, false, errorText.replace("[EClient/MRQL]|", "").replace("|FindItemsMethod", ""));
                    that.currentStatus = ProjectViewDefines_1.SearchState.ServerDone;
                    that.doDelayed(); // just in case
                }
                else {
                    // no search performed (e.g. empty string)
                    that.showSearchStatus(-1, false);
                    that.currentStatus = ProjectViewDefines_1.SearchState.NoSearch;
                    that.doDelayed(); // just in case
                }
            });
        }
        ;
        // delayed actions might happen if user types or uses UI while a server 
        // request is going on. in that case the (last) delayed action is done after
        // server returns
        doDelayed() {
            if (!this.delayedAction) {
                return;
            }
            if (this.delayedAction.type === "server") {
                this.search(this.delayedAction.expression);
            }
            else if (this.delayedAction.type === "filter") {
                this.filter(this.delayedAction.expression);
            }
            else if (this.delayedAction.type === "render") {
                this.render();
            }
        }
        // status:
        // -1 no search running
        // -2 error (details contains message)
        // -3 server search running
        // 0 no matching results
        // n>0 n matching results 
        showSearchStatus(status, local, details) {
            let that = this;
            var searchResultInfo = $(".searchResultInfo");
            clearTimeout(this.spinnerServerSearch);
            $(".searchResultWaiting").hide();
            $(".searchResultSelect").hide();
            let searchHint = "";
            if (matrixlib_1.ml.LabelTools.getFilter()) {
                let filterNames = matrixlib_1.ml.LabelTools.getFilter().split(",").map(function (f) { return matrixlib_1.ml.LabelTools.getFilterName(f); }).join(",");
                searchHint += " <span style='color:" + MatrixLibInterfaces_1.UIToolsConstants.CIColors.BrownDiSerria.color + "'>Results filtered by label(s): '" + filterNames + "'</span>.";
            }
            if (local && !that.isConfigSearch) {
                searchHint += " Click on search button to run fulltext search.";
            }
            if (status === -3) {
                this.spinnerServerSearch = window.setTimeout(function () {
                    $(".searchResultWaiting", that.searchMetaInfo).show();
                    that.updateSearchStatusHeights();
                }, 200);
            }
            else if (status === -2) {
                searchResultInfo.html("error in search expression: " + details);
                searchResultInfo.show();
            }
            else if (status === -1) {
                searchResultInfo.html("");
                searchResultInfo.hide();
            }
            else if (status === 0) {
                searchResultInfo.html("<span style='color:grey;width:100%;padding-top:20px'>No matching items found." + searchHint + (details ? details : "") + "</span>");
                searchResultInfo.show();
            }
            else {
                searchResultInfo.html(status + " matching items found." + (details ? details : "") + searchHint);
                searchResultInfo.show();
                if (this.panel.settings.canSelectItems) {
                    $(".searchResultSelect").show();
                }
            }
            $(".searchResultTabLink", searchResultInfo).click((event) => {
                let link = $(event.delegateTarget);
                let tab = link.data("tab");
                NavigationBar_1.NavBar.switchTab(tab);
                that.render();
            });
            this.updateSearchStatusHeights();
        }
        // recompute position of tree/list control
        updateSearchStatusHeights() {
            var top = 44;
            $.each(this.searchMetaInfo.children(), function (idx, div) {
                if ($(div).is(":visible")) {
                    top += $(div).height();
                }
            });
            this.panel.updateTopPosition(top);
        }
    }
    exports.SearchBox = SearchBox;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 28 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, ProjectViewDefines_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ViewModeSelector = void 0;
    // this function manages the display style selection of the tree
    class ViewModeSelector {
        constructor(panel) {
            var _a;
            this.panel = panel;
            this.isMainTree = panel.settings.canSelectItems;
            this.searchVizModes = [
                // uid: a unique id used by selenium tests...         
                // icon: icon to show        
                // text: text in drop down    
                // maintree: whether available in main tree, 
                // asList: whether to show as list 
                // hide: whether to hide elements which don't match
                // expand: whether to expand tree
                {
                    uid: "0", icon: "search_dimtree.png", text: "grey out mismatches",
                    mainTree: true, asList: false, hide: false, check: false, expand: false
                },
                {
                    uid: "1", icon: "search_expanddimtree.png", text: "grey out mismatches and expand tree",
                    mainTree: true, asList: false, hide: false, check: false, expand: true
                },
                {
                    uid: "2", icon: "search_hidetree.png", text: "hide mismatches",
                    mainTree: true, asList: false, hide: true, check: false, expand: false
                },
                {
                    uid: "3", icon: "search_expandtree.png", text: "hide mismatches and expand tree",
                    mainTree: true, asList: false, hide: true, check: false, expand: true
                }
                //    ,{ icon:"search_checklist.png", text:"select in list",   mainTree:false,   asList:true,  hide:true,    check:true , expand:false}
                //   ,{ icon:"search_checktree.png", text:"select in tree",   mainTree:false,   asList:false, hide:false,   check:true, expand:false } 
            ];
            if (!this.selectFoldersOnly()) {
                this.searchVizModes.push({
                    uid: "4", icon: "search_list.png", text: "show as list",
                    mainTree: true, asList: true, hide: true, check: false, expand: false
                });
            }
            if ((_a = this.panel.settings.isConfigSearch) !== null && _a !== void 0 ? _a : false) {
                this.searchVizModes = this.searchVizModes.filter((i) => { return i.uid === "1"; });
            }
        }
        selectFoldersOnly() {
            return !!(this.panel && this.panel.settings && (this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.singleFolder || this.panel.settings.selectMode == ProjectViewDefines_1.SelectMode.folders));
        }
        getVizModeControl(onChange) {
            let that = this;
            let lastMode = this.getMode();
            var current = this.searchVizModes[lastMode];
            var btn_grp = $('<div class="" style="position:absolute">');
            this.btn = $('<button data-cy="searchMode" style="background-color:transparent;height:34px" type="button" title="" data-original-title="Tree search filter mode" data-toggle="dropdown" class="btn btn-stree btn-sm dropdown-toggle">');
            this.img = $('<img style="margin-left: 0px;" src="' + globals_1.globalMatrix.matrixBaseUrl + '/img/' + current.icon + '" />');
            this.btn.append(this.img);
            this.btn.append('<span style="margin-left: 6px;"  class="caret">');
            btn_grp.append(this.btn);
            this.btn.data("uid", current.uid);
            this.setEnabled(false);
            var ul = $(' <ul class="dropdown-menu dropdown-menu-sub" role="menu"> ');
            for (var idx = 0; idx < this.searchVizModes.length; idx++) {
                if (!this.isMainTree || this.searchVizModes[idx].mainTree) {
                    var img_src = globals_1.globalMatrix.matrixBaseUrl + '/img/' + this.searchVizModes[idx].icon;
                    var li = $(`<li data-cy="${this.searchVizModes[idx].text}"  title="${this.searchVizModes[idx].text}">
                        <a href="javascript:void(0)">
                            <img style="margin-left: -6px;" src="${img_src}" />
                            <span style="padding-left:10px">${this.searchVizModes[idx].text}<span>
                        </a>
                    </li>`);
                    ul.append(li);
                    li.click(function (event) {
                        var selIdx = $(event.delegateTarget).data("lidx");
                        that.btn.data("uid", $(event.delegateTarget).data("uid"));
                        that.img[0].src = $(event.delegateTarget).data("img_src");
                        if (that.panel.settings.isConfigSearch == undefined || that.panel.settings.isConfigSearch == false) {
                            that.setMode(selIdx);
                        }
                        onChange();
                    }).data("lidx", idx).data("uid", this.searchVizModes[idx].uid).data("img_src", img_src);
                }
            }
            btn_grp.append(ul);
            return btn_grp;
        }
        // function to grey out button (in case nothing is in search bar)
        setEnabled(enabled) {
            $("img", this.btn).css("opacity", enabled ? 1 : 0.3);
        }
        showAsList() {
            return this.searchVizModes[this.getMode()].asList;
        }
        hideMismatches() {
            return this.searchVizModes[this.getMode()].hide;
        }
        isExpandTree() {
            return this.searchVizModes[this.getMode()].expand;
        }
        // rememebered last filter 
        getMode() {
            var svm = localStorage.getItem('searchFilter' + (this.isMainTree ? "Select" : "Main"));
            if (svm) {
                let option = parseInt(svm);
                return option >= this.searchVizModes.length ? 0 : option;
            }
            else {
                return 0; // default dimmable tree
            }
        }
        // remember last filter method
        setMode(mode) {
            localStorage.setItem('searchFilter' + (this.isMainTree ? "Select" : "Main"), mode.toString());
        }
    }
    exports.ViewModeSelector = ViewModeSelector;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 29 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//Import
/// <reference types="matrixrequirements-type-declarations" />
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(1), __webpack_require__(30), __webpack_require__(21), __webpack_require__(6), __webpack_require__(32), __webpack_require__(3), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, matrixlib_1, dateselect_1, MainTree_1, globals_1, ProjectSettings_1, MatrixLibInterfaces_1, Components_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.initialize = exports.NotificationList = exports.Notifications = void 0;
    class Notifications {
        constructor() {
            this.projectCount = null;
            this.isDefault = true;
            this.previousNotificationsIds = [];
            this.addFancyTreeNotificationCounterPlugin();
            this.watchActivity();
        }
        onUpdate(ui, config, context) {
        }
        init() {
            let that = this;
            $().ready(() => {
                if (globals_1.matrixSession && globals_1.matrixSession.serverConfig) {
                    let all = globals_1.restConnection.getServer("all/todo").done((result) => {
                        that.setPreviousNotificationsIds(result.todos.map((o) => { return o.todoId; }));
                    });
                }
            });
        }
        setPreviousNotificationsIds(notifIds) {
            localStorage.setItem("previousNotificationsIds", JSON.stringify(notifIds));
        }
        getPreviousNotificationsIds() {
            let notif = [];
            let notifAsString = localStorage.getItem("previousNotificationsIds");
            if (notifAsString != undefined) {
                let parseNotif = JSON.parse(notifAsString);
                if (parseNotif != undefined) {
                    return parseNotif;
                }
            }
            return notif;
        }
        initItem(item, jui) {
            if (!this.isEnabled()) {
                return;
            }
            this._item = item;
            if (!this.projectCount) {
                this.projectCount = {};
                this.countRec(globals_1.app.getTree());
            }
        }
        initServerSettings() {
        }
        initProject() {
            this.notificationConfig = globals_1.matrixSession.getCustomerSettingJSON(ProjectSettings_1.notificationSetting, ProjectSettings_1.defaultNotificationConfig);
            if (!this.isEnabled()) {
                return;
            }
            this.updateProjectMenu();
            this.init();
            this.projectCount = null;
        }
        isEnabled() {
            return this.notificationConfig && this.notificationConfig.enabled;
        }
        getProjectPages() {
            let that = this;
            var pages = [];
            if (this.isEnabled() && !globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                pages.push({ id: "NOTIFICATION", title: "My Notifications", folder: "MYWORK", order: 2000, icon: "fal fa-bell", usesFilters: false, render: (options) => that.renderNotificationProjectPage(options) });
            }
            window.setTimeout(function () {
                if (!that.projectCount) {
                    that.projectCount = {};
                    that.countRec(globals_1.app.getTree());
                }
            }, 1);
            return pages;
        }
        updateMenu(ul) {
            if (!this.isEnabled() || !ul || !this._item || matrixlib_1.ml.Item.parseRef(this._item.id).isFolder) {
                return;
            }
            let that = this;
            this.lastMenu = ul;
            $(".notificationMenu").remove();
            $(".notificationBtn").remove();
            let myNotification = this.getProjectNotifications(globals_1.matrixSession.getProject(), globals_1.app.getCurrentItemId());
            let myNotificationMarker = myNotification.length ?
                ("<i class='fal fa-bell '></i><span class='fancytree-notificationCounter notificationCounter'>" + myNotification.length + "</span>") :
                "<i class='fal fa-bell '></i>";
            $('<div class="btn-group" style=""><button class="btn btn-item btn-sm notificationBtn" tabindex="-1" title="Show and create notifications">' + myNotificationMarker + '</button></div>').click(function (event) {
                that.showAllNotificationsDialog();
            }).insertBefore($("#shareButton").closest("div"));
        }
        userCanAcknowledgeNotification(notification) {
            return !notification.auto;
            // that should be  notification.action.todoType == "user" ||  notification.action.todoType == "signaturesDone" ||  notification.action.todoType == "reviewsDone";
        }
        supportsControl() {
            return false;
        }
        updateNotifications() {
            let that = this;
            if (!this.isEnabled()) {
                return;
            }
            clearTimeout(this.notificationUpdateTimer);
            this.notificationUpdateTimer = window.setTimeout(function () {
                // in case there's a couple of notifications created in a short time
                that.getNotificationChanges();
            }, 300 + Math.random() * 700); // wait up to 1 second before updating UI -> in case user has many tabs open
        }
        watchActivity() {
            let that = this;
            $(window).on('keyup click', function (event) {
                if (that.newNotification) {
                    globals_1.app.updateFavicon(globals_1.matrixSession.getProject(), false);
                    that.newNotification = false;
                }
            });
        }
        updateActivity(newCount) {
            if (newCount > this.lastCount) {
                globals_1.app.updateFavicon(globals_1.matrixSession.getProject(), true);
                this.newNotification = true;
            }
            this.lastCount = newCount;
        }
        // this gets all the updates about the user's notifications after being signalled that something changed for the user
        getNotificationChanges() {
            let that = this;
            globals_1.restConnection.getServer("all/todo", true).done(function (allNotifications) {
                let notificationCounts = [];
                // create object with counts
                let projects = globals_1.matrixSession.getProjectList(true).map(function (p) { return p.shortLabel; });
                notificationCounts = allNotifications.todoCounts.filter(function (notificationCount) { return projects.indexOf(notificationCount.projectShort) != -1; });
                let total = 0;
                $.each(notificationCounts, function (idx, tc) {
                    total += tc.nbTodos;
                });
                // show a icon if the number increased
                that.updateActivity(total);
                // store them in session
                globals_1.matrixSession.setNotificationCounts(notificationCounts);
                globals_1.matrixSession.setNotifications(allNotifications.todos);
                // update UI
                that.projectCount = null; // removing the cache, so it will be reloaded next time updateCounters is called
                that.updateCounters();
                that.updateMenu(that.lastMenu);
                // Send browser notification. The random delay will avoid duplicates
                if (that.notificationConfig.browserNotificationDisabled == undefined || that.notificationConfig.browserNotificationDisabled == false) {
                    let timeOut = that.notificationConfig.browserNotificationAutoCloseAfter != undefined ? that.notificationConfig.browserNotificationAutoCloseAfter : 9000;
                    allNotifications.todos.forEach((t) => {
                        if (that.getPreviousNotificationsIds().indexOf(t.todoId) == -1 && t.login == globals_1.matrixSession.getUser()) {
                            if (window.Notification != undefined) {
                                if (window.Notification.permission !== "granted")
                                    window.Notification.requestPermission();
                                else {
                                    var n = new Notification(t.projectShort + "/" + t.itemRef, {
                                        icon: globals_1.globalMatrix.matrixBaseUrl + "/favicon_medical.ico",
                                        body: t.originatorLogin + ": " + Notifications.getMessage(t),
                                        requireInteraction: true,
                                    });
                                    n.onclick = () => { window.open(globals_1.globalMatrix.matrixBaseUrl + "/" + t.projectShort + "/" + t.itemRef); };
                                }
                                setTimeout(() => {
                                    if (n != undefined) {
                                        n.close();
                                    }
                                }, timeOut);
                            }
                        }
                    });
                }
                that.setPreviousNotificationsIds(allNotifications.todos.map((o) => { return o.todoId; }));
            });
        }
        // get the notifications
        getTotalNotificationsProject(project) {
            let list = globals_1.matrixSession.getNotificationCounts().filter(function (notificationCount) { return notificationCount.projectShort == project; });
            return list.length ? list[0] : null;
        }
        getTotalNotifications() {
            let sum = 0;
            $.each(globals_1.matrixSession.getNotificationCounts(), function (cidx, notificationCount) { sum += notificationCount.nbTodos; });
            return sum;
        }
        getProjectNotifications(project, item) {
            return globals_1.matrixSession.getNotifications().filter(function (notification) {
                return (!project || notification.projectShort == project) && (!item || item == notification.itemRef);
            });
        }
        renderNotificationProjectPage(options) {
            let that = this;
            if (options.controlState === globals_1.ControlState.Print) {
                return;
            }
            document.title = "Notifications - " + globals_1.matrixSession.getProject();
            options.control.html("");
            let h2 = matrixlib_1.ml.UI.getPageTitle("Notifications overview").appendTo(options.control);
            // paint the tabs
            let tabpanel = $('<div role="tabpanel" class="tabpanel-container contextFrameContainer" style="top:60px;padding: 5px;">');
            let tabpanelul = $('<ul class="nav nav-tabs contextFrameTabs" role="tablist">');
            let tabpanels = $('<div class="tab-content">');
            // enable copy
            matrixlib_1.ml.UI.copyBuffer(h2, "copy to clipboard", tabpanels, options.control, (copied) => {
                $(".tabpaneltab.tab-pane", copied).not(".active").remove();
                $(".tab-content", copied).css("height", "");
            });
            options.control.append(tabpanel);
            tabpanel.append(tabpanelul);
            tabpanel.append(tabpanels);
            tabpanelul.append('<li role="presentation" class="active"><a href="#MYNOTIFICATIONS"  role="tab" data-toggle="tab">Notifications for me</a></li>');
            let myNotifications = $('<div role="tabpanel"  style="height:100%" class="tabpaneltab tab-pane active" id="MYNOTIFICATIONS" >');
            tabpanels.append(myNotifications);
            tabpanelul.append('<li role="presentation"><a href="#MYDONE"  role="tab" data-toggle="tab">My previous notifications</a></li>');
            let myDone = $('<div role="tabpanel"  style="height:100%" class="tabpaneltab tab-pane" id="MYDONE" >');
            tabpanels.append(myDone);
            tabpanelul.append('<li role="presentation"><a href="#MYOWNED"  role="tab" data-toggle="tab">Notifications I created</a></li>');
            let myOwned = $('<div role="tabpanel"  style="height:100%" class="tabpaneltab tab-pane" id="MYOWNED" >');
            tabpanels.append(myOwned);
            tabpanelul.append('<li role="presentation"><a href="#MYOWNEDDONE"  role="tab" data-toggle="tab">Previous notifications I created</a></li>');
            let myOwnedDone = $('<div role="tabpanel"  style="height:100%" class="tabpaneltab tab-pane" id="MYOWNEDDONE" >');
            tabpanels.append(myOwnedDone);
            // adjust heights of panels
            let height = $("#main").height() - tabpanels.offset().top + $("#main").offset().top;
            tabpanels.height(height);
            globals_1.restConnection.getProject("todo?includeDone=1&includeFuture=1", true).done(function (allNotifications) {
                let todosForNow = allNotifications.todos.filter(function (notification) { return !notification.future; });
                let todosForLater = allNotifications.todos.filter(function (notification) { return notification.future; }).sort(function (a, b) {
                    let da = new Date(a.createdAt).getTime();
                    let db = new Date(b.createdAt).getTime();
                    return da > db ? 1 : -1;
                });
                that.renderNotificationTable(myNotifications, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: globals_1.globalMatrix.globalShiftDown, forColumn: false, itemColumn: true, doneColumn: false, canCloseMine: true, canCloseAll: false, showAddButton: false, none: "you have no todos", moveDoneTo: "MYDONE"
                }, todosForNow.filter(function (notification) {
                    return notification.login == globals_1.matrixSession.getUser() && !notification.closedAt;
                }));
                that.renderNotificationTable(myNotifications, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: globals_1.globalMatrix.globalShiftDown, forColumn: false, itemColumn: true, doneColumn: false, canCloseMine: true, canCloseAll: true, showAddButton: false, none: "", moveDoneTo: "MYDONE"
                }, todosForLater.filter(function (notification) {
                    return notification.login == globals_1.matrixSession.getUser() && !notification.closedAt;
                }));
                that.renderNotificationTable(myDone, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: false, forColumn: false, itemColumn: true, doneColumn: true, canCloseMine: false, canCloseAll: true, showAddButton: false, none: "you did not finish any todo"
                }, todosForNow.filter(function (notification) {
                    return notification.login == globals_1.matrixSession.getUser() && notification.closedAt;
                }));
                that.renderNotificationTable(myOwned, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: globals_1.globalMatrix.globalShiftDown, forColumn: true, itemColumn: true, doneColumn: false, canCloseMine: false, canCloseAll: true, showAddButton: false, none: "you did not create any todos", moveDoneTo: "MYOWNEDDONE"
                }, todosForNow.filter(function (notification) {
                    return notification.originatorLogin == globals_1.matrixSession.getUser() && !notification.closedAt;
                }));
                that.renderNotificationTable(myOwned, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: globals_1.globalMatrix.globalShiftDown, forColumn: true, itemColumn: true, doneColumn: false, canCloseMine: false, canCloseAll: true, showAddButton: false, none: ""
                }, todosForLater.filter(function (notification) {
                    return notification.originatorLogin == globals_1.matrixSession.getUser() && !notification.closedAt;
                }));
                that.renderNotificationTable(myOwnedDone, {
                    allowDelete: globals_1.globalMatrix.globalShiftDown, selectable: false, forColumn: true, itemColumn: true, doneColumn: true, canCloseMine: false, canCloseAll: false, showAddButton: false, none: "none of your todos were done"
                }, todosForNow.filter(function (notification) {
                    return notification.originatorLogin == globals_1.matrixSession.getUser() && notification.closedAt;
                }));
                globals_1.app.waitForMainTree(() => { options.control.highlightReferences(); });
            });
        }
        // renders a row with a notifications and +- actions on it
        renderNotificationRow(tr, notification, tableOptions) {
            let that = this;
            let isAutomatic = !that.userCanAcknowledgeNotification(notification);
            let isForMe = notification.login == globals_1.matrixSession.getUser();
            let isFromMe = notification.originatorLogin == globals_1.matrixSession.getUser();
            if (notification.future) {
                tr.addClass("future");
            }
            if (notification.closedAt) {
                tr.addClass("past");
            }
            if (!isForMe) {
                tr.addClass("others");
            }
            if (tableOptions.selectable || tableOptions.allowDelete) {
                let input = $('<input class="notificationSelector" type="checkbox">').data("todoid", notification.todoId);
                $('<td>').appendTo(tr).append(input);
            }
            if (tableOptions.itemColumn)
                $('<td>' + notification.itemRef + '!</td>').appendTo(tr);
            if (tableOptions.forColumn)
                $('<td>' + (notification.login == globals_1.matrixSession.getUser() ? "You" : notification.login) + '</td>').appendTo(tr);
            $('<td style="white-space: pre-wrap;"">' + Notifications.getMessage(notification) + '</td>').appendTo(tr);
            $('<td>' + notification.originatorLogin + '</td>').appendTo(tr);
            $('<td>' + notification.createdAtUserFormat + '</td>').appendTo(tr);
            if (tableOptions.doneColumn)
                $('<td>' + notification.closedAtUserFormat + '</td>').appendTo(tr);
            if (tableOptions.canCloseMine || tableOptions.canCloseAll) {
                if (tableOptions.canCloseAll || isForMe || isFromMe) {
                    let td = $('<td>').appendTo(tr);
                    if (isAutomatic && !that.notificationConfig.closeAuto) {
                        return;
                    }
                    if (notification.closedAt) {
                        if (!tableOptions.doneColumn)
                            $('<span class="closedAt">Closed: ' + notification.closedAtUserFormat + '</span>').appendTo(td);
                        return;
                    }
                    let closeStyle = "btn-link";
                    let closeText = "acknowledge";
                    let closeTitle = "remove notification";
                    if (isAutomatic) {
                        closeStyle = "btn-link";
                        closeText = "force acknowledge";
                        closeTitle = "notification will also go once you do the job!";
                    }
                    if (notification.future) {
                        closeStyle = "btn-link";
                        closeText = "acknowledge already";
                        closeTitle = "remove notification already now";
                    }
                    if (!isForMe) {
                        closeStyle = "btn-link";
                        closeText = "mark done";
                        closeTitle = "mark notification as done for someone else";
                    }
                    if (tableOptions.moveDoneTo) {
                        tr.addClass("canBeClosed");
                        tr.data("todoId", notification.todoId);
                        tr.data("moveTo", tableOptions.moveDoneTo);
                    }
                    $('<button class="' + closeStyle + '" title="' + closeTitle + '">' + closeText + '</button>').appendTo(td).click(function (event) {
                        let button = $(event.delegateTarget);
                        that.deleteNotificationId(globals_1.matrixSession.getProject(), button.data("todoid"), false).done(function () {
                            if (tableOptions.moveDoneTo) {
                                let todoId = button.closest("tr").data("todoId");
                                let toBeMoved = $(".canBeClosed").filter(function (trIdx, tr) { return $(tr).data("todoId") == todoId; });
                                $.each(toBeMoved, function (idx, tbm) {
                                    let moveTo = $(tbm).data("moveTo");
                                    let tbodys = $("tbody", $("#" + moveTo));
                                    if (tbodys.length) {
                                        $(".btn", $(tbm)).replaceWith("<span>just now</span>");
                                        $(tbodys[0]).append($(tbm));
                                    }
                                    else {
                                        button.closest("tr").remove();
                                    }
                                });
                            }
                            else {
                                button.closest("tr").remove();
                            }
                        });
                    }).data("todoid", notification.todoId);
                }
                else {
                    $('<td>').appendTo(tr);
                }
            }
        }
        // renders a table with notifications and +- actions on them
        renderNotificationTable(container, tableOptions, notifications) {
            let that = this;
            if (notifications.length == 0 && !tableOptions.showAddButton) {
                if (tableOptions.none) {
                    $('<p>').html(tableOptions.none).appendTo(container);
                }
                return;
            }
            let table = $("<table class='table table-lined " + (tableOptions.tableClass ? tableOptions.tableClass : "") + "'>");
            if (!tableOptions.none) {
                $('<p>').html("Upcoming notifications").appendTo(container);
            }
            let tbody = $("<tbody>");
            // add notifications
            $.each(notifications, function (idx, notification) {
                let tr = $("<tr>").appendTo(tbody);
                that.renderNotificationRow(tr, notification, tableOptions);
            });
            // create table with headings and body
            let thead = $("<thead><tr>"
                + ((tableOptions.selectable || tableOptions.allowDelete) ? "<th data-sorter='false' style='white-space: nowrap;'><input class='selectAllNotification' type='checkbox'> all</th>" : "")
                + (tableOptions.itemColumn ? "<th>Item</th>" : "")
                + (tableOptions.forColumn ? "<th>Notification For</th>" : "")
                + "<th>Notification</th><th>Originator</th><th>Due date</th>" + (tableOptions.doneColumn ? "<th>Done at</th>" : "")
                + ((tableOptions.canCloseMine || tableOptions.canCloseAll) ? "<th></th>)" : "")
                + "</tr></thead>");
            if (tableOptions.showAddButton && this.notificationConfig.manualCreate) {
                //  create an extra row with add button
                let addRow = $("<tr>").appendTo(tbody);
                let columnCount = $("th", thead).length;
                let addCell = $("<td colspan='" + columnCount + "'>").appendTo(addRow);
                $("<button style='margin-top: 12px;' class='btn btn-success btn-xs'><i class='fal fa-bell' style='margin-right:12px'></i>Create New</button>")
                    .appendTo(addCell)
                    .click(function () {
                    that.showCreateNotificationDialog().done(function (todoIds) {
                        globals_1.restConnection.getProject("todo?includeFuture=1&itemRef=" + globals_1.app.getCurrentItemId()).done(function (allNotification) {
                            // create is always for current item
                            let todos = allNotification.todos.filter(function (todo) { return todoIds.indexOf(todo.todoId) != -1; });
                            $.each(todos, function (idx, todo) {
                                let newNotificationRow = $("<tr>").insertBefore(addRow);
                                that.renderNotificationRow(newNotificationRow, todo, tableOptions);
                            });
                            table.trigger('update');
                        });
                    });
                });
            }
            // assemble table
            table.append(thead)
                .append(tbody)
                .appendTo(container).tablesorter();
            if (tableOptions.selectable || tableOptions.allowDelete) {
                $(".selectAllNotification", table).click(function () {
                    $(".notificationSelector", table).prop("checked", $(".selectAllNotification", table).prop("checked"));
                });
                if (tableOptions.selectable) {
                    $("<button title class='btn btn-xs btn-default hideCopy'>Mark as done</button>").appendTo(container).click(function () {
                        that.closeNotifications($(".notificationSelector:checked", table), false);
                    });
                }
                if (tableOptions.allowDelete) {
                    $("<button title class='btn btn-xs btn-default hideCopy'>Permanently delete</button>").appendTo(container).click(function () {
                        that.closeNotifications($(".notificationSelector:checked", table), true);
                    });
                }
                $("<p><br></p>").appendTo(container);
            }
        }
        indicateNotificationChange() {
            $(".notificationBtn").removeClass("bounce").addClass("bounce");
        }
        closeNotifications(notifications, deleteThem) {
            matrixlib_1.ml.UI.BlockingProgress.Init([{ name: "Acknowledging notifications" }]);
            this.deleteNotificationIdRec(globals_1.matrixSession.getProject(), notifications, deleteThem, 0).always(function () {
            });
        }
        // show all notifications for current user
        updateProjectMenu() {
            let that = this;
            let menu = $("#idNotificationList");
            let menuResponsive = $("#idNotificationListResponsive");
            // add a navigation icon left next button to project  menu
            $(".notificationBtnMenu").remove();
            let projectButton = $('<a class="nav-link no-decoration notificationBtnMenu dropdown-toggle" data-toggle="dropdown" title="" data-original-title="Show all notifications"><i class="fal fa-bell notificationAction"></i></a>')
                .insertBefore(menu);
            let projectButtonResponsive = $('<a class="nav-link no-decoration notificationBtnMenu dropdown-toggle" data-toggle="dropdown" title="" data-original-title="Show all notifications"><i class="fal fa-bell notificationAction"></i></a>')
                .insertBefore(menuResponsive);
            // remove old items
            menu.html("");
            menuResponsive.html("");
            $.each(globals_1.matrixSession.getProjectList(false), function (idx, project) {
                // We skip projects that we don't have access
                if (project.accessType === "none")
                    return;
                let notificationCount = that.getTotalNotificationsProject(project.shortLabel);
                if (notificationCount) {
                    // there are some notifications for project
                    let mss = [];
                    // take up to first two messages from recent message list
                    if (notificationCount.firstTodos.length > 0)
                        mss.push(Notifications.getMessage(notificationCount.firstTodos[0]));
                    if (notificationCount.firstTodos.length > 1)
                        mss.push(Notifications.getMessage(notificationCount.firstTodos[1]));
                    // format messages for ui: 3 lines
                    let last = "";
                    if (mss.length > 0) {
                        if (mss[0] != undefined) {
                            last = (mss[0].length < 30 ? mss[0] : (mss[0].substring(0, 30 - 3) + "..."));
                        }
                    }
                    let before = "";
                    if (mss.length > 1) {
                        if (mss[1] != undefined) {
                            before = (mss[1].length < 30 ? mss[1] : (mss[1].substring(0, 30 - 3) + "..."));
                        }
                    }
                    let more = (notificationCount.nbTodos > mss.length) ? ((notificationCount.nbTodos - mss.length) + " more messages") : "";
                    // build ui
                    let img = globals_1.matrixSession.getImgFromProject(project.shortLabel, 5);
                    let msg = ` ${img} <span class='mainmenu'>${project.shortLabel}
                                        <div class="notificationMenuSummary">
                                        <span class="last">${last}</span>
                                        <span class="before">${before}</span>
                                        <span class="more">${more}</span>
                                        </div>
                                    </span>`;
                    $('<li style="position: relative;">' + msg + '</li>').appendTo(menu).click(function (event) {
                        globals_1.app.canNavigateAwayAsync().done(function () {
                            // If we have QMSViewer only access, we open the published QMS in a new tab.
                            if (project.accessType === "qmsviewer") {
                                window.open(`${globals_1.globalMatrix.matrixBaseUrl}/pub/${$(event.delegateTarget).data("project")}?USER=training`);
                            }
                            else {
                                globals_1.matrixSession.loadProject(null, $(event.delegateTarget).data("project") + "/MYWORK", true);
                            }
                        });
                    }).data("project", project.shortLabel);
                    $('<li style="position: relative;">' + msg + '</li>').appendTo(menuResponsive).click(function (event) {
                        globals_1.app.canNavigateAwayAsync().done(function () {
                            globals_1.matrixSession.loadProject(null, $(event.delegateTarget).data("project") + "/MYWORK", true);
                        });
                    }).data("project", project.shortLabel);
                }
            });
            // fake show the list, to get the sizes
            let height = Math.max($("#main").height(), 200);
            // end fake show the list, to get the sizes
            $("#idNotificationList")
                .css("max-height", height + "px")
                .css("overflow-y", "auto")
                .css("overflow-x", "none");
            $("nav").css("visibility", "").css("display", "");
            // do main button
            this.lastCount = that.getTotalNotifications();
            if (this.lastCount) {
                projectButton.append($("<span class='notificationIcon'>").html("" + this.lastCount));
                projectButtonResponsive.append($("<span class='notificationIcon'>").html("" + this.lastCount));
            }
        }
        // either the message is plain text or some formatted json object
        static getMessage(todo) {
            if (!todo || !todo.action || !todo.action.text)
                return "";
            if (todo.action.text[0] != "{")
                return todo.action.text;
            try {
                let json = JSON.parse(todo.action.text);
                if (json.message) {
                    return json.message;
                }
            }
            catch (e) { }
            ;
            return todo.action.text;
        }
        // either the message is plain text or some formatted json object: the anchor is a place in the UI
        static getField(todo) {
            if (!todo || !todo.action || !todo.action.text)
                return null;
            if (todo.action.text[0] != "{")
                return null;
            try {
                let json = JSON.parse(todo.action.text);
                if (json.field) {
                    return json.field;
                }
            }
            catch (e) { }
            ;
            return null;
        }
        // either the message is plain text or some formatted json object: the reply is a reference to another todo - for which this is a replyTo
        static getReply(todo) {
            if (!todo || !todo.action || !todo.action.text)
                return null;
            if (todo.action.text[0] != "{")
                return null;
            try {
                let json = JSON.parse(todo.action.text);
                if (json.replyTo) {
                    return json.replyTo;
                }
            }
            catch (e) { }
            ;
            return null;
        }
        // show a dialog asking for details of a notification to create
        showCreateNotificationDialog() {
            let that = this;
            let res = $.Deferred();
            let sendTo = [];
            function updateSend() {
                var sendButton = $(".btnDoIt", ui.parent().parent());
                var enabled = sendTo.length && subj && subj.getController().getValue() !== "";
                matrixlib_1.ml.UI.setEnabled(sendButton, enabled);
            }
            let usel = $("<div>");
            // take users from current project
            matrixlib_1.ml.UI.SelectUserOrGroup.showMultiUserSelect(usel, "For", [], "Create Notification For", "", "", true, true, (selection) => {
                sendTo = selection;
                updateSend();
            });
            let subj = $("<div>").plainText({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Notification message",
                fieldValue: "",
                valueChanged: function () {
                    updateSend();
                },
                parameter: {
                    allowResize: false
                }
            });
            let dateSel = $("<div>").dateselect({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Date to activate (optional)",
                fieldValue: "",
                valueChanged: function () {
                    updateSend();
                },
                parameter: {
                    allowClear: true,
                    minDate: new Date()
                }
            });
            let dlg = $("<div>").appendTo($("body"));
            let ui = $("<div style='width:100%;height:100%'>");
            ui.append(dateSel);
            ui.append(usel);
            ui.append(subj);
            ui.addClass("dlg-no-scroll");
            ui.removeClass("dlg-v-scroll");
            matrixlib_1.ml.UI.showDialog(dlg, "Create Notification", ui, -730, -440, [{
                    text: 'Create',
                    class: 'btnDoIt',
                    click: function () {
                        let text = DOMPurify.sanitize(subj.getController().getValue()) + '';
                        let dateStr = dateSel.getController().getValue();
                        let date = dateselect_1.DateSelectImpl.getDateFromString(dateStr);
                        if (date && matrixlib_1.ml.UI.DateTime.renderDashFormat(date) == matrixlib_1.ml.UI.DateTime.renderDashFormat(new Date())) {
                            // date is for today
                            date = null;
                        }
                        that.createNotification(sendTo, globals_1.matrixSession.getProject(), globals_1.app.getCurrentItemId(), text, null, date).done(function (created) {
                            res.resolve(created);
                        });
                        dlg.dialog("close");
                    }
                }, {
                    text: 'Cancel',
                    class: 'btnCancelIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, false, false, () => { dlg.remove(); }, () => { updateSend(); $("textarea", subj).focus(); }, () => { });
            return res;
        }
        // show a dialog with all notifications
        showAllNotificationsDialog() {
            let that = this;
            let dlg = $("<div>").appendTo($("body"));
            let ui = $("<div style='width:100%'>");
            matrixlib_1.ml.UI.showDialog(dlg, "Notifications", ui, 900, 600, [{
                    text: 'Ok',
                    class: 'btnDoIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { dlg.remove(); }, () => {
                that.showNotifications(ui);
            }, () => { });
        }
        showNotifications(ui) {
            let that = this;
            ui.html("").append(matrixlib_1.ml.UI.getSpinningWait("getting notifications..."));
            globals_1.restConnection.getProject("todo?includeDone=1&includeFuture=1&itemRef=" + globals_1.app.getCurrentItemId()).done(function (allNotification) {
                ui.html("");
                let cbs = {
                    others: (localStorage.getItem("ShowNotificationOthers") == "0") ? false : true,
                    future: (localStorage.getItem("ShowNotificationFuture") == "0") ? false : true,
                    past: (localStorage.getItem("ShowNotificationPast") == "0") ? false : true,
                };
                let table = $("<table style='width:100%'>").appendTo(ui);
                let tr = $("<tr>").appendTo(table);
                let td1 = $("<td>").appendTo(tr);
                let td2 = $("<td>").appendTo(tr);
                let td3 = $("<td>").appendTo(tr);
                matrixlib_1.ml.UI.addCheckbox(td1, "Show notifications for others", cbs, "others", function () {
                    that.filterNotifications(ui, cbs);
                });
                matrixlib_1.ml.UI.addCheckbox(td2, "Show notifications for future", cbs, "future", function () {
                    that.filterNotifications(ui, cbs);
                });
                matrixlib_1.ml.UI.addCheckbox(td3, "Show notifications from the past", cbs, "past", function () {
                    that.filterNotifications(ui, cbs);
                });
                $('<div style="margin-bottom: 40px;">').appendTo(ui); // just a bit of space
                that.renderNotificationTable(ui, { allowDelete: false, selectable: false, forColumn: true, itemColumn: false, doneColumn: false, canCloseMine: true, canCloseAll: false, showAddButton: true, none: "no (more) to dos", tableClass: "itemNotifications" }, allNotification.todos);
                that.filterNotifications(ui, cbs);
            });
        }
        // hide / show notifications depending on checkboxes, remember last value
        filterNotifications(ui, cbs) {
            localStorage.setItem("ShowNotificationOthers", cbs.others ? "1" : "0");
            localStorage.setItem("ShowNotificationFuture", cbs.future ? "1" : "0");
            localStorage.setItem("ShowNotificationPast", cbs.past ? "1" : "0");
            $("tr", ui).show();
            if (!cbs.others)
                $("tr.others", ui).hide();
            if (!cbs.future)
                $("tr.future", ui).hide();
            if (!cbs.past)
                $("tr.past", ui).hide();
        }
        // mark a notification as resolved (mark as done) 
        deleteNotificationDlg(notification) {
            let that = this;
            let res = $.Deferred();
            matrixlib_1.ml.UI.showConfirm(-1, { title: "Remove notification '" + Notifications.getMessage(notification) + "'", ok: "Ok", nok: "Cancel" }, () => {
                globals_1.restConnection.deleteServerAsync(notification.projectShort + "/todo/" + notification.todoId, {}).done(function () {
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }, null);
            return res;
        }
        deleteNotification(notification) {
            return this.deleteNotificationId(notification.projectShort, notification.todoId, false);
        }
        deleteNotificationIdRec(project, notifications, deleteThem, idx) {
            let that = this;
            let res = $.Deferred();
            if (notifications.length <= idx) {
                res.resolve();
                return res;
            }
            this.deleteNotificationId(project, $(notifications[idx]).data("todoid"), deleteThem).done(function () {
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, (idx + 1) * 100 / notifications.length);
                $(notifications[idx]).closest("tr").css("color", "lightgrey").css("text-decoration", "line-through");
                that.deleteNotificationIdRec(project, notifications, deleteThem, idx + 1).done(function () {
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }).fail(function () {
                matrixlib_1.ml.UI.BlockingProgress.SetProgressError(0, "failed deleting todo");
            });
            return res;
        }
        deleteNotificationId(project, todoId, deleteThem) {
            let res = $.Deferred();
            globals_1.restConnection.deleteServerAsync(project + "/todo/" + todoId, deleteThem ? { hardDelete: "yes" } : {}).done(function () {
                res.resolve();
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        // create a new notification object
        createNotification(users, project, item, text, type, atDate) {
            let that = this;
            let res = $.Deferred();
            let todoDetails = {
                text: text,
                logins: users.join(",")
            };
            if (atDate) {
                todoDetails.atDate = atDate.toISOString();
            }
            if (type) {
                todoDetails.todoType = type;
            }
            globals_1.restConnection.postServer(project + "/todo/" + item, todoDetails).done(function (created) {
                res.resolve(created);
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        // count the notifications of a folder by adding up notifications of it's items
        countRec(idb) {
            let that = this;
            let sum = 0;
            for (const child of idb) {
                let count = 0;
                if (child.children) {
                    // this is a folder
                    count = that.countRec(child.children);
                }
                else {
                    count = that.getProjectNotifications(globals_1.matrixSession.getProject(), child.id).length;
                }
                that.projectCount[child.id] = count;
                sum += count;
            }
            ;
            return sum;
        }
        // update the counters in the tree: build a new cache and repaint them
        updateCounters() {
            let that = this;
            // update counters
            window.setTimeout(function () {
                if (!that.projectCount) {
                    that.projectCount = {};
                    that.countRec(globals_1.app.getTree());
                    that.updateProjectMenu();
                    // change icons in tree
                    MainTree_1.NavigationPanel.updateNotificationCounters();
                    Components_1.NavBar.updateNotificationCounters();
                }
            }, 1);
        }
        // returned the cached count of notifications for a specific item
        // if it is not yet cached, recreate it
        getNotificationCount(itemId) {
            let that = this;
            if (!this.projectCount) {
                this.projectCount = {};
                this.countRec(globals_1.app.getTree());
            }
            return this.projectCount[itemId];
        }
        addFancyTreeNotificationCounterPlugin() {
            ($.ui).fancytree._FancytreeClass.prototype.updateNotificationCounters = function () {
                var tree = this;
                tree.visit(function (node) {
                    node.updateNotificationCounters(false);
                });
                ;
            };
            ($.ui).fancytree._FancytreeNodeClass.prototype.updateNotificationCounters = function (doParents) {
                var node = this;
                if (node.span) {
                    var $badge = $("span.fancytree-notificationCounter", node.span), extOpts = node.tree.options.notificationCounter, count = NotificationList.getNotificationCount(node.key);
                    if (count && node.span && (!node.isExpanded() || !extOpts.hideExpanded)) {
                        if (!$badge.length) {
                            if (node.folder) {
                                let expander = $("span.fancytree-expander", node.span);
                                $badge = $("<span class='fancytree-notificationCounter notificationCounter'/>").insertBefore(expander);
                            }
                            else {
                                $badge = $("<span class='fancytree-notificationCounter notificationCounter'/>").insertBefore($("span.fancytree-icon,span.fancytree-custom-icon", node.span));
                            }
                        }
                        $badge.text(count);
                        $badge.closest("li").data("notifications", count);
                    }
                    else {
                        $badge.closest("li").data("notifications", 0);
                        $badge.remove();
                    }
                    if (doParents && extOpts.deep && !node.isTopLevel() && !node.isRoot()) {
                        node.parent.updateCounters();
                    }
                }
            };
            // TODO(modules): improve all this casting.
            const tmp = $.ui.fancytree;
            tmp.registerExtension({
                // Every extension must be registered by a unique name.
                name: "notificationCounter",
                // Version information should be compliant with [semver](http://semver.org)
                version: "1.0",
                // Extension specific options and their defaults.
                // This options will be available as `tree.options.notificationCounter.hideExpanded`
                options: {
                    deep: true,
                    hideZeros: true,
                    hideExpanded: false,
                },
                // Local functions are prefixed with an underscore '_'.
                // Callable as `this._local._appendCounter()`.
                /*_appendCounter: function(bar) {
                    var tree = this;
                },*/
                // **Override virtual methods for this extension.**
                // `treeInit` is triggered when a tree is initialized. We can set up classes or
                // bind event handlers here...
                treeInit: function () {
                    this._super.apply(this, arguments);
                    // Add a class to the tree container
                    this.$container.addClass("fancytree-ext-notificationCounter");
                },
                // Destroy this tree instance (we only call the default implementation, so
                // this method could as well be omitted).
                treeDestroy: function () {
                    //(<any>this)._superApply(arguments);
                    this._super.apply(this, arguments);
                },
                // Overload the `renderTitle` hook, to append a counter badge
                nodeRenderTitle: function (ctx, title) {
                    var node = ctx.node, extOpts = ctx.options.notificationCounter, count = NotificationList.getNotificationCount(node.key);
                    // Let the base implementation render the title
                    // We use `_super()` instead of `_superApply()` here, since it is a little bit
                    // more performant when called often
                    this._super(ctx, title);
                    // Append a counter badge
                    if (count && (!node.isExpanded() || !extOpts.hideExpanded)) {
                        if (node.folder) {
                            $("span.fancytree-expander", node.span).before($("<span class='fancytree-notificationCounter notificationCounter'/>").text(count)).closest("li").data("notifications", count);
                        }
                        else {
                            $("span.fancytree-icon,span.fancytree-custom-icon", node.span).before($("<span class='fancytree-notificationCounter notificationCounter'/>").text(count));
                        }
                    }
                }
            });
        }
        static anchorNotifications() {
            window.clearTimeout(Notifications.anchorTimer);
            let itemId = globals_1.app.getCurrentItemId();
            Notifications.anchorTimer = window.setTimeout(() => {
                if (itemId == globals_1.app.getCurrentItemId()) {
                    let project = globals_1.matrixSession.getProject();
                    for (let notification of globals_1.matrixSession.getNotifications()) {
                        if (notification.projectShort == project && itemId == notification.itemRef) {
                            let anchor = Notifications.getField(notification);
                            $(anchor).append(`<i class="fal fa-bell" style="color:${notification.userId}"></i>`);
                        }
                    }
                }
            }, 1000);
        }
    }
    exports.Notifications = Notifications;
    var NotificationList;
    exports.NotificationList = NotificationList;
    function initialize() {
        exports.NotificationList = NotificationList = new Notifications();
        index_1.plugins.register(NotificationList);
    }
    exports.initialize = initialize;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 30 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, BaseControl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DateSelectImpl = void 0;
    $.fn.dateselect = function (options) {
        let baseControl = new DateSelectImpl(this);
        this.getController = () => { return baseControl; };
        baseControl.init(options);
        return this;
    };
    class DateSelectImpl extends BaseControl_1.BaseControl {
        constructor(control) {
            super(control);
            this.doesRequireContent = false;
        }
        init(options) {
            let that = this;
            var defaultOptions = {
                controlState: globals_1.ControlState.FormView,
                dummyData: false,
                canEdit: false,
                valueChanged: function () {
                },
                parameter: {
                    readonly: false,
                    allowClear: false
                }
            };
            this.settings = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, options);
            this.data = "";
            // have default values
            if (!this.settings.fieldValue && this.settings.parameter.initialContent && !this.settings.item) {
                let date = new Date();
                this.settings.fieldValue = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
            }
            this.setDateFromString(this.settings.fieldValue);
            if (this.settings.controlState === globals_1.ControlState.Print || this.settings.controlState === globals_1.ControlState.Tooltip) {
                this._root.append(super.createHelp(this.settings));
                var css = (this.settings.controlState === globals_1.ControlState.Print) ? "class='printBox'" : "";
                this._root.append("<div class='" + css + "'>" + this.renderHuman() + "</div>");
                return;
            }
            this._root.append(super.createHelp(this.settings));
            var ctrlContainer = $("<div>").addClass("baseControl");
            this._root.append(ctrlContainer);
            if (!this.settings.canEdit) {
                var ctrlx = $('<input autocomplete="off" class="lineInput form-control" type="text" readonly>').addClass("dateSelect");
                ctrlx.val(this.renderHuman());
                ctrlContainer.append(ctrlx);
                return;
            }
            if (options.parameter && options.parameter.requiresContent) {
                this.doesRequireContent = options.parameter.requiresContent;
            }
            this.ctrl = $('<input autocomplete="off" class="lineInput form-control datepickText" type="text" readonly />').addClass("dateSelect").val(this.renderHuman());
            this.ctrl.data("lastSelectedDate", this.lastSelectedDate);
            ctrlContainer.append(this.ctrl);
            if (this.settings.parameter && this.settings.parameter.allowClear) {
                this.ctrl.css("display", "inline");
                let clear = $('<span name="clear" class="far fa-times-circle filter-clear-xin">');
                ctrlContainer.append(clear);
                clear.click(function () {
                    that.ctrl.val("");
                    that.lastSelectedDate = null;
                    that.ctrl.data("lastSelectedDate", "");
                    that.valueChanged();
                });
            }
            this.ctrl.datetimepicker({
                ignoreReadonly: true,
                format: matrixlib_1.ml.UI.DateTime.getSimpleDateFormatMoment(),
                widgetPositioning: {
                    horizontal: this.settings.parameter.horizontal ? this.settings.parameter.horizontal : 'auto',
                    vertical: this.settings.parameter.vertical ? this.settings.parameter.vertical : 'auto'
                },
                minDate: this.settings.parameter.minDate
            }).on('dp.change', function (event) {
                that.lastSelectedDate = new Date(event.date.toISOString());
                that.ctrl.data("lastSelectedDate", that.lastSelectedDate);
                that.valueChanged();
            });
            this.ctrl.on('keyup', function () {
                window.setTimeout(() => that.valueChanged, 10);
            });
            var rt = this.ctrl.val();
            this._root.data("original", rt);
            this._root.data("new", rt);
        }
        // public interface
        hasChanged() {
            return this._root.data("original") !== this._root.data("new");
        }
        getValue() {
            try {
                var date = this.lastSelectedDate;
                if (!date) {
                    if (this.settings.parameter.allowClear) {
                        // the user might decide not to specify a date
                        return "";
                    }
                    // was not changed
                    if (this._root.data("new")) {
                        date = new Date(this._root.data("new"));
                    }
                    else {
                        // item saved, though date was never created, use today instead!
                        date = new Date();
                    }
                }
                return date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
            }
            catch (err) {
                date = new Date();
                return date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
            }
        }
        setValue(date) {
            // parse string
            this.setDateFromString(date);
            // update ui
            this.ctrl.val(this.renderHuman());
            this.ctrl.data("lastSelectedDate", this.lastSelectedDate);
            // set new value
            this._root.data("new", this.ctrl.val());
            this.valueChanged();
        }
        destroy() {
            if (this.ctrl) {
                this.ctrl.off();
            }
            $(".datepicker").remove();
        }
        ;
        resizeItem() {
        }
        requiresContent() {
            return this.doesRequireContent;
        }
        setDateFromString(val) {
            if (!val)
                return;
            let date = DateSelectImpl.getDateFromString(val);
            if (date) {
                this.lastSelectedDate = date;
                this.data = date.toString();
            }
            else {
                this.data = "";
            }
        }
        static getDateFromString(dateStr) {
            if (dateStr) {
                var split = (dateStr).split("/");
                if (split.length === 3 && split[0] !== "NaN") {
                    var date = new Date(parseInt(split[0]), parseInt(split[1]) - 1, parseInt(split[2]));
                    return date;
                }
            }
            return null;
        }
        // private functions
        valueChanged() {
            this._root.data("new", this.ctrl.val());
            if (this.settings.valueChanged) {
                this.settings.valueChanged.apply(null);
            }
        }
        renderHuman() {
            if (this.data === '') {
                return "";
            }
            else {
                return matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(this.data), true);
            }
        }
    }
    exports.DateSelectImpl = DateSelectImpl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 31 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.BaseControl = void 0;
    class BaseControl {
        constructor(control) {
            this._root = control;
            this.needsLatest = false;
        }
        createHelp(settings) {
            var helpline = $("<span class='baseControlHelp'>" + settings.help + "</span>");
            helpline.data("fieldId", settings.fieldId);
            if (settings.parameter.externalHelp && settings.controlState !== globals_1.ControlState.Print) {
                var showHelp = $("<a href='https://" + settings.parameter.externalHelp + "' target='_blank'> <span class='fa fa-info-circle'></span></a>");
                helpline.append(showHelp);
            }
            if (settings.parameter.popupHelp && settings.controlState !== globals_1.ControlState.Print) {
                var showHelp = $("<span class='fa fa-question-circle showMore' style='padding-left:10px'></span>");
                showHelp.tooltip({
                    html: true,
                    title: settings.parameter.popupHelp,
                    container: 'body',
                    template: '<div class="tooltip smarttext-tooltip" role="tooltip"><div class="tooltip-arrow smarttext-tooltip-arrow"></div><div class="tooltip-inner smarttext-tooltip-inner"></div></div>'
                });
                helpline.append(showHelp);
            }
            if (settings.parameter.inlineHelp && settings.controlState !== globals_1.ControlState.Print) {
                var showHelp = $("<div class='inlineHelp'>");
                showHelp.html(settings.parameter.inlineHelp);
                helpline.append(showHelp);
            }
            return helpline;
        }
    }
    exports.BaseControl = BaseControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 32 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// example generation of json schema from typescript type
// 
//  typescript-json-schema web/ts/ProjectSettings.ts ITestConfig > test.txt
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ACL_SETTING = exports.defaultNotificationConfig = exports.notificationSetting = exports.autoColumnDefault = exports.autoColumnSetting = exports.smartTextConfigSetting = exports.mailConfigSetting = exports.qmsDefaultConfig = exports.EnumItemPublish = void 0;
    // *******************************
    // qms configuration        
    // *******************************
    var EnumItemPublish;
    (function (EnumItemPublish) {
        EnumItemPublish[EnumItemPublish["IfNotInGroup"] = 0] = "IfNotInGroup";
        EnumItemPublish[EnumItemPublish["Always"] = 1] = "Always";
        EnumItemPublish[EnumItemPublish["Never"] = 2] = "Never"; // items cannot be published by itself 
    })(EnumItemPublish || (EnumItemPublish = {}));
    exports.EnumItemPublish = EnumItemPublish;
    const qmsDefaultConfig = {
        publications: [{
                rules: [
                    {
                        category: "PROC",
                        readyLabels: ["PROCOK"],
                        itemRules: EnumItemPublish.IfNotInGroup,
                        groupName: "SOP",
                        groupLabelType: "SOPS",
                        groupDown: ["WI"]
                    },
                    {
                        category: "WI",
                        readyLabels: ["WIOK"],
                        itemRules: EnumItemPublish.IfNotInGroup,
                    }
                ],
                toCategory: "PUB",
                target: "pub",
                keepFlatList: false,
                publisher: "_" // comma separated list of publishers _ for legacy: look in category setting for PUB,
            }
        ],
        legacyRoles: false // use user groups 
    };
    exports.qmsDefaultConfig = qmsDefaultConfig;
    // *******************************
    // mail config
    // *******************************
    const mailConfigSetting = "mail_config";
    exports.mailConfigSetting = mailConfigSetting;
    // ******************************* 
    // ACL user access lists
    // *******************************
    const ACL_SETTING = "acl";
    exports.ACL_SETTING = ACL_SETTING;
    // *******************************
    // smart text , abbreviations, ....
    // *******************************
    const smartTextConfigSetting = "rtf";
    exports.smartTextConfigSetting = smartTextConfigSetting;
    let notificationSetting = "settingsNotification";
    exports.notificationSetting = notificationSetting;
    let defaultNotificationConfig = {
        enabled: true,
        closeAuto: true,
        manualCreate: true,
        browserNotificationDisabled: false,
        browserNotificationAutoCloseAfter: 9000
    };
    exports.defaultNotificationConfig = defaultNotificationConfig;
    // setting can be for customer (e.g. user titles) and project (user roles)
    const autoColumnSetting = "autoColumn";
    exports.autoColumnSetting = autoColumnSetting;
    const autoColumnDefault = { maps: [] };
    exports.autoColumnDefault = autoColumnDefault;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 33 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(4), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, index_1, RefLinkDefines_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    $.fn.refLink = function (options) {
        let component = new RefLink(this, options);
        this.destroy = () => component.destroy();
        this.getValue = () => component.getValue();
        return this;
    };
    class RefLink {
        constructor(control, options) {
            let that = this;
            this.settings = options;
            // defaults
            this.settings.style = (typeof this.settings.style === 'undefined') ? RefLinkDefines_1.refLinkStyle.show : this.settings.style;
            this.settings.tooltip = (typeof this.settings.tooltip === 'undefined') ? RefLinkDefines_1.refLinkTooltip.none : this.settings.tooltip;
            this.settings.validate = (typeof this.settings.validate === 'undefined') ? true : this.settings.validate;
            this.newTitle = this.settings.title;
            var title = this.settings.title;
            var isFolderLink = (typeof this.settings.folder !== 'undefined' && this.settings.folder);
            var key = this.settings.id; // key without revision
            if (localStorage.getItem('matixShowVersionInId') === 'true') {
                var versionPos = key.indexOf("-v");
                if (versionPos !== -1) {
                    key = key.substring(0, versionPos);
                }
            }
            var linkId = "<span class='" + (this.settings.isHidden ? "refId greyRefIdHyper" : "refId refIdHyper") + "'>" + (isFolderLink ? "" : key) + "</span>";
            let style = this.settings.css ? (" style='" + this.settings.css + "'") : "";
            var linkTitle = "<span class='key-" + key + " " + (this.settings.isHidden ? "refTitle greyTitle" : "refTitle") + "'" + style + ">" + title + "</span> ";
            if (key && key[0] === "-") {
                // special node, e.g. Deleted Items
                linkId = "";
                linkTitle = "<span class='refTitleSpecial'>" + title + "</span> ";
            }
            var theTitle = $(linkTitle);
            if (this.settings.hideTitle) {
                theTitle.hide();
            }
            var ttpart = $("");
            if (this.settings.style === RefLinkDefines_1.refLinkStyle.link) {
                ttpart = $("<a>" + linkId + "</a>").attr("href", globals_1.app.createItemUrl(this.settings.id, this.settings.crossProject)).attr('target', '_blank');
                control.html("").append(ttpart).append(theTitle);
            }
            if (this.settings.style === RefLinkDefines_1.refLinkStyle.selectTree) {
                ttpart = $("<a>" + linkId + "</a>").css("cursor", "pointer");
                ttpart.off("click").click(function (evt) {
                    if (evt.ctrlKey || evt.metaKey) {
                        var win = window.open(globals_1.app.createItemUrl(that.settings.id), '_blank');
                        if (win) {
                            //Browser has allowed it to be opened
                            win.focus();
                        }
                        else {
                            //Browser has blocked it
                            alert('Please allow popups for this site');
                        }
                        if (evt.preventDefault)
                            evt.preventDefault();
                        if (evt.stopPropagation)
                            evt.stopPropagation();
                    }
                    else {
                        return globals_1.app.treeSelectionChangeAsync(that.settings.id);
                    }
                });
                control.html("").append(ttpart).append(theTitle);
            }
            else if (this.settings.style === RefLinkDefines_1.refLinkStyle.edit) {
                this.lineEditor = theTitle.editable({
                    mode: 'inline',
                    onblur: 'submit',
                    placeholder: that.settings.placeholder,
                    clear: false,
                    showbuttons: false,
                    validate: function (value) {
                        if ($.trim(value) == '' && that.settings.validate && $(this).css("display") != "none") {
                            if (that.settings.callback) {
                                that.settings.callback.apply(null, [that.settings.id, ""]);
                            }
                            return { msg: 'title required!', newValue: '', activate: false };
                        }
                    },
                    success: function (response, newValue) {
                        if (that.settings.callback) {
                            let text = new index_1.HTMLCleaner(newValue, true).getClean(index_1.HTMLCleaner.CleanLevel.Basic);
                            that.settings.callback.apply(null, [that.settings.id, text]);
                        }
                    }
                });
                ttpart = $(linkId);
                this.lineEditor.on('shown', function (event) {
                    if (that.settings.callback && that.settings.validate) {
                        $(event.delegateTarget).data('editable').input.$input.on('keyup', function (e) {
                            that.newTitle = $(e.delegateTarget).val();
                            that.settings.callback.apply(null, [that.settings.id, that.newTitle]);
                        });
                    }
                });
                control.html("").append(ttpart).append(this.lineEditor);
            }
            else if (this.settings.style === RefLinkDefines_1.refLinkStyle.show) {
                ttpart = $(linkId);
                control.html("").append(ttpart).append(theTitle);
                if (this.settings.callback) {
                    control.off("click").click(function (evt) {
                        if (evt.ctrlKey || evt.metaKey) {
                            var win = window.open(globals_1.app.createItemUrl(that.settings.id, that.settings.crossProject), '_blank');
                            if (win) {
                                //Browser has allowed it to be opened
                                win.focus();
                            }
                            else {
                                //Browser has blocked it
                                alert('Please allow popups for this site');
                            }
                            if (evt.preventDefault)
                                evt.preventDefault();
                            if (evt.stopPropagation)
                                evt.stopPropagation();
                        }
                        else {
                            return that.settings.callback.apply(null, [that.settings.id]);
                        }
                    });
                }
            }
            else if (this.settings.style === RefLinkDefines_1.refLinkStyle.select) {
                ttpart = $("<span class='" + (this.settings.isHidden ? "refId greyRefIdHyper" : "refId refIdHyper") + "'>" + key + "</span>");
                control.html("").append(ttpart).append(theTitle);
                if (this.settings.callback) {
                    ttpart.off("click").click(function (evt) {
                        if (evt.ctrlKey || evt.metaKey) {
                            var win = window.open(globals_1.app.createItemUrl(that.settings.id), '_blank');
                            if (win) {
                                //Browser has allowed it to be opened
                                win.focus();
                            }
                            else {
                                //Browser has blocked it
                                alert('Please allow popups for this site');
                            }
                        }
                        else {
                            return that.settings.callback.apply(null, [that.settings.id]);
                        }
                    });
                }
            }
            if (this.settings.tooltip === RefLinkDefines_1.refLinkTooltip.html &&
                that.settings.id.indexOf("-") != 0 &&
                globals_1.app.getType(that.settings.id)[0] != "_" &&
                !globals_1.app.isFolder(that.settings.id) &&
                globals_1.app.getCurrentItemId() != that.settings.id) {
                ttpart.data("tooltip", "popover").data("placement", "bottom");
                ttpart.tooltip({ title: "hold shift to see a preview", trigger: '', container: "body" });
                ttpart.on('mouseover', function (event) {
                    if (!globalThis.globalMouseDown) {
                        matrixlib_1.ml.UI.showTooltip(that.settings.id, $(event.delegateTarget), event, that.settings.crossProject);
                        ttpart.tooltip('show');
                        // and hide after a second
                        setTimeout(function () {
                            ttpart.tooltip('hide');
                            $(".tooltip.fade").remove(); // the hiding is really not working well
                        }, 1000);
                    }
                    else {
                        ttpart.tooltip('hide');
                    }
                });
                ttpart.on('mouseleave', function () {
                    matrixlib_1.ml.UI.hideTooltip();
                    ttpart.tooltip('hide');
                });
                ttpart.on('mousedown', function () {
                    matrixlib_1.ml.UI.hideTooltip(true);
                    ttpart.tooltip('hide');
                });
            }
        }
        getValue() {
            return this.newTitle;
        }
        destroy() {
            if (this.lineEditor) {
                this.lineEditor.off();
                this.lineEditor.editable('destroy');
            }
            if (this.ttpart) {
                this.ttpart.off();
            }
        }
    }
    globalThis.globalMouseDown = false;
    $(document).mousedown(function () {
        globalThis.globalMouseDown = true;
    }).mouseup(function () {
        globalThis.globalMouseDown = false;
    });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 34 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(1), __webpack_require__(6), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, matrixlib_1, globals_1, Notifications_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.initialize = exports.Cleanup = void 0;
    class Cleanup {
        constructor() {
            // ****************************************
            // standard plugin interface
            // ****************************************
            this.isDefault = true;
        }
        initItem(_item, _jui) {
            this.item = _item;
            this.jui = _jui;
        }
        initServerSettings(serverSettings) {
        }
        updateMenu(ul, hook) {
            return;
        }
        supportsControl(ctrlType) {
            return false;
        }
        createControl(ctrl, options) {
        }
        initProject() {
        }
        // project pages show in the top in Projects, Reports and Documents
        getProjectPages() {
            let that = this;
            var pages = [];
            let extras = globals_1.globalMatrix.ItemConfig.getExtrasConfig();
            if (extras && matrixlib_1.ml.JSON.isTrue(extras.cleanup)) {
                pages.push({ id: "CLEANUP", title: "technical verification of project", folder: "TOOLS", order: 1000, icon: "fal fa-washer", usesFilters: true, render: (options) => that.renderProjectPage(options) });
            }
            return pages;
        }
        // ****************************************
        // Misc functions called by task control  
        // to create / refresh UI components
        // ****************************************
        renderProjectPage(options) {
            let that = this;
            $("#globalProjectFilter >> button").removeAttr("disabled");
            let cleanUpTasks = $("<ul style='margin-top:6px'>");
            matrixlib_1.ml.UI.getPageTitle("Cleanup").appendTo(options.control);
            let page = $('<div class="panel-body-v-scroll fillHeight" style="padding:12px">').appendTo(options.control);
            $("<button title class='btn btn-success hidden-print'>Find zombie smart links</button>")
                .appendTo(page)
                .click(function () {
                cleanUpTasks.html("").append(matrixlib_1.ml.UI.getSpinningWait("finding zombie links"));
                that.runCleanupSmartZombies(cleanUpTasks);
            });
            $("<button style='margin-left:12px' title class='btn btn-success hidden-print'>Find zombie images</button>")
                .appendTo(page)
                .click(function () {
                cleanUpTasks.html("").append(matrixlib_1.ml.UI.getSpinningWait("finding zombie links"));
                that.runCleanupImageZombies(cleanUpTasks);
            });
            $("<button style='margin-left:12px' title class='btn btn-success hidden-print'>Find invalid characters</button>")
                .appendTo(page)
                .click(function () {
                cleanUpTasks.html("").append(matrixlib_1.ml.UI.getSpinningWait("finding invalid characters"));
                that.runCleanupCharacters(cleanUpTasks);
            });
            let results = $("<div style='padding-top:6px'>").appendTo(page);
            results.append("<p><b>Zombie smart links</b> are smart links which point to items which done exist (anymore).</p>");
            results.append("<p><b>Zombie images</b> are images which are on a third party server. These are problematic, because during the report generation, our server might not have the right to access these, so they will be missing in the generated documents.</p>");
            results.append("<p><b>Invalid characters</b> are characters which cannot be printed. In case data gets imported (maybe through the api or excel), some items might these unprintable characters and printing will fail.</p>");
            results.append(cleanUpTasks).appendTo(page);
        }
        runCleanupSmartZombies(cleanUpTasks) {
            let that = this;
            globals_1.restConnection.getProject("needle?search=mrql:category!=XTC&fieldsOut=*").done(function (results) {
                cleanUpTasks.html("");
                let zombies = [];
                let allItems = results.needles.map(function (needle) { return matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id; });
                let allFolders = that.getFolders(globals_1.app.getTree());
                let all = allItems.concat(allFolders).concat(globals_1.app.getItemTitle("F-XTC-1") ? globals_1.app.getChildrenIdsRec("F-XTC-1") : []);
                $.each(results.needles, function (idx, needle) {
                    let item = matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id;
                    let smartLinks = that.getSmartLinks(needle);
                    if (smartLinks) {
                        $.each(smartLinks, function (fsl, sl) {
                            if (all.indexOf(sl) == -1) {
                                console.log("zombie: " + sl + " in id " + item);
                                let parsed = matrixlib_1.ml.Item.parseRef(sl);
                                let first = (parsed.isFolder ? "F-" : "") + parsed.type;
                                cleanUpTasks.append("<li>" + item + " has a zombie link to <span>" + first + "-</span>" + parsed.number + "</li>");
                                zombies.push({ from: item, to: sl });
                            }
                        });
                    }
                });
                cleanUpTasks.highlightReferences();
                if (zombies.length) {
                    matrixlib_1.ml.UI.showConfirm(-1, { title: "Found " + zombies.length + " zombie links! These are smart links which point to non existing items.", ok: "Create Notifications", nok: "Review Manually" }, () => {
                        globals_1.restConnection.getProject("todo", true).done(function (allNotifications) {
                            let oldFixIt = allNotifications.todos.filter(function (todo) {
                                if (Notifications_1.Notifications.getMessage(todo).indexOf(Cleanup.FIX_THE_ZOMBIE) != 0) {
                                    // an unrelated notification - ignore it
                                    return false;
                                }
                                for (var zidx = 0; zidx < zombies.length; zidx++) {
                                    if (zombies[zidx].from == todo.itemRef && Notifications_1.Notifications.getMessage(todo) == that.getZombieNotificationName(zombies[zidx].to)) {
                                        // there is a zombie and a notification, no need to create a new one, nor to remove  the old
                                        zombies.splice(zidx, 1);
                                        return false;
                                    }
                                }
                                ;
                                return true;
                            });
                            // now oldFixIt contains all the obsolete notifications and zombies all new ones
                            that.createSmartZombieNotifications(zombies, 0).done(function () {
                                that.removeNotifications(oldFixIt, 0);
                            });
                        });
                    }, null);
                }
                else {
                    matrixlib_1.ml.UI.showSuccess("no zombies found!");
                }
            }).fail(function () {
                matrixlib_1.ml.UI.showError("Error retrieving project data", "");
            });
        }
        // create a notification about a smart link being a zombie
        createSmartZombieNotifications(zombies, idx) {
            let res = $.Deferred();
            let that = this;
            if (zombies.length <= idx) {
                res.resolve();
                return res;
            }
            Notifications_1.NotificationList.createNotification([globals_1.matrixSession.getUser()], globals_1.matrixSession.getProject(), zombies[idx].from, that.getZombieNotificationName(zombies[idx].to), null, null).always(function () {
                that.createSmartZombieNotifications(zombies, idx + 1).always(function () {
                    res.resolve;
                });
            });
            return res;
        }
        getZombieNotificationName(itemId) {
            return Cleanup.FIX_THE_ZOMBIE + itemId;
        }
        getSmartLinks(needle) {
            if (!needle.fieldVal) {
                return null;
            }
            // define expression for smart links
            var regexstr = '((F-)*(\/)*(' + globals_1.globalMatrix.ItemConfig.getCategories(true).join("|") + ')-[0-9]+)';
            var re = new RegExp(regexstr, 'g');
            // parse fields
            var links = [];
            $.each(needle.fieldVal, function (idx, fieldVal) {
                // some fields needs to be ignored
                let fieldType = globals_1.globalMatrix.ItemConfig.getFieldById(matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).type, fieldVal.id).fieldType;
                if (fieldType == "crosslinks" || fieldType == "fileManager" || fieldType == "signCache" || fieldType == "risk2" || fieldType == "publishedItemList") {
                    return;
                }
                var match = fieldVal.value ? fieldVal.value.match(re) : null;
                if (match) {
                    $.each(match, function (midx, m) {
                        if (m.indexOf("/") == 0)
                            return; // folder or cross project are not yet supported
                        if (links.indexOf(m) === -1) {
                            links.push(m);
                        }
                    });
                }
            });
            return links;
        }
        runCleanupImageZombies(cleanUpTasks) {
            let that = this;
            globals_1.restConnection.getProject("needle?search=mrql:category!=XXXXXX&fieldsOut=*").done(function (results) {
                cleanUpTasks.html("");
                let zombies = [];
                $.each(results.needles, function (idx, needle) {
                    let item = matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id;
                    let imageLinks = that.getImages(needle);
                    if (imageLinks) {
                        $.each(imageLinks, function (fsl, sl) {
                            console.log("zombie: " + sl + " in id " + item);
                            cleanUpTasks.append("<li>" + item + " has a zombie image '<span>" + sl + "'</li>");
                            zombies.push({ from: item, to: sl });
                        });
                    }
                });
                $("img", cleanUpTasks).addClass("cleanupImg");
                cleanUpTasks.highlightReferences();
                if (zombies.length) {
                    matrixlib_1.ml.UI.showConfirm(-1, { title: "Found " + zombies.length + " zombie images! These are images which point to an external file server.", ok: "Create Notifications", nok: "Review Manually" }, () => {
                        globals_1.restConnection.getProject("todo", true).done(function (allNotifications) {
                            let oldFixIt = allNotifications.todos.filter(function (todo) {
                                if (Notifications_1.Notifications.getMessage(todo).indexOf(Cleanup.FIX_THE_IMAGE) != 0) {
                                    // an unrelated notification - ignore that
                                    return false;
                                }
                                for (var zidx = 0; zidx < zombies.length; zidx++) {
                                    if (zombies[zidx].from == todo.itemRef && Notifications_1.Notifications.getMessage(todo) == that.getZombieImageName(zombies[zidx].to)) {
                                        // there is a zombie and a notification, no need to create a new one, nor to remove  the old
                                        zombies.splice(zidx, 1);
                                        return false;
                                    }
                                }
                                ;
                                return true;
                            });
                            // now oldFixIt contains all the obsolete notifications and zombies all new ones
                            that.createImageZombieNotifications(zombies, 0).done(function () {
                                that.removeNotifications(oldFixIt, 0);
                            });
                        });
                    }, null);
                }
                else {
                    matrixlib_1.ml.UI.showSuccess("no zombies found!");
                }
            }).fail(function () {
                matrixlib_1.ml.UI.showError("Error retrieving project data", "");
            });
        }
        // create a notification about a smart link being a zombie
        createImageZombieNotifications(zombies, idx) {
            let res = $.Deferred();
            let that = this;
            if (zombies.length <= idx) {
                res.resolve();
                return res;
            }
            Notifications_1.NotificationList.createNotification([globals_1.matrixSession.getUser()], globals_1.matrixSession.getProject(), zombies[idx].from, that.getZombieImageName(zombies[idx].to), null, null).always(function () {
                that.createSmartZombieNotifications(zombies, idx + 1).always(function () {
                    res.resolve;
                });
            });
            return res;
        }
        getZombieImageName(link) {
            return Cleanup.FIX_THE_IMAGE;
        }
        removeNotifications(oldFixIt, idx) {
            let that = this;
            if (oldFixIt.length <= idx) {
                return;
            }
            Notifications_1.NotificationList.deleteNotification(oldFixIt[idx]).always(function () {
                that.removeNotifications(oldFixIt, idx + 1);
            });
        }
        getFolders(tree) {
            let that = this;
            let folders = [];
            $.each(tree, function (idx, folderOrItem) {
                if (folderOrItem.children) {
                    folders.push(folderOrItem.id);
                    folders = folders.concat(that.getFolders(folderOrItem.children));
                }
            });
            return folders;
        }
        // image links
        getImages(needle) {
            if (!needle.fieldVal) {
                return null;
            }
            // define expression for smart links
            let quote = "['" + '"]+';
            let regexstr = '<img.*?src.*?=.*?' + quote + '.*?' + quote + '.*?>';
            let re = new RegExp(regexstr, 'g');
            // parse fields
            var links = [];
            $.each(needle.fieldVal, function (idx, fieldVal) {
                var match = fieldVal.value ? fieldVal.value.match(re) : null;
                if (match) {
                    $.each(match, function (midx, m) {
                        if (m.indexOf(globals_1.globalMatrix.matrixBaseUrl) != -1)
                            return; // local - no issue
                        if (m.indexOf("data:image") != -1)
                            return; // embedded no issue
                        if (links.indexOf(m) == -1)
                            links.push(m.replace(/\\"/g, '"'));
                    });
                }
            });
            return links;
        }
        /*****************************************
         *
         * invalid xml characters
         *
        */
        async runCleanupCharacters(cleanUpTasks) {
            let that = this;
            cleanUpTasks.html("");
            for (let category of globals_1.globalMatrix.ItemConfig.getCategories(true)) {
                let line = $(`<li>Testing category: ${category}</li>`).appendTo(cleanUpTasks);
                let xmlCharIssues = [];
                let results = await globals_1.restConnection.getProject(`needle?search=mrql:category=${category}&fieldsOut=*`);
                for (let needle of results.needles) {
                    let itemId = matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id;
                    for (let fieldVal of needle.fieldVal) {
                        that.testXML(xmlCharIssues, itemId, fieldVal.id, JSON.stringify(fieldVal.value));
                    }
                    that.testXML(xmlCharIssues, itemId, 0, needle.title);
                }
                if (xmlCharIssues.length == 0) {
                    line.append("<span> - no issues found</span>");
                }
                for (let issue of xmlCharIssues) {
                    cleanUpTasks.append("<li>" + matrixlib_1.ml.Item.parseRef(issue.itemId).link + " has an issue " + issue.details + "</li>");
                }
            }
        }
        static textOk(fieldVal) {
            if (!fieldVal) {
                return true;
            }
            let text = typeof fieldVal == "string" ? fieldVal : JSON.stringify(fieldVal);
            for (var j = 0; j < Cleanup.badEncodedChars.length; j++) {
                let matches = text.match(Cleanup.badEncodedChars[j]);
                if (matches) {
                    return false;
                }
            }
            return true;
        }
        testXML(xmlCharIssues, itemId, fieldId, fieldVal) {
            for (var j = 0; j < Cleanup.badEncodedChars.length; j++) {
                if (fieldVal) {
                    let matches = fieldVal.match(Cleanup.badEncodedChars[j]);
                    if (!matches) {
                        try {
                            let parsed = JSON.parse(fieldVal);
                            matches = parsed.match(Cleanup.badEncodedChars[j]);
                        }
                        catch (e) {
                            // not sire
                        }
                    }
                    if (matches) {
                        let pos = matches["index"] - 10;
                        let cat = matrixlib_1.ml.Item.parseRef(itemId).type;
                        let fieldName = fieldId > 0 ? globals_1.globalMatrix.ItemConfig.getFieldById(cat, fieldId).label : "title";
                        xmlCharIssues.push({ itemId: itemId, details: "field:'" + fieldName + "' pos:" + matches["index"] + " char:" + matches[0] + " near: " + fieldVal.substr(pos < 0 ? 0 : pos, 20) });
                    }
                }
            }
        }
    }
    exports.Cleanup = Cleanup;
    Cleanup.FIX_THE_ZOMBIE = "Fix the zombie link to ";
    Cleanup.FIX_THE_IMAGE = "Fix the zombie image ";
    Cleanup.FIX_INVALID_XML = "Find invalid xml";
    Cleanup.badEncodedChars = [
        // ok: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
        "[\x00-\x08]",
        // OK: #x9 | #xA 
        "[\x0B-\x0C]",
        // OK: #xD  
        "[\x0E-\x1F]",
        // OK: [#x20-#xD7FF] 
        "[\uD800-\uDFFF]",
        // OK: [#xE000-#xFFFD] 
        "[\uFFFE-\uFFFF]",
        // some bad html characters NOT USED https://www.w3schools.com/tags/ref_charactersets.asp
        String.fromCharCode(129),
        String.fromCharCode(141),
        String.fromCharCode(143),
        String.fromCharCode(144),
        String.fromCharCode(157),
    ];
    // register the engine as plugin
    function initialize() {
        let mCleanup = new Cleanup();
        index_1.plugins.register(mCleanup);
    }
    exports.initialize = initialize;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 35 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(12), __webpack_require__(3), __webpack_require__(4), __webpack_require__(31), __webpack_require__(36), __webpack_require__(1), __webpack_require__(10), __webpack_require__(43), __webpack_require__(44), __webpack_require__(12), __webpack_require__(12), __webpack_require__(12), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, index_1, MatrixLibInterfaces_1, index_2, BaseControl_1, markAsTemplate_1, matrixlib_1, RefLinkDefines_1, ItemHistoryView_1, ItemReferenceView_1, index_3, index_4, index_5, ComponentImport_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.TitleToolbarImpl = void 0;
    $.fn.titleToolbar = function (options) {
        let baseControl = new TitleToolbarImpl(this);
        this.getController = () => { return baseControl; };
        baseControl.init(options);
        return this;
    };
    class TitleToolbarImpl extends BaseControl_1.BaseControl {
        constructor(control) {
            super(control);
        }
        init(options) {
            let that = this;
            this._refDlgIcon = null;
            var defaultOptions = {
                id: "",
                title: "",
                controlState: globals_1.ControlState.FormView,
                dummyData: false,
                valueChanged: function () {
                },
                canEdit: false,
                canEditTitle: false,
                canDelete: false,
                validate: true,
                parameter: {
                    readonly: false,
                    placeholder: "enter title"
                }
            };
            this.isInHiddenMode = false;
            this.settings = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, options);
            this.warnedAboutOutOfDate = false;
            var showTools = this.settings.controlState === globals_1.ControlState.FormEdit || this.settings.controlState === globals_1.ControlState.FormView;
            var title = this.settings.title;
            if (this.settings.controlState === globals_1.ControlState.DialogCreate) {
                this._root.append($("<span class='pull-left baseControlHelp itemTitleDemand'>" + this.settings.help + "</span>"));
            }
            else {
                this._root.append($("<div class='pull-left itemViewers'>"));
            }
            this._root.data("original", this.settings.title);
            this._root.data("new", this.settings.title);
            // create title bar
            if (showTools) {
                this._root.addClass("itemTitleBar");
            }
            else if (this.settings.canEdit) {
                this._root.addClass("itemTitleBarNoTools");
            }
            else {
                this._root.addClass("itemTitleBarNoToolsNoEdit");
            }
            this.link = $("<div>").refLink({
                folder: false,
                placeholder: this.settings.parameter.placeholder,
                id: this.settings.id,
                title: title,
                style: ((this.settings.canEdit && this.settings.canEditTitle) ? RefLinkDefines_1.refLinkStyle.edit : RefLinkDefines_1.refLinkStyle.link),
                tooltip: RefLinkDefines_1.refLinkTooltip.none,
                callback: function (id, newText) {
                    if (!that.isInHiddenMode) {
                        if (that.settings.type == "DOC" && newText.indexOf("\\") != -1) {
                            matrixlib_1.ml.UI.showError("Invalid character in DOC title", "backslashes are not allowed!");
                        }
                        that._root.data("new", newText);
                        if (that.settings.valueChanged) {
                            that.settings.valueChanged.apply(null);
                        }
                    }
                },
                validate: this.settings.validate
            });
            $(".refId", this.link).click(function () {
                if (that.settings.controlState != globals_1.ControlState.FormEdit && that.settings.controlState != globals_1.ControlState.FormView) {
                    // nothing to show
                    return;
                }
                else if (matrixlib_1.ml.Item.parseRef(that.settings.id).isFolder) {
                    return;
                }
                else {
                    let currentPanel = globals_1.matrixApplicationUI.currentPanel;
                    if (currentPanel.toggleZen) {
                        currentPanel.toggleZen();
                    }
                }
            });
            this.showOutOfDateIcon();
            this.link.addClass('itemTitle pull-left');
            if (this.settings.locked) {
                let labelTools = new index_2.LabelTools();
                let dn = labelTools.getDisplayName(this.settings.locked);
                let lockedBy = $("<span class='lockedItem'>").html("(locked)");
                // tooltip with info why it is locked and how it can be unlocked
                this.link.append(lockedBy);
                let tooltip = "Locked by label '" + this.settings.locked + (dn ? (": " + dn) : "") + "'";
                tooltip += this.settings.unlockers ? (". Can be unlocked by: " + this.settings.unlockers + ".") : ". Cannot be unlocked in UI.";
                lockedBy.tooltip({ title: tooltip, placement: "bottom" });
            }
            this._root.append(this.link);
            if (this.settings.controlState === globals_1.ControlState.DialogCreate && !this.settings.noAutoActivation) {
                setTimeout(function () {
                    $(".refTitle", that.link).click();
                }, 500);
            }
            $(this._root).on('focusout.editable', function (e) {
                $('.editable-open').parent().find("form").trigger('submit');
                console.log("title submitted");
            });
            if (showTools) { // add titlebar tools
                var itemTools = $("<div class='pull-right hidden-print tools-pull-right'></div>");
                this._root.append(itemTools);
                var miTouch = $('<li title="Create new version of item"><a href="javascript:void(0)" id="toolTouch">Touch</a></li>').click(function () {
                    globals_1.app.touchAsync(that.settings.id, 1);
                });
                var bShare = $('<div class="btn-group">' +
                    ' <button id="shareButton"  tabindex="-1" type="button" title data-original-title="Tools" data-toggle="dropdown" class="btn btn-item btn-sm dropdown-toggle">' +
                    '<span class="fal fa-share"></span>  <span class="caret"></span></button>' +
                    ' <ul class="sharemenu dropdown-menu dropdown-menu-sub pull-right" role="menu">' +
                    ' </ul>' +
                    '</div>');
                var bShareMenu = $('ul', bShare);
                var extras = globals_1.globalMatrix.ItemConfig.getExtrasConfig();
                if (!this.settings.locked && !this.settings.isFolder && globals_1.app.touchToolAvailable(this.settings.item) && (!extras || !matrixlib_1.ml.JSON.isTrue(extras.noTouch))) {
                    bShareMenu.append(miTouch);
                }
                if (!index_4.mDHF.isDocumentType(this.settings.type)) {
                    if (globals_1.matrixSession.getUISettings().legacyPrint) {
                        var miPrint = $('<li title="prepare to print"><a href="javascript:void(0)">Print</a></li>').click(function () {
                            globals_1.app.print();
                        });
                        bShareMenu.append(miPrint);
                    }
                }
                if (globals_1.app.mailToolAvailable()) {
                    var miMail = $('<li class="mailMenu"><a id="toolSendTo" href="javascript:void(0)">Send link by mail</a></li>');
                    miMail.click(function (event) {
                        var itemId = globals_1.app.getCurrentItemId();
                        var message = matrixlib_1.ml.Mail.getCannedMessage("link", "", itemId);
                        matrixlib_1.ml.Mail.sendMailDlg("", null, itemId, message, "");
                    });
                    bShareMenu.append(miMail);
                }
                else {
                    var miMail = $('<li class="mailMenu"><a href="mailto:?subject=' + this.settings.id + '&amp;body=' + location + '">Email</a></li>');
                    bShareMenu.append(miMail);
                }
                var labelTools = $('<div class="labelTools">');
                if (globals_1.globalMatrix.ItemConfig.getLabelsConfig() && globals_1.globalMatrix.ItemConfig.getLabelsConfig().useLabelBar) {
                    let labelBar = $("<div class='labelBar'>");
                    this._root.after(labelBar);
                    labelBar.append(labelTools);
                }
                else {
                    itemTools.after(labelTools);
                }
                var workflowTools = $('<div class="btn-group workflowTools">');
                itemTools.append(workflowTools);
                itemTools.append(bShare);
                if (!this.settings.isFolder && (globals_1.app.hasLinks(this.settings.item) || (index_3.mTM.getCloneSources() && index_3.mTM.getCloneSources().indexOf(this.settings.type) != -1))) {
                    this._refDlgIcon = $('<i class="fal fa-sitemap" aria-hidden="true" style="font-size:larger;">');
                    var refDlgButton = $("<button id='referenceToolBtn' tabindex='-1' title data-original-title='References' class='btn btn-item'>").append(this._refDlgIcon);
                    var refDlgGroup = $("<div class='btn-group'>").append(refDlgButton).click(function () {
                        var rt = new ItemReferenceView_1.ReferenceTools();
                        rt.showReferenceDialog({ item: that.settings.item, canEdit: that.settings.canEdit });
                    });
                    itemTools.append(refDlgGroup);
                    this.updateItem();
                }
                if (!this.settings.isFolder) {
                    // there is no easy way to get history of folder
                    var historyTools = new ItemHistoryView_1.HistoryTools();
                    historyTools.renderButtons({
                        control: itemTools,
                        id: this.settings.id,
                        isFolder: this.settings.isFolder,
                        item: this.settings.item,
                        readOnly: !this.settings.canEdit
                    });
                    let importSource = globals_1.app.getImportSource(this.settings.item);
                    if (importSource) {
                        let sourceInfo = (importSource.relation == ComponentImport_1.EImportMode.Include ? "included from " : "copied from ") + importSource.downItem.projectShort + "/" + importSource.downItem.itemRefWithVersion;
                        let sourceLink = $(`<div  class='btn-group'><button id='originalItemBtn' tabindex='-1' title data-original-title='${sourceInfo}' class='btn btn-item'> <span class='fal fa-external-link-alt'></span></button></div>`);
                        sourceLink.click(() => window.open(globals_1.globalMatrix.matrixBaseUrl + "/" + importSource.downItem.projectShort + "/" + importSource.downItem.itemRefWithVersion.split("-v")[0]));
                        itemTools.append(sourceLink);
                    }
                    let usedBy = globals_1.app.getUsedBy(this.settings.item);
                    if (usedBy) {
                        let linkList = $("<ul>");
                        for (let useByLink of usedBy) {
                            let targetType = useByLink.relation == ComponentImport_1.EImportMode.Include ? "included as" : "copied as";
                            let targetInfo = useByLink.upItem.projectShort + "/" + useByLink.upItem.itemRefWithVersion;
                            $(`<li>${targetType} <span data-target='${targetInfo.split("-v")[0]}' class='refIdHyper includedLink'>${targetInfo}</span></li>`).appendTo(linkList);
                        }
                        let targetLink = $(`<div  class='btn-group'><button id='originalItemBtn' tabindex='-1' title data-original-title='used by' class='btn btn-item'> <span class='fal fa-external-link-square-alt'></span></button></div>`);
                        itemTools.append(targetLink);
                        targetLink.click(() => {
                            let usedByDlg = $("<div>").appendTo($("body"));
                            matrixlib_1.ml.UI.showDialog(usedByDlg, "Item used by", linkList, 300, 200, [{
                                    text: "Close",
                                    class: 'btnDoIt',
                                    click: function () {
                                        usedByDlg.dialog("close");
                                    }
                                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => {
                                usedByDlg.remove();
                            }, () => {
                                $(".includedLink", linkList).click((e) => {
                                    window.open(globals_1.globalMatrix.matrixBaseUrl + "/" + $(e.delegateTarget).data("target"));
                                });
                            }, () => { });
                        });
                    }
                }
                // moved after adding history (for jobs plugin to be able to remove it;-)
                index_5.plugins.updateMenu(index_5.pluginHooks.shares, bShareMenu);
                let itemParsed = matrixlib_1.ml.Item.parseRef(this.settings.item.id);
                let root = itemParsed.number == 1 && itemParsed.isFolder;
                if (this.settings.canEdit && globals_1.app.canDeleteItem(this.settings.item) && !root) {
                    var bDelete = $("<div  class='btn-group'><button title data-original-title='Delete' class='btn btn-item deleteItemBtn' tabindex='-1'> <span class='fal fa-trash-alt'></span></button></div>").click(function () {
                        var whatToDelete = that.settings.id;
                        index_1.MR1.triggerBeforeDeleteAsync(that.settings.item).done(function () {
                            let isTemplate = index_4.mDHF.isUsedAsTemplate(that.settings.item.id);
                            let message = isTemplate ?
                                (that.settings.item.id + " is used as template. Deleting will also remove the templates!")
                                : ("Delete '" + that.settings.item.id + " " + title + " '?");
                            let ok = isTemplate ?
                                ("Delete and remove templates")
                                : ("Delete");
                            matrixlib_1.ml.UI.showConfirm(1, { title: message, ok: ok }, function () {
                                let deletedItems = globals_1.app.getChildrenIdsRec(whatToDelete);
                                globals_1.app.deleteItem(whatToDelete).done(function () {
                                    markAsTemplate_1.MarkAsTemplateImpl.removeFromTemplates(deletedItems);
                                    index_1.MR1.triggerAfterDelete(that.settings.item);
                                    if (isTemplate) {
                                        index_4.mDHF.removeAsTemplate(that.settings.item.id);
                                    }
                                });
                            }, function () {
                            });
                        }).fail(function () {
                            matrixlib_1.ml.Logger.log("warn", "delete cancelled using MR1");
                        });
                    });
                    itemTools.append(bDelete);
                }
                itemTools.append(matrixlib_1.ml.ContextFrames.getExpender());
                $("button", itemTools).tooltip({ placement: "bottom" });
            }
        }
        // public interface
        hasChanged() {
            return this._root.data("original") !== this._root.data("new");
        }
        getValue() {
            return this._root.data("new");
        }
        setValue(newTitle, fireUpdate) {
            this._root.data("new", newTitle);
            this._root.find("input").val(newTitle);
            this._root.find(".refTitle").html(newTitle);
            if (fireUpdate && this.settings.valueChanged) {
                this.settings.valueChanged.apply(null);
            }
        }
        getText() { }
        getValueRaw() { }
        titleCreationMode() {
            // special mode where control is hidden and used by report generator to set the value
            this._root.hide();
            this.isInHiddenMode = true;
        }
        destroy() {
            if (this.link) {
                this.link.destroy();
            }
        }
        resizeItem() {
        }
        setViewers(viewers) {
            let that = this;
            if (viewers.item !== this.settings.item.id) {
                // that can happen 
                // e.g. if use changes item and does not type for a while, the old item will be pinged
                return;
            }
            $(".itemViewers", this._root).html("");
            let ignoredFirstMe = false;
            let otherEditor = (viewers.editor && !viewers.editor.thisSocket) ? viewers.editor.user : "";
            if (viewers.editor && this.settings.type != "XTC" && this.settings.type != "SIGN") {
                $("#thisItemIsDated").hide();
            }
            else {
                $("#thisItemIsDated").show();
            }
            $.each(viewers.users, function (vidx, viewer) {
                if (viewer == globals_1.matrixSession.getUser() && !ignoredFirstMe) {
                    // I myself appear at most once in an item
                    ignoredFirstMe = true;
                    return;
                }
                let user = globals_1.globalMatrix.ItemConfig.getUserInfo(viewer);
                if (!user) {
                    // that's a spying super user;-)
                    return;
                }
                let name = (user.firstName ? user.firstName : "") + " " + (user.lastName ? user.lastName : "");
                if (name == " ")
                    name = viewer;
                let itemAccess = "itemViewer";
                if (otherEditor == viewer) {
                    otherEditor = ""; // there can only be one
                    itemAccess = "itemEditor";
                    name += " - is editing this item";
                }
                let spanItemViewer = $("<div class='" + itemAccess + "' title='" + name + "'></div>");
                spanItemViewer.append(matrixlib_1.ml.UI.getAvatar(user.login, 23));
                $(".itemViewers", that._root).append(spanItemViewer);
            });
        }
        updateItem(newItem) {
            let that = this;
            if (newItem) {
                if (newItem.id !== this.settings.item.id) {
                    // that can happen 
                    // e.g. if use changes item and does not type for a while, the old item will be pinged
                    // console.write("newItem.id !== settings.item.id");
                    return;
                }
                if (newItem.history.length && newItem.history.length !== this.settings.item.history.length &&
                    !(newItem.history.length === this.settings.item.history.length + 1 && newItem.history[0].action === "move" && newItem.history[0].user === globals_1.matrixSession.getUser()) // no warning after simple move by this user! MATRIX-1416
                ) {
                    if (!this.warnedAboutOutOfDate) {
                        var message = "User " + newItem.history[0].user + " changed item after you loaded it <br><br> Last change at " + newItem.history[0].dateUserFormat;
                        matrixlib_1.ml.UI.showConfirm(-12, { title: message, ok: "Update to new", nok: "Keep displaying old" }, function () {
                            globals_1.app.cancel();
                        }, function () {
                            that.warnedAboutOutOfDate = true;
                            that._root.addClass("staleItem");
                            $(".itemTitle", that._root).tooltip({
                                title: message + " ",
                                placement: "right",
                                html: true,
                                template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner" style="max-width:800px"></div></div>'
                            });
                        });
                    }
                }
                this.settings.item.downLinks = newItem.downLinks;
                this.settings.item.upLinks = newItem.upLinks;
            }
            if (this._refDlgIcon) {
                var downMissing = globals_1.app.isDownLinkMissing(this.settings.item);
                var upMissing = globals_1.app.isUpLinkMissing(this.settings.item);
                this._refDlgIcon.removeClass("refGood").removeClass("refOutdated").removeClass("refMissing");
                if (upMissing || downMissing) {
                    this._refDlgIcon.addClass("refMissing");
                }
                else if (globals_1.app.isAnyLinkOutdated(this.settings.item)) {
                    this._refDlgIcon.addClass("refOutdated");
                }
                else {
                    this._refDlgIcon.addClass("refGood");
                }
            }
        }
        toggleOutOfDateIcon() {
        }
        showOutOfDateIcon() {
            let that = this;
            if (this.settings.controlState == globals_1.ControlState.FormEdit && this.settings.item && this.settings.item.history && this.settings.item.upLinks && this.settings.item.upLinks.length) {
                // check if item is potentially out of date
                let isXTCorSIGN = this.settings.type == "XTC" || this.settings.type == "SIGN";
                // for XTC take time of creation of XTC, for other the last modification time
                let thisTime = this.settings.item.history[isXTCorSIGN ? this.settings.item.history.length - 1 : 0].date;
                // get the last modification date of all parents
                let parentLastChange = new Date(this.settings.item.upLinks[0].modDate);
                for (let parent of this.settings.item.upLinks) {
                    if (new Date(parent.modDate) > parentLastChange) {
                        parentLastChange = new Date(parent.modDate);
                    }
                }
                if (new Date(thisTime) < parentLastChange) {
                    let clickToTouch = this.settings.canEdit ? " Click to touch" : "";
                    let message = isXTCorSIGN ? ("the underlying " + (this.settings.type == "XTC" ? "test" : "DOC") + " was changed after the " + this.settings.type + " was created") : ("at least one uplinked item is newer than this item." + clickToTouch);
                    let icon = $(`<span id="thisItemIsDated" class="fal fa-history datedLink" title="${message}"></span>`);
                    if (this.settings.canEdit && !isXTCorSIGN) {
                        icon.css("cursor", "pointer").click(() => {
                            globals_1.app.touchAsync(that.settings.id, 1);
                        });
                    }
                    this.link.append(icon);
                }
            }
        }
    }
    exports.TitleToolbarImpl = TitleToolbarImpl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 36 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(37)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, index_1, index_2, matrixlib_1, docSign_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.MarkAsTemplateImpl = void 0;
    $.fn.markAsTemplate = function (options) {
        let baseControl = new MarkAsTemplateImpl(this);
        this.getController = () => { return baseControl; };
        baseControl.init(options);
        return this;
    };
    class MarkAsTemplateImpl extends docSign_1.DocSignImpl {
        constructor(control) {
            super(control);
            this.publishTo = [];
        }
        formatUserLogin(userLogin) {
            return globals_1.globalMatrix.ItemConfig.hasUserInfo(userLogin)
                ? userLogin
                : `<s>${userLogin}</s>`;
        }
        init(options) {
            let that = this;
            var defaultOptions = {
                controlState: globals_1.ControlState.FormView,
                canEdit: false,
                valueChanged: function () {
                },
                parameter: {
                // item the item containing the rest of the information
                }
            };
            this.settings = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, options);
            // changes shall not overwrite other people's changes
            this.needsLatest = true;
            // get current value        
            this.originalValue = (this.settings.fieldValue ? JSON.parse(this.settings.fieldValue) : {
                signatures: []
            });
            this.newValue = matrixlib_1.ml.JSON.clone(this.originalValue);
            if (options.controlState == globals_1.ControlState.Tooltip) {
                return;
            }
            let docTypes = index_2.mDHF.getDocumentFormTypes(); // ["DOC"]
            let templateTypes = index_2.mDHF.getDocumentTemplatesTypes(); // ["SIGN"] could be ["SIGN","DOC"]
            if (docTypes.indexOf(options.type) != -1) {
                // in print version do not show anything
                if (options.controlState == globals_1.ControlState.Print) {
                    return;
                }
                // this is a DOC, user needs to decide who needs to sign the template to release it
                this.showSignatureTableEdit();
                return;
            }
            if (templateTypes.indexOf(options.type) == -1) {
                // neither a DOC not a SIGN...
                this._root.html("config error: This category cannot be used as template - contact support.");
                return;
            }
            // so this is a SIGN and it's a DOC which still exists
            let signs = this.getTemplateSignatureStatus();
            if (signs.signatures.length == 0) {
                // in print version do not show anything
                if (options.controlState == globals_1.ControlState.Print) {
                    this.hideSignatureCtrl();
                }
                // this is a normal document as SIGN .. ignore all template  stuff
                return;
            }
            // this is a SIGN or something which has been created from a DOC
            let uplinks = options.item.upLinkList ? options.item.upLinkList.filter(function (uplink) { return docTypes.indexOf(matrixlib_1.ml.Item.parseRef(uplink.itemRef).type) != -1; }) : [];
            if (uplinks && uplinks.length) {
                // this is actually a template, so the template needs approvals
                // hide signature box
                this.hideSignatureCtrl();
                // print approval box / template publishing feature
                if (signs.missingSignatures) {
                    if (this.settings.help.indexOf("|") != -1 && this.settings.help.lastIndexOf("|") != -1)
                        this.settings.help = this.getHelpPart(1) ? this.getHelpPart(1) : (this.settings.help + " - (required approvals)");
                    if (this.settings.parameter && this.settings.parameter.inlineHelp && this.settings.parameter.inlineHelp.indexOf("|") != -1) {
                        this.settings.parameter.inlineHelp = this.settings.parameter.inlineHelp.split("|")[0];
                    }
                    let help = this._root.append(super.createHelp(this.settings));
                    this.pub = $("<div class='baseControl'>").appendTo(this._root);
                    this.askForSignatures(signs);
                }
                else {
                    this.settings.help = this.getHelpPart(2) ? this.getHelpPart(2) : (this.settings.help + " - (distribution to projects)");
                    let help = this._root.append(super.createHelp(this.settings));
                    if (this.settings.parameter && this.settings.parameter.inlineHelp && this.settings.parameter.inlineHelp.indexOf("|") != -1) {
                        this.settings.parameter.inlineHelp = this.settings.parameter.inlineHelp.split("|")[0];
                    }
                    this.pub = $("<div class='baseControl'>").appendTo(this._root);
                    let vl = matrixlib_1.ml.Item.parseRef(uplinks[0].itemRef).id;
                    if (signs.signatures.length > 0) {
                        let approvedBy = $("<div class='inlineHelp approvedBy'>").appendTo(this.pub);
                        let text = "Approved by ";
                        $.each(signs.signatures, function (sidx, s) {
                            text += that.formatUserLogin(s.userid) + " (" + matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(s.signDate)) + " )" + ((sidx < signs.signatures.length - 1) ? ", " : "");
                        });
                        approvedBy.html(text);
                    }
                    if (options.controlState == globals_1.ControlState.Print) {
                        return;
                    }
                    this.showProjects(vl, options.id);
                }
            }
            else {
                let help = this._root.append(super.createHelp(this.settings));
                this.pub = $("<div class='baseControl'>").appendTo(this._root);
                this.pub.html("Cannot be used as template: underlying " + docTypes.join(",") + " has been deleted.");
            }
        }
        getHelpPart(part) {
            let parts = this.settings.help.split("|");
            return (parts.length == 3) ? parts[part] : null;
        }
        // public interface
        hasChanged() {
            return JSON.stringify(this.originalValue) != JSON.stringify(this.newValue);
        }
        getValue() {
            return JSON.stringify(this.newValue);
        }
        setValue() {
            return "";
        }
        destroy() {
        }
        resizeItem() {
        }
        static getRequiredApprovals(value) {
            let required = [];
            if (!value)
                return required;
            let jval = JSON.parse(value);
            if (!jval.signatures)
                return required;
            for (let idx = 0; idx < jval.signatures.length; idx++) {
                if (!jval.signatures[idx].datetime) {
                    required.push(jval.signatures[idx].user);
                }
            }
            return required;
        }
        static getTemplateSignatureStatus(value) {
            let signatureStatus = {
                signatures: [],
                missing: [],
                given: [],
                signatureDate: {},
                missingSignatures: 0,
                givenSignatures: 0,
                needSignature: false,
                hasSignature: false,
                isTemplate: true
            };
            if (!value)
                return signatureStatus;
            let jval = JSON.parse(value);
            if (!jval.signatures)
                return signatureStatus;
            // matrixspecs
            $.each(jval.signatures, function (key, val) {
                if (val.user) { // workaround handle existing docs with BUG MATRIX-2442 correctly
                    signatureStatus.signatures.push({ orgid: val.user, userid: val.user, signDateCustomer: matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(val.datetime)), signDate: val.datetime, signaturefileid: "" });
                    if (val.datetime) {
                        signatureStatus.given.push(val.user);
                        signatureStatus.givenSignatures++;
                        signatureStatus.hasSignature = signatureStatus.hasSignature || (val.user == globals_1.matrixSession.getUser());
                    }
                    else {
                        signatureStatus.missing.push(val.user);
                        signatureStatus.missingSignatures++;
                        signatureStatus.needSignature = signatureStatus.needSignature || (val.user == globals_1.matrixSession.getUser());
                    }
                    signatureStatus.signatureDate[val.user] = matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(val.datetime));
                }
            });
            return signatureStatus;
        }
        static removeFromTemplates(deletedItems) {
            let cached = globals_1.globalMatrix.ItemConfig.getSettingJSON(MarkAsTemplateImpl.PROJECT_SETTING);
            // check if any item is used as template if not // nothing to do
            if (!cached || !cached.templates || cached.templates.filter(function (temp) { return deletedItems.indexOf(temp.fromSign) != -1; }).length == 0) {
                return;
            }
            // get most recent setting 
            globals_1.app.readSettingJSONAsync(MarkAsTemplateImpl.PROJECT_SETTING).done(function (templates) {
                templates.templates = templates.templates.filter(function (temp) { return deletedItems.indexOf(temp.fromSign) == -1; });
                globals_1.app.setSettingJSON(MarkAsTemplateImpl.PROJECT_SETTING, templates);
            });
        }
        hideSignatureCtrl() {
            $(".ft_signatureControl").hide();
            window.setTimeout(function () {
                // just to be sure...
                $(".ft_signatureControl").hide();
            }, 100);
        }
        showProjects(sourceDoc, sourceSign) {
            let that = this;
            // get current project setting
            globals_1.app.readSettingJSONAsync(MarkAsTemplateImpl.PROJECT_SETTING).done(function (result) {
                let templates = result;
                if (!templates || !templates.templates) {
                    templates = { templates: [] };
                }
                // print table
                that.publishTo = [];
                that.showCurrentUsages(templates.templates, sourceDoc, sourceSign);
                let pb = $("<button id='pubTemp' class='btn btn-default btn-sm'>Publish as template for selected projects</button>").appendTo(that.pub);
                pb.click(function () {
                    // make sure to have latest and greatest
                    globals_1.app.readSettingJSONAsync(MarkAsTemplateImpl.PROJECT_SETTING).done(function (result) {
                        templates = result;
                        if (!templates || !templates.templates) {
                            templates = { templates: [] };
                        }
                        // update 
                        $.each(templates.templates, function (idx, ps) {
                            if (ps.fromProject == globals_1.matrixSession.getProject() && ps.fromSign != sourceSign) {
                                if (ps.fromDOC == sourceDoc) {
                                    // for other items based on the same docs, remove everything which is being published somewhere else 
                                    ps.canUseIn = ps.canUseIn.filter(function (p) {
                                        let doPublish = that.publishTo.indexOf(p) != -1;
                                        return !doPublish;
                                    });
                                }
                            }
                        });
                        // remove templates which are not visible in any projects
                        templates.templates = templates.templates.filter(function (temp) {
                            return temp.canUseIn.length > 0;
                        });
                        // remove publishing info for this sign
                        templates.templates = templates.templates.filter(function (temp) {
                            return temp.fromProject != globals_1.matrixSession.getProject() || temp.fromSign != sourceSign;
                        });
                        // add publishing info for this sign
                        templates.templates.push({ fromProject: globals_1.matrixSession.getProject(), fromDOC: sourceDoc, fromSign: sourceSign, fromName: globals_1.app.getItemTitle(sourceSign), canUseIn: matrixlib_1.ml.JSON.clone(that.publishTo) });
                        globals_1.app.setSettingJSON(MarkAsTemplateImpl.PROJECT_SETTING, templates).done(function () {
                            that.pub.html("");
                            that.showProjects(sourceDoc, sourceSign);
                        });
                    });
                });
            });
        }
        showCurrentUsages(current, sourceDoc, sourceSign) {
            let that = this;
            // figure out what is currently used as template
            let others = [];
            $.each(current, function (idx, ps) {
                if (ps.fromProject == globals_1.matrixSession.getProject()) {
                    if (ps.fromSign == sourceSign) {
                        // this is currently published
                        that.publishTo = ps.canUseIn;
                    }
                    else if (ps.fromDOC == sourceDoc) {
                        // another version of DOC is used as template in some projects
                        others = others.concat(ps.canUseIn);
                    }
                }
            });
            let projects = globals_1.matrixSession.getProjectList(false).filter(function (p) { return p.shortLabel != "EMPTY" && p.shortLabel != globals_1.matrixSession.getProject(); });
            let templateProjects = globals_1.matrixSession.getCustomerSettingJSON(MarkAsTemplateImpl.PROJECT_SETTING_Projects);
            if (templateProjects && templateProjects.targets && templateProjects.targets.length) {
                projects = projects.filter(function (p) { return templateProjects.targets.indexOf(p.shortLabel) != -1; });
            }
            let hasUsedOther = false; // whether some have other published versions
            $.each(projects, function (idx, project) {
                var short = project.shortLabel;
                hasUsedOther = hasUsedOther || others.indexOf(project.shortLabel) != -1;
                var cb = $("<div>").appendTo(that.pub).checkBox({
                    canEdit: true,
                    help: (others.indexOf(project.shortLabel) != -1 ? "* " : "") + project.shortLabel + " - " + project.label,
                    valueChanged: function () {
                        if (cb.getController().getValue()) {
                            that.publishTo.push(short);
                        }
                        else {
                            that.publishTo = that.publishTo.filter(function (p) { return p != short; });
                        }
                        $("#pubTemp").addClass("btn-success");
                    },
                    parameter: {},
                    fieldValue: that.publishTo.indexOf(project.shortLabel) == -1 ? "0" : "1"
                });
            });
            if (hasUsedOther) {
                $("<div>").appendTo(that.pub).html("* Some project(s) use another version of template");
            }
        }
        // show a table in DOC, where author can decide who needs to sign to release the document
        showSignatureTableEdit() {
            let that = this;
            var userDropdown = [];
            var userList = globals_1.globalMatrix.ItemConfig.getUserNames();
            for (var udx = 0; udx < userList.length; udx++) {
                userDropdown.push({ id: userList[udx].login.toLowerCase(), label: userList[udx].login.toLowerCase() });
            }
            let dd = $("<div>").appendTo(this._root);
            let cb = that.settings.valueChanged;
            let userSelectionChanged = function () {
                let val = dd.getController().getValue();
                if (val) {
                    that.newValue = {
                        // MATRIX-4764 Don't save deleted user.
                        signatures: MarkAsTemplateImpl.removeDeletedUsers(val.split(",")).map(function (usr) { return { user: usr, datetime: "" }; })
                    };
                }
                else { // fix MATRIX-2442
                    that.newValue = {
                        signatures: []
                    };
                }
                if (cb) {
                    cb.apply(null);
                }
            };
            let params = {
                fieldValue: that.originalValue.signatures.map(function (us) { return us.user; }).join(","),
                canEdit: true,
                help: that.getHelpPart(0) ? that.getHelpPart(0) : (that.settings.help + " - (required approvals)"),
                parameter: {
                    placeholder: "select user who need to sign template",
                    create: false,
                    options: userDropdown,
                    maxItems: 100,
                    sort: true,
                    inlineHelp: (that.settings.parameter && that.settings.parameter.inlineHelp) ? that.settings.parameter.inlineHelp : ""
                },
                valueChanged: userSelectionChanged
            };
            dd.mxDropdown(params);
            //Fix for MATRIX-4764 Problem with Template approver and deleted users
            let missingUser = that.originalValue.signatures.filter(sig => globals_1.globalMatrix.ItemConfig.getUserNames().findIndex(user => user.login.toLowerCase() == sig.user) == -1);
            if (missingUser.length > 0) {
                let cleanupUserList = (a) => {
                    matrixlib_1.ml.UI.showAck(-1, "These users has been removed sinced they are no longer active : <ul style='margin-left:80px'>" + missingUser.map(o => "<li style='text-align:left;'>" + o.user + "</li>").join("") + "</ul> Please save to correct.", "User list has been cleaned in '" + params.help + "'");
                    userSelectionChanged();
                    index_1.MR1.onItemDisplayed().unsubscribe(cleanupUserList);
                };
                index_1.MR1.onItemDisplayed().subscribe(this, cleanupUserList);
            }
        }
        static removeDeletedUsers(userList) {
            return userList.filter(u => globals_1.globalMatrix.ItemConfig.getUserNames().findIndex(un => un.login.toLowerCase() == u.toLowerCase()) != -1);
        }
        getTemplateSignatureStatus() {
            return MarkAsTemplateImpl.getTemplateSignatureStatus(JSON.stringify(this.originalValue));
        }
        // ask for signatures
        askForSignatures(signatureStatus) {
            let that = this;
            let uiCtrl = $("<div>").appendTo(this.pub);
            // render a signature table with current status if there is 1+ signature in document
            this.renderSignatureTable(signatureStatus, uiCtrl, "not yet approved", "you need to approve this template", "approved at");
            if (this.settings.controlState == globals_1.ControlState.Print || this.settings.controlState == globals_1.ControlState.Tooltip) {
                return;
            }
            // show signature box unless user needs to sign or this is a tooltip, print or other special view
            this.showSignatureField(signatureStatus, uiCtrl, $(uiCtrl.find("td")[0]).width(), "Approve", function (pwd) {
                that.signTemplate(pwd);
            }, true);
        }
        signTemplate(pwd) {
            let that = this;
            globals_1.app.checkPassword(pwd).done(function () {
                // pwd is correct
                // get item with most current approvals
                globals_1.app.getItemAsync(that.settings.id).done(function (item) {
                    let current = item[that.settings.fieldId];
                    that.originalValue = (current ? JSON.parse(current) : {
                        signatures: []
                    });
                    that.newValue = matrixlib_1.ml.JSON.clone(that.originalValue);
                    $.each(that.newValue.signatures, function (idx, sig) {
                        if (sig.user == globals_1.matrixSession.getUser()) {
                            sig.datetime = new Date().toJSON();
                        }
                    });
                    globals_1.app.saveAsync(false);
                }).fail(function (error) {
                    matrixlib_1.ml.UI.showError("cannot approve template", error);
                });
            }).fail(function (error) {
                matrixlib_1.ml.UI.showError("invalid password", "");
            });
        }
    }
    exports.MarkAsTemplateImpl = MarkAsTemplateImpl;
    MarkAsTemplateImpl.PROJECT_SETTING = "templates";
    MarkAsTemplateImpl.PROJECT_SETTING_Projects = "templateProjects";
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 37 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(38), __webpack_require__(1), __webpack_require__(39), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, docBase_1, matrixlib_1, UserControl_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DocSignImpl = void 0;
    $.fn.docSign = function (options) {
        let baseControl = new DocSignImpl(this);
        this.getController = () => { return baseControl; };
        baseControl.init(options);
        return this;
    };
    class DocSignImpl extends docBase_1.DocBaseImpl {
        constructor(control) {
            super(control);
        }
        init(options) {
            let that = this;
            this._root.append(super.createHelp(options));
            this.uiCtrl = $("<div class='baseControl'>").appendTo(this._root);
            //this.uiCtrl.append("<div style='color:red'>BETA</div>");
            this.uiCtrl.append("<br>");
            let defaultOptions = {
                controlState: globals_1.ControlState.FormView,
                canEdit: false,
                valueChanged: function () {
                },
                parameter: {
                // item the item containing the rest of the information
                }
            };
            this.settings = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, options);
            // changes shall not overwrite other people's changes
            this.needsLatest = true;
            this.data = this.parseValue(this.settings.fieldValue);
            if (this.data.rejectComments && this.data.rejectComments.length) {
                $.each(this.data.rejectComments, function (rcidx, rejectComment) {
                    that.uiCtrl.append(`<div style='color:red'>Document was rejected by <b>${rejectComment.user}</b> at <b>${matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(rejectComment.createdAt))}</b>. Reason was:</div>`);
                    let reason = $(`<div'>${rejectComment.comment}</div>`).appendTo(that.uiCtrl);
                    reason.highlightReferences();
                });
            }
            else {
                // document was not rejected 
                let signatureStatus = docBase_1.DocBaseImpl.readSignatureInfo(this.settings.item);
                // render a signature table with current status if there is 1+ signature in document
                this.renderSignatureTable(signatureStatus, this.uiCtrl, "not yet signed", "you need to sign this document", "signed at");
                // show signature box unless user needs to sign or this is a tooltip, print or other special view
                if (signatureStatus.needSignature) {
                    if (globals_1.globalMatrix.ItemConfig.canSign(options.type)) {
                        this.showSignatureField(signatureStatus, this.uiCtrl, $(this.uiCtrl.find("td")[0]).width(), "Sign", function (pwd) {
                            that.signDocument(pwd);
                        }, false);
                    }
                    else {
                        this._root.append("<div class='inlineHelp'>You have no rights to sign documents</div>");
                    }
                }
                if (!that.isMe(DocSignImpl.iUser)) {
                    DocSignImpl.iUser = globals_1.matrixSession.getUser();
                    globals_1.restConnection.getServer("user").done(function (allUsers) {
                        DocSignImpl.iHaveSignature = false;
                        for (var idx = 0; idx < allUsers.user.length; idx++) {
                            if (that.isMe(allUsers.user[idx].login)) {
                                DocSignImpl.iHaveSignature = allUsers.user[idx].signatureImage !== "";
                            }
                        }
                    });
                }
            }
        }
        // initialize options
        // public interface
        hasChanged() {
            return false;
        }
        getValue(currentItem) {
            let that = this;
            return JSON.stringify(this.data);
        }
        destroy() {
        }
        resizeItem() {
            let width = Math.max(100, $(this.uiCtrl.find("td")[0]).width());
            $("input.signatureInfo", this.uiCtrl).width(width);
        }
        parseValue(fieldVal) {
            if (fieldVal) {
                return JSON.parse(fieldVal);
            }
            else {
                return {
                    rejectComments: []
                };
            }
        }
        // try to get additional info from original DOC signature table. and than draw the UI
        addSignMeaning(uiCtrl) {
            let that = this;
            let itemId = globals_1.app.getCurrentItemId();
            if (matrixlib_1.ml.Item.parseRef(itemId).type != "SIGN" || !globals_1.globalMatrix.ItemConfig.getDHFConfig().showOriginalSignMeaning) {
                return;
            }
            let dhfFields = globals_1.globalMatrix.ItemConfig.getFieldsOfType("dhf").map(field => "" + field.field.id);
            // get the parent DOC
            index_2.mDHF.getBaseDOCofSIGN(globals_1.matrixSession.getProject(), that.settings.item).done((theDoc) => {
                for (let field in theDoc) {
                    let meanings = index_2.mDHF.getSignatureMeanings() ? index_2.mDHF.getSignatureMeanings() : {};
                    if (dhfFields.indexOf(field) != -1 && theDoc[field]) {
                        let dhfField = JSON.parse(theDoc[field]);
                        if (dhfField.type == "signaturebox" && dhfField.fieldValue && dhfField.ctrlConfig && dhfField.ctrlConfig.columns) {
                            let columns = dhfField.ctrlConfig.columns;
                            let meaningColumn = columns.filter(c => c.columnType == "type6");
                            let userColumn = columns.filter(c => c.columnType == "type4");
                            if (meaningColumn.length && userColumn.length) {
                                let meaningColumnField = meaningColumn[0].field;
                                let userColumnField = userColumn[0].field;
                                let signTable = JSON.parse(dhfField.fieldValue);
                                for (let signDef of signTable) {
                                    let user = signDef[userColumnField];
                                    let meaning = signDef[meaningColumnField];
                                    let meaningHuman = meanings[meaning] ? meanings[meaning] : meaning;
                                    if (user && meaningHuman) {
                                        $.each($("tr", $(".signatureTable")), (rowIdx, row) => {
                                            let hasUser = false;
                                            $.each($("td", $(row)), (tdIdx, td) => {
                                                if ($(td).text() == user)
                                                    hasUser = true;
                                            });
                                            if (hasUser) {
                                                let meaningTd = $(".OriginalSignMeaning", $(row));
                                                let current = $(meaningTd).text();
                                                current = (current ? (current + ", ") : "") + meaningHuman;
                                                $(meaningTd).text(current);
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }).fail(() => {
                matrixlib_1.ml.Logger.error("no original parent of DOC found, columns with signature meaning stays empty...");
            });
        }
        // render signature table (maybe with some extra info from DOC)
        renderSignatureTable(signatureInfo, uiCtrl, notSigned, youSign, signedAt) {
            let that = this;
            if (signatureInfo.signatures.length === 0) {
                $("<div style='margin-bottom: 12px;'><span class='searchResult'>no signatures required</span></div>").appendTo(uiCtrl);
                return;
            }
            let sigInfo = $("<div class='sigInfo'>").appendTo(uiCtrl);
            let statusTable = $("<table class='signatureTable table table-bordered'>");
            let ctrlContainer = $("<div class='baseControl'>");
            sigInfo.append(ctrlContainer.append(statusTable));
            let body = $("<tbody>");
            statusTable.append(body);
            let hasSignComment = false;
            for (let idx = 0; idx < signatureInfo.signatures.length; idx++) {
                let needSign = $("<td>").html("<span class='needsSignature'>" + notSigned + "</span>");
                if (this.isMe(signatureInfo.signatures[idx].userid) && !signatureInfo.signatures[idx].signDate) {
                    needSign = $("<td>").html("<span class='needsSignature'>" + youSign + "</span>");
                }
                let dateCustomer = signatureInfo.signatures[idx].signDateCustomer;
                let tr = $("<tr>");
                let user = signatureInfo.signatures[idx].userid;
                let orgid = signatureInfo.signatures[idx].orgid;
                let userDisplayString = globals_1.globalMatrix.ItemConfig.hasUserInfo(user) ? user : `<s>${user}</s>`;
                let userText = `<span title="${globals_1.globalMatrix.ItemConfig.getFullName(user)}">${userDisplayString}</span>`;
                if (orgid && orgid != user) {
                    userText += `<span class="proxyInfo">(proxy for  <span title="${globals_1.globalMatrix.ItemConfig.getFullName(orgid)}">${orgid}</span>)</span>`;
                }
                if (globals_1.globalMatrix.ItemConfig.getDHFConfig().showOriginalSignMeaning) {
                    tr.append($(`<td class='OriginalSignMeaning'>`));
                }
                if (dateCustomer) {
                    tr.append($("<td>").html(userText));
                    let signed = $("<td>").appendTo(tr);
                    signed.append($("<span>").html(signedAt + " " + dateCustomer));
                    if (globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning) {
                        let commentCol = $("<td class='commentCol'>").appendTo(tr);
                        if (that.data.acceptComments) {
                            let acceptComment = that.data.acceptComments.filter(comment => comment.user == user && comment.comment);
                            if (acceptComment.length) {
                                hasSignComment = true;
                                commentCol.append($("<div>").html(acceptComment[acceptComment.length - 1].comment));
                            }
                        }
                    }
                }
                else if (globals_1.globalMatrix.ItemConfig.getDHFConfig().proxyRights && globals_1.matrixSession.amIAllowedUser(globals_1.globalMatrix.ItemConfig.getDHFConfig().proxyRights) && that.settings.canEdit) {
                    let tdUser = $("<td>").html(`<span>${userText}</span> <button data-proxy="${user}" class="proxy btn btn-xs" style="float:right">proxy</button>`);
                    tr.append(tdUser);
                    tr.append(needSign);
                    if (globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning) {
                        let commentCol = $("<td class='commentCol'>").appendTo(tr);
                    }
                }
                else {
                    tr.append($("<td>").html(userText));
                    tr.append(needSign);
                    if (globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning) {
                        $("<td class='commentCol'>").appendTo(tr);
                    }
                }
                body.append(tr);
            }
            if (!hasSignComment) {
                $(".commentCol").hide();
            }
            // fill column with sign meaning from DOC
            if (globals_1.globalMatrix.ItemConfig.getDHFConfig().showOriginalSignMeaning) {
                this.addSignMeaning(uiCtrl);
            }
            // handle proxy button
            $(".proxy").click(function (event) {
                let btn = $(event.delegateTarget);
                let user = btn.data("proxy");
                if (globals_1.app.needsSave()) {
                    matrixlib_1.ml.UI.showError("Cannot change user", "You need to save first.");
                    return;
                }
                matrixlib_1.ml.UI.SelectUserOrGroup.showSingleSelectDialog(user, "Select Proxy", "Replaces required signature", true, false, (newUser) => {
                    if (newUser == user) {
                        // nothing changed
                        return;
                    }
                    if (signatureInfo.signatures.map(info => info.userid).indexOf(newUser) != -1) {
                        matrixlib_1.ml.UI.showError("User exists", "The same user cannot sign for two");
                        return;
                    }
                    let signatureFieldId = globals_1.globalMatrix.ItemConfig.getFieldsOfType("signature", "SIGN")[0].field.id;
                    let update = { id: that.settings.item.id, onlyThoseFields: 1, onlyThoseLabels: 1 };
                    let oldSign = that.settings.item[signatureFieldId];
                    let newSign = oldSign.replace(`user="${user}" userId="${that.getUserId(user)}"`, `user="${newUser}" userId="${that.getUserId(newUser)}"`);
                    update["fx" + signatureFieldId] = newSign;
                    globals_1.app.updateItemInDBAsync(update, "proxy change").done(function () {
                        globals_1.app.treeSelectionChangeAsync(that.settings.item.id);
                        that.removeNotifications(that.settings.item.id, user);
                    });
                }, null);
            });
        }
        // remove signature notifications for one or more users
        removeNotifications(itemId, user) {
            let that = this;
            if (!globals_1.globalMatrix.ItemConfig.getDHFConfig().fixNotifications) {
                return;
            }
            globals_1.restConnection.getProject("todo?includeFuture=0&itemRef=" + itemId).done(function (allNotification) {
                let toDelete = allNotification.todos.filter(todo => todo.action && todo.action.todoType == "needSignature" && (!user || user == todo.login));
                that.removeNotificationsRec(toDelete, 0);
            });
        }
        removeNotificationsRec(toDelete, idx) {
            let that = this;
            if (idx >= toDelete.length)
                return;
            globals_1.restConnection.deleteServerAsync(globals_1.matrixSession.getProject() + "/todo/" + toDelete[idx].todoId, {}).done(() => {
                that.removeNotificationsRec(toDelete, idx + 1);
            });
        }
        getUserId(login) {
            let user = globals_1.globalMatrix.ItemConfig.getUserNames().filter(info => info.login == login);
            if (user.length != 1)
                return 0;
            let userId = user[0].id;
            if (userId == -1) {
                // this is a user who has access only through a user group. get the real id
                $.each(globals_1.globalMatrix.ItemConfig.getUserGroups(), function (ugIdx, ug) {
                    $.each(ug.membership, function (mIdx, m) {
                        if (m.login == login) {
                            userId = m.userId;
                        }
                    });
                });
            }
            return userId;
        }
        showSignatureField(signatureInfo, uiCtrl, columnSize, btnName, onSign, templateApproval) {
            let that = this;
            if (!signatureInfo.needSignature || this.settings.controlState === globals_1.ControlState.Print || this.settings.controlState === globals_1.ControlState.Tooltip || this.settings.controlState === globals_1.ControlState.HistoryView || this.settings.locked) {
                return;
            }
            var needEnterUserName = globals_1.matrixSession.getCustomerSetting("needEnterUserName") == "1";
            new UserControl_1.UserControl().askForPassword(uiCtrl, btnName, !needEnterUserName, Math.max(100, columnSize), (name, pwd) => {
                if (!pwd) {
                    matrixlib_1.ml.UI.showError("You must supply a password to sign the document", "");
                }
                else if (needEnterUserName && name != globals_1.matrixSession.getUser()) {
                    matrixlib_1.ml.UI.showError("Please provide your user id", "");
                }
                else {
                    onSign(pwd);
                }
            });
            if (!templateApproval) {
                if (globals_1.globalMatrix.ItemConfig.getDHFConfig().signatureHint) {
                    $(".signatureInfo button").html(globals_1.globalMatrix.ItemConfig.getDHFConfig().canReject ? "Reject/Sign*" : "Sign*");
                    uiCtrl.append(`<div class="inlineHelp" style="margin-top:12px;font-size:smaller">* ${globals_1.globalMatrix.ItemConfig.getDHFConfig().signatureHint}</div>`);
                }
                if (globals_1.globalMatrix.ItemConfig.getDHFConfig().canReject || globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning) {
                    // replace the sign button by a dropdown
                    this.replaceSignButton();
                }
            }
            uiCtrl.append("<br/>");
        }
        // make the sign button a drop down menu with different options
        replaceSignButton() {
            let that = this;
            let ddOptions = [];
            if (globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning && globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning.length) {
                for (let meaning of globals_1.globalMatrix.ItemConfig.getDHFConfig().signedMeaning) {
                    ddOptions.push({ name: meaning, click: () => { that.signFromDropdown(meaning); } });
                }
            }
            else {
                // normal sign
                ddOptions.push({ name: "Sign", click: () => { that.signFromDropdown(); } });
            }
            if (globals_1.globalMatrix.ItemConfig.getDHFConfig().canReject) {
                ddOptions.push({ name: "Reject", click: () => {
                        if (globals_1.globalMatrix.ItemConfig.getDHFConfig().rejectWithoutPass) {
                            that.rejectSign();
                        }
                        else {
                            that.rejectSignWithPass();
                        }
                    } });
            }
            $(".signatureInfo button").replaceWith(matrixlib_1.ml.UI.createDropDownButton($(".signatureInfo button").html(), ddOptions, false, false, "signBtn", true));
            $("ul", $(".signatureInfo")).addClass("pull-right");
        }
        rejectSignWithPass() {
            let pwd = $(".signatureInfo input[placeholder='password']").val();
            let name = $("input.signatureInfo").val();
            let needEnterUserName = globals_1.matrixSession.getCustomerSetting("needEnterUserName") == "1";
            if (!pwd) {
                matrixlib_1.ml.UI.showError("You must supply a password to reject the document", "");
            }
            else if (needEnterUserName && name != globals_1.matrixSession.getUser()) {
                matrixlib_1.ml.UI.showError("Please provide your user id", "");
            }
            else {
                globals_1.app.checkPassword(pwd).done(() => {
                    this.rejectSign();
                }).fail(() => {
                    matrixlib_1.ml.UI.showError("Incorrect Password", "");
                });
            }
        }
        // ask user for comment and reject SIGN
        rejectSign() {
            let that = this;
            let subj = $("<div>").richText({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Reject message",
                fieldValue: "",
                valueChanged: function () {
                },
                parameter: {}
            });
            let dlg = $("<div>").appendTo($("body"));
            let ui = $("<div style='width:100%;height:100%'>");
            ui.append(subj);
            ui.addClass("dlg-no-scroll");
            ui.removeClass("dlg-v-scroll");
            matrixlib_1.ml.UI.showDialog(dlg, "Reject SIGN", ui, -730, -470, [{
                    text: 'Reject',
                    class: 'btnDoIt',
                    click: function () {
                        let text = subj.getController().getValue();
                        if (globals_1.globalMatrix.ItemConfig.getDHFConfig().rejectNeedsComment && !text) {
                            return false;
                        }
                        globals_1.restConnection.putProject(`sign/${that.settings.item.id}`, { rejectSign: (text ? text : "rejected") }).done(() => {
                            globals_1.app.treeSelectionChangeAsync(that.settings.item.id);
                        });
                        dlg.dialog("close");
                    }
                }, {
                    text: 'Cancel',
                    class: 'btnCancelIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, false, false, () => { dlg.remove(); }, () => { $("input", subj).focus(); }, () => { });
        }
        signFromDropdown(meaning) {
            let pwd = $(".signatureInfo input[placeholder='password']").val();
            let name = $("input.signatureInfo").val();
            let needEnterUserName = globals_1.matrixSession.getCustomerSetting("needEnterUserName") == "1";
            if (!pwd) {
                matrixlib_1.ml.UI.showError("You must supply a password to sign the document", "");
            }
            else if (needEnterUserName && name != globals_1.matrixSession.getUser()) {
                matrixlib_1.ml.UI.showError("Please provide your user id", "");
            }
            else {
                this.signDocument(pwd, meaning);
            }
        }
        signDocument(pwd, meaning) {
            let that = this;
            if (globals_1.app.needsSave()) {
                matrixlib_1.ml.UI.showError("You need to save other changes first", "");
                return;
            }
            function addSignature() {
                globals_1.app.signItemAsync(that.settings.item.id, pwd, meaning).done(function (result) {
                    if (result && !result.ok) {
                        matrixlib_1.ml.UI.showError("Could not sign document", result.result);
                        return;
                    }
                    // get item with new signatures
                    globals_1.app.getItemAsync(that.settings.id).done(function (item) {
                        // do automation stuff 
                        let lastSignature = docBase_1.DocBaseImpl.readSignatureInfo(item).missingSignatures === 0;
                        index_1.MR1.triggerAfterSignature(item, lastSignature);
                        globals_1.app.renderItem();
                    });
                }).fail(function (error) {
                    if (error) {
                        matrixlib_1.ml.UI.showError("Could not sign document", error);
                    }
                    else {
                        // cancelled save
                    }
                });
            }
            if (!DocSignImpl.iHaveSignature) {
                matrixlib_1.ml.UI.showConfirm(4, { title: "You have not uploaded a signature image! Do you want to sign the document without an image?", ok: "Sign anyway" }, function () {
                    addSignature();
                }, function () {
                });
            }
            else {
                addSignature();
            }
        }
    }
    exports.DocSignImpl = DocSignImpl;
    DocSignImpl.iHaveSignature = false;
    DocSignImpl.iUser = "";
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 38 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(31), __webpack_require__(1), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, BaseControl_1, matrixlib_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DocBaseImpl = void 0;
    class DocBaseImpl extends BaseControl_1.BaseControl {
        constructor(control) {
            super(control);
        }
        // this method returns all signature information from a item
        // the item can be a DOC, SIGN, RELEASE 
        // depending on the type (e.g. DOC) it looks for different fields
        static readSignatureInfo(item) {
            let that = this;
            let signatureStatus = {
                signatures: [],
                missing: [],
                given: [],
                signatureDate: {},
                missingSignatures: 0,
                givenSignatures: 0,
                needSignature: false,
                hasSignature: false,
                isTemplate: false
            };
            if (!item) {
                return signatureStatus;
            }
            $.each(item, function (key, val) {
                if (val && globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                    // special dhf control
                    var fieldVal = JSON.parse(val);
                    if (fieldVal.type.toLocaleLowerCase() === "templateapproval") {
                        signatureStatus.isTemplate = true;
                    }
                }
            });
            if (index_1.mDHF.isDocumentFormType(item.type)) { // DRAFT, DOC, ...
                $.each(item, function (key, val) {
                    if (val && globals_1.globalMatrix.ItemConfig.getFieldType(item.type, key) === "dhf") {
                        // special dhf control
                        var fieldVal = JSON.parse(val);
                        if (fieldVal.type.toLocaleLowerCase() === (signatureStatus.isTemplate ? "templateapproval" : "signaturebox")) {
                            // control is a signature table
                            $.each(fieldVal, function (tableIdx, value) {
                                // get calue of control
                                let tableStr = value.fieldValue;
                                if (tableStr) {
                                    let table = JSON.parse(tableStr);
                                    $.each(table, function (rowIdx, row) {
                                        $.each(value.ctrlConfig.columns, function (tableColIdx, tableCol) {
                                            let user = row[tableCol.field];
                                            if (tableCol.editor == "user" && user && signatureStatus.missing.indexOf(user) == -1) {
                                                signatureStatus.missingSignatures++;
                                                signatureStatus.missing.push(user);
                                            }
                                        });
                                    });
                                }
                            });
                        }
                    }
                });
            }
            else {
                // this is a signed item
                $.each(item, function (detail, val) {
                    if (typeof val === "string" && val.indexOf("<signatures ") === 0) {
                        var signaturesXML = $(val);
                        $.each(signaturesXML.find("signature"), function (idx, signature) {
                            signatureStatus.hasSignature = true; // there is at least this signature field
                            let orgUser = $(signature).attr("originaluserlogin");
                            let currentUser = $(signature).attr("user").toLowerCase();
                            let sig = {
                                orgid: orgUser ? orgUser.toLowerCase() : currentUser,
                                userid: currentUser,
                                signDate: ($(signature).attr("signDate")),
                                signaturefileid: ($(signature).attr("signaturefileid")),
                                signDateCustomer: ($(signature).attr("signDateCustomer"))
                            };
                            if (that.isMeTest(sig.userid)) {
                                signatureStatus.needSignature = !sig.signDate;
                            }
                            if (sig.signDate) {
                                signatureStatus.given.push($(signature).attr("user"));
                                signatureStatus.givenSignatures++;
                                if (!sig.signDateCustomer) {
                                    // in some old projects signDateCustomer was not set...
                                    sig.signDateCustomer = matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(sig.signDate));
                                }
                            }
                            else {
                                signatureStatus.missingSignatures++;
                                signatureStatus.missing.push($(signature).attr("user"));
                            }
                            signatureStatus.signatureDate[$(signature).attr("user").toLowerCase()] = sig.signDateCustomer;
                            signatureStatus.signatures.push(sig);
                        });
                    }
                });
            }
            return signatureStatus;
        }
        static isMeTest(user) {
            return user.toLowerCase() === globals_1.matrixSession.getUser().toLowerCase();
        }
        isMe(user) {
            return DocBaseImpl.isMeTest(user);
        }
    }
    exports.DocBaseImpl = DocBaseImpl;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 39 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(40), __webpack_require__(41), __webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, EmailValidator_1, PasswordValidator_1, UserNameValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.userControls = exports.UserControl = void 0;
    class UserControl {
        constructor() {
            this.canAutoFill = false;
        }
        // mode
        // create (always an admin)
        // adminedit (an admin editing in admin client)
        // useredit (a user through menu)
        editUserDetails(mode, userId, userAddedCb, noUserAddedCb) {
            let that = this;
            globals_1.restConnection.getServer("user").done(function (allUsers) {
                var userDetails;
                if (userId) {
                    for (var idx = 0; idx < allUsers.user.length; idx++) {
                        if (allUsers.user[idx].login.toLowerCase() === userId.toLowerCase()) {
                            userDetails = allUsers.user[idx];
                            userDetails.login = userDetails.login.toLowerCase();
                        }
                    }
                }
                that.editUserDetailsDlg(mode, userDetails, userAddedCb, noUserAddedCb, allUsers);
            }).fail(function (error) {
                matrixlib_1.ml.UI.showError("Cannot edit user", error);
            });
        }
        resetPassword(userId) {
            let that = this;
            globals_1.restConnection.getServer("user").done(function (allUsers) {
                for (var idx = 0; idx < allUsers.user.length; idx++) {
                    if (allUsers.user[idx].login.toLowerCase() === userId.toLowerCase()) {
                        let currentUser = allUsers.user[idx];
                        var userDetails = currentUser;
                        userDetails.password = that.generatePassword();
                        userDetails.signaturePassword = that.generatePassword();
                        // fix MATRIX-1046 reset password button resets admin flag
                        userDetails.admin = userDetails.customerAdmin;
                        // fix MATRIX-1660 The "reset password" function in the admin UI doesn't work anymore
                        if (currentUser.signatureImage == "") {
                            userDetails.signatureImage = -1;
                        }
                        else {
                            userDetails.signatureImage = parseInt(currentUser.signatureImage.split("?")[0]);
                        }
                        globals_1.restConnection.putServer("user/" + userDetails.login.toLowerCase(), {
                            json: JSON.stringify(userDetails)
                        }).done(function (result) {
                            /* MATRIX-2996 initial set password dialog ask for user name if not set*/
                            var askForName = ((userDetails.firstName == undefined || userDetails.firstName == "") ||
                                (userDetails.lastName == undefined || userDetails.lastName == ""));
                            that.createUserMail(allUsers, userDetails.login.toLowerCase(), true, "", askForName);
                        }).fail(function (errorMsg) {
                            matrixlib_1.ml.UI.showError("Failed to change passwords!", errorMsg);
                        });
                    }
                }
            }).fail(function (error) {
                matrixlib_1.ml.UI.showError("Cannot retrieve user info!", error);
            });
        }
        ;
        askForPassword(container, btnName, showUser, userWidth, onSign) {
            let that = this;
            let table = $('<div class="signatureInfo input-group" style="margin-top:12px;width:100%">').appendTo(container);
            // by default do not allow change
            let autoFill = globals_1.matrixSession.getCustomerSettingJSON("autoFillSettings", {});
            that.canAutoFill = autoFill.allowAutoFill || autoFill.allowDocSignAutoFill;
            let name = $("<input autocomplete='off' type='text' class='signatureInfo form-control' placeholder='enter user id' style='padding:8px'>");
            let pwd = $("<input type='" + (that.canAutoFill ? "password" : "text") + "' class='form-control' placeholder='password'>");
            let signIt = $("<button class='form-control btn btn-default'>" + btnName + "</button>").click(function () {
                onSign(name.val(), pwd.val());
            });
            let pwdSpan = $("<span class='input-group-btn'>").append(pwd);
            table.append(name);
            table.append(pwdSpan);
            table.append($("<span class='input-group-btn'>").append(signIt));
            if (userWidth) {
                name.width(userWidth);
                pwdSpan.css("width", "90%");
            }
            else {
                pwdSpan.css("width", "90%");
            }
            that.initUserAndPassword(name, pwd, showUser);
            pwd.on("keyup paste", () => {
                pwd.attr("type", "password");
            });
        }
        initUserAndPassword(name, pwd, showUser) {
            // canChange is set to true at first keypress, mousedown before that 
            // it is an autofill which is not allowed in signature box
            if (showUser) { // normally the user can be displayed and not be changed
                name.val(globals_1.matrixSession.getUser() + (this.canAutoFill ? "" : " ")); // the " "  makes sure the password is not filled when loading
                name.attr("readonly", "readonly");
            }
            if (this.canAutoFill)
                return;
            if (!showUser) {
                // sometimes user need to type it (this is actually a very special case)
                name.val("");
            }
            pwd.val("");
        }
        async updateGlobalUserInfo() {
            if (globals_1.globalMatrix.ItemConfig.isConfigured() && globals_1.matrixSession.getProject()) {
                try {
                    const accessInfo = await globals_1.restConnection.getServer(globals_1.matrixSession.getProject() + "/access");
                    globals_1.globalMatrix.ItemConfig.addUsers(accessInfo.userPermission, accessInfo.groupPermission);
                }
                catch (e) {
                    matrixlib_1.ml.Logger.error("Error updating global user information.");
                }
            }
        }
        editUserDetailsDlg(mode, userDetails, userAddedCb, noUserAddedCb, userInfo) {
            let that = this;
            if (mode === "create") {
                userDetails = {
                    login: "",
                    email: "",
                    firstName: "",
                    lastName: "",
                    customerAdmin: 0
                };
            }
            var tablewidth = 680;
            var form = $(this.getUserDetailsHTML(mode, tablewidth));
            globals_1.app.dlgForm.hide();
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            var scrollPanel = $('<div class="layoutContainerScroll"></div>');
            globals_1.app.dlgForm.append(scrollPanel);
            scrollPanel.append(form);
            var table = $('#userPrefTable');
            var save = function (event) {
                that.enableSavePwd(true);
                matrixlib_1.ml.UI.showSuccess((mode === "create") ? 'Creating user!' : 'Updating user!');
                var newValues = readform();
                if (!newValues) {
                    return;
                }
                var pl = "";
                $.each($(".qmsViewerOnly:checked"), function (idx, p) {
                    let url = globals_1.globalMatrix.matrixBaseUrl + "/pub/" + $(p).data("pid");
                    pl += "<a href='" + url + "'><b>" + $(p).data("pid") + "</b> - " + $(p).data("plabel") + "</a> (as QMS viewer)<br/>";
                });
                $.each($(".proch:checked"), function (idx, p) {
                    pl += "<b>" + $(p).data("pid") + "</b> - " + $(p).data("plabel") + "<br/>";
                });
                // create or update user 
                saveData(newValues).done(function () {
                    // MATRIX-1341
                    // The create user function in the admin UI doesn't open up projects for users
                    // save projects to give access later
                    var paccess = [];
                    $.each($(".proch:checked"), function (idx, p) {
                        paccess.push($(p).data("pid"));
                    });
                    var paccessQms = [];
                    $.each($(".qmsViewerOnly:checked"), function (idx, p) {
                        paccessQms.push($(p).data("pid"));
                    });
                    globals_1.app.dlgForm.dialog("close");
                    // user created
                    if (mode === "create") {
                        globals_1.restConnection.getServer("user").done(async function (allUsers) {
                            // update list of existing users if necessary.
                            await that.updateGlobalUserInfo();
                            var askForName = ((newValues.firstName == undefined || newValues.firstName == "") ||
                                (newValues.lastName == undefined || newValues.lastName == ""));
                            // send mail to user
                            that.createUserMail(allUsers, newValues.login, false, pl, askForName);
                            // give initial access rights to projects
                            $.each(paccess, function (idx, pid) {
                                globals_1.restConnection.postServer("user/" + newValues.login + "/" + pid, {
                                    permission: "2",
                                    reason: "admin.js"
                                });
                            });
                            // give initial access rights to projects
                            $.each(paccessQms, function (idx, pid) {
                                globals_1.restConnection.postServer("user/" + newValues.login + "/" + pid, {
                                    permission: "4",
                                    reason: "admin.js"
                                });
                            });
                        });
                    }
                });
            };
            if (mode !== "create") {
                var table3 = $("<table class='userSettings' style='width:100%'><tbody/></table>");
                $("#userPref").append(table3);
                var table2 = $("<table class='dateSettings' style='width:100%'><tbody/></table>");
                $("#userPref").append(table2);
                matrixlib_1.ml.UI.DateTime.renderSettingControls({
                    user: userDetails.login,
                    help: "User Date and Time Settings",
                    table: table2
                });
                $("#userPref").append(table2);
                if (userDetails.login === globals_1.matrixSession.getUser()) {
                    matrixlib_1.ml.UI.ThemeSelector.renderThemeSelectorControl("Theme", table3);
                }
                that.renderNotificationEmailReminder(userDetails, table3);
                var savePwDiv = $("<div class=''  ></div>");
                var saveButton = $("<button class='savePwButton ' id='saveBtn'> Save </button>").click(save);
                saveButton.button();
                var savePwTb = $(" <span class='' style='float:right'><button class='' >PW</button></span></div>");
                savePwTb.append(saveButton);
                savePwDiv.append(savePwTb);
                table.after(savePwDiv);
                setTimeout(() => { $("#ud_pw3").width($("#ud_login").width() - $("#saveBtn").width() - 40); }, 400);
            }
            $("input", scrollPanel).on("change keyup paste", function () {
                that.enableSavePwd(!readform());
                let isEnabled = !$("#saveBtn").attr("disabled");
                $("#ud_pw3").css("border-color", isEnabled ? "" : "red");
            });
            // attach password creation handler
            $(".pwgen", scrollPanel).click(function (event) {
                that.generatePassword($(event.delegateTarget));
            });
            // fill form with input
            $.each(userDetails, function (detail, val) {
                if (detail === "signatureImage") {
                    if (val && val !== -1) {
                        $("#ud_currentImg").html("").append("<img class='signature' src='" + globals_1.globalMatrix.matrixRestUrl + "/all/file/" + val + "'>");
                    }
                }
                if (detail === "customerAdmin") {
                    $("#ud_" + detail).prop("checked", val ? true : false);
                }
                else {
                    $("#ud_" + detail).val(val);
                }
            });
            // hide / disable stuff which cannot be changed
            if (mode === "create") {
                $("#ud_pw1_line").hide();
                $("#ud_pw1R_line").hide();
                $("#ud_pw2_line").hide();
                $("#ud_pw1").val(that.generatePassword());
                $("#ud_pw1R").val($("#ud_pw1").val());
                $("#ud_pw2").val(that.generatePassword());
            }
            else if (mode === "adminedit") {
                $("#ud_login").attr("readonly", "readonly");
            }
            else {
                $("#ud_login").attr("readonly", "readonly");
                $(".admin_line").hide();
            }
            if (globals_1.matrixSession.oAuthOnly()) {
                $("#ud_pw1").val(that.generatePassword());
                $("#ud_pw1R").val($("#ud_pw1").val());
                $("#ud_pw1_line").hide();
                $("#ud_pw1R_line").hide();
            }
            if (userInfo.needDoublePassword != 1 && !globals_1.matrixSession.oAuthOnly()) {
                $("#ud_pw2_line").hide();
                $("#ud_pw1").on('change keyup paste', function () {
                    $("#ud_pw2").val($("#ud_pw1").val() + "#'*PSSD");
                });
            }
            if (mode !== "useredit") {
                $(".ud_useredit_line").hide();
            }
            if (mode === "adminedit") {
                $("fieldset", globals_1.app.dlgForm).css("border", "none").css("padding", 0).css("padding-bottom", 0);
                $("legend", globals_1.app.dlgForm).hide();
            }
            if (mode === "create") {
                $("fieldset", globals_1.app.dlgForm).css("border", "none").css("padding", 0).css("padding-bottom", 0);
                $("legend", globals_1.app.dlgForm).hide();
                var accessRights = $("<div >");
                table.after(accessRights);
                if (globals_1.matrixSession.getProjectList(false).filter(p => p.qmsProject).length > 0) {
                    accessRights.append("<span class='baseControlHelp'>LiveQMS (viewer only)</span>");
                    $.each(globals_1.matrixSession.getProjectList(false), function (ip, p) {
                        if (p.shortLabel !== "EMPTY") {
                            if (p.qmsProject) {
                                accessRights.append('<div style="padding-left:35px" >' +
                                    '<label><input type="checkbox" class="qmsViewerOnly" data-pid="' + p.shortLabel + '" data-plabel="' + p.label + '">' +
                                    '<span style="padding-left:10px">' + p.shortLabel + '</span> <span style="font-weight:normal">' + p.label + '</span>' +
                                    '</div>');
                            }
                        }
                    });
                }
                accessRights.append("<span class='baseControlHelp'>Give user read/write access to these projects</span>");
                accessRights.append('<div style="padding-left:35px" >' +
                    '<label><input type="checkbox" class="toogleProjectAccess">' +
                    '<span style="padding-left:10px;font-weight:normal">toggle all projects</span></label>' +
                    '</div>');
                $('.toogleProjectAccess').change(function () {
                    let checked = $('.toogleProjectAccess').is(":checked");
                    $.each($(".proch"), function (idx, proch) {
                        $(proch).prop("checked", checked);
                    });
                    if (checked)
                        $(".qmsViewerOnly").prop("checked", false);
                });
                $.each(globals_1.matrixSession.getProjectList(false), function (ip, p) {
                    if (p.shortLabel !== "EMPTY") {
                        accessRights.append('<div style="padding-left:35px" >' +
                            '<label><input type="checkbox" class="proch" data-pid="' + p.shortLabel + '" data-plabel="' + p.label + '">' +
                            '<span style="padding-left:10px">' + p.shortLabel + '</span> <span style="font-weight:normal">' + p.label + '</span></label>' +
                            '</div>');
                    }
                });
                $(".proch").change(function (event) {
                    if ($(event.target).is(":checked")) {
                        $(".qmsViewerOnly[data-pid='" + $(event.target).data("pid") + "']").prop("checked", false);
                    }
                });
                $(".qmsViewerOnly").change(function (event) {
                    if ($(event.target).is(":checked")) {
                        $(".proch[data-pid='" + $(event.target).data("pid") + "']").prop("checked", false);
                        $(".toogleProjectAccess").prop("checked", false);
                    }
                });
            }
            // init validators
            var pw1 = new PasswordValidator_1.StrongPass("#ud_pw1", {
                passFail: function () {
                    //console.log(passed);
                },
                passIndex: userInfo.passwordStrength,
                other: "#ud_pw2"
            });
            var pw2 = new PasswordValidator_1.StrongPass("#ud_pw2", {
                passFail: function () {
                    //console.log(passed);
                },
                passIndex: userInfo.passwordStrength,
                other: "#ud_pw1"
            });
            var user = new UserNameValidator_1.User("#ud_login");
            var email = new EmailValidator_1.Email("#ud_email");
            // handle signature file upload 
            $("#ud_signatureImageChange").change(function () {
                var files = $("#ud_signatureImageChange")[0].files;
                if (files) {
                    let validFileExtensions = ["jpg", "jpeg", "bmp", "gif", "png"];
                    let nameparts = files[0].name.toLowerCase().split(".");
                    if (validFileExtensions.indexOf(nameparts[nameparts.length - 1]) != -1) {
                        globals_1.restConnection.uploadFileCustomerAsync(files[0], function (progress) {
                        }).done(function (result) {
                            let imgPath = globals_1.globalMatrix.matrixRestUrl + "/all/file/" + result.fileId + "?key=" + result.key;
                            let testSize = $("<img style='display:none'>").appendTo("body").attr("src", imgPath).load(function (event) {
                                if (testSize.height() > 300 || testSize.width() > 800) {
                                    matrixlib_1.ml.UI.showError("Signature image too large", "Image cannot exceed 800x300 pixels.");
                                }
                                else {
                                    $("#ud_signatureImage").val(result.fileId);
                                    $("#ud_currentImg").html("").append("<img class='signature' src='" + imgPath + "'>");
                                    if (mode === "useredit" && globals_1.matrixSession.oAuthOnly()) {
                                        that.enableSaveOAuth();
                                    }
                                }
                                testSize.remove();
                            });
                        }).fail(function (error) {
                            matrixlib_1.ml.UI.showError("Failed to upload image", error);
                        });
                    }
                    else {
                        matrixlib_1.ml.UI.showError("Only image files are supported", "");
                    }
                }
            });
            // function to get values back from form
            function readform() {
                var error = false;
                error = ($("#ud_pw1").val() != "" && !pw1.isOK()) || error;
                error = ((userInfo.needDoublePassword == 1 || globals_1.matrixSession.oAuthOnly()) && ($("#ud_pw2").val() != "" && !pw2.isOK())) || error;
                error = !email.isOK() || error;
                error = !user.isOK() || error;
                if (error) {
                    return null;
                }
                let signImageVal = $("#ud_signatureImage").val();
                let signImage = signImageVal ? parseInt(signImageVal.split("?")[0]) : -1;
                return {
                    login: $("#ud_login").val().toLowerCase(),
                    email: $("#ud_email").val(),
                    pw1: $("#ud_pw1").val(),
                    firstName: $("#ud_firstName").val(),
                    lastName: $("#ud_lastName").val(),
                    signatureImage: signImage,
                    pw2: $("#ud_pw2").val(),
                    pw3: $("#ud_pw3").val(),
                    customerAdmin: $("#ud_customerAdmin").prop("checked") ? 1 : 0
                };
            }
            function saveData(newValues) {
                var res = $.Deferred();
                var signatureImage = -1;
                if (newValues.signatureImage) {
                    signatureImage = newValues.signatureImage;
                    if (isNaN(signatureImage)) {
                        signatureImage = -1;
                    }
                }
                var jsonParamObj = {
                    login: newValues.login.toLowerCase(),
                    email: newValues.email,
                    password: newValues.pw1,
                    firstName: newValues.firstName,
                    lastName: newValues.lastName,
                    signatureImage: signatureImage,
                    signaturePassword: newValues.pw2,
                    admin: newValues.customerAdmin // whether user is an admin
                };
                if (!jsonParamObj.password)
                    delete jsonParamObj.password;
                if (!jsonParamObj.signaturePassword)
                    delete jsonParamObj.signaturePassword;
                var jsonParam = JSON.stringify(jsonParamObj);
                if (mode === "create") {
                    globals_1.restConnection.postServer("user", {
                        json: jsonParam
                    }).done(function () {
                        if (userAddedCb) {
                            userAddedCb();
                        }
                        res.resolve();
                    }).fail(function (jqxhr, textStatus, error) {
                        let msg = matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error);
                        if (jqxhr &&
                            jqxhr.responseJSON &&
                            jqxhr.responseJSON.detailsList &&
                            jqxhr.responseJSON.detailsList.length &&
                            jqxhr.responseJSON.detailsList[0].indexOf("Last operation would overflow number of licenses (error in compute)|CreateUserMethod") != -1) {
                            msg = "There are no more write licenses.";
                        }
                        else if (jqxhr && jqxhr.responseText && jqxhr.responseText.indexOf("duplicate") !== -1) {
                            msg = "user id exists already";
                        }
                        matrixlib_1.ml.UI.showError("Failed to create user!", msg);
                        if (noUserAddedCb) {
                            noUserAddedCb();
                        }
                        res.reject();
                    });
                }
                else if (mode === "adminedit") {
                    globals_1.restConnection.putServer("user/" + newValues.login.toLowerCase(), {
                        json: jsonParam
                    }).done(function (result) {
                        if (userAddedCb) {
                            userAddedCb();
                        }
                        res.resolve();
                    }).fail(function (errorMsg) {
                        matrixlib_1.ml.UI.showError("Failed to create user!", errorMsg);
                        if (noUserAddedCb) {
                            noUserAddedCb();
                        }
                        res.reject();
                    });
                }
                else if (globals_1.matrixSession.oAuthOnly()) { // user edit oAuth only
                    that.setUserData(newValues.login.toLowerCase(), jsonParam, userAddedCb, noUserAddedCb).done(function () {
                        res.resolve();
                    }).fail(function () {
                        res.reject();
                    });
                }
                else { // user edit normal auth user
                    $.post(globals_1.globalMatrix.matrixRestUrl + "/user/" + newValues.login.toLowerCase() + "/login", { password: newValues.pw3 }).done(function (data) {
                        that.setUserData(newValues.login.toLowerCase(), jsonParam, userAddedCb, noUserAddedCb, newValues.pw1 != "" && newValues.pw2 != "").done(function () {
                            res.resolve();
                        }).fail(function () {
                            res.reject();
                        });
                    }).fail(function (jqxhr, textStatus, error) {
                        matrixlib_1.ml.UI.showError("Incorrect current password!", "");
                        if (noUserAddedCb) {
                            noUserAddedCb();
                        }
                        res.reject();
                    });
                }
                return res;
            }
            let buttons = [];
            buttons.push({
                text: 'Close',
                class: 'btnCancelIt',
                click: function () {
                    if (noUserAddedCb) {
                        noUserAddedCb();
                    }
                    globals_1.app.dlgForm.dialog("close");
                }
            });
            if (mode === "create" || mode == "adminedit") {
                buttons.push({
                    text: (mode === "create") ? 'Create' : 'Save',
                    class: 'btnDoIt savePwButton',
                    click: save
                });
            }
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: (mode === "create") ? "Create new User" : "My profile",
                width: tablewidth + 80,
                height: 600,
                modal: true,
                resize: function () {
                    $("#ud_pw3").width($("#ud_login").width() - $("#saveBtn").width() - 40);
                },
                open: function () {
                    var pwb = $('span button:contains(PW)', globals_1.app.dlgForm.parent());
                    if (mode === "useredit") {
                        if (globals_1.matrixSession.oAuthOnly()) {
                            pwb.replaceWith($("<span>"));
                            $("#ud_signatureImage").data("org", $("#ud_signatureImage").val());
                            let saveOAuth = $(`<button id="saveBtnOAuth" class="ui-button ui-corner-all ui-widget"> Save </button>`).click(() => {
                                saveData(readform());
                            });
                            $("#saveBtn").hide().parent().append(saveOAuth);
                            $("#ud_pw2").on("change keyup paste", function () {
                                that.enableSaveOAuth();
                            });
                            that.enableSaveOAuth();
                        }
                        else {
                            // request a current password to change user
                            var pwp = $('<input type="text" class="form-control ud_useredit_line" id="ud_pw3" style="height:31px;margin-right:10px;width:250px;display: inline-block;" placeholder="enter current password to save">');
                            pwp.on("keyup", function () {
                                pwp.attr("type", "password");
                            });
                            var errorPwp = $("<span id='errorPWP' style='color:red;padding-right:8px;'>").html(matrixlib_1.ml.UI.spaceMessage(false, true));
                            pwb.replaceWith($("<span>").append(errorPwp).append(pwp));
                            $("#saveBtn").closest("div").css("margin-top", "36px");
                            errorPwp.hide();
                            $(".savePwButton").button("disable");
                            pwp.on("change keyup paste", function () {
                                that.enableSavePwd(!readform());
                            });
                            that.enableSavePwd(!readform());
                        }
                    }
                    else {
                        pwb.hide();
                        $("#saveBtn").hide();
                        if (!globals_1.globalMatrix.globalShiftDown) {
                            $("#userPref").hide();
                        }
                        else {
                            $("#userPref .dateSettings").hide();
                        }
                        that.enableSavePwd(!readform());
                    }
                },
                buttons: buttons
            });
        }
        enableSaveOAuth() {
            ;
            matrixlib_1.ml.UI.setEnabled($("#saveBtnOAuth"), $("#ud_signatureImage").data("org") != $("#ud_signatureImage").val() || !!$("#ud_pw2").val());
        }
        saveEmailNotificationsSetting(user, setting) {
            let data = {
                key: UserControl.EMAILNOTIF_CONFIG,
                value: JSON.stringify(setting),
                reason: "Updating notification Setting"
            };
            globals_1.restConnection.postServer("user/" + user + "/setting", data).then(() => {
                if (user == globals_1.matrixSession.getUser()) {
                    globals_1.matrixSession.tryReconnect();
                }
            });
        }
        renderNotificationEmailReminder(userDetails, table) {
            let that = this;
            if (userDetails.userSettingsList == undefined) {
                userDetails.userSettingsList = [];
            }
            let emailNotificationSettings = userDetails.userSettingsList.filter((set) => { return set.key == UserControl.EMAILNOTIF_CONFIG; });
            let emailNotificationSetting = emailNotificationSettings.length > 0 ? JSON.parse(emailNotificationSettings[0].value) : { periodicity: "" };
            let tableBody = $("tbody", table);
            tableBody.append($('<tr class="notif showInAdmin" ><td colspan="2" class="baseControlHelp">Notifications Digest Email</td></tr'));
            var tr = $("<tr  class='notif showInAdmin' >");
            tableBody.append(tr);
            tr.append($("<td class='admin_utdl'>").append($("<label class='control-label'>").html("Email notifications")));
            let options = [
                { id: "", label: "No email" },
                { id: "daily", label: "Email me daily" },
                { id: "weekly", label: "Email me weekly" }
            ];
            let div = $("<div/>");
            // ml.UI.addDropdownToValue(  "Periodicity", emailNotificationSetting, "periodicity", options, false, false, () => {
            //     that.saveEmailNotificationsSetting(userDetails.login, emailNotificationSetting); });
            tr.append($("<td>").append(`<select  style="width: 100%;height: 34px;" class="form-control" id="emailNotifCombo">   
                <option value="">No email</option>
                <option value="daily">Email me daily</option> 
                <option value="weekly">Email me weekly</option> 
           </select>`));
            $("#emailNotifCombo").change((o) => {
                var value = $("#emailNotifCombo option:selected").val();
                emailNotificationSetting.periodicity = value;
                that.saveEmailNotificationsSetting(userDetails.login, emailNotificationSetting);
            });
            $("#emailNotifCombo").val(emailNotificationSetting.periodicity);
            tr.append($("<td>").append(""));
        }
        createUserMail(allUsers, user, reset, pl, askForName) {
            let that = this;
            let prl = parseInt(globals_1.matrixSession.getCustomerSetting("passwordResetLimitation"));
            // if NaN or undefined then fallback to 3days
            let maxDuration = prl ? prl : 72;
            globals_1.restConnection.postServer("user/" + user + "/token", {
                purpose: "password_reset",
                validity: maxDuration,
                reason: "password reset by admin"
            }).done(async function (token) {
                // Update list of existing users if necessary.
                await that.updateGlobalUserInfo();
                var userDetails = (allUsers.user.filter(o => o.login == user));
                let additionnalParameters = "";
                if (askForName) {
                    additionnalParameters = "&askForName=1";
                    if (userDetails.length > 0) {
                        additionnalParameters += "&first=" + userDetails[0].firstName + "&last=" + userDetails[0].lastName;
                    }
                }
                let url = globals_1.globalMatrix.matrixBaseUrl + "/resetPassword.jsp?user=" + user + "&passwordStrength=" + allUsers.passwordStrength + additionnalParameters + "&double=" + ((allUsers.needDoublePassword == 1 || globals_1.matrixSession.oAuthOnly()) ? "1" : "0") + "&oAuthOnly=" + (globals_1.matrixSession.oAuthOnly() ? "1" : "0") + "&token=" + token.token;
                var userinfo = "You need to set your password(s) using this link: <a href='" + url + "'>" + url + "</a><br/><br/>" +
                    "Once you set your password you can login here: <a href='" + globals_1.globalMatrix.matrixBaseUrl + "'>" + globals_1.globalMatrix.matrixBaseUrl + "</a><br/>" +
                    "Your user id is: <b>" + user + "</b><br/><br/>" +
                    "Note: you have " + maxDuration + " hours to do this. If you are too late ask your admin for a new link!";
                var message = matrixlib_1.ml.Mail.getCannedMessage(reset ? "reset_pwd" : "new_user", user, "");
                message = message.replace("_userinfo_", userinfo);
                message = message.replace("_projectlist_", pl);
                matrixlib_1.ml.Mail.sendMail(user, "", "", reset ? "Password Reset" : "Access to Matrix", message, undefined, undefined, 1);
            });
        }
        enableSavePwd(disable) {
            let pwp = $("#ud_pw3");
            let errorPwp = $("#errorPWP");
            let errorMatch = $("#errorMatch");
            let btn = $(".savePwButton");
            errorPwp.hide();
            errorMatch.hide();
            if ($("#ud_pw1").val() != $("#ud_pw1R").val()) {
                btn.button("disable");
                errorMatch.show();
            }
            else if (pwp.length && pwp.val().length === 0) {
                btn.button("disable");
            }
            else if (pwp.length && pwp.val().indexOf(" ") !== -1) {
                btn.button("disable");
                errorPwp.show();
            }
            else {
                btn.button(disable ? "disable" : "enable");
            }
        }
        setUserData(userId, jsonParam, userAddedCb, noUserAddedCb, signOut = true) {
            let res = $.Deferred();
            globals_1.restConnection.putServer("user/" + userId, {
                json: jsonParam
            }).done(function (result) {
                if (userAddedCb) {
                    userAddedCb();
                }
                if (signOut) {
                    globals_1.matrixSession.signOut(false);
                    matrixlib_1.ml.UI.showSuccess("The password has been updated!");
                }
                res.resolve();
            }).fail(function (errorMsg) {
                matrixlib_1.ml.UI.showError("Failed to create user!", errorMsg);
                if (noUserAddedCb) {
                    noUserAddedCb();
                }
                res.reject();
            });
            return res;
        }
        getUserDetailsHTML(mode, tablewidth) {
            let disable = mode == "useredit" ? "disabled" : "";
            return '<div class="container" style="width:100%;white-space:nowrap;">' +
                '<fieldset><legend>User info</legend><table id="userPrefTable" style="width:100%" >' +
                '  <tr><td colspan="2" class="baseControlHelp">Sign-In</td></tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"><label for="ud_login" class="control-label">User Id</label></td>' +
                '    <td class="admin_utdr"><input autocomplete="off" type="text" class="form-control" id="ud_login" placeholder="User id"></td>' +
                '  </tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"><label for="ud_firstName" class="control-label">First Name</label></td>' +
                '    <td class="admin_utdr"><input autocomplete="off" type="text" class="form-control" id="ud_firstName" placeholder="First name" ' + disable + '></td>' +
                '  </tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"><label for="ud_lastName" class="control-label">Last Name</label></td>' +
                '    <td class="admin_utdr"><input autocomplete="off" type="text" class="form-control" id="ud_lastName" placeholder="Last name" ' + disable + '></td>' +
                '  </tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"><label for="ud_email" class="control-label">Email</label></td>' +
                '    <td class="admin_utdr"><input autocomplete="off" type="text" class="form-control" id="ud_email" placeholder="Email" ' + disable + '></td>' +
                '  </tr>' +
                '  <tr  id="ud_pw1_line">' +
                '    <td class="admin_utdl"><label autocomplete="new-password" for="ud_pw1" class="control-label">Password for Login</label>' +
                //'       <button class="btn btn-default btn-xs pwgen" data-target="ud_pw1" id="ud_cpw1" >create</button>' +
                '    </td>' +
                '    <td class="admin_utdr"><input autocomplete="new-password" type="password" class="form-control" id="ud_pw1" placeholder="password"></td>' +
                '  </tr>' +
                '  <tr  id="ud_pw1R_line">' +
                '    <td class="admin_utdl"><label autocomplete="new-password" for="ud_pw1R" class="control-label">Repeat</label>' +
                '    </td>' +
                '    <td class="admin_utdr"><input autocomplete="new-password" type="password" class="form-control" id="ud_pw1R" placeholder="repeat">' +
                '         <div id="errorMatch" style="color:red;">passwords do not match</div></td>' +
                '  </tr>' +
                //'  <tr><td colspan="2" class="baseControlHelp">Electronic Signatures</td></tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"><label class="control-label">Signature Image</label></td>' +
                '    <td class="admin_utdr">' +
                '       <span id="ud_currentImg"></span>' +
                '       <label for="ud_signatureImageChange" style="color:blue;font-weight:normal;cursor:pointer">select signature image</label>' +
                '       <input accept="image/JPEG,image/GIF,image/PNG,image/BMP" style="display:none" type="file" id="ud_signatureImageChange">' +
                '       <input autocomplete="off" style="display:none" type="text" id="ud_signatureImage">' +
                '    </td>' +
                '  </tr>' +
                '  <tr>' +
                '    <td class="admin_utdl"></td>' +
                '    <td class="admin_utdr">' +
                '    </td>' +
                '  </tr>' +
                '  <tr id="ud_pw2_line">' +
                '    <td class="admin_utdl"><label for="ud_pw2" class="control-label">Password for eSignatures</label>' +
                //'       <button class="btn btn-default btn-xs pwgen" data-target="ud_pw2" id="ud_cpw2" >create</button>' +
                '    </td>' +
                '    <td class="admin_utdr"><input type="password" class="form-control" id="ud_pw2" placeholder="password"></td>' +
                '  </tr>' +
                '  <tr class="admin_line"><td colspan="2" class="baseControlHelp">Server Administration Rights</td></tr>' +
                '  <tr class="admin_line">' +
                '    <td class="admin_utdl" colspan="2" > <div class="checkbox"><label><input id="ud_customerAdmin" type="checkbox"> is administrator</label></div></td>' +
                '  </tr>' +
                '  </table></fieldset><br/>' +
                '<fieldset id="userPref"><legend>User preferences</legend></fieldset>';
        }
        generatePassword(btn) {
            var keylist1 = "ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwxyz123456789_@?+-";
            var keylist2 = "_@?+-";
            function gp(chars, count) {
                var pwd = '';
                for (var idx = 0; idx < count; idx++) {
                    pwd += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return pwd;
            }
            var pw = gp(keylist1, 11) + gp(keylist2, 1) + gp(keylist1, 3);
            if (btn) {
                var target = btn.data("target");
                $("#" + target).val(pw);
                // make readable
                $("#" + target).get(0).type = 'text';
            }
            return pw;
        }
    }
    exports.UserControl = UserControl;
    UserControl.TOKEN_CONFIG = "settingsToken";
    UserControl.EMAILNOTIF_CONFIG = "emailNotificationReminders";
    var userControls = new UserControl();
    exports.userControls = userControls;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 40 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.Email = void 0;
    // makes an email field with validation out of an input field
    class Email {
        constructor(e) {
            this.element = $(e);
            this.resultBox = $("<div>");
            this.resultBox.css("color", "red");
            this.element.parent().append(this.resultBox);
            this.element.keyup(() => this.validate());
        }
        isOK() {
            return this.validate();
        }
        validate() {
            var name = this.element.val();
            if (name === "") {
                this.resultBox.html('email is required and cannot be empty');
                this.resultBox.show();
                return false;
            }
            if (/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(name)) {
                this.resultBox.hide();
                return true;
            }
            this.resultBox.html('This is not a correct email');
            this.resultBox.show();
            return false;
        }
    }
    exports.Email = Email;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 41 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.StrongPass = void 0;
    class StrongPass {
        constructor(element, param) {
            let defaultOptions = {
                minChar: 6,
                passIndex: 3,
                // output verdicts, colours and bar %
                label: 'Password strength: ',
                verdicts: ["Error: Too Short", "Error: far too weak", "Error: very weak", "Error: still very weak", "Error: too weak", "Error: still too weak"],
                colors: ['#ccc', '#500', '#800', '#f60', '#050', '#0f0'],
                width: ['0%', '10%', '30%', '60%', '80%', '100%'],
                // tweak scores here
                scores: [10, 15, 25, 45],
                passFail: (result) => { },
                other: ""
            };
            this.bannedPasswords = [
                // see study here: http://smrt.io/JlNfrH
                '123456', '12345', '123456789', 'password', 'iloveyou', 'princess', 'rockyou', '1234567', '12345678', 'abc123', 'nicole',
                'daniel', 'babygirl', 'monkey', 'jessica', 'lovely', 'michael', 'ashley', '654321', 'qwerty', 'password1', 'welcome', 'welcome1',
                'password2', 'password01', 'password3', 'p@ssw0rd', 'passw0rd', 'password4', 'password123', 'summer09', 'password6',
                'password7', 'password9', 'password8', 'welcome2', 'welcome01', 'winter12', 'spring2012', 'summer12', 'summer2012'
            ];
            this.checks = [
                /* alphaLower */ {
                    re: /[a-z]/,
                    score: 1
                },
                /* alphaUpper */ {
                    re: /[A-Z]/,
                    score: 5
                },
                /* mixture of upper and lowercase */ {
                    re: /([a-z].*[A-Z])|([A-Z].*[a-z])/,
                    score: 2
                },
                /* threeNumbers */ {
                    re: /(.*[0-9].*[0-9].*[0-9])/,
                    score: 7
                },
                /* special chars */ {
                    re: /.[!@#$%^&*?_~]/,
                    score: 5
                },
                /* multiple special chars */ {
                    re: /(.*[!@#$%^&*?_~].*[!@#$%^&*?_~])/,
                    score: 7
                },
                /* all together now, does it look nice? */ {
                    re: /([a-zA-Z0-9].*[!@#$%^&*?_~])|([!@#$%^&*?_~].*[a-zA-Z0-9])/,
                    score: 3
                },
                /* password of a single char sucks */ {
                    re: /(.)\1+$/,
                    score: 2
                }
            ];
            this.resultBox = $("<div>");
            this.options = matrixlib_1.ml.JSON.mergeOptions(defaultOptions, param);
            this.element = $(element);
            this.createBox();
            this.attachEvents();
        }
        setPassIndex(newIndex) {
            this.options.passIndex = newIndex;
            this.runPassword();
        }
        isOK() {
            return this.runPassword();
        }
        attachEvents() {
            // only attach events once 
            this.element.keyup(() => this.runPassword());
        }
        createBox() {
            this.element.parent().append(this.resultBox);
        }
        runPassword() {
            var password = this.element.val();
            this.resultBox.html("");
            let score = this.checkPassword(password);
            let index = 0;
            let s = matrixlib_1.ml.JSON.clone(this.options.scores);
            let verdict;
            if (this.bannedPasswords.indexOf(password.toLowerCase()) !== -1) {
                this.resultBox.append("Error: banned password");
                this.resultBox.css("color", "red");
                this.resultBox.show();
                this.options.passFail(false);
                return false;
            }
            else if (password === "") {
                this.resultBox.append("you must enter a password");
                this.resultBox.css("color", "red");
                this.resultBox.show();
                this.options.passFail(false);
                return false;
            }
            else if (password !== "" && password.indexOf(" ") !== -1) {
                this.resultBox.append("spaces are not allowed in password");
                this.resultBox.css("color", "red");
                this.resultBox.show();
                this.options.passFail(false);
                return false;
            }
            else if (password !== "" && this.options.other !== "" && $(this.options.other).val() === password) {
                this.resultBox.append("login and signature password must be different");
                this.resultBox.css("color", "red");
                this.resultBox.show();
                this.options.passFail(false);
                return false;
            }
            else {
                if (score < 0 && score > -199) {
                    index = 0;
                }
                else {
                    s.push(score);
                    s.sort(function (a, b) {
                        return a - b;
                    });
                    index = s.indexOf(score) + 1;
                }
                var passed = index >= this.options.passIndex;
                if (passed) {
                    this.resultBox.hide();
                }
                else {
                    verdict = this.options.verdicts[index] || this.options.verdicts[this.options.verdicts.length - 1];
                    this.resultBox.append("Score " + score + " verdict " + verdict);
                    this.resultBox.css("color", passed ? "black" : "red");
                    this.resultBox.show();
                }
                this.options.passFail(passed);
                return passed;
            }
        }
        ;
        checkPassword(pass) {
            let score = 0;
            let minChar = this.options.minChar;
            let len = pass.length;
            let diff = len - minChar;
            (diff < 0 && (score -= 100)) || (diff >= 5 && (score += 18)) || (diff >= 3 && (score += 12)) || (diff === 2 && (score += 6));
            $.each(this.checks, function (idx, check) {
                pass.match(check.re) && (score += check.score);
            });
            // bonus for length per char
            score && (score += len);
            return score;
        }
    }
    exports.StrongPass = StrongPass;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 42 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.User = void 0;
    class User {
        constructor(el) {
            this.element = $(el);
            this.resultBox = $("<div>");
            this.resultBox.css("color", "red");
            this.element.parent().append(this.resultBox);
            this.element.keyup(() => this.validate());
        }
        isOK() {
            return this.validate();
        }
        validate() {
            var name = this.element.val();
            if (name === "") {
                this.resultBox.html("The user id is required and cannot be empty");
                this.resultBox.show();
                return false;
            }
            if (name.length < 1 || name.length > 30) {
                this.resultBox.html('The user id must be at least 1 and at most 30 characters long');
                this.resultBox.show();
                return false;
            }
            if (/^[a-zA-Z0-9_\.\-]+$/.test(name)) {
                this.resultBox.hide();
                return true;
            }
            this.resultBox.html('The user id can only consist of letters, dots, digits, dash and underscores');
            this.resultBox.show();
            return false;
        }
    }
    exports.User = User;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 43 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference types="matrixrequirements-type-declarations" />
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(18), __webpack_require__(21), __webpack_require__(10), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, matrixlib_1, ItemForm_1, MainTree_1, RefLinkDefines_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.HistoryTools = void 0;
    ;
    ;
    ;
    class HistoryTools {
        constructor() {
            this.lastWasTimewarp = false;
            this.scrollInstalled = false;
            this.panelIdCounter = 0;
            this.controls = [];
        }
        onNewResult(cb) {
            this.onNewResultCallback = cb;
        }
        compareLatest(itemId) {
            let that = this;
            globals_1.app.getItemAsync(itemId).done(function (item) {
                that.showHistoryDialog({ item: item, preselect: [0, item.history.length], readOnly: !globals_1.app.canEditItem(item) });
            });
        }
        compare(fullVersion) {
            let that = this;
            var i0 = matrixlib_1.ml.Item.parseRef(fullVersion);
            globals_1.app.getItemAsync(i0.id).done(function (item) {
                that.showHistoryDialog({ item: item, preselect: [i0.version - 1, i0.version], readOnly: !globals_1.app.canEditItem(item) });
            });
        }
        compareVersions(itemId, oldVersion, newVersion) {
            let that = this;
            globals_1.app.getItemAsync(itemId).done(function (item) {
                that.showHistoryDialog({ item: item, preselect: [oldVersion, newVersion], readOnly: !globals_1.app.canEditItem(item) });
            });
        }
        // compare what is in current editor against what is in database now
        diffAgainstLatest(localChanges) {
            let that = this;
            globals_1.app.getItemAsync(globals_1.app.getCurrentItemId()).done(function (item) {
                // make a copy of item and copy in all the changes from the UI
                let copyOfItem = matrixlib_1.ml.JSON.clone(item);
                $.each(copyOfItem, function (key, _val) { if (localChanges[key] != null)
                    copyOfItem[key] = localChanges[key]; if (localChanges["fx" + key] != null)
                    copyOfItem[key] = localChanges["fx" + key]; });
                copyOfItem.title = localChanges.title;
                // compare the item against the UI
                that.showDiffDialog(item, copyOfItem);
            });
        }
        showDeletedItems(ctrl) {
            let that = this;
            globals_1.app.itemForm.prepend(matrixlib_1.ml.UI.getPageTitle("Deleted Items"));
            if (matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                $(".toolbarButtons .buttonCTA").remove();
                $(".toolbarButtons").append(matrixlib_1.ml.UI.DateTime.getTimeZoneCTA());
            }
            var control = $('<div class="panel-body-v-scroll fillHeight"></div>');
            ctrl.append(control);
            var accordion = $('<div class="panel-group history-panel-group" id="accordion"></div>');
            control.append(accordion);
            var progressBar = $('<div style="height:4px;"></div><div class="progress progress-striped active">' +
                '  <div name="progress-bar" class="progress-bar"  role="progressbar" aria-valuenow="1" aria-valuemin="0" aria-valuemax="100" style="width:1%">' +
                '    <span class="sr-only"></span>' +
                '  </div>' +
                '</div>');
            control.append(progressBar);
            progressBar.hide();
            var rendered = 0;
            var showDelayed = window.setTimeout(function () { progressBar.show(); }, 1000); // wait for 1 second to show a progress bar
            globals_1.app.getDeletedItemsAsync(function (item) {
                rendered++;
                let panel = that.createPanel({
                    deletedItems: true,
                    ctrl: control,
                    id: item.id,
                    title: item.title,
                    isFolder: false,
                    version: item.version,
                    user: item.user,
                    action: "",
                    dateServer: item.date,
                    date: item.dateUserFormat,
                    comment: item.comment,
                    allowRestore: true,
                    fullVersion: item.fullVersion,
                    auditId: item.auditId,
                    tags: item.tags
                });
                accordion.append(panel);
                // add timewarp info 
                if (globals_1.globalMatrix.ItemConfig.isAfterTimeWarp(item.date)) {
                    that.lastWasTimewarp = true;
                    panel.addClass("timewarp");
                }
                else if (that.lastWasTimewarp) {
                    that.lastWasTimewarp = false;
                    panel.addClass("justAfterTimewarp");
                }
            }, function (progress) {
                $("div[name=progress-bar]", progressBar).data("valuenow", progress).width(progress + "%");
            }).done(function (_total) {
                clearTimeout(showDelayed);
                progressBar.hide();
                if (rendered === 0) {
                    control.append("<p style='padding:8px;margin-top:8px;'>There are no deleted items in this project</p>");
                }
            });
        }
        showActivity(ctrl, auditIdMin, auditIdMax) {
            let that = this;
            if (matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                $(".toolbarButtons .buttonCTA").remove();
                $(".toolbarButtons").append(matrixlib_1.ml.UI.DateTime.getTimeZoneCTA());
            }
            var control = $('<div class="panel-body-no-scroll">');
            ctrl.append(control);
            var accordion = $('<div class="panel-group history-panel-group" id="accordion">');
            control.append(accordion);
            control.append(matrixlib_1.ml.UI.getSpinningWait());
            let thisIstheEnd = $("<div id='endOfIt' style='text-align:center; margin:10px; display:none;'> the end! </div>");
            control.append(thisIstheEnd);
            let loadMoreDiv = $("<div style='text-align:right;'  ><a id='loadMore' style='display:block; text-align:right, width:100%;margin:10px; cursor:pointer;text-decoration:underline; '> Load more... </a></div>");
            control.append(loadMoreDiv);
            let loading = false;
            let loadMore = ((_t) => {
                console.log('Loading more into calendar');
                if (!loading) {
                    loadMoreDiv.show();
                    if (that.pFrom + that.pCount < that.pTotal) {
                        if (($("#accordion").height() - $(".change-result").scrollTop()) < ($(".change-result").height() + 30)) {
                            loading = true;
                            thisIstheEnd.hide();
                            $(".spinningWait", control).replaceWith(matrixlib_1.ml.UI.getSpinningWait());
                            that.showNextActivity(accordion, control, that.pFrom + that.pCount, that.pCount)
                                .always(() => {
                                loading = false;
                                if (that.onNewResultCallback != undefined) {
                                    that.onNewResultCallback();
                                }
                                loadMoreDiv.show();
                            });
                        }
                    }
                    else {
                        thisIstheEnd.show();
                        loadMoreDiv.hide();
                    }
                }
            });
            this.showNextActivity(accordion, control, 0, 200, auditIdMin, auditIdMax).then(() => {
                if (that.pTotal == 0) {
                    $(".calendar-wrapper .spinningWait").hide();
                    $("<div>No changes </div>").insertAfter($(".change-result h1"));
                    thisIstheEnd.hide();
                    loadMoreDiv.hide();
                }
                if (that.onNewResultCallback != undefined) {
                    that.onNewResultCallback();
                }
                if (!that.scrollInstalled) {
                    $("#loadMore").click(loadMore);
                    $(".change-result").on("scroll", loadMore);
                    that.scrollInstalled = true;
                }
                if (!loading) {
                    $(".spinningWait", control).hide();
                    $("#loadMore").show();
                }
            });
        }
        showReadersDigest(ctrl) {
            globals_1.app.itemForm.prepend(matrixlib_1.ml.UI.getPageTitle("Document Changes and Downloads"));
            if (matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                $(".toolbarButtons .buttonCTA").remove();
                $(".toolbarButtons").append(matrixlib_1.ml.UI.DateTime.getTimeZoneCTA());
            }
            var control = $('<div class="panel-body-v-scroll  fillHeight" style="margin:0 12px">');
            ctrl.append(control);
            var doclist = $('<div>');
            control.append(doclist);
            control.append(matrixlib_1.ml.UI.getSpinningWait());
            this.readHistory = {};
            this.showNextReaders(doclist, control, 0, 100);
        }
        renderButtons(options) {
            var button = $("<div  class='btn-group'><button id='historyDlgBtn' tabindex='-1' title data-original-title='History' class='btn btn-item'> <span class='fal fa-history'></span></button></div>");
            var data = {
                id: options.id,
                item: options.item,
                isFolder: options.isFolder,
                readOnly: options.readOnly
            };
            button.click(() => this.showHistoryDialog(data));
            options.control.append(button);
        }
        ;
        createPanel(options) {
            let that = this;
            this.panelIdCounter++;
            var icon = $('<i class="hideCopy fal fa-chevron-right"></i>');
            var ir = matrixlib_1.ml.Item.parseRef(options.id);
            var itemDisp = $("<span ></span>");
            if (options.isFolder) {
                globals_1.app.getItemAsync(options.id, options.version).done(function (data) {
                    itemDisp.refLink({
                        id: options.id,
                        title: data.title,
                        style: RefLinkDefines_1.refLinkStyle.show,
                        tooltip: RefLinkDefines_1.refLinkTooltip.none
                    });
                });
                itemDisp.addClass('history-header');
                itemDisp.addClass('key-' + options.id);
            }
            if (options.title) {
                itemDisp = $('<span class="history-header key-' + options.id + '"><b>' + options.id + ' ' + options.title + '</span>');
            }
            var versionInfo = $("<span ></span>");
            if (options.deletedItems || options.action === "delete") {
                versionInfo = $('<span class="history-header "><span class="historyPanelDeletedInfo historyPanelActionInfo">deleted</span> by <span class="historyPanelUserInfo">' + options.user + '</span></span>');
            }
            else {
                let action = options.action == "undelete" ? "restore" : options.action;
                versionInfo = $('<span class="history-header">Version <span class="historyPanelVersionInfo">' + options.version + '</span> - <span class="historyPanelActionInfo">' + action + '</span> by <span class="historyPanelUserInfo">' + options.user + '</span></span>');
            }
            var tags = $("<span class='taglist'>");
            var tag_labels = [];
            if (options.tags) {
                $.each(options.tags, function (_idx, et) {
                    tag_labels.push("[" + et.label + "]");
                });
                tags.html(tag_labels.join(', '));
            }
            var rollback = $('<a class="history-header history-restore">' + 'restore' + '</a>').click(function (event) {
                event.stopPropagation();
                var version;
                if (options.deletedItems) {
                    $(event.delegateTarget).parent().parent().parent().parent().parent().hide();
                }
                else {
                    version = options.version;
                }
                globals_1.app.restoreItemAsync(options.id, options.title, version).done(function (result) {
                    if (result) {
                        if (options.deletedItems) {
                            var parent = result.response.newParent;
                            MainTree_1.NavigationPanel.openFolder(parent, true);
                        }
                        else {
                            globals_1.app.dlgForm.dialog("close");
                        }
                        index_2.MR1.triggerAfterRestore(options.id);
                    }
                });
                return false;
            });
            var compare = $('<a class="hideCopy history-header history-restore activityViewChanges">' + 'view changes' + '</a>').click(function (event) {
                event.stopPropagation();
                var ht = new HistoryTools();
                ht.compare($(event.delegateTarget).data("fullVersion"));
                return false;
            }).data("fullVersion", options.fullVersion);
            var tag = $('<a class="hideCopy history-header history-restore activityTag">' + 'tag version' + '</a>').click(function (event) {
                event.stopPropagation();
                var auditId = $(event.delegateTarget).data("auditId");
                that.createTag(auditId, (label) => {
                    tag_labels.push("[" + label + "]");
                    tags.html(tag_labels.join(', '));
                    matrixlib_1.ml.UI.showSuccess("Tag has been created");
                });
                return false;
            }).data("auditId", options.auditId);
            var deletedAtDate = "";
            if (options.deletedate) {
                deletedAtDate = '<div style="color: darkgray;"><div class="fal fa-trash-alt" /> ' + options.deletedate + '</div>';
            }
            var date = that.createDateInfo(options.date, deletedAtDate);
            var header = $('<span name="collapseOne' + this.panelIdCounter + '"></span>');
            var comment = that.createCommentInfo(options.comment);
            header.append(icon);
            header.append(itemDisp);
            header.append("<span class='hideScreen'>&nbsp;</span>");
            header.append(versionInfo);
            var tools = $("<div class='hideCopy pull-right'>");
            date.append(tools);
            if (options.action === "edit" || options.action === "reviewed") {
                if (!options.id || !matrixlib_1.ml.Item.parseRef(options.id).isFolder) {
                    tools.append(compare);
                }
            }
            if (options.allowRestore && globals_1.matrixSession.isEditor()) {
                tools.append(rollback);
            }
            if (options.auditId) {
                tools.append(tag);
                tools.append(tags);
            }
            header.append(date);
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading history-panel">' +
                '    </div>' +
                '    <div name="collapseOne' + this.panelIdCounter + '" class="hideCopy panel-collapse collapse">' +
                '      <div class="panel-body"></div>' +
                '    </div>' +
                '  </div>');
            if (ir.isFolder && options.action !== "touch") {
                icon.css("color", "transparent");
            }
            else {
                panel.css("cursor", "pointer");
            }
            let toggleOptions = {
                ctrl: options.ctrl,
                id: options.id,
                version: options.version,
                panelId: this.panelIdCounter,
                auditId: options.auditId,
                action: options.action
            };
            $(".panel-heading", panel).append(header).append(comment).click(() => this.toggle(toggleOptions));
            if (tags.html()) {
                $(".panel-heading", panel).append($("<span class='hideScreen'><i>Tags: </i></span>").append(tags.html()));
            }
            panel.append("<div class='hideScreen'>&nbsp;</div>");
            return panel;
        }
        createDateInfo(date, deletedAtDate) {
            return $('<span class="pull-right" style="text-align:right;"><div><span class="hideScreen"><i>Change Date: </i></span>' + date + '</div>' + (deletedAtDate ? deletedAtDate : "") + '</span>');
        }
        createCommentInfo(comment) {
            return $("<div class='historyComment'>").html("<span class='hideScreen'><i>Comment: </i></span>" + comment).highlightReferences();
        }
        createTag(auditId, update) {
            const okButtonSelector = "div.ui-dialog[aria-describedby=newTagDialog] > .ui-dialog-buttonpane > .ui-dialog-buttonset > .btnDoIt";
            function tagStatusChange() {
                var okButton = $(okButtonSelector);
                if (tagLabel.getController().getValue() !== "" && tagLabel.getController().getValue() !== "") {
                    okButton.prop("disabled", false);
                    okButton.removeClass("ui-state-disabled");
                }
                else {
                    okButton.prop("disabled", true);
                    okButton.addClass("ui-state-disabled");
                }
            }
            let newTagDlg = $("<div id='newTagDialog'>").appendTo("body");
            let newTagContent = $("<div>");
            var tagLabel = $("<div id='tagLabel'>").plainText({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Tag Name",
                fieldValue: "",
                valueChanged: function () {
                    tagStatusChange();
                },
                parameter: {
                    rows: 1
                }
            });
            newTagContent.append(tagLabel);
            var tagComment = $("<div id='tagComment'>").plainText({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Tag Comment",
                fieldValue: globals_1.matrixSession.getComment(),
                valueChanged: function () {
                    tagStatusChange();
                },
                parameter: {
                    allowResize: false,
                    rows: 9,
                }
            });
            newTagContent.append(tagComment);
            matrixlib_1.ml.UI.showDialog(newTagDlg, "Create Tag", newTagContent, -730, -400, [{
                    text: 'Ok',
                    class: 'btnDoIt',
                    click: function () {
                        globals_1.restConnection.postProject("tag", {
                            label: tagLabel.getController().getValue(),
                            auditId: auditId,
                            comments: tagComment.getController().getValue(),
                            type: "tag"
                        }).done(function () {
                            update(tagLabel.getController().getValue());
                        }).fail(function (jqxhr, textStatus, error) {
                            if (jqxhr && jqxhr.responseText && jqxhr.responseText.indexOf("This tag already exists for this project") !== -1) {
                                matrixlib_1.ml.UI.showError("Could not create tag", "A tag with this label already exist");
                            }
                            else {
                                matrixlib_1.ml.UI.showError("Could not create tag", "Status:" + textStatus + ". Error was:" + error);
                            }
                        });
                        newTagDlg.dialog("close");
                    }
                }, {
                    text: 'Cancel',
                    class: 'btnCancelIt',
                    click: function () {
                        newTagDlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, false, false, () => {
                //close
                newTagDlg.remove();
            }, () => {
                // open
                tagStatusChange();
            });
        }
        createReportLine(options) {
            let that = this;
            //  id: item.id,
            //        title: item.title,
            //        version: item.version,
            //         user: item.user,
            //        date: item.date 
            //        job:number or empty in case the report has been removed
            var icon = $('<span class="fal fa-list-alt downloadFile"></span>');
            var downloadText = $("");
            // if job is 1 week or less show download button / otherwise the file will be gone
            if (options.job && options.dateServer && (new Date().getTime() - new Date(options.dateServer).getTime() < 7 * 24 * 60 * 60 * 1000)) {
                icon.css("cursor", "pointer").click(function () {
                }).tooltip({
                    title: "document creation",
                    placement: 'bottom'
                });
                downloadText = $('<span class="hideCopy history-header history-restore pull-right downloadFile">&nbsp;<a href="javascript:void(0)">download</a></span>').click(function () {
                    that.downloadReport(options.job);
                });
            }
            else {
                icon.css("cursor", "pointer").tooltip({
                    title: "document creation",
                    placement: 'bottom'
                });
            }
            var itemDisp = $('<span class="history-header key-' + options.id + '"><b>' + options.id + '</b> ' + options.title + '</span>');
            var versionInfo = $('<span class="history-header"><span class="hideScreen">&nbsp;</span>(Version ' + options.version + ') - was <span class="historyPanelActionInfo">produced</span> by ' + options.user + '</span>');
            var date = that.createDateInfo(options.date, null);
            var extraline = $("<div class='historyComment'>").html("&nbsp;");
            var tools = $("<div class='hideCopy' >");
            date.append(tools);
            tools.append(downloadText);
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading-report panel-heading history-panel">' +
                '    </div>' +
                '  </div>');
            $(".panel-heading", panel).append(icon).append(itemDisp).append(versionInfo).append(date).append(extraline);
            return panel;
        }
        createExecuteLine(options) {
            //  id: item.id,
            //        title: item.title,
            //        version: item.version,
            //         user: item.user,
            //        date: item.date 
            //        job:number or empty in case the report has been removed
            var icon = $('<span class="fal fa-exchange"></span>');
            var itemDisp = $('<span class="history-header key-' + options.id + '"><b>' + options.id + '</b> ' + options.title + '</span>');
            var versionInfo = $('<span class="history-header"><span class="historyPanelUserInfo">' + options.user + '</span> <span class="historyPanelActionInfo">created test forms</span></span>');
            var date = this.createDateInfo(options.date, null);
            var extraline = $("<div class='historyComment'>").html("&nbsp;");
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading-report panel-heading history-panel">' +
                '    </div>' +
                '  </div>');
            $(".panel-heading", panel).append(icon).append(itemDisp).append(versionInfo).append(date).append(extraline);
            return panel;
        }
        createReferenceLine(options) {
            var icon = options.added ? $('<span class="fal fa-link">') : $('<span class="fal fa-unlink">');
            var action = options.added ? "Added" : "Deleted";
            var itemDisp = $('<span class="history-header key-' + options.fromId + '"><b>' + options.fromId + '</b> ' + action + ' link to <b>' + options.toId + '</b></span>');
            var versionInfo = $('<span class="history-header"><span class="hideScreen">&nbsp;</span>- by ' + options.user + '</span></span>');
            var date = this.createDateInfo(options.dateUserFormat, null);
            var extraline = this.createCommentInfo(options.comment);
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading-report panel-heading history-panel">' +
                '    </div>' +
                '  </div>');
            $(".panel-heading", panel).append(icon).append(itemDisp).append(versionInfo).append(date).append(extraline);
            panel.append("<div class='hideScreen'>&nbsp;</div>");
            return panel;
        }
        createSignLine(options) {
            //  id: item.id,
            //        title: item.title,
            //        version: item.version,
            //         user: item.user,
            //        date: item.date 
            //        job:number or empty in case the report has been removed
            var icon = $('<span class="fal fa-pencil"></span>');
            var itemDisp = $('<span class="history-header key-' + options.id + '"><b>' + options.id + '</b> ' + options.title + '</span>');
            var versionInfo = $('<span class="history-header"><span class="hideScreen">&nbsp;</span>- was <span class="historyPanelActionInfo">' + (typeof options.reason != 'undefined' ? options.reason : "signed") + '</span></span>');
            var date = this.createDateInfo(options.date, null);
            var extraline = $("<div class='historyComment'>").html("&nbsp;");
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading-report panel-heading history-panel">' +
                '    </div>' +
                '  </div>');
            $(".panel-heading", panel).append(icon).append(itemDisp).append(versionInfo).append(date).append(extraline);
            return panel;
        }
        createMergeLine(options) {
            //        user: item.user,
            //        date: item.date 
            //        job:number or empty in case the report has been removed
            this.panelIdCounter++;
            let icon = $('<span style="cursor:pointer" class="fal fa-code-merge"></span>');
            let itemDisp = $('<span class="history-header"><b>' + 'MERGE' + '</b></span>');
            let versionInfo = $('<span class="history-header"><span class="hideScreen">&nbsp;</span>- by ' + options.user + '</span></span>');
            let date = this.createDateInfo(options.date, null);
            let header = $('<span name="collapseOne' + this.panelIdCounter + '"></span>');
            let comment = this.createCommentInfo(options.comment);
            header.append(icon);
            header.append(itemDisp);
            header.append(versionInfo);
            let tools = $("<div class='hideCopy pull-right'>");
            let tags = $("<span class='taglist'>");
            let tag_labels = [];
            if (options.tags) {
                $.each(options.tags, function (_idx, et) {
                    tag_labels.push("[" + et.label + "]");
                });
                tags.html(tag_labels.join(', '));
            }
            date.append(tools.append(tags));
            header.append(date);
            var panel = $('<div class="panel panel-default">' +
                '    <div class="panel-heading history-panel">' +
                '    </div>' +
                '    <div name="collapseOne' + this.panelIdCounter + '" class="hideCopy panel-collapse collapse">' +
                '      <div class="panel-body"></div>' +
                '    </div>' +
                '  </div>');
            panel.css("cursor", "pointer");
            let toggleOptions = {
                ctrl: options.ctrl,
                id: null,
                version: null,
                panelId: this.panelIdCounter,
                auditId: options.auditId,
                action: options.action
            };
            $(".panel-heading", panel).append(header).append(comment).click(() => this.toggle(toggleOptions));
            return panel;
        }
        downloadReport(jobNumber) {
            globals_1.app.getReportDetails(jobNumber).done(function (progress) {
                globals_1.app.download(jobNumber, progress.jobFile[progress.jobFile.length - 1].jobFileId);
            });
        }
        toggle(options) {
            let that = this;
            if (options.action !== "merge") {
                let ir = matrixlib_1.ml.Item.parseRef(options.id);
                if (ir.isFolder && options.action !== "touch") {
                    // there is no history of folders...
                    return;
                }
            }
            var tag = "collapseOne" + options.panelId;
            var panelHeader = $("span[name='" + tag + "']", options.ctrl);
            $(".fa-chevron-right", panelHeader).removeClass("fa-chevron-right").addClass("fa-chevron-up");
            $(".fa-chevron-down", panelHeader).removeClass("fa-chevron-down").addClass("fa-chevron-right");
            $(".fa-chevron-up", panelHeader).removeClass("fa-chevron-up").addClass("fa-chevron-down");
            var panel = $("div[name='" + tag + "']", options.ctrl);
            var panelBody = $(".panel-body", panel);
            if (panelBody.html() === "") {
                switch (options.action) {
                    case "touch":
                        globals_1.app.getAuditDetailsAsync(options.auditId).done(function (audit) {
                            panelBody.append("<p>The following items have been touched:</p>");
                            let actionDetails = $("<ul>");
                            $.each(audit.techAudit, function (_idx, ta) {
                                if (ta.operation === "add" && ta.table === "item_instance" && ta.ref) {
                                    actionDetails.prepend($("<li>").append(matrixlib_1.ml.Item.renderLink(ta.ref)));
                                }
                            });
                            panelBody.append(actionDetails);
                        });
                        break;
                    case "merge":
                        globals_1.app.getAuditDetailsAsync(options.auditId).done(function (audit) {
                            let mergeMain = audit.techAudit.filter(ta => ta.table == "merge_main");
                            if (mergeMain.length) {
                                let mergeId = mergeMain[0].index;
                                globals_1.restConnection.getProject("mergehistory").done((history) => {
                                    let details = history.entries.filter(his => his.id == mergeId);
                                    if (details.length) {
                                        let isMerge = globals_1.matrixSession.getBranches(globals_1.matrixSession.getProject(), "").map(info => info.branch).lastIndexOf(details[0].branchProject) != -1;
                                        if (isMerge) {
                                            panelBody.append(`<p>Merge back from branch: ${details[0].branchProject}</p>`);
                                        }
                                        else {
                                            panelBody.append(`<p>Updated from mainline: ${details[0].branchProject}</p>`);
                                        }
                                        let ul = $("<ul>").appendTo(panelBody);
                                        for (let detail of details[0].details) {
                                            index_1.BranchingHelper.addMergeDetail(ul, detail, null, isMerge);
                                        }
                                    }
                                    else {
                                        // ignore operation: "add" , table "item_link"
                                        panelBody.append(`<p>Merge back from a deleted or not accessible branch. The following has been modified:</p>`);
                                        let ul = $("<ul>").appendTo(panelBody);
                                        let links = false;
                                        let items = [];
                                        for (let change of audit.techAudit) {
                                            if (change.table == "item_link") {
                                                links = true;
                                            }
                                            else if (!change.ref || items.indexOf(change.ref) != -1) {
                                                // already registered
                                            }
                                            else {
                                                if (change.table == "item_instance") {
                                                    if (change.operation == "add") {
                                                        items.push(change.ref);
                                                    }
                                                    else if (change.operation == "invalidate") {
                                                        items.push(change.ref);
                                                    }
                                                    if (change.operation == "moved") {
                                                        items.push(change.ref);
                                                    }
                                                }
                                            }
                                        }
                                        for (let item of items) {
                                            ul.append($(`<li>Item created/update/moved/deleted: ${item}</li>`));
                                        }
                                        if (links) {
                                            ul.append($(`<li>Links have been modified</li>`));
                                        }
                                    }
                                    panelBody.highlightReferences();
                                });
                            }
                        });
                        break;
                    default:
                        globals_1.app.getItemAsync(options.id, options.version).done(function (data) {
                            var render = new ItemForm_1.ItemControl({
                                control: panelBody,
                                controlState: globals_1.ControlState.HistoryView,
                                isHistory: options.version,
                                item: data,
                                isItem: !data.children
                            });
                            that.controls.push(render);
                        });
                        break;
                }
            }
            panel.collapse('toggle');
            globals_1.app.dlgForm.resizeDlgContent(this.controls);
        }
        updateVersionPanes() {
            let that = this;
            // get all visible version panes
            var visiblePanes = $(".versionpane:visible .panel-body-v-scroll");
            // nothing is displayed
            if (visiblePanes.length < 1) {
                return;
            }
            // only one version is displayed: show without change markup
            if (visiblePanes.length == 1) {
                $(visiblePanes[0]).html($(visiblePanes[0]).parent().data("originalHTML"));
                globals_1.matrixApplicationUI.lastMainItemForm.resizeIt(true);
                that.updateRowHeights($(".slickTable", $(visiblePanes[0])));
                return;
            }
            // build data to send to compare function
            let versions = [];
            $.each(visiblePanes, function (_idx, visiblePane) {
                let rendered = $("<div>").html($(visiblePane).parent().data("originalHTML"));
                $("textarea,pre", rendered).each(function (idx, select) { $(select).replaceWith("<div>" + $(select).html().replace(/(?:\r\n|\r|\n)/g, '<br>') + "</div>"); });
                $(".fal.fa-square", rendered).each((idx, elem) => { $(elem).parent().addClass("history-unchecked"); });
                $(".fal.fa-square-square", rendered).each((idx, elem) => { $(elem).parent().addClass("history-checked"); });
                versions.push(rendered.html());
            });
            let split = this.splitVersions(versions);
            let compareParams = {
                arg: JSON.stringify(split ? { versionsMultiple: split } : { versions: versions })
            };
            // call compare
            globals_1.app.compareHTML(compareParams).done(function (compareResults) {
                $.each(visiblePanes, function (idx, visibleVersionPane) {
                    if (split) {
                        let compare = `<div class='dialog-body'>`;
                        for (let assemble = 0; assemble < compareResults.htmlMultiple.length; assemble++) {
                            compare += compareResults.htmlMultiple[assemble][idx].replace(/pull-left/g, "");
                        }
                        compare += `</div>`;
                        $(visibleVersionPane).parent().data("compareHTML", compare);
                    }
                    else {
                        $(visibleVersionPane).parent().data("compareHTML", compareResults.html[idx]);
                    }
                });
                that.renderVersionPanes();
                // make sure hyperlinks open in new view
                $(".itemTitle>a", visiblePanes).attr("target", "_blank");
            });
        }
        splitVersions(versions) {
            let split = [];
            let parts = 0;
            // split each of html blobs
            for (let version of versions) {
                let oneSplit = [];
                split.push(oneSplit);
                let all = $(version);
                for (let child of all.children().toArray()) {
                    oneSplit.push(child.outerHTML);
                }
                if (parts && oneSplit.length != parts) {
                    // items not well aligned -> don't compare section by section
                    return null;
                }
                parts = oneSplit.length;
            }
            // transpose the array
            let splitTranspose = [];
            for (let part = 0; part < parts; part++) {
                splitTranspose.push([]);
                for (let doc = 0; doc < versions.length; doc++) {
                    splitTranspose[part].push(split[doc][part]);
                }
            }
            return splitTranspose;
        }
        updateRowHeights(table) {
            // calculate real rendered heights of cells and adjust heights accordingly
            let rows = $(".slick-row", table);
            if (rows.length < 1)
                return; // nothing to update
            var cellSizer = $("<div style='padding:0px 4px 0px 4px'>");
            $("body").append(cellSizer.css("left", "-20000px"));
            let top = 0;
            $.each(rows, function (_ridx, row) {
                let columns = $(".slick-cell", $(row));
                let height = Math.max(20, $(row).height());
                $.each(columns, function (_cidx, col) {
                    //if ( $(".multiLineFormatter"),$(col) ||  $(".itemRefFormatter"),$(col) ) {
                    cellSizer.width(Math.max(10, $(col).width() - 10));
                    cellSizer.html($(col).html());
                    height = Math.max(height, cellSizer.height());
                    $(col).css("padding-top", "0").css("padding-bottom", "0");
                    //}
                    $(col).css("height", "100%");
                });
                $(row).height(height);
                $(row).css("top", top + "px");
                top += height;
            });
            cellSizer.remove();
            table.height(top + 27); // where does that number come from?
            $(".slick-viewport", table).css("height", "100%");
        }
        renderVersionPanes() {
            let that = this;
            let visiblePanes = $(".versionpane:visible  .panel-body-v-scroll");
            let titles = $(".versionpane:visible .itemTitleBarNoToolsNoEdit");
            // several versions are displayed show each with change markup
            $.each(visiblePanes, function (_idx, visiblePane) {
                $(visiblePane).html($(visiblePane).parent().data("compareHTML"));
                $.each($(".slickTable", $(visiblePane)), function (_tableIdx, table) {
                    that.updateRowHeights($(table));
                });
            });
            let visibleBodies = $(".versionpane:visible  .dialog-body");
            var count = $(visibleBodies[0]).children().length;
            // just a safety check if number of fields changes the code after would be fairly random
            for (var idx = 1; idx < visibleBodies.length; idx++) {
                if (count !== $(visibleBodies[idx]).children().length) {
                    return;
                }
            }
            // assume.... all 1+ panes have same structure: adjust heights
            for (var c = 0; c < count; c++) {
                var mh = 0;
                for (var idx = 0; idx < visibleBodies.length; idx++) {
                    var p = $($(visibleBodies[idx]).children()[c]);
                    p.css("height", "auto");
                    mh = Math.max(mh, p.height());
                }
                // run from right to left
                for (var idx = visibleBodies.length - 1; idx >= 0; idx--) {
                    var p = $($(visibleBodies[idx]).children()[c]);
                    p.height(mh);
                }
            }
            // same for version info
            visibleBodies = $(".versionpane:visible .versionInfo");
            var mh = 0;
            for (var idx = 0; idx < visibleBodies.length; idx++) {
                var p = $(visibleBodies[idx]);
                p.css("height", "auto");
                mh = Math.max(mh, p.height());
            }
            for (var idx = 0; idx < visibleBodies.length; idx++) {
                var p = $(visibleBodies[idx]);
                p.height(mh);
            }
        }
        renderItemMeat(hi, item) {
            new ItemForm_1.ItemControl({
                control: hi,
                controlState: globals_1.ControlState.HistoryView,
                isHistory: 1,
                item: item,
                isItem: true,
                parameter: {
                    manualTableHeights: true,
                    reviewMode: true // don't show outdated icons
                }
            });
            let itemDetails = $(".panel-body-v-scroll", hi);
            matrixlib_1.ml.SmartText.prepareForReadReadRender(itemDetails);
        }
        showSaveConflict(dlg, latest, localChanges) {
            let that = this;
            function showVersion(hi, item, version, userLogin) {
                $("#tellToSelect").hide();
                const userLoginDisplay = that.formatUserLogin(userLogin);
                var vi = $("<div class='versionInfo'>");
                var header = $("<div class='baseControlHelp'>Version Info</div>");
                hi.append(header);
                hi.append(vi);
                vi.append("<div class=''>Version: <span class='historyDlgVersionDetail'>" + version + "</span></div>");
                vi.append("<div class=''>User: <span class='historyDlgVersionDetail'>" + userLoginDisplay + "</span></div>");
                hi.append("<hr>");
                that.renderItemMeat(hi, item);
                hi.data("status", "show");
                hi.show();
            }
            let changeView = $("<div>").appendTo(dlg);
            $("<div class='warningMerge'>").html(`Someone changed and saved the same item (${globals_1.app.getCurrentItemId()}) while you were editing it. In order not to overwrite these changes:<br>
        <ul style="text-align: left;font-size: smaller;margin-left: 100px;">
        <li>open the changed item in another <a href='${matrixlib_1.ml.Item.parseRef(globals_1.app.getCurrentItemId()).url}' target='_blank'>tab</a></li>
        <li>copy the changes you did in this tab</li>
        <li>close this tab (to be able to edit in the other tab)</li>
        <li>manually update the item with your changes</li>`).appendTo(changeView);
            if (latest.history.length &&
                latest.history.length > 0) {
                let flex = $("<div style='display:flex;justify-content: center;'>").appendTo(changeView);
                var changed = $("<div class='versionpane'>").appendTo(flex);
                var current = $("<div class='versionpane'>").appendTo(flex);
                // latest.history is organized newest to oldest.
                showVersion(changed, latest, "New Version on Server", latest.history[0].user);
                showVersion(current, localChanges, "Your Changes", globals_1.matrixSession.getUser());
                this.updateVersionPanes();
            }
            else {
                // it's a folder
            }
        }
        compareVersionDialog(item, history, selectBar, show, allowRestore) {
            let that = this;
            var trmy = $("<tr id='historyDlgYear' style='background-color: #eee;'>");
            var last_my = "";
            var span_my = 0;
            var trday = $("<tr id='historyDlgMonth' style='background-color: #eee;'>");
            var last_day = "";
            var span_day = 0;
            var trtime = $("<tr id='historyDlgTime'>");
            var trdetails = $("<tr>");
            var tddetails = $("<td>").attr("colspan", history.length);
            trdetails.append(tddetails);
            var flex = $("<div style='display:flex;justify-content: center;'>");
            tddetails.append(flex);
            var format_my = new SimpleDateFormat("yyyy MMMM");
            var format_day = new SimpleDateFormat("d");
            var format_time = new SimpleDateFormat("HH:mm");
            let itemIsDeleted = item.isDeleted;
            let timewarpVersion = -1;
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                let treeInfo = globals_1.app.getItemFromTree(item.id);
                if (treeInfo.version) {
                    let vp = treeInfo.version.split("/");
                    timewarpVersion = Number(vp[0]);
                    itemIsDeleted = treeInfo.version.indexOf("*") != -1;
                }
            }
            for (var idx = history.length - 1; idx >= 0; idx--) {
                var date = new Date(history[idx].date);
                var my = format_my.format(date);
                var day = format_day.format(date);
                var time = format_time.format(date);
                let newMonth = false;
                if (my !== last_my) {
                    newMonth = true;
                    span_my = 1;
                    trmy.append($("<td>").html(my).css("font-weight", "bold").css("text-align", "center"));
                    last_my = my;
                }
                else {
                    span_my++;
                    $("td", trmy).last().attr("colspan", span_my);
                }
                if (day !== last_day || newMonth) {
                    span_day = 1;
                    trday.append($("<td>").html(day).css("font-weight", "bold").css("text-align", "center"));
                    last_day = day;
                }
                else {
                    span_day++;
                    $("td", trday).last().attr("colspan", span_day);
                }
                let timewarp = history[idx].version == timewarpVersion;
                let timewarpClass = "";
                if (timewarpVersion != -1) {
                    if (history[idx].version > timewarpVersion)
                        timewarpClass = " timepwarp_after";
                    if (history[idx].version == timewarpVersion)
                        timewarpClass = " timepwarp_day";
                }
                // always show very first and last one and always the last of a day
                let other_day = idx == history.length - 1 || idx == 0 || new Date(history[idx].date).getDate() != new Date(history[idx - 1].date).getDate() || timewarp;
                var time_toggle = $("<td class='historyDlgVersionPaneSelector " + (other_day ? "last_day" : "any_day") + timewarpClass + "'>").html("<div>" + time + "</div>" + "<div>rev&nbsp;" + history[idx].version + "</div>");
                time_toggle.data("rev", history[idx].version);
                time_toggle.click(function (event) {
                    let revision = $(event.delegateTarget).data("rev");
                    // update top bar
                    var hi = $("#ver" + revision);
                    $(event.delegateTarget).toggleClass("historyDlgVersionPaneSelected");
                    // update side bar
                    let selected = $(event.delegateTarget).hasClass("historyDlgVersionPaneSelected");
                    $.each($(".historyDetailLine"), function (_hrlIdx, hrl) {
                        if ($(hrl).data("rev") == revision) {
                            selected ? $(hrl).parent().addClass("historyVersionContainerSelected") : $(hrl).parent().removeClass("historyVersionContainerSelected");
                        }
                    });
                    // update panes
                    if (hi.data("status") === "show") {
                        hi.hide();
                        hi.data("status", "hide");
                        that.updateVersionPanes();
                    }
                    else if (hi.data("status") === "hide") {
                        hi.show();
                        hi.data("status", "show");
                        that.updateVersionPanes();
                    }
                    else {
                        showVersion(hi, revision);
                    }
                    if ($(".versionpane:visible").length === 0) {
                        $("#tellToSelect").show();
                    }
                    else {
                        $("#tellToSelect").hide();
                    }
                });
                trtime.append(time_toggle);
                var vp = $("<div class='versionpane' id='ver" + history[idx].version + "'>");
                vp.hide();
                flex.append(vp);
                if (show.indexOf(history[idx].version) !== -1) {
                    showVersion(vp, history[idx].version);
                    time_toggle.addClass("historyDlgVersionPaneSelected");
                }
            }
            if (itemIsDeleted) {
                trmy.append($("<td rowspan='4' style='vertical-align: middle;border: 1px solid #ddd;'>").html("<span style='color:red'>item deleted</span>"));
            }
            if (!show || show.length === 0) {
                flex.append("<div id='tellToSelect'>select revisions to be shown / compared</div>");
            }
            function showVersion(hi, r) {
                $("#tellToSelect").hide();
                var h = history[history.length - r];
                var vi = $("<div class='versionInfo'>");
                var header = $("<div class='baseControlHelp'>Version Info</div>");
                hi.append(header);
                hi.append(vi);
                vi.append("<div class=''>Version: <span class='historyDlgVersionDetail'>" + h.version + "</span></div>");
                if (h.action == "signature") {
                    vi.append("<div class=''>Action: <span class='historyDlgVersionDetail'>" + h.comment + "</span>" + "</div>");
                }
                else {
                    let restoreInfo = "";
                    if (h.deletedate) {
                        restoreInfo = (h.deletedate == h.dateUserFormat) ? " (rolled back to previous version)" : ` (was deleted on ${h.deletedate}) `;
                    }
                    vi.append("<div class=''>Action: <span class='historyDlgVersionDetail'>" + h.action + "</span>" + restoreInfo + "</div>");
                    var comment = $("<div class='' style='white-space: pre-wrap'>Comment: <span class='historyDlgVersionDetail'>" + h.comment + "</span></div>");
                    comment.highlightReferences();
                    vi.append(comment);
                    const userLoginDisplay = that.formatUserLogin(h.user);
                    vi.append("<div class=''>User: <span class='historyDlgVersionDetail'>" + userLoginDisplay + "</span></div>");
                }
                vi.append("<div class='' style='margin-bottom:4px'>Date: <span class='historyDlgVersionDetail'>" + h.dateUserFormat + "</span></div>");
                hi.append("<hr>");
                globals_1.app.getItemAsync(h.id, (r === history.length && !itemIsDeleted && !globals_1.globalMatrix.ItemConfig.getTimeWarp()) ? undefined : r).done(function (data) {
                    new ItemForm_1.ItemControl({
                        control: hi,
                        controlState: globals_1.ControlState.HistoryView,
                        isHistory: r,
                        item: data,
                        isItem: !data.children,
                        parameter: {
                            manualTableHeights: true,
                            reviewMode: true // don't show outdated icons
                        }
                    });
                    let itemDetails = $(".panel-body-v-scroll", hi);
                    matrixlib_1.ml.SmartText.prepareForReadReadRender(itemDetails);
                    that.updateVersionPanes();
                });
                var rollback = $('<a class="history-header history-restore">' + 'restore' + '</a>').click(function (event) {
                    if (event.preventDefault)
                        event.preventDefault();
                    if (event.stopPropagation)
                        event.stopPropagation();
                    var r = $(event.delegateTarget).data("ver");
                    var h = history[history.length - r];
                    globals_1.app.restoreItemAsync(h.id, h.title, r).done(function (result) {
                        if (result) {
                            index_2.MR1.triggerAfterRestore(h.id);
                            globals_1.app.dlgForm.dialog("close");
                        }
                    });
                    return false;
                }).data("ver", r);
                if (r !== history.length && globals_1.matrixSession.isEditor() && allowRestore) {
                    header.append(rollback);
                }
                hi.data("status", "show");
                hi.show();
            }
            var selectTable = $("<table class='table table-bordered' style='width:100%;border:none'>");
            var tbody = $("<tbody>");
            selectTable.append(tbody);
            tbody.append(trmy);
            tbody.append(trday);
            tbody.append(trtime);
            tbody.append(trdetails);
            if (selectBar) {
                return selectTable;
            }
            else {
                return flex;
            }
        }
        // check if item is either not specified or as expected
        checkItemId(xr, itemId) {
            if (!xr)
                return true;
            if (!xr.itemOrFolderRef)
                return true;
            return itemId == matrixlib_1.ml.Item.parseRef(xr.itemOrFolderRef).id;
        }
        formatUserLogin(userLogin) {
            return globals_1.globalMatrix.ItemConfig.hasUserInfo(userLogin) ? userLogin : `<s>${userLogin}</s>`;
        }
        formatUserName(userLogin, userName) {
            return globals_1.globalMatrix.ItemConfig.hasUserInfo(userLogin) ? userName : `<s>${userName}</s>`;
        }
        showHistoryDetails(itemId, simpleHistory, historyUnfiltered, tags) {
            let that = this;
            let inner = $("<div class='detailsHistoryContainer'>")
                .appendTo($("#detailsHistory"));
            const printAction = {
                "edit item": ["modified", "fa-pencil"],
                "reviewed item": ["reviewed", "fa-check"],
                "touch items": ["touched", "fa-hand-point-up"],
                "undelete item": ["restored", "fa-trash-restore"],
                "delete item": ["deleted", "fa-trash"],
                "add item": ["created", "fa-plus"],
                "execute tests": [" created test form", "fa-cogs"],
                "add link": ["add link", "fa-link"],
                "merge merge": ["merged", "fa-code-merge"],
                "clone project": ["project copy", "fa-copy"]
            };
            // MATRIX-4704 filter history: there's some entries which belong to other items, get rid of those
            let audit = historyUnfiltered.audit.filter(historyEntry => that.checkItemId(historyEntry.itemBefore, itemId) && that.checkItemId(historyEntry.itemAfter, itemId));
            let version = 1;
            let preVersion = 0;
            let line = null;
            let auditIdx = audit.length - 1;
            let tagIdx = 0;
            if (tags.length && tags[0].label == "base")
                tags[0].label = "Project creation";
            tags.sort(function (a, b) {
                return a.auditId - b.auditId;
            });
            let begin;
            let lastSelectionBucket = null;
            while (auditIdx >= 0 || tagIdx < tags.length) {
                if (auditIdx < 0 || (tagIdx < tags.length && tags[tagIdx].auditId < audit[auditIdx].auditId)) {
                    let tag = $(`
                    <div class='historyTagLine' title='Tagged time: ${tags[tagIdx].auditTime}'>
                        <div class="tagLabel"><span>${tags[tagIdx].label}</span></div>
                        <div class="historyIcon historyTagIcon"><i class="fal fa-tag"></i></div>
                    </div>
                `).prependTo(inner);
                    if (tags[tagIdx].label.match(/^MERGE_.*_begin$/)) {
                        begin = tag;
                    }
                    else if (begin && tags[tagIdx].label.match(/^MERGE_.*_end$/)) {
                        $(".tagLabel", begin).html(`<span>${tags[tagIdx].label.replace("_end", "_begin_end")}</span>`);
                        tag.remove();
                    }
                    tagIdx++;
                }
                else {
                    begin = null;
                    let historyEntry = audit[auditIdx];
                    let icon = "";
                    let negateIcon = false;
                    let createdSign = "";
                    let actionName = "";
                    let detail = null;
                    if (matrixlib_1.ml.Item.parseRef(itemId).type != "XTC" && historyEntry.action == "execute") {
                        // special case (XTC execution does not create a new version but it has the XTC as item after...)
                    }
                    else if (historyEntry.itemAfter && historyEntry.itemAfter.itemOrFolderRef) {
                        version = matrixlib_1.ml.Item.parseRef(historyEntry.itemAfter.itemOrFolderRef).version;
                        createdSign = (matrixlib_1.ml.Item.parseRef(historyEntry.itemAfter.itemOrFolderRef).type == "SIGN" && matrixlib_1.ml.Item.parseRef(itemId).type == "DOC") ? matrixlib_1.ml.Item.parseRef(historyEntry.itemAfter.itemOrFolderRef).id : "";
                    }
                    else {
                        let explicitVersion = simpleHistory.filter(sh => sh.date == historyEntry.dateTime);
                        if (explicitVersion.length == 1) {
                            version = explicitVersion[0].version;
                        }
                    }
                    let ad = historyEntry.action + " " + historyEntry.entity;
                    const print = printAction[ad];
                    let hideLine = false;
                    if (createdSign) {
                        actionName = "created sign";
                        detail = "Created " + createdSign;
                        version = preVersion;
                    }
                    else if (historyEntry.action == "indexer") {
                        actionName = "reindex";
                        icon = "fa-pencil";
                        historyEntry.reason = "Item updated after config change";
                    }
                    else if (historyEntry.reason == "SignReject") {
                        actionName = "rejected signature";
                        icon = "fa-pencil";
                        detail = "rejected document";
                        negateIcon = true;
                        historyEntry.reason = "";
                    }
                    else if (print) {
                        actionName = print[0];
                        icon = print[1];
                    }
                    else if (ad == "add item_link") {
                        let itemUp = historyEntry.itemUp.itemOrFolderRef;
                        let itemDown = historyEntry.itemDown.itemOrFolderRef;
                        icon = "fa-link";
                        if (itemUp == itemId) {
                            actionName = "Link down";
                            detail = "link:" + itemDown;
                        }
                        else {
                            actionName = "Link up";
                            detail = "uplink:" + itemUp;
                        }
                    }
                    else if (ad == "delete item_link") {
                        let itemUp = historyEntry.itemUp.itemOrFolderRef;
                        let itemDown = historyEntry.itemDown.itemOrFolderRef;
                        icon = "fa-unlink";
                        if (itemUp == itemId) {
                            detail = "remove link:" + itemDown;
                        }
                        else {
                            detail = "remove uplink:" + itemUp;
                        }
                    }
                    else if (ad == "signature item") {
                        icon = "fa-pencil";
                        detail = historyEntry.reason;
                        historyEntry.reason = "";
                    }
                    else if (ad == "move item") {
                        icon = "fa-arrow-right";
                        actionName = "move";
                    }
                    else if (ad == "store signed item") {
                        hideLine = true;
                    }
                    else if (ad == "document reject item") {
                        detail = "Rejected Document";
                        actionName = ad;
                        icon = "fa-pencil";
                        negateIcon = true;
                        // hack remove if server's fixed
                        if (version == preVersion)
                            version += 1;
                    }
                    else {
                        actionName = ad;
                        icon = "fa-question-circle";
                    }
                    if (actionName == "restored") {
                        detail = "restored";
                    }
                    if (!hideLine) {
                        const detailLine = detail !== null ? `<b>${detail}${historyEntry.reason ? ":" : ""}</b> ` : "";
                        const userNameDisplay = this.formatUserName(historyEntry.userLogin, globals_1.globalMatrix.ItemConfig.getFullName(historyEntry.userLogin));
                        if (version !== preVersion) {
                            lastSelectionBucket = $(`<div class="historyVersionContainer"/>`).prependTo(inner);
                        }
                        else if (actionName == "deleted") {
                            lastSelectionBucket = $(`<div class="historyVersionContainerDeleted"/>`).prependTo(inner);
                        }
                        let negate = "<i class='fal fa-slash' style='position: absolute;left: 10px;'></i>";
                        line = $(`
                        <div class='historyDetailLine'>
                            <div class="historyIcon" title="${actionName}"><i class="fal ${icon}"></i>${negateIcon ? negate : ""}</div>
                            <div class="historyDetail">
                                <span class='historyDetailAction'>${detailLine}${historyEntry.reason}</span>
                                <div class='historyDetailDate'>
                                    <span>${historyEntry.dateTimeUserFormat}</span>
                                    <span>${userNameDisplay}</span>
                                </div>                        
                            </div>
                        </div>
                    `).prependTo(lastSelectionBucket).data("rev", actionName == "deleted" ? -1 : version);
                        if (version !== preVersion) {
                            line.append($(`                        
                            <span class="historyTagContainer">
                                <a class="historyTag" title="Create Tag" data-auditid="${historyEntry.auditId}">
                                    <div class="addLabelImage"></div>
                                </a>
                            </span>
                        `));
                        }
                        else {
                            line.append($(`<span class="historyTagContainer">`));
                        }
                    }
                    preVersion = version;
                    auditIdx--;
                }
            }
            $('.historyTag').click(function (event) {
                if (event.preventDefault)
                    event.preventDefault();
                if (event.stopPropagation)
                    event.stopPropagation();
                let auditId = $(event.delegateTarget).data("auditid");
                let clickedLine = $(event.delegateTarget).closest(".historyVersionContainer");
                //TODO:[TS] Discuss with Wolfgang, this is messy, should recreate UI from state instead
                that.createTag(auditId, function (newTag) {
                    let line = $(`
                    <div class='historyTagLine'>
                        <div class="tagLabel"><span>${newTag}</span></div>
                        <div class="historyIcon historyTagIcon" title="Tagged"><i class="fal fa-tag"></i></div>
                    </div>
                `).insertBefore(clickedLine);
                    matrixlib_1.ml.UI.showSuccess("Tag has been created");
                });
                return false;
            });
            $(".historyDetailLine", inner).click(function (event) {
                let clicked = $(event.delegateTarget);
                let revision = clicked.data("rev");
                let tab = $('td.historyDlgVersionPaneSelector').filter(function (_idx, node) { return $(node).data("rev") == revision; });
                tab.trigger("click");
                if (event.preventDefault)
                    event.preventDefault();
                if (event.stopPropagation)
                    event.stopPropagation();
            });
        }
        showHistoryDialog(options) {
            let that = this;
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.addClass("dlg-no-scroll");
            globals_1.app.dlgForm.removeClass("dlg-scroll");
            let versions = this.compareVersionDialog(options.item, options.item.history, true, options.preselect ? options.preselect : [], !options.readOnly);
            let detailsVersion = $("<div class='detailsVersions'>").append(versions);
            let detailsHistory = $("<div id='detailsHistory'>");
            globals_1.app.dlgForm.append(detailsHistory).append(detailsVersion);
            if (matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                globals_1.app.dlgForm.append(matrixlib_1.ml.UI.DateTime.getTimeZoneCTA());
            }
            // prevent auto scrolling when opening dialog
            let scrollTop = $("#itemDetails > .panel-body-v-scroll").length ? $("#itemDetails > .panel-body-v-scroll")[0].scrollTop : 0;
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "History of '" + (options.id ? options.id : options.item.id) + "'",
                width: $(document).width() * 0.85,
                height: globals_1.app.itemForm.height() * 0.85,
                modal: true,
                resizeStop: function () {
                    globals_1.app.dlgForm.resizeDlgContent(that.controls);
                }, open: function () {
                    matrixlib_1.ml.UI.pushDialog(globals_1.app.dlgForm);
                    if (globals_1.app.dlgForm[0].scrollWidth > globals_1.app.dlgForm.innerWidth()) {
                        $(".any_day > div").hide();
                        // still bigger? -> scroll right
                        if (globals_1.app.dlgForm[0].scrollWidth > globals_1.app.dlgForm.innerWidth()) {
                            globals_1.app.dlgForm[0].scrollLeft = globals_1.app.dlgForm[0].scrollWidth - globals_1.app.dlgForm.innerWidth() + 10;
                        }
                    }
                    that.initHistoryOptionSelect(options.item.history, $('.cbHide'), options.id ? options.id : options.item.id);
                }, close: function () {
                    if (scrollTop)
                        $("#itemDetails > .panel-body-v-scroll")[0].scrollTop = scrollTop;
                    matrixlib_1.ml.UI.popDialog(globals_1.app.dlgForm);
                },
                buttons: [{
                        text: 'Hide ',
                        class: 'cbHide',
                        click: function () {
                        }
                    }, {
                        text: 'Ok',
                        class: 'btnOk',
                        click: function () {
                            globals_1.app.dlgForm.removeClass("dlg-scroll");
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            }).resizeDlgContent(this.controls);
        }
        ;
        initHistoryOptionSelect(history, container, itemId) {
            let that = this;
            const optionsHistoryViewSelect = ["Time Bar", "Time Bar Condensed", "Full History"];
            let currentStr = globals_1.globalMatrix.serverStorage.getItem("HistoryViewSelect");
            let current = currentStr ? Number(currentStr) : 0;
            let dropup = matrixlib_1.ml.UI.createDropDownButton("", [{
                    name: optionsHistoryViewSelect[0], click: () => { that.updateHistoryOptionSelect(history, dropup, itemId, 0, optionsHistoryViewSelect[0]); }
                }, {
                    name: optionsHistoryViewSelect[1], click: () => { that.updateHistoryOptionSelect(history, dropup, itemId, 1, optionsHistoryViewSelect[1]); }
                }, {
                    name: optionsHistoryViewSelect[2], click: () => { that.updateHistoryOptionSelect(history, dropup, itemId, 2, optionsHistoryViewSelect[2]); }
                }], true, true, "HistoryViewSelect", true);
            container.replaceWith(dropup);
            that.updateHistoryOptionSelect(history, dropup, itemId, current, optionsHistoryViewSelect[current]);
        }
        updateHistoryOptionSelect(simpleHistory, dropup, itemId, option, text) {
            let that = this;
            dropup.removeClass("open");
            $("#HistoryViewSelect").html(text);
            globals_1.globalMatrix.serverStorage.setItem("HistoryViewSelect", option + "");
            switch (option) {
                case 0:
                    $("#historyDlgYear").show();
                    $("#historyDlgMonth").show();
                    $("#historyDlgTime").show();
                    $(".any_day > div").show();
                    $("#detailsHistory").hide();
                    $("#detailsHistory").removeClass('detailsHistoryEx');
                    $(".detailsVersions").removeClass('detailsVersionsEx');
                    break;
                case 1:
                    $("#historyDlgYear").show();
                    $("#historyDlgMonth").show();
                    $("#historyDlgTime").show();
                    $("#detailsHistory").hide();
                    $(".any_day > div").hide();
                    $("#detailsHistory").removeClass('detailsHistoryEx');
                    $(".detailsVersions").removeClass('detailsVersionsEx');
                    break;
                default:
                    $("#historyDlgYear").hide();
                    $("#historyDlgMonth").hide();
                    $("#historyDlgTime").hide();
                    $("#detailsHistory").show();
                    $("#detailsHistory").addClass('detailsHistoryEx');
                    $(".detailsVersions").addClass('detailsVersionsEx');
                    if ($("div", $("#detailsHistory")).length == 0) {
                        globals_1.restConnection.getProject("tag").done(function (tags) {
                            globals_1.restConnection.getProject("audit?startAt=0&maxResults=1000&itemRef=" + itemId).done(function (history) {
                                that.showHistoryDetails(itemId, simpleHistory, history, tags);
                                // get the currently shown tabs 
                                let shown = [];
                                $.each($(".historyDlgVersionPaneSelected"), (topIdx, top) => {
                                    shown.push($(top).data("rev"));
                                });
                                // highlight them in the bar on left
                                $.each($(".historyDetailLine"), function (_hrlIdx, hrl) {
                                    if (shown.indexOf($(hrl).data("rev")) != -1) {
                                        $(hrl).parent().addClass("historyVersionContainerSelected");
                                    }
                                });
                            });
                        });
                    }
                    break;
            }
        }
        showDiffDialog(latest, localChanges) {
            let that = this;
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-scroll");
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Item changed",
                height: $(window).height() - 40,
                width: $(window).width() - 40,
                modal: true,
                resizeStop: function () {
                    globals_1.app.dlgForm.resizeDlgContent(that.controls);
                }, open: function () {
                    matrixlib_1.ml.UI.pushDialog(globals_1.app.dlgForm);
                    that.showSaveConflict(globals_1.app.dlgForm, latest, localChanges);
                }, close: function () { matrixlib_1.ml.UI.popDialog(globals_1.app.dlgForm); },
                buttons: [{
                        text: 'Ok',
                        class: 'btnOk',
                        click: function () {
                            globals_1.app.dlgForm.removeClass("dlg-scroll");
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            }).resizeDlgContent(this.controls);
        }
        ;
        showNextActivity(accordion, control, from, count, auditIdMin, auditIdMax) {
            let that = this;
            let d = $.Deferred();
            globals_1.app.getActivityAsync(function (item, _first, _last, updatedLink) {
                $(".spinningWait", control).hide();
                let versionPanel;
                if (item) {
                    if (item.action === 'report') {
                        versionPanel = that.createReportLine({
                            id: item.id,
                            title: item.title,
                            version: item.version,
                            user: item.user,
                            date: item.dateUserFormat,
                            dateServer: item.date,
                            job: item.job
                        });
                        accordion.append(versionPanel);
                    }
                    else if (item.action === 'execute') {
                        versionPanel = that.createExecuteLine({
                            id: item.id,
                            title: item.title,
                            version: item.version,
                            user: item.user,
                            dateServer: item.date,
                            date: item.dateUserFormat
                        });
                        accordion.append(versionPanel);
                    }
                    else if (item.action === 'signature') {
                        versionPanel = that.createSignLine({
                            id: item.id,
                            title: item.title,
                            version: item.version,
                            user: item.user,
                            dateServer: item.date,
                            date: item.dateUserFormat,
                            reason: item.reason
                        });
                        accordion.append(versionPanel);
                    }
                    else if (item.action === 'merge') {
                        versionPanel = that.createMergeLine({
                            user: item.user,
                            dateServer: item.date,
                            date: item.dateUserFormat,
                            tags: item.tags,
                            comment: item.comment,
                            ctrl: control,
                            auditId: item.auditId,
                            action: item.action
                        });
                        accordion.append(versionPanel);
                    }
                    else {
                        versionPanel = that.createPanel({
                            deletedItems: (item.action === 'deleted'),
                            ctrl: control,
                            id: item.id,
                            title: item.title,
                            isFolder: false,
                            version: item.version,
                            user: item.user,
                            action: item.action,
                            dateServer: item.date,
                            date: item.dateUserFormat,
                            comment: item.comment,
                            allowRestore: false,
                            fullVersion: item.fullVersion,
                            auditId: item.auditId,
                            tags: item.tags
                        });
                        accordion.append(versionPanel);
                        that.lastHistory = item.dateUserFormat;
                    }
                }
                else if (updatedLink) {
                    versionPanel = that.createReferenceLine(updatedLink);
                    accordion.append(versionPanel);
                    that.lastHistory = updatedLink.dateUserFormat;
                }
                // add timewarp info 
                if (versionPanel && item && globals_1.globalMatrix.ItemConfig.isAfterTimeWarp(item.date)) {
                    that.lastWasTimewarp = true;
                    versionPanel.addClass("timewarp");
                }
                else if (that.lastWasTimewarp) {
                    that.lastWasTimewarp = false;
                    versionPanel.addClass("justAfterTimewarp");
                }
            }, from, count, auditIdMin, auditIdMax).done(function (total) {
                that.pFrom = from;
                that.pCount = count;
                that.pTotal = total;
                d.resolve();
            });
            return d;
        }
        showNextReaders(doclist, control, from, count) {
            let that = this;
            globals_1.app.getActivityAsync(function (item) {
                $(".spinningWait", control).hide();
                if (item) { // item can be null for added links
                    if (item.id.indexOf("DOC-") === 0 || item.id.indexOf("SIGN-") === 0) {
                        if (!that.readHistory[item.id]) {
                            that.readHistory[item.id] = { history: [], id: item.id };
                        }
                        that.readHistory[item.id].history.push(item);
                        that.showReadHistory(doclist, that.readHistory[item.id]);
                    }
                    that.lastHistory = item.dateUserFormat;
                }
            }, from, count).done(function (total) {
                if (from + count < total) {
                    $(".spinningWait", control).html('Showing activity after ' + that.lastHistory + '. <span class="showMore">show more...</span>').show().click(function () {
                        $(".spinningWait", control).replaceWith(matrixlib_1.ml.UI.getSpinningWait());
                        that.showNextReaders(doclist, control, from + count, count);
                    });
                }
            });
        }
        formatReadHistoryAction(action, actionDetails) {
            var result = $("<span>");
            if (action === "signed") {
                var reason = actionDetails.reason.split(" by ");
                if (reason.length > 1) {
                    result.append("<b>" + action + "</b> by " + reason[1] + " at " + actionDetails.dateUserFormat);
                }
                else {
                    result.append("<b>" + action + "</b> at " + actionDetails.dateUserFormat);
                }
            }
            else {
                result.append("<b>" + action + "</b> by " + actionDetails.user + " at " + actionDetails.dateUserFormat);
            }
            return result;
        }
        showReadHistory(doclist, doc) {
            let that = this;
            if (!doc.panel) {
                var plus = $('<span class="fal fa-minus-square plusctrl">');
                plus.data("doc", doc.id);
                plus.data("open", true);
                plus.click(function (event) {
                    var info = that.readHistory[$(event.delegateTarget).data("doc")];
                    if ($(event.delegateTarget).data("open")) {
                        $(event.delegateTarget).removeClass("fa-minus-square");
                        $(event.delegateTarget).addClass("fa-plus-square-o");
                        $(event.delegateTarget).data("open", false);
                        info.panelBorder.hide();
                    }
                    else {
                        $(event.delegateTarget).addClass("fa-minus-square");
                        $(event.delegateTarget).removeClass("fa-plus-square-o");
                        $(event.delegateTarget).data("open", true);
                        info.panelBorder.show();
                    }
                });
                doc.header = $('<div class="">').refLink({
                    folder: false,
                    id: doc.id,
                    title: doc.history[0].title,
                    style: RefLinkDefines_1.refLinkStyle.selectTree,
                    tooltip: RefLinkDefines_1.refLinkTooltip.none
                });
                doc.panel = $('<div class="detailsRead">');
                doc.panelBorder = $('<div class="detailsReadOuter">');
                doclist.append(plus).append(doc.header).append(doc.panelBorder.append(doc.panel));
            }
            var current = doc.history[doc.history.length - 1];
            var version = $('<div class="">');
            doc.panel.append(version);
            if (current.action === 'edit') {
                if (!doc.wasEdit) {
                    version.append(this.formatReadHistoryAction("modified", current));
                }
                else {
                    // don't show this is an edit after an edit or create
                }
                doc.wasEdit = true;
            }
            else if (current.action === 'add') {
                version.append(this.formatReadHistoryAction("created", current));
            }
            else if (current.action === 'report') {
                version.append(this.formatReadHistoryAction("downloaded", current));
                doc.wasEdit = false;
            }
            else if (current.action === 'signature') {
                version.append(this.formatReadHistoryAction("signed", current));
                doc.wasEdit = false;
            }
            else {
                version.append(this.formatReadHistoryAction(current.action, current));
                doc.wasEdit = false;
            }
        }
    }
    exports.HistoryTools = HistoryTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 44 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -----------------------------------------------------------
// Tools to show reference dialog (with up and downtraces)
// -----------------------------------------------------------
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(19), __webpack_require__(10), __webpack_require__(20), __webpack_require__(45), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, ProjectViewDefines_1, RefLinkDefines_1, ItemCreationView_1, ItemSelectionView_1, MatrixLibInterfaces_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ReferenceTools = void 0;
    class ReferenceTools {
        showReferenceDialog(options) {
            if (options.callback == undefined) {
                //Make sure we have a callback
                options.callback = (item) => { };
            }
            var treeContainer = $('<div class="Container nodeContainer"></div>');
            let riskCategories = globals_1.globalMatrix.ItemConfig.getFieldsOfType("risk2").map(function (rc) { return rc.category; });
            var allDownTypes = [];
            $.each(globals_1.globalMatrix.ItemConfig.getLinkTypes(options.item.type, true, true), function (idx, type) {
                allDownTypes.push({ type: type });
            });
            $.each(globals_1.globalMatrix.ItemConfig.getLinkTypes(options.item.type, true, false), function (idx, type) {
                allDownTypes.push({ type: type });
            });
            var allUpTypes = [];
            $.each(globals_1.globalMatrix.ItemConfig.getLinkTypes(options.item.type, false, true), function (idx, type) {
                if (riskCategories.indexOf(type) == -1) {
                    allUpTypes.push({ type: type });
                }
            });
            $.each(globals_1.globalMatrix.ItemConfig.getLinkTypes(options.item.type, false, false), function (idx, type) {
                if (riskCategories.indexOf(type) == -1) {
                    allUpTypes.push({ type: type });
                }
            });
            var rootDown;
            var rootUp;
            function hideXTCs(nodes) {
                let hideFrom = 1000;
                let hideTo = -1000;
                for (var idx = 0; idx < nodes.length; idx++) {
                    // assume that all XTCs come one after the other...
                    if (matrixlib_1.ml.Item.parseRef(nodes[idx].id).type == "XTC") {
                        if (idx < hideFrom)
                            hideFrom = idx;
                        if (idx > hideTo)
                            hideTo = idx;
                    }
                }
                if (hideTo - hideFrom > 2) {
                    // at least 4 XTCs
                    let dotdotdot = {
                        isRoot: false,
                        isOutDate: false,
                        Class: "nodesExpand",
                        Nodes: [],
                        ToolTip: "click to expand",
                        Content: $("<span>...</span>")
                    };
                    dotdotdot.Hidden = nodes.splice(hideFrom + 1, hideTo - hideFrom - 1);
                    nodes.splice(hideFrom + 1, 0, dotdotdot);
                }
            }
            function createStartNode(item) {
                var itemDate = new Date(item.modDate);
                var missingDownLinks = globals_1.app.getMissingDownLinks(item);
                let evalDownlinks = globals_1.app.evaluateTraceRule(item, true);
                rootDown = { isRoot: true, isDown: true, id: item.id, Content: $("<div></div>").refLink({
                        id: item.id, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                    }), Nodes: [] };
                for (var idx = 0; idx < item.downLinks.length; idx++) {
                    var refDate = new Date(item.downLinks[idx].modDate);
                    rootDown.Nodes.push({ isCreate: false, isOutDate: (refDate < itemDate), isDown: true, isIndirect: item.downLinks[idx].isIndirect, id: item.downLinks[idx].to, Content: $("<div></div>").refLink({
                            id: item.downLinks[idx].to, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                        }), Nodes: [] });
                }
                hideXTCs(rootDown.Nodes);
                if (globals_1.matrixSession.isEditor() && options.canEdit) {
                    for (var idx = 0; idx < missingDownLinks.length; idx++) {
                        let required = (evalDownlinks.missingMustHaveCategories.indexOf(missingDownLinks[idx]) != -1) ? "nodeCreate" : "nodeCreateOptional";
                        rootDown.Nodes.push({ isCreate: true, type: missingDownLinks[idx], isDown: true, Class: required, ToolTip: "Create new linked item", Content: $("<div>").html(missingDownLinks[idx]), Nodes: [] });
                    }
                }
                var missingUpLinks = globals_1.app.getMissingUpLinks(item);
                let upRequired = globals_1.app.evaluateTraceRule(item, false);
                rootUp = { isRoot: true, isDown: false, id: item.id, Content: $("<div></div>").refLink({
                        id: item.id, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                    }), Nodes: [] };
                for (var idx = 0; idx < item.upLinks.length; idx++) {
                    var refDate = new Date(item.upLinks[idx].modDate);
                    rootUp.Nodes.push({ isCreate: false, isOutDate: (refDate > itemDate), isDown: false, isIndirect: item.upLinks[idx].isIndirect, id: item.upLinks[idx].to, Content: $("<div></div>").refLink({
                            id: item.upLinks[idx].to, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                        }), Nodes: [] });
                }
                if (globals_1.matrixSession.isEditor() && options.canEdit) {
                    for (var idx = 0; idx < missingUpLinks.length; idx++) {
                        let required = (upRequired.missingMustHaveCategories.indexOf(missingUpLinks[idx]) != -1) ? "nodeCreate" : "nodeCreateOptional";
                        rootUp.Nodes.push({ isCreate: true, type: missingUpLinks[idx], isDown: false, Class: required, ToolTip: "Create new linked item", Content: $("<div>").html(missingUpLinks[idx]), Nodes: [] });
                    }
                }
                if (allUpTypes.length > 0 && globals_1.matrixSession.isEditor() && options.canEdit) {
                    rootUp.Nodes.push({ isSelect: true, types: allUpTypes, isDown: false, Class: "nodeCreate", ToolTip: "Select linked item", Content: $("<div>").html("Select"), Nodes: [] });
                }
                if (allDownTypes.length > 0 && globals_1.matrixSession.isEditor() && options.canEdit) {
                    rootDown.Nodes.push({ isSelect: true, types: allDownTypes, isDown: true, Class: "nodeSelect", ToolTip: "Select linked item", Content: $("<div>").html("Select"), Nodes: [] });
                }
            }
            function RefreshTree() {
                var oldContainer = treeContainer;
                oldContainer.hide();
                treeContainer = $('<div class="Container nodeContainer"></div>');
                globals_1.app.dlgForm.append(treeContainer);
                DrawTree({
                    Container: treeContainer,
                    RootDown: rootDown,
                    RootUp: rootUp,
                    Layout: "Horizontal",
                    OnNodeClick: NodeClick,
                    OnNodeDoubleClick: NodeDoubleClick
                });
                oldContainer.html("");
                var ph = treeContainer.parent().height();
                var pw = treeContainer.parent().width();
                var nh = treeContainer.height();
                var nw = treeContainer.data("maxWidth");
                if (ph > nh) {
                    treeContainer.css({ top: (ph - nh) / 2 });
                }
                if (pw > nw) {
                    treeContainer.css({ left: (pw - nw) / 2 });
                }
                treeContainer.width(nw);
            }
            function NodeClick(theNode, event) {
                if (theNode.Class == "nodesExpand") {
                    theNode.Nodes = matrixlib_1.ml.JSON.clone(theNode.Hidden);
                    theNode.Class = "nodesExpanded";
                    RefreshTree();
                }
                else if (theNode.Class == "nodesExpanded") {
                    // toggle XTCs
                    theNode.Nodes = null;
                    theNode.Class = "nodesExpand";
                    RefreshTree();
                }
                else if (theNode.isSelect) {
                    globals_1.app.dlgForm.dialog("close");
                    var select = new ItemSelectionView_1.ItemSelectionTools();
                    select.showDialog({
                        linkTypes: theNode.types,
                        getSelectedItems: function () {
                            return theNode.isDown ? options.item.downLinks : options.item.upLinks;
                        },
                        selectionChange: function (newRefs) {
                            var oldRefs = theNode.isDown ? options.item.downLinks : options.item.upLinks;
                            // figure out if the old refs have some links to some items which cannot be selected in tree (e.g. uplinks as risk controls -> these should not be removed)
                            let selectableTypes = (theNode.isDown ? allDownTypes : allUpTypes).map(function (st) { return st.type; });
                            $.each(oldRefs, function (oridx, oref) {
                                if (selectableTypes.indexOf(matrixlib_1.ml.Item.parseRef(oref.to).type) == -1) {
                                    newRefs.push(oref);
                                }
                            });
                            var changes = matrixlib_1.ml.Item.updateReferences(oldRefs, newRefs, theNode.isDown ? options.item.id : null, theNode.isDown ? null : options.item.id);
                            globals_1.app.commitChangeListAsync(changes).always(function (error, stepsDone) {
                                options.callback(options.item);
                            });
                        },
                        selectMode: ProjectViewDefines_1.SelectMode.items,
                    });
                }
                else if (theNode.isCreate) {
                    if (globals_1.app.canCreateItemType(theNode.type, false)) {
                        globals_1.app.dlgForm.dialog("close");
                        var create = new ItemCreationView_1.ItemCreationTools();
                        create.showDialog({
                            name: globals_1.globalMatrix.ItemConfig.getItemConfiguration(theNode.type).label,
                            parent: globals_1.app.getRootOfType(theNode.type),
                            type: theNode.type,
                            folder: false,
                            dontOpenNewItem: true,
                            created: function (created) {
                                var fromId;
                                var toId;
                                if (theNode.isDown) {
                                    fromId = options.item.id;
                                    toId = created.to;
                                }
                                else {
                                    fromId = created.to;
                                    toId = options.item.id;
                                }
                                globals_1.app.addDownLinkAsync(fromId, toId).done(function () {
                                }).fail(function () {
                                    matrixlib_1.ml.UI.showError("Could not link items.", "");
                                }).always(function () {
                                    options.callback(options.item);
                                });
                            }
                        });
                    }
                }
                else if (event.ctrlKey) {
                    var win = window.open(globals_1.app.createItemUrl(theNode.id), '_blank');
                    if (event.preventDefault)
                        event.preventDefault();
                    if (event.stopPropagation)
                        event.stopPropagation();
                    return;
                }
                else if (theNode.Nodes.length == 0) {
                    globals_1.app.getItemAsync(theNode.id).done(function (item) {
                        if (theNode.isDown) {
                            for (var idx = 0; idx < item.downLinks.length; idx++) {
                                theNode.Nodes[idx] = {
                                    isCreate: false, isDown: true, isIndirect: item.downLinks[idx].isIndirect, id: item.downLinks[idx].to, Content: $("<div></div>").refLink({
                                        id: item.downLinks[idx].to, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                                    }), Nodes: []
                                };
                            }
                            hideXTCs(theNode.Nodes);
                        }
                        else {
                            for (var idx = 0; idx < item.upLinks.length; idx++) {
                                theNode.Nodes[idx] = { isCreate: false, isDown: false, isIndirect: item.upLinks[idx].isIndirect, id: item.upLinks[idx].to, Content: $("<div></div>").refLink({
                                        id: item.upLinks[idx].to, title: "", style: RefLinkDefines_1.refLinkStyle.show, tooltip: RefLinkDefines_1.refLinkTooltip.html, hideTitle: true
                                    }), Nodes: [] };
                            }
                        }
                        // Draw the tree for the first time
                        RefreshTree();
                    });
                }
            }
            function NodeDoubleClick(theNode, event) {
                if (event.ctrlKey || event.metaKey) {
                    var win = window.open(globals_1.app.createItemUrl(theNode.id), '_blank');
                    if (event.preventDefault)
                        event.preventDefault();
                    if (event.stopPropagation)
                        event.stopPropagation();
                    return;
                }
                globals_1.app.dlgForm.dialog("close");
                globals_1.app.treeSelectionChangeAsync(theNode.id).done(function () {
                }).fail(function () {
                }).always(function () { options.callback(options.item); });
            }
            matrixlib_1.ml.UI.showDialog(globals_1.app.dlgForm, "References of '" + options.item.id + "'", treeContainer, 900, 400, [{
                    text: 'Close',
                    class: 'btnCancelIt',
                    click: function () {
                        globals_1.app.dlgForm.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Auto, false, true, null, null, function () {
                globals_1.app.dlgForm.resizeDlgContent([]);
                RefreshTree();
            });
            /*
            app.dlgForm.dialog({
                autoOpen: true,
                title: "References of '" + options.item.id + "'",
                height: 400,
                width: 900,
                modal: true,
                resizeStop: function () {
                    app.dlgForm.resizeDlgContent([]);
                    RefreshTree();
                },
                open: function () {},
                buttons: []
            });
           */
            globals_1.app.getItemAsync(options.item.id).done(function (item) {
                createStartNode(item);
                RefreshTree();
            });
        }
        ;
    }
    exports.ReferenceTools = ReferenceTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 45 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -----------------------------------------------------------
// Dialog to selection items
// -----------------------------------------------------------
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(19), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, matrixlib_1, ProjectViewDefines_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ItemSelectionTools = void 0;
    class ItemSelectionTools {
        constructor() {
        }
        showDialog(options) {
            this.showSelectDialog(options);
        }
        renderButtons(options) {
            var buttonName = options.buttonName ? options.buttonName : "Select Existing";
            var renderStyle = options.smallbutton ? "btn-sm " : "";
            var seleniumClass = "sel_" + buttonName.replace(/ /g, "");
            var riskFormat = options.isRiskControl ? "btn-sm rcbn" : "";
            if (options.tinybutton) {
                buttonName = "()";
                renderStyle = "btn-xs";
                riskFormat = options.isRiskControl ? "rcbn" : "";
            }
            var button = $("<button name='selectRef' class='" + riskFormat + " buttonCreateSelect btn btn-default " + seleniumClass + " " + renderStyle + "'>" + buttonName + "</button>");
            var dlgOptions = {
                linkTypes: options.linkTypes,
                getSelectedItems: options.getSelectedItems,
                selectionChange: options.selectionChange,
                selectMode: options.selectMode,
                crossProject: options.crossProject,
                crossProjectInit: options.crossProjectInit,
                crossProjectProject: options.crossProjectProject,
                allowedProjects: options.allowedProjects,
                allowedCategories: options.allowedCategories,
                allowAutoDownlinkSelection: options.allowAutoDownlinkSelection,
                crossProjectFilter: options.crossProjectFilter ? options.crossProjectFilter : null,
                crossProjectFilterStrict: options.crossProjectFilterStrict
            };
            if (options.crossProject) {
                button.click(() => this.showCrossProjectDialog(dlgOptions));
            }
            else {
                button.click(() => this.showSelectDialog(dlgOptions));
            }
            options.control.append(button);
        }
        showSelectDialog(options) {
            let that = this;
            // remove global highlight and show only matches in dlg after
            matrixlib_1.ml.Search.searchInDialog();
            var linkTypes = [];
            for (var idx = 0; idx < options.linkTypes.length; idx++) {
                linkTypes.push(options.linkTypes[idx].type);
            }
            let container = $("<div>");
            let tree = $("<div>").appendTo(container);
            tree.append(matrixlib_1.ml.UI.getSpinningWait("Loading tree"));
            globals_1.app.waitForMainTree(loadTree);
            let dlg = $("#selectItemDlg");
            matrixlib_1.ml.UI.showDialog(dlg, options.dialogTitle ? options.dialogTitle : "Select Items", container, 500, options.height ? options.height : 400, [{
                    text: 'Select',
                    class: 'btnDoIt',
                    click: function () {
                        options.selectionChange(tree.getController().getValue());
                        dlg.dialog("close");
                    }
                }, {
                    text: 'Cancel',
                    class: 'btnCancelIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, true, true, function () {
                // dlg is gone, remove highlights and back to global highlighting
                matrixlib_1.ml.Search.endSearchInDialog();
                matrixlib_1.ml.UI.popDialog(dlg);
            }, function () {
                matrixlib_1.ml.UI.pushDialog(dlg);
                if (options.selectOptions) {
                    $(".treeContent", container).css("bottom", options.selectOptions.height());
                    $(".listContent", container).css("bottom", options.selectOptions.height());
                }
                if (options.focusOn) {
                    tree.getController().select(options.focusOn);
                }
            });
            function loadTree() {
                //Let's remove the loading stuff
                tree.html("");
                let treeData = globals_1.app.getTree(linkTypes);
                tree.projectView({
                    tree: treeData,
                    controlState: globals_1.ControlState.DialogCreate,
                    selectedItems: options.getSelectedItems(),
                    canSelectItems: true,
                    selectMode: options.selectMode,
                    expand: (options.selectMode == ProjectViewDefines_1.SelectMode.auto || options.selectMode == ProjectViewDefines_1.SelectMode.independent) ? 0 : 1,
                    autoScroll: options.autoScroll
                });
                if (options.selectOptions) {
                    container.append(options.selectOptions);
                }
            }
        }
        toggleSelect(enabled) {
            matrixlib_1.ml.UI.setEnabled($(".btnDoIt", $("#selectItemDlg").parent()), enabled);
        }
        showCrossProjectDialog(options) {
            let that = this;
            let originalIC = matrixlib_1.ml.JSON.clone(globals_1.globalMatrix.ItemConfig);
            // remove global highligh and show only matches in dlg after
            matrixlib_1.ml.Search.searchInDialog();
            var linkTypes = [];
            for (var idx = 0; idx < options.linkTypes.length; idx++) {
                linkTypes.push(options.linkTypes[idx].type);
            }
            var dlgUi = $("<div>");
            dlgUi.append('<span class="ui-helper-hidden-accessible"><input autocomplete="off" type="text"/></span>');
            var projectList = options.allowedProjects ? options.allowedProjects : globals_1.matrixSession.getProjectList(true);
            var projectSelect = [];
            $.each(projectList, function (projectIdx, project) {
                if (!options.crossProjectProject || options.crossProjectProject === project.shortLabel) {
                    projectSelect.push({ id: project.shortLabel, label: project.shortLabel + " - " + project.label });
                }
            });
            var tree = $("<div>").html("Select a project");
            var projectSelection = $("<div>").mxDropdown({
                controlState: globals_1.ControlState.DialogCreate,
                canEdit: true,
                dummyData: false,
                help: 'Project',
                parameter: {
                    readonly: false,
                    placeholder: "select project",
                    splitHuman: false,
                    options: projectSelect
                },
                valueChanged: function () {
                    var newProjectId = projectSelection.getController().getValue();
                    projectSelection.hide();
                    options.crossProjectInit(newProjectId);
                    globals_1.setIC(new index_1.ItemConfiguration(matrixlib_1.ml.Logger, matrixlib_1.ml.JSON));
                    if (options.allowAutoDownlinkSelection) {
                        // add a button to auto select downlinked items
                        $(`<div class='dlgLinkButton'>select all downlinks</div>`).appendTo($(".ui-dialog-buttonpane", dlg.parent())).click(() => {
                            let selection = tree.getController().getValue().map(sel => sel.to);
                            let di = selection.map(sel => `uplinkm=${sel}`);
                            if (di.length) {
                                matrixlib_1.ml.UI.BlockingProgress.Init([{ name: "getting downlinks of current selection" }], true);
                                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 1);
                                let search = `/needleminimal?search=mrql:${di.join(" or ")}`;
                                globals_1.restConnection.getServer(newProjectId + search).done((downlinks) => {
                                    tree.getController().setValue(selection.concat(downlinks));
                                    matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100);
                                });
                            }
                        });
                    }
                    globals_1.restConnection.getServer(newProjectId + "/cat").done(function (catDetails) {
                        globals_1.globalMatrix.ItemConfig.addCategories(catDetails);
                        globals_1.restConnection.getServer(newProjectId + "/setting").done(function (settings) {
                            globals_1.globalMatrix.ItemConfig.addSettings(settings);
                            let treeSearch = "/tree?fancy" + (options.crossProjectFilter ? ("&filter=" + options.crossProjectFilter) : "");
                            globals_1.restConnection.getServer(newProjectId + treeSearch).done(function (result) {
                                result = index_2.RestDB.filterLegacyReportCat(result);
                                if (options.allowedCategories) {
                                    result = result.filter(node => options.allowedCategories.includes(node.type));
                                }
                                if (options.crossProjectFilterStrict) {
                                    result = that.removeHidden(result);
                                }
                                var pdb = new index_1.DBCache();
                                pdb.initMatrixTree(result, false);
                                var treeContent = pdb.getTree(linkTypes);
                                tree.html("").projectView({
                                    tree: treeContent,
                                    controlState: globals_1.ControlState.DialogCreate,
                                    selectedItems: options.getSelectedItems(),
                                    canSelectItems: true,
                                    selectMode: options.selectMode,
                                    expand: options.selectMode == ProjectViewDefines_1.SelectMode.auto ? 0 : 1,
                                    crossProject: newProjectId
                                });
                                if (options.selectOptions) {
                                    $(".treeContent", tree).css("bottom", options.selectOptions.height() + 4);
                                }
                                that.toggleSelect(true);
                            }).fail(function () {
                                globals_1.setIC(originalIC);
                            });
                        }).fail(function () {
                            globals_1.setIC(originalIC);
                        });
                    }).fail(function () {
                        globals_1.setIC(originalIC);
                    });
                }
            });
            dlgUi.append(projectSelection);
            dlgUi.append(tree);
            var niceSize = matrixlib_1.ml.UI.getNiceDialogSize(750, 400);
            let dlg = $("#selectItemDlg");
            dlg.html("");
            dlg.removeClass("dlg-v-scroll");
            dlg.addClass("dlg-no-scroll");
            dlg.append(dlgUi);
            if (options.selectOptions) {
                dlg.append(options.selectOptions);
            }
            dlg.dialog({
                autoOpen: true,
                title: "Select Project and Items",
                height: niceSize.height,
                width: niceSize.width,
                modal: true,
                close: function () {
                    // just in case it was added
                    $(".dlgLinkButton").remove();
                    // dlg is gone, remove highlights and back to global highlighting
                    matrixlib_1.ml.Search.endSearchInDialog();
                    matrixlib_1.ml.UI.popDialog(dlg);
                },
                open: function () {
                    matrixlib_1.ml.UI.pushDialog(dlg);
                    if (options.crossProjectProject) {
                        projectSelection.getController().setValue(options.crossProjectProject, false, true);
                    }
                    that.toggleSelect(false);
                },
                resizeStop: function (event, ui) {
                    if (tree) {
                        dlg.resizeDlgContent([tree]);
                    }
                },
                buttons: [{
                        text: 'Select',
                        class: 'btnDoIt',
                        click: function () {
                            options.selectionChange(tree.getController().getValue());
                            globals_1.setIC(originalIC);
                            dlg.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.setIC(originalIC);
                            dlg.dialog("close");
                        }
                    }]
            }).resizeDlgContent([tree], false);
        }
        ;
        removeHidden(tree) {
            let that = this;
            let newTree = [];
            $.each(tree, function (idx, node) {
                if (!node.isUnselected) {
                    let pushy = {
                        id: node.id,
                        title: node.title,
                        type: node.type,
                        isUnselected: node.isUnselected
                    };
                    if (typeof node.children !== 'undefined') {
                        pushy.children = that.removeHidden(node.children);
                    }
                    newTree.push(pushy);
                }
            });
            return newTree;
        }
    }
    exports.ItemSelectionTools = ItemSelectionTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 46 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(47), __webpack_require__(6), __webpack_require__(12), __webpack_require__(12), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ReviewContextFrame_1, globals_1, index_1, index_2, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.KeyboardShortcuts = void 0;
    ;
    class KeyboardShortcuts {
        constructor() {
            this.documentSectionIdx = 0;
            let that = this;
            this.defineShortcuts();
            index_1.MR1.onItemDisplayed().subscribe(this, this.initToggleSection);
        }
        defineShortcuts() {
            let that = this;
            this.shortCuts = [];
            this.addCtrlShortcut("?", "Global", "show help dialog", null, null, this.help, true, true);
            this.addShortcut("Delete", "Delete", "delete item", null, [".baseControl", ".itemTitle", "#itemDetails", "input", "textarea"], this.delete, true, false);
            this.addCtrlShortcut("l", "Global", "(l)ocate / find / search", null, null, this.focusSearch, false, true);
            this.addShortcut('<span class="short-ctrl">ctrl</span> - l - ITEM-ID <span class="short-ctrl">space</span>', "Global", "(l)ocate and select item in tree", null, null, this.focusSearch, false, true);
            this.addCtrlShortcut("m", "Global", "mirror current item in review frame", null, null, this.showInReview, false, false);
            this.addCtrlShortcut("Z", "Global", "zen preview of items and docs", null, null, this.showZen, false, false);
            this.addCtrlShortcut("1", "Item Editing/Creation", "click on 1st create / select button", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("2", "Item Editing/Creation", "click on 2nd create / select button", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("3", "Item Editing/Creation", "click on 3rd create / select button", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("4", "Item Editing/Creation", "click on 4th create / select button", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("s", "Item Editing/Creation", "save item, create in new item dialog, select in item select dialog", null, null, this.save, false, false);
            this.addCtrlShortcut("5", "", "", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("6", "", "", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("7", "", "", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("8", "", "", null, null, this.createSelect, true, false);
            this.addCtrlShortcut("9", "", "", null, null, this.createSelect, true, false);
            this.addCtrlShortcutCode(39, "Documents", "right arrow", "open sections in document", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSections, true, false);
            this.addCtrlShortcutCode(37, "Documents", "left arrow", "close sections in document", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSections, true, false);
            this.addShortcutCode(39, "Documents", "right arrow", "open current section", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSection, true, false);
            this.addShortcutCode(38, "Documents", "up arrow", "section up", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSection, true, false);
            this.addShortcutCode(37, "Documents", "left arrow", "close current section", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSection, true, false);
            this.addShortcutCode(40, "Documents", "down arrow", "section down", null, [".baseControl", "input", "textarea", "#commentDlg"], this.toggleSection, true, false);
            this.addCtrlShortcutCode(32, "Documents", "space", "download document", null, [".baseControl", "input", "textarea", "#commentDlg"], this.downloadDocument, false, true);
            let ow = localStorage.getItem('shortcuts_ow');
            if (ow) {
                let oow = JSON.parse(ow);
                $.each(oow, function (oowidx, o) {
                    $.each(that.shortCuts, function (si, s) {
                        if (s.key == o.orgKey && s.keyCode == o.orgKeyCode && s.withCtrl == o.orgCtrl) {
                            console.log("change key: " + (s.withCtrl ? "ctrl-" : "") + (s.keyCode ? s.keyCode : s.key) + " to " + (o.newCtrl ? "ctrl-" : "") + (o.newKeyCode ? o.newKeyCode : o.newKey));
                            s.key = o.newKey;
                            s.keyCode = o.newKeyCode;
                            s.withCtrl = o.newCtrl;
                        }
                    });
                });
            }
        }
        print() {
            $.each(this.shortCuts, function (si, s) {
                console.log(s.help + ": " + (s.withCtrl ? "ctrl-" : "") + (s.keyCode ? s.keyCode : s.key));
            });
        }
        resetCustomKeys() {
            localStorage.setItem('shortcuts_ow', '');
            console.log("Reset all key to default. F5 (refresh browser) to make effective");
        }
        setKey(orgCtrl, newCtrl, orgKey, newKey) {
            let ow = localStorage.getItem('shortcuts_ow');
            let oow = (ow ? JSON.parse(ow) : []);
            oow.push({ orgCtrl: orgCtrl, orgKey: orgKey, newCtrl: newCtrl, newKey: newKey, orgKeyCode: 0, newKeyCode: 0 });
            localStorage.setItem('shortcuts_ow', JSON.stringify(oow));
            this.defineShortcuts();
            console.log("F5 (refresh browser) to make effective");
        }
        setKeyCode(orgCtrl, newCtrl, orgKeyCode, newKeyCode) {
            let ow = localStorage.getItem('shortcuts_ow');
            let oow = (ow ? JSON.parse(ow) : []);
            oow.push({ orgCtrl: orgCtrl, orgKey: '', newCtrl: newCtrl, newKey: '', orgKeyCode: orgKeyCode, newKeyCode: newKeyCode });
            localStorage.setItem('shortcuts_ow', JSON.stringify(oow));
            this.defineShortcuts();
            console.log("F5 (refresh browser) to make effective");
        }
        addCtrlShortcut(key, category, help, inElement, notInElement, fct, disableEdge, disableSafari) {
            this.shortCuts.push({ withCtrl: true, keyCode: 0, category: category, key: key, help: help, inElement: inElement, notInElement: notInElement, fct: fct, disableEdge, disableSafari });
        }
        addShortcut(key, category, help, inElement, notInElement, fct, disableEdge, disableSafari) {
            this.shortCuts.push({ withCtrl: false, keyCode: 0, category: category, key: key, help: help, inElement: inElement, notInElement: notInElement, fct: fct, disableEdge, disableSafari });
        }
        addCtrlShortcutCode(keyCode, category, key, help, inElement, notInElement, fct, disableEdge, disableSafari) {
            this.shortCuts.push({ withCtrl: true, keyCode: keyCode, category: category, key: key, help: help, inElement: inElement, notInElement: notInElement, fct: fct, disableEdge, disableSafari });
        }
        addShortcutCode(keyCode, category, key, help, inElement, notInElement, fct, disableEdge, disableSafari) {
            this.shortCuts.push({ withCtrl: false, keyCode: keyCode, category: category, key: key, help: help, inElement: inElement, notInElement: notInElement, fct: fct, disableEdge, disableSafari });
        }
        init() {
            let that = this;
            this.lastKeyDown = new Date();
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            let urlGlobalShiftDown = globals_1.globalMatrix.globalShiftDown = urlParams.has('globalShiftDown');
            let urlGlobalCtrltDown = globals_1.globalMatrix.globalCtrlDown = urlParams.has('globalCtrltDown');
            $(window).on('keydown', function (event) {
                var continueEvent = true;
                // console.log("key:" + event.key + " charCode: " + event.charCode + " keyCode:" + event.keyCode + " which:" + event.which + "ctrlKey: " + event.ctrlKey + "metaKey: " + event.metaKey ); 
                let notEdge = Modernizr.smil && !(/Edge/i.test(navigator.userAgent));
                let notSafari = navigator.userAgent.indexOf("Safari") == -1 || navigator.userAgent.indexOf('Chrome') > -1;
                // shortcuts only work for reasonable browsers
                // edge leads straight to hell MATRIX-1912
                $.each(that.shortCuts, function (idx, shortcut) {
                    if ((notEdge || !shortcut.disableEdge) && (notSafari || !shortcut.disableSafari)) { // CTRL (PC) or COMMAND (Mac) or background clicked
                        if (event.ctrlKey || event.metaKey || !shortcut.withCtrl) { // CTRL (PC) or COMMAND (Mac) or background clicked
                            if (shortcut.keyCode > 0 && event.which === shortcut.keyCode && that.isGoodTarget($(event.target), shortcut.inElement, shortcut.notInElement)) {
                                shortcut.fct(event, that);
                                //console.log("keyCode triggered" ); 
                                if (event.preventDefault)
                                    event.preventDefault();
                            }
                            else if (event.key === shortcut.key && that.isGoodTarget($(event.target), shortcut.inElement, shortcut.notInElement)) {
                                shortcut.fct(event, that);
                                //console.log("key triggered" ); 
                                if (event.preventDefault)
                                    event.preventDefault();
                            }
                        }
                    }
                });
                if (event.shiftKey || urlGlobalShiftDown) {
                    globals_1.globalMatrix.globalShiftDown = true;
                    matrixlib_1.ml.UI.updateTooltip();
                }
                if (event.ctrlKey || urlGlobalCtrltDown) {
                    globals_1.globalMatrix.globalCtrlDown = true;
                }
                // every minute (at most) check if the item on the server changed if so inform the user
                // this also make sure that the system does not time out while someone is writing a big text
                // also if someone writes something after he has been away a a login dialog will show 
                var newKeyDown = new Date();
                if (newKeyDown.getTime() - that.lastKeyDown.getTime() > 60000) {
                    globals_1.app.pingCurrentItem();
                    that.lastKeyDown = newKeyDown;
                }
                return continueEvent;
            });
            $(window).blur(() => { globals_1.globalMatrix.globalShiftDown = false; });
            $(window).on('keyup', function (event) {
                // shift does not actually fire an event of a specific key
                if (event.keyCode === 16) {
                    globals_1.globalMatrix.globalShiftDown = false;
                }
                if (event.keyCode === 17 || event.keyCode === 91) {
                    globals_1.globalMatrix.globalCtrlDown = false;
                }
                return true;
            });
        }
        isGoodTarget(currentTarget, inElement, notInElement) {
            let isGood = true;
            if (inElement) {
                isGood = false;
                $.each(inElement, function (eidx, el) {
                    if (currentTarget.closest(el).length > 0) {
                        isGood = true;
                    }
                });
            }
            if (!isGood) {
                return false;
            }
            if (notInElement) {
                $.each(notInElement, function (eidx, el) {
                    if (currentTarget.closest(el).length > 0) {
                        isGood = false;
                    }
                });
            }
            return isGood;
        }
        isDialogOpen(dialogSelector) {
            return KeyboardShortcuts.isDialogOpen(dialogSelector);
        }
        static isDialogOpen(dialogSelector) {
            try {
                if (dialogSelector) {
                    if ($(dialogSelector).hasClass("ui-dialog-content") && $(dialogSelector).is("isOpen")) {
                        return true;
                    }
                    else if ($(dialogSelector).hasClass("modal") && $(dialogSelector).css("display") == "block") {
                        return true;
                    }
                    return false;
                }
                if ($(".ui-dialog").is(":visible")) {
                    return true;
                }
                if ($('.modal.in').length > 0) { // test if any bootstrap dialog is open
                    return true;
                }
            }
            catch (ex) {
                return false;
            }
            return false;
        }
        showInReview(event, that) {
            // create / select dialog
            if (event.preventDefault) {
                event.preventDefault();
            }
            let itemId = globals_1.app.getCurrentItemId();
            if (itemId && !matrixlib_1.ml.Item.parseRef(itemId).isFolder) {
                ReviewContextFrame_1.ReviewContextFrame.renderItem(itemId, 0, true);
            }
        }
        showZen(event, that) {
            if (event.preventDefault) {
                event.preventDefault();
            }
            if (!that.isDialogOpen() && globals_1.matrixApplicationUI.lastMainItemForm) {
                let currentPanel = globals_1.matrixApplicationUI.currentPanel;
                if (currentPanel.toggleZen) {
                    currentPanel.toggleZen();
                }
            }
        }
        save(event, that) {
            // create / select dialog
            if (event.preventDefault) {
                event.preventDefault();
            }
            KeyboardShortcuts.doSave();
        }
        static doSave() {
            if (KeyboardShortcuts.isDialogOpen("#appPopup")) {
                var createBtn = $(".btnDoIt:visible", $("#appPopup").next());
                if (createBtn.length === 1 && !$(".btnDoIt:visible", $("#appPopup").next()).prop("disabled")) {
                    var text = $(".btnDoIt:visible", $("#appPopup").next()).text();
                    if (text === "Create" || text === "Select") {
                        createBtn.click();
                        return;
                    }
                }
            }
            else if (!KeyboardShortcuts.isDialogOpen() && globals_1.app.getNeedsSave()) {
                window.setTimeout(() => { globals_1.matrixApplicationUI.saveSave(); }, 50);
            }
        }
        createSelect(event, that) {
            var createSelBtns = $(".buttonCreateSelect:visible");
            if (createSelBtns.length + 1 >= Number(event.key) && !($(createSelBtns[Number(event.key) - 1]).prop("disabled"))) {
                $(createSelBtns[Number(event.key) - 1]).click();
            }
        }
        toggleSections(event, that) {
            if (event.key === "ArrowRight") {
                $(".showHideAdmin:not(:checked)").click();
            }
            if (event.key === "ArrowLeft") {
                $(".showHideAdmin:checked").click();
            }
        }
        delete(event, that) {
            if (!that.isDialogOpen()) {
                let btns = $(".deleteItemBtn");
                if (btns.length === 1) {
                    $(btns[0]).click();
                }
            }
        }
        initToggleSection(event) {
            let that = event.caller;
            that.documentSectionIdx = -1;
            if (!event.item || event.item.isFolder || !index_2.mDHF.isDocumentFormType(event.item.type)) {
                return;
            }
            var sections = $("#itemDetails .cbimg");
            if (sections.length > 0) {
                that.documentSectionIdx = 0;
                $(sections[that.documentSectionIdx]).next().css("text-decoration", "underline");
            }
        }
        toggleSection(event, that) {
            if (this.documentSectionIdx < 0) {
                return;
            }
            var sections = $("#itemDetails .cbimg");
            if (that.documentSectionIdx < sections.length) {
                let cb = $(sections[that.documentSectionIdx]).parent().prev();
                if (event.key === "ArrowRight" && !cb.is(":checked")) {
                    $(sections[that.documentSectionIdx]).click();
                }
                if (event.key === "ArrowLeft" && cb.is(":checked")) {
                    $(sections[that.documentSectionIdx]).click();
                }
            }
            if (event.key === "ArrowUp" && that.documentSectionIdx > 0) {
                that.documentSectionIdx--;
            }
            if (event.key === "ArrowDown" && that.documentSectionIdx < sections.length - 1) {
                that.documentSectionIdx++;
            }
            sections.next().css("text-decoration", "inherit");
            if (that.documentSectionIdx < sections.length) {
                $(sections[that.documentSectionIdx]).next().css("text-decoration", "underline");
            }
        }
        downloadDocument(event, that) {
            $("#btnDownload").click();
        }
        focusSearch(event, that) {
            if ($("#appPopup [name=search]").is(":visible")) {
                $("#appPopup [name=search]").focus();
            }
            else {
                $("#projectTree [name=search]").focus();
            }
            event.preventDefault();
        }
        help(event, that) {
            if (globals_1.app.dlgForm.html() !== "" && globals_1.app.dlgForm.is(':visible')) {
                return;
            }
            if ($("#helpModal").length === 0) {
                let globals = "";
                let globalCategories = [];
                $.each(that.shortCuts, function (idx, shortcut) {
                    if (shortcut.category !== "" && globalCategories.indexOf(shortcut.category) === -1) {
                        globalCategories.push(shortcut.category);
                    }
                });
                $.each(globalCategories, function (cidx, category) {
                    let right = true;
                    globals += '<div class="row"><div class="col-sm-12"><h1>' + category + '</h1></div></div>';
                    globals += '<div class="row">';
                    $.each(that.shortCuts, function (idx, shortcut) {
                        if (shortcut.help !== "" && shortcut.category === category) {
                            right = !right;
                            globals += '<div class="col-sm-2 key">' + (shortcut.withCtrl ? "CMD-" : "") + shortcut.key + '</div>';
                            globals += '<div class="col-sm-4 command">' + shortcut.help + '</div>';
                            if (right && idx !== that.shortCuts.length - 1) { // new row
                                globals += '</div><div class="row">';
                            }
                        }
                    });
                    globals += '</div>';
                });
                let help = `

                <div class="modal" id="helpModal" tabindex="-1" role="dialog" >
                <div class="modal-dialog large" role="document">
                  <div class="modal-content">
                    <div class="modal-header">
                      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                      <h4 class="modal-title" >Keyboard Shortcuts</h4>
                    </div>
                    <div class="modal-body scrollable-modal">

                    ${globals}

<div class="row"><div class="col-sm-12"><h1>Text Editor</h1></div></div>                    

                    <div class="row">
                              <div class="col-sm-2 key">CMD-b</div><div class="col-sm-4 command">bold</div>
                              <div class="col-sm-2 key">CMD-i</div><div class="col-sm-4 command">italic</div>
                    </div>
                    <div class="row">
                              <div class="col-sm-2 key">CMD-u</div><div class="col-sm-4 command">underline</div>
                              <div class="col-sm-2 key">CMD-k</div><div class="col-sm-4 command">hyperlink</div>
                    </div>
                    
                    
                <div class="row"><div class="col-sm-12"><h1>Table Control</h1></div></div>
              
                    <div class="row">
                              <div class="col-sm-2 key">tab</div><div class="col-sm-4 command">next cell (right)</div>
                              <div class="col-sm-2 key">SHIFT-tab</div><div class="col-sm-4 command">previous cell (left)</div>
                    </div>
                    <div class="row">
                              <div class="col-sm-2 key">CMD-enter</div><div class="col-sm-4 command">below cell (down)</div>
                              <div class="col-sm-2 key">SHIFT-enter</div><div class="col-sm-4 command">open / close text editor</div>
                    </div>
                    <div class="row">
                              <div class="col-sm-2 key">esc</div><div class="col-sm-4 command">cancel edit</div>
                    </div>

<div class="row"><div class="col-sm-12"><h1>Tree Navigation</h1></div></div>
              
                    <div class="row">
                              <div class="col-sm-2 key">arrow down</div><div class="col-sm-4 command">down</div>
                              <div class="col-sm-2 key">arrow right</div><div class="col-sm-4 command">open folder</div>
                    </div>
                    <div class="row">
                              <div class="col-sm-2 key">arrow up</div><div class="col-sm-4 command">up</div>
                              <div class="col-sm-2 key">arrow left</div><div class="col-sm-4 command">close folder</div>
                    </div>
                    <div class="row">
                              <div class="col-sm-2 key">space</div><div class="col-sm-4 command">select/show item</div>
                              <div class="col-sm-2 key"></div><div class="col-sm-4 command"></div>
                    </div>

                    </div>
                    <div class="modal-footer">
                      <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                    </div>
                  </div>
                </div>
              </div>`;
                if (navigator.appVersion.indexOf('Mac') > -1) {
                    help = help.replace(/CMD-/g, '<span class="short-ctrl">\u2318</span><span class="short-and">-</span>');
                    help = help.replace(/SHIFT-/g, '<span class="short-ctrl">\u21E7</span><span class="short-and">-</span>');
                }
                else {
                    help = help.replace(/CMD-/g, '<span class="short-ctrl">ctrl</span><span class="short-and">-</span>');
                    help = help.replace(/SHIFT-/g, '<span class="short-ctrl">shift</span><span class="short-and">-</span>');
                }
                $("body").append(help);
            }
            $("#helpModal").modal();
        }
    }
    exports.KeyboardShortcuts = KeyboardShortcuts;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 47 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(17), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, matrixlib_1, index_3, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.initialize = exports.ReviewContextFrame = void 0;
    class ReviewContextFrame {
        constructor() {
            this.isDefault = true;
        }
        onUpdate(ui, config, context) {
            ui.addClass("reviewContextFrame");
            ui.addClass("noRefresh");
            if (!ReviewContextFrame.lastDisplayedItemId) {
                ui.html("no pinned item (use ctrl-m or the item menu to pin an item here)");
            }
        }
        static renderItem(itemId, version, showContextFrameIfNotVisible) {
            ReviewContextFrame.lastDisplayedItemId = itemId;
            // check if review context frame is configured
            let cp = globals_1.globalMatrix.ItemConfig.getContextPagesConfig();
            if (!cp || !cp.tabs)
                return;
            let cps = cp.tabs.filter(function (cpc) { return cpc.type == ReviewContextFrame.reviewContextFrame; });
            if (cps.length == 0)
                return;
            // make sure context frames are visible and tab is selected
            let visible = matrixlib_1.ml.ContextFrames.showContextFrame(ReviewContextFrame.reviewContextFrame, showContextFrameIfNotVisible);
            if (!visible)
                return;
            // avoid getting same item again and again
            if (ReviewContextFrame.lastRenderedItem == itemId && ReviewContextFrame.lastRenderedVersion == version)
                return;
            globals_1.app.getItemAsync(itemId, version ? version : undefined).done(function (item) {
                $(".reviewContextFrame").html("");
                if (item.title === undefined) {
                    globals_1.matrixApplicationUI.renderErrorControl($(".reviewContextFrame"), "The item " + item.id + " was deleted", "ou can find it in the deleted item log.", true);
                }
                else if (globals_1.app.canViewItem(item)) {
                    var ctrl = new index_3.ItemControl({
                        control: $(".reviewContextFrame"),
                        controlState: globals_1.ControlState.Tooltip,
                        item: item,
                        isItem: (typeof item.children === 'undefined')
                    });
                    let bcs = globals_1.app.getBreadcrumbs(item.id).filter(function (bc) { return bc != item.id; });
                    let breadcrumb = bcs.reverse().map(function (bid) { return bid + " " + globals_1.app.getItemTitle(bid); }).join(" > ");
                    let title = $(".reviewContextFrame .itemTitle").addClass("tooltipItem").removeClass("pull-left").removeClass("itemTitle");
                    title.closest(".itemTitleBarNoToolsNoEdit").removeClass("itemTitleBarNoToolsNoEdit");
                    $("<hr style='border-top-color: #aaa;margin-top: 10px;width: 100%;margin-bottom: 10px;'/>").insertAfter(title);
                    $('<div style="font-size: smaller;">').append($("<span class='inlineHelp'>").html(breadcrumb)).insertAfter(title);
                }
                else {
                    globals_1.matrixApplicationUI.renderErrorControl($(".reviewContextFrame"), "You have no rights to view " + item.id + "", "Talk to the project administrator.", true);
                }
            });
        }
        initItem(item, jui) {
            this._item = item;
        }
        initServerSettings() { }
        initProject() { }
        getProjectPages() { return []; }
        updateMenu(ul) {
            let that = this;
            let cp = globals_1.globalMatrix.ItemConfig.getContextPagesConfig();
            if (!cp || !cp.tabs)
                return;
            let cps = cp.tabs.filter(function (cpc) { return cpc.type == ReviewContextFrame.reviewContextFrame; });
            if (this._item.id && cps.length == 1 && !matrixlib_1.ml.Item.parseRef(this._item.id).isFolder) {
                var dev = $('<li><span class="toolmenu">Pin item in review pane</span></li>').appendTo(ul);
                dev.click(function () {
                    ReviewContextFrame.renderItem(that._item.id, 0, true);
                });
            }
        }
        supportsControl() {
            return false;
        }
    }
    exports.ReviewContextFrame = ReviewContextFrame;
    ReviewContextFrame.reviewContextFrame = "reviewContextFrame";
    ReviewContextFrame.lastDisplayedItemId = "";
    function initialize() {
        let reviewContextFrame = new ReviewContextFrame();
        index_2.ContextFrameManager.register({
            id: "reviewContextFrame",
            title: "Review Pane",
            adminOption: "allows to pin items for review",
            onUpdate: function (ui, config, context) {
                reviewContextFrame.onUpdate(ui, config, context);
            }
        });
        index_1.plugins.register(reviewContextFrame);
    }
    exports.initialize = initialize;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 48 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(49), __webpack_require__(1), __webpack_require__(3), __webpack_require__(50)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, PrintProcessorInterfaces_1, matrixlib_1, MatrixLibInterfaces_1, JsonEditor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.Layouter = void 0;
    class Layouter {
        constructor() {
        }
        // show editor dialog
        show(itemId, fieldId, sectionConfig, fromSelection, toSelection, labelFilter, onUpdate, previewOnly = false, previewDiv) {
            let that = this;
            this.itemId = itemId;
            this.sectionConfig = (sectionConfig && sectionConfig.options) ? sectionConfig.options : {};
            // TODO(modules): property landscape not found on ICustomSectionOptions.
            this.isLandScape = sectionConfig && sectionConfig.landscape;
            this.toSelection = toSelection;
            this.fromSelection = fromSelection;
            let ui = $("<div style='width:100%'>");
            ui.append(matrixlib_1.ml.UI.getSpinningWait("retrieving data..."));
            let reportOptions = { format: "mf" };
            if (labelFilter && labelFilter.length > 0) {
                reportOptions.filter = JSON.parse(labelFilter).join(",");
            }
            let start1 = new Date().getTime();
            globals_1.app.startCreateDocumentAsync(this.itemId, reportOptions).done(function (result) {
                that.waitForJob(result.jobId).done(function (iXML) {
                    let start2 = new Date().getTime();
                    console.log("time to create filter[s]: " + (start2 - start1) / 1000);
                    globals_1.app.downloadInMemory(result.jobId, iXML.toString(), "text").done(function (iDown) {
                        let start3 = new Date().getTime();
                        console.log("time to download filter[s]: " + (start3 - start2) / 1000);
                        that.mf = $.parseXML(iDown);
                        let start4 = new Date().getTime();
                        console.log("time to create dom[s]: " + (start4 - start3) / 1000);
                        globals_1.app.readSettingCustomerJSONAsync("PrintProcessor").done(function (formatters) {
                            if (!previewOnly)
                                that.initEditor(formatters, ui);
                            else
                                that.displayPreview(previewDiv);
                        });
                    });
                });
            });
            // show dialog
            if (!previewOnly) {
                let dlg = $("<div class=''>").appendTo($("body"));
                matrixlib_1.ml.UI.showDialog(dlg, "Section Layout", ui, $(document).width() * 0.9, globals_1.app.itemForm.height() * 0.9, [{
                        text: 'Save',
                        class: 'btnDoIt',
                        click: function () {
                            onUpdate(JSON.stringify(that.sectionConfig));
                            $("#layoutR").html("");
                            dlg.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            $("#layoutR").html("");
                            dlg.dialog("close");
                        }
                    }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, true, true, () => { dlg.remove(); }, () => { }, () => {
                    $("#layoutR").height(dlg.height());
                    dlg.resizeDlgContent([]);
                });
            }
        }
        // show the layout editor 
        initEditor(formatters, ui) {
            var sidebar = localStorage.getItem('layout_sidebar');
            if (!sidebar) {
                sidebar = '200px';
            }
            let layoutC = $(`<div id="layoutC" style="overflow:auto;width:${sidebar};padding-right:12px;float:left;height: 100%;margin-right: 6px;">`);
            let dragbar = $(`<div style="background-color:var(--Grey6);height: 100%;float:left;width: 5px;cursor: col-resize;">`);
            let layoutR = $(`<div id="layoutR" style="overflow:auto;padding-left:12px;height: 100%;">`);
            ui.html("").append(layoutC).append(dragbar).append(layoutR).css("height", "100%");
            const leftContainer = $(`<div class="layouter-left-container">`).appendTo(layoutC);
            // dropdown  to select width
            this.displayStyle = { width: this.isLandScape ? "26.7cm" : "18cm" };
            matrixlib_1.ml.UI.addDropdownToValue(leftContainer, "page size & orientation (preview)", this.displayStyle, "width", [
                { id: "18cm", label: "Portrait (A4)" },
                { id: "18.6cm", label: "Portrait (Letter)" },
                { id: "26.6cm", label: "Portrait (A3)" },
                { id: "26.7cm", label: "Landscape (A4)" },
                { id: "24.9cm", label: "Landscape (Letter)" },
                { id: "39cm", label: "Landscape (A3)" },
                { id: "100%", label: "Full width" },
                { id: "EXCEL", label: "Excel (Plaintext)" }
            ], false, false, () => this.displayPreview(), null, { width: "100%" });
            const textOptionDiv = $("<div style='margin: -12px 0 0 -12px;'>").appendTo(leftContainer);
            $("<button class='btn btn-link'>Set introductory text</button>").click(() => this.introOptions()).appendTo(textOptionDiv);
            $("<button class='btn btn-link'>Set advanced options</button>").click(() => this.advancedOptions()).appendTo(textOptionDiv);
            let filter = $('<input type="text" style="margin-bottom:10px;padding: 6px 12px;" placeholder="filter..." class="form-control">').on("keyup", function (e) {
                let filterVal = filter.val().toLowerCase();
                $(".formatter-item").each((idx, fi) => {
                    (filterVal && $(fi).text().toLowerCase().indexOf(filterVal) == -1) ? $(fi).hide() : $(fi).show();
                });
            }).appendTo(leftContainer);
            this.formatterList(formatters).appendTo(leftContainer);
            dragbar.mousedown(function (e) {
                if (e.preventDefault)
                    e.preventDefault();
                $(document).mousemove(function (e) {
                    let maxWidth = ui.width() - 100;
                    let mousePos = e.pageX - layoutC.offset().left; // mousepos relative to left border of layoutC
                    if (mousePos > 100 && mousePos < maxWidth) {
                        localStorage.setItem('layout_sidebar', (mousePos - 15) + "px");
                        layoutC.width(mousePos - 15);
                    }
                });
            });
            if (!this.sectionConfig.formatter || this.sectionConfig.formatter.trim() == "" || !formatters.items[this.sectionConfig.formatter]) {
                layoutR.append(`<div style="padding: 16px;"><em>Please choose a layout!</em></div>`);
            }
            else {
                this.displayPreview();
            }
        }
        formatterList(formatters) {
            const createFormatter = (formatter) => {
                const selected = this.sectionConfig.formatter === formatter.uid ? "selected" : "";
                const id = `formatter-item-${formatter.uid}`;
                let help = formatter.help;
                if (help == null || help.trim() == "") {
                    help = "<i>No description provided</i>";
                }
                return $(`<div class="formatter-item ${selected}" id="${id}" title="${formatter.path ? formatter.path : ""}"><div class="formatter-title"><span class="formatter-id">${formatter.uid}</span> ${formatter.name}</div><div class="formatter-help">${help}</div></div>`)
                    .click(() => {
                    this.sectionConfig.formatter = formatter.uid;
                    this.displayPreview();
                    $(".formatter-item.selected").removeClass("selected");
                    $("#" + id).addClass("selected");
                });
            };
            const sectionTitle = (title) => {
                return $(`<div class="list-section-title">${title}</div>`);
            };
            const formatterList = $(`<div class="formatter-list">`);
            const scroller = () => {
                const id = `#formatter-item-${this.sectionConfig.formatter}`;
                const offsetElement = $(id);
                if (offsetElement.length > 0) {
                    const me = offsetElement[0];
                    const myOffset = me.offsetTop;
                    const parentOffset = me.parentElement.offsetTop;
                    formatterList.scrollTop(myOffset - parentOffset);
                }
            };
            sectionTitle("Lists").appendTo(formatterList);
            const topLevelLists = Layouter.filterTopLevelFormatters(formatters.items, "SEQUENTIAL");
            const topLevelTables = Layouter.filterTopLevelFormatters(formatters.items, "TABLE");
            Object.keys(topLevelLists).sort(Layouter.sortItems).forEach(id => {
                const formatter = formatters.items[id];
                createFormatter(formatter).appendTo(formatterList);
            });
            sectionTitle("Tables").appendTo(formatterList);
            Object.keys(topLevelTables).sort(Layouter.sortItems).forEach(id => {
                const formatter = formatters.items[id];
                createFormatter(formatter).appendTo(formatterList);
            });
            window.setTimeout(scroller, 100);
            return formatterList;
        }
        displayPreview(previewDiv) {
            let width = "100%";
            if (previewDiv == null) {
                previewDiv = $("#layoutR");
                width = this.displayStyle.width;
            }
            Layouter.convert(this.sectionConfig, this.fromSelection, this.toSelection, width, this.mf, previewDiv);
        }
        introOptions() {
            const dlg = $("<div>").appendTo($("body"));
            const ui = $("<div style='height:100%;width:100%'>");
            matrixlib_1.ml.UI.addRichTextInput(ui, { width: "100%" }, "intro", this.sectionConfig, "description", () => { }, () => { });
            matrixlib_1.ml.UI.addRichTextInput(ui, { width: "100%" }, "intro only if there are items selected", this.sectionConfig, "descriptionContent", () => { }, () => { });
            matrixlib_1.ml.UI.addRichTextInput(ui, { width: "100%" }, "intro if there are no items selected", this.sectionConfig, "descriptionNoContent", () => { }, () => { });
            matrixlib_1.ml.UI.showDialog(dlg, "Set introductory text", ui, $(document).width() * 0.90, globals_1.app.itemForm.height() * 0.90, [{
                    text: "Close",
                    "class": "btnDoIt",
                    click: () => {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { dlg.remove(); this.displayPreview(); });
        }
        advancedOptions() {
            let current = this.sectionConfig.functionDefaults ? this.sectionConfig.functionDefaults : {};
            let je = new JsonEditor_1.JsonEditor();
            let apiHelp = `<h1>Section options</h1>
<p>The content is rendered using functions specified in the PRINT project. Each function has some parameters with some default values.</p>
<p>The default parameters of functions can be overwritten globally (for all projects), in the PRINT project itself, for the project itself or for each section</p>
<p>These are the section settings with the following syntax</p>
<pre>
{
    "debug":number // default:0. if set to 1 or more some debugging information is printed.
    "FUNCTION_1_ID": { // the id of the function (see below a list of all functions)
        "FUNCTION_PARAM_1":value1 // the name of a parameter and it's value
        "FUNCTION_PARAM_2":value2
        ...
    },
    "FUNCTION_2_ID": { 
        ...
    }
}
</pre>
<p>The following functions exist:</p>`;
            $.each(PrintProcessorInterfaces_1.globalPrintConfig.getAllFunctions(), function (uid, fct) {
                apiHelp += fct.getHelp(true).replace("<pre>", `<pre>"${uid}":{`).replace("</pre>", "}</pre>");
            });
            je.showDialog("Advanced Options", JSON.stringify(current), (newValue) => {
                this.sectionConfig.functionDefaults = JSON.parse(newValue);
                this.displayPreview();
            }, { apiHelp: apiHelp });
        }
        static sortItems(a, b) {
            const aRef = matrixlib_1.ml.Item.parseRef(a);
            const bRef = matrixlib_1.ml.Item.parseRef(b);
            return aRef.number - bRef.number;
        }
        static filterTopLevelFormatters(formatters, category) {
            const result = {};
            Object.keys(formatters).forEach(key => {
                if (key.indexOf(category + "-") == 0 && !formatters[key].deleted && formatters[key].topLevelTemplate) {
                    result[key] = formatters[key];
                }
            });
            return result;
        }
        // wait until a document has been created
        waitForJob(jobId) {
            let that = this;
            let res = $.Deferred();
            globals_1.app.getReportDetails(jobId).done(function (progress) {
                if (progress.status === "Error" || progress.status.indexOf("Report generation error") === 0) {
                    matrixlib_1.ml.UI.showError("Error creating document", "");
                }
                else if (progress.status !== "Done" || progress.progress < 100) {
                    window.setTimeout(function () {
                        that.waitForJob(jobId).done(function (iXML, oXML) {
                            res.resolve(iXML, oXML);
                        });
                    }, 500);
                }
                else {
                    let filters = progress.jobFile.filter(jobFile => jobFile.visibleName == "filter.xml");
                    // let mos = progress.jobFile.filter( (jobFile) => { return jobFile.visibleName != "filter.xml" && jobFile.mimeType == "text/xml"});
                    res.resolve(filters[0].jobFileId); //, mos[0].jobFileId);
                }
            });
            return res;
        }
        static convert(customSectionConfig, customSectionFroms, customSectionTo, paperWidth, mf, container) {
            let pp = PrintProcessorInterfaces_1.globalPrintConfig.getPrintProcessor();
            var format = "html";
            if (paperWidth === "EXCEL") {
                format = "xlsx";
            }
            let startPrepare = new Date().getTime();
            pp.prepareProcessing(mf, (message) => {
                matrixlib_1.ml.UI.showError("processing error", message);
            }, format);
            let timer = new Date().getTime() - startPrepare;
            console.log("report preparation time [s]:" + timer / 1000);
            container.html("").append(matrixlib_1.ml.UI.getSpinningWait("creating preview..."));
            globals_1.app.readSettingCustomerJSONAsync("PrintProcessor").done(function (formatters) {
                // put newest into cache
                globals_1.matrixSession.setCustomerSettingJSON("PrintProcessor", formatters);
                let projectSettings = globals_1.globalMatrix.ItemConfig.getDHFConfig();
                let projectFunctionDefaults = projectSettings && projectSettings.functionDefaults ? projectSettings.functionDefaults : { debug: 0 };
                let startDate = new Date().getTime();
                let rendered = pp.processSection(formatters, customSectionConfig, projectFunctionDefaults, customSectionFroms ? customSectionFroms.split(",") : [], customSectionTo ? customSectionTo.split(",") : []);
                let timer = new Date().getTime() - startDate;
                console.log("report generation time [s]:" + timer / 1000);
                console.log(pp.globals.count);
                let iframe = $(`<iframe frameborder='0' style='width:${paperWidth}'>`);
                container.html("");
                container.append(iframe);
                let doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                const ppStylingKey = "new_element_custom_style";
                let ppStyling = "";
                if (globals_1.globalMatrix.ItemConfig.getSetting(ppStylingKey)) {
                    ppStyling += globals_1.globalMatrix.ItemConfig.getSetting(ppStylingKey) + "\n";
                }
                ppStyling += pp.getCustomStylesheet();
                doc.write(`<!doctype html>
            <html>
                <head>
                <link href="/static/css/print.css" rel="stylesheet" type="text/css" />
                <link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css" />
                <style>
                    ${ppStyling}
                </style>
                </head>
                <body>
                    ${rendered.html}
                </body>
            </html>`);
                doc.close();
                $("a", doc.body).attr("target", "_blank");
                iframe.width(paperWidth == "100%" ? (iframe[0].contentWindow.document.body.scrollWidth - 10) : iframe.width() + 50);
                iframe.height(iframe[0].contentWindow.document.body.scrollHeight + 50);
                window.setTimeout(() => {
                    iframe.height(iframe[0].contentWindow.document.body.scrollHeight + 50);
                }, 1);
            });
        }
    }
    exports.Layouter = Layouter;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 49 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.setGlobalPrintConfig = exports.globalPrintConfig = exports.PrintFindAllScriptsRegex = void 0;
    const PrintFindAllScriptsRegex = /\$\[.*?\]\$/g;
    exports.PrintFindAllScriptsRegex = PrintFindAllScriptsRegex;
    var globalPrintConfig;
    exports.globalPrintConfig = globalPrintConfig;
    function setGlobalPrintConfig(config) {
        exports.globalPrintConfig = globalPrintConfig = config;
    }
    exports.setGlobalPrintConfig = setGlobalPrintConfig;
    ;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 50 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1, MatrixLibInterfaces_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.JsonEditor = void 0;
    class JsonEditor {
        constructor() { }
        ;
        showDialog(title, value, onOk, semanticValidate = {}) {
            let dlg = $("<div>").appendTo("body");
            dlg.html("");
            dlg.addClass("dlg-v-scroll");
            dlg.removeClass("dlg-no-scroll");
            const container = $("<div id='jsonEditorContainer' class='jsonEditorContainer'>");
            // const containerContainer = $("<div id='jsonEditorContainerContainer'>");
            const editor = $("<div class='theeditor'>").appendTo(container);
            // container.append(containerContainer);
            // dlg.append(container);
            matrixlib_1.ml.UI.showDialog(dlg, title, container, $(document).width() * 0.9, globals_1.app.itemForm.height() * 0.9, [
                {
                    text: 'Ok',
                    class: 'btnDoIt',
                    click: function (event) {
                        let value = editor.getController().getValue();
                        try {
                            jsl.parser.parse(value);
                            let json = JSON.parse(value);
                            const callback = (error) => {
                                const submit = () => {
                                    onOk(value);
                                    dlg.dialog("close");
                                };
                                if (error) {
                                    if (event.shiftKey) {
                                        console.error("Validation error suppressed", error);
                                        submit();
                                        return;
                                    }
                                    matrixlib_1.ml.UI.showError("JSON Validation error", `<div style='font-weight: bold'>You can still save if you press the Shift key while clicking OK.</div><div>${error}</div>`);
                                    // ignore OK
                                    event.preventDefault();
                                    //return false;
                                }
                                else {
                                    submit();
                                }
                            };
                            if (semanticValidate.validationFunction) {
                                semanticValidate.validationFunction(json)
                                    .then(callback)
                                    .catch((err) => console.log("error", err));
                            }
                            else if (semanticValidate.schema) {
                                globals_1.globalMatrix.jsonValidator.validateType(json, semanticValidate.schema)
                                    .then(errors => callback(globals_1.globalMatrix.jsonValidator.errorString(errors)))
                                    .catch((err) => console.log("error", err));
                            }
                            else {
                                onOk(value);
                                dlg.dialog("close");
                            }
                        }
                        catch (parseException) {
                            alert(parseException.message);
                        }
                    }
                },
                {
                    text: 'Cancel',
                    class: 'btnCancelIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }
            ], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, false, true, () => {
                dlg.remove();
            }, () => {
                editor.html("").plainText({
                    id: "",
                    help: "&nbsp;",
                    controlState: globals_1.ControlState.DialogCreate,
                    valueChanged: function () { },
                    isFolder: true,
                    canEdit: true,
                    fieldValue: value,
                    parameter: {
                        code: 'json',
                        height: 0,
                        autoFormat: true,
                        showJSONFormat: true,
                        apiHelp: semanticValidate.apiHelp,
                        hideFullscreen: true
                    }
                });
                if (semanticValidate.schema) {
                    globals_1.globalMatrix.jsonValidator.schemaView(semanticValidate.schema).then(view => {
                        editor.addClass("split");
                        let drag = $("<div id='codeDrag'>");
                        container.append(drag);
                        let help = $(view.render());
                        help.addClass("editorHelp");
                        container.append(help);
                        drag.mousedown(function (e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            let mi = container.offset().left;
                            let ma = container.width() + mi;
                            $(document).mousemove(function (e) {
                                if (e.pageX > mi + 100 && e.pageX < ma - 100) {
                                    let per = 100 * (e.pageX - mi) / container.width();
                                    editor.css("width", per + "%");
                                    help.css("width", (100 - per) + "%");
                                }
                            });
                        });
                    }).catch((err) => console.log("error", err));
                }
                else {
                    editor.css("width", "100%");
                }
            }, () => {
                $(".CodeMirror", dlg).height($(".apiEdit", dlg).height() - 50);
            }, false);
        }
    }
    exports.JsonEditor = JsonEditor;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 51 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(12), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(43), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, index_3, matrixlib_1, index_4, MatrixLibInterfaces_1, ItemHistoryView_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.initialize = exports.Redlining = void 0;
    class Redlining {
        constructor() {
            this.isDefault = true;
            this.selectedOnly = null;
            this.documentCompareCanceled = false;
        }
        initItem(item, jui) {
            this._item = item;
            this._jui = jui;
        }
        initServerSettings() { }
        initProject() { }
        supportsControl() {
            return false;
        }
        updateMenu(ul) {
            let that = this;
        }
        getProjectPages() {
            let that = this;
            var pages = [];
            pages.push({ id: "REDLINE", title: "Redlining", folder: "AUDIT", order: 3000, icon: "fal fa-stream", usesFilters: false, render: (options) => that.renderProjectPage(options) });
            return pages;
        }
        compareDocuments(report, leftId, rightId) {
            let that = this;
            this.documentCompareCanceled = false;
            globals_1.app.getItemAsync(leftId).done((leftItem) => {
                if (that.documentCompareCanceled)
                    return;
                globals_1.app.getItemAsync(rightId).done((rightItem) => {
                    if (that.documentCompareCanceled)
                        return;
                    let leftDate = matrixlib_1.ml.Item.parseRef(leftId).type == "DOC" ? new Date().toISOString() : leftItem.history[leftItem.history.length - 1].date;
                    let rightDate = matrixlib_1.ml.Item.parseRef(rightId).type == "DOC" ? new Date().toISOString() : rightItem.history[rightItem.history.length - 1].date;
                    let leftFilter = that.getFilterOfDoc(leftId, leftItem);
                    let rightFilter = that.getFilterOfDoc(rightId, rightItem);
                    that.compareDocumentsDetail(report, leftId, rightId, leftDate, rightDate, leftFilter, rightFilter);
                });
            });
        }
        cancelCompare() {
            this.documentCompareCanceled = true;
        }
        compareDocumentsDetail(report, leftId, rightId, leftCreationDate, rightCreationDate, leftFilter, rightFilter) {
            let that = this;
            this.selectedOnly = null;
            report.html("");
            let containerDetailsSections = $("<div>").appendTo(report);
            let containerDetailsItems = $("<div>").appendTo(report);
            let step1 = matrixlib_1.ml.UI.getSpinningWait("Retrieving documents - please wait");
            containerDetailsSections.append(step1);
            let leftParams = { format: "html" };
            if (leftFilter)
                leftParams["filter"] = leftFilter;
            let rightParams = { format: "html" };
            if (rightFilter)
                leftParams["filter"] = rightFilter;
            globals_1.app.startCreateDocumentAsync(leftId, leftParams).done(function (result) {
                if (that.documentCompareCanceled)
                    return;
                index_2.mDHF.loadDocument(result.jobId, function (leftHTML) {
                    if (that.documentCompareCanceled)
                        return;
                    globals_1.app.startCreateDocumentAsync(rightId, rightParams).done(function (result) {
                        if (that.documentCompareCanceled)
                            return;
                        index_2.mDHF.loadDocument(result.jobId, function (rightHTML) {
                            if (that.documentCompareCanceled)
                                return;
                            if (new Date(leftCreationDate) < new Date(rightCreationDate)) {
                                that.showDetailedSectionChanges(containerDetailsSections, leftId, rightId, leftHTML, rightHTML);
                                that.showDetailedItemChanges(containerDetailsItems, leftId, rightId, leftCreationDate, rightCreationDate, leftHTML, rightHTML);
                            }
                            else {
                                that.showDetailedSectionChanges(containerDetailsSections, rightId, leftId, rightHTML, leftHTML);
                                that.showDetailedItemChanges(containerDetailsItems, rightId, leftId, rightCreationDate, leftCreationDate, rightHTML, leftHTML);
                            }
                        });
                    });
                });
            });
        }
        destroy() {
        }
        getFilterOfDoc(id, item) {
            if (matrixlib_1.ml.Item.parseRef(id).type != "DOC") {
                return ""; // only interested in filter of DOC items
            }
            let filterFieldIds = globals_1.globalMatrix.ItemConfig.getFieldsOfType("docFilter", "DOC");
            if (filterFieldIds.length == 0) {
                return ""; // no filter field
            }
            // get filter id
            let filterFieldId = filterFieldIds[0].field.id;
            // get filter from item 
            let filter = item[filterFieldId];
            if (!filter) {
                return "";
            }
            return JSON.parse(filter).join(",");
        }
        // shows pure text changes for each section
        showDetailedSectionChanges(container, leftId, rightId, leftHTML, rightHTML) {
            let that = this;
            container.html('<h1>Document sections</h1>');
            let dynamicSections = index_2.mDHF.getSections(true);
            let staticSections = index_2.mDHF.getSections(false);
            let allSections = dynamicSections.concat(staticSections);
            // get all the right sections as 'baseline'
            let left23 = false;
            let right23 = false;
            let pairs = [];
            $(".subchapter,.subsubchapter,.checksection", $(rightHTML)).each((idx, section) => {
                let type = that.getTypeFromClass($(section).attr("class"), allSections);
                if (type)
                    right23 = true;
                pairs.push({ right: {
                        html: that.getHtmlFromSection($(section)),
                        title: that.getTitleFromSection($(section)),
                        type: type
                    }, left: null,
                    dynamic: dynamicSections.indexOf(type) != -1 });
            });
            // add the left sections to the matching right or at end
            // get all the left sections
            $(".subchapter,.subsubchapter,.checksection", $(leftHTML)).each((idx, section) => {
                let type = that.getTypeFromClass($(section).attr("class"), allSections);
                if (type)
                    left23 = true;
            });
            let only23 = left23 && right23;
            $(".subchapter,.subsubchapter,.checksection", $(leftHTML)).each((idx, section) => {
                let type = that.getTypeFromClass($(section).attr("class"), allSections);
                if (type)
                    left23 = true;
                let left = {
                    html: that.getHtmlFromSection($(section)),
                    title: that.getTitleFromSection($(section)),
                    type: type
                };
                let added = false;
                for (let pair of pairs) {
                    // if both are 2.3 generated documents, go by section type and title - if not only title
                    if (!added && !pair.left && pair.right.title == left.title && (!only23 || pair.right.type == left.type)) {
                        pair.left = left;
                        added = true;
                    }
                }
                if (!added) {
                    // no match 
                    pairs.push({ left: left, right: null, dynamic: dynamicSections.indexOf(type) != -1 });
                }
            });
            // now the pairs is a list of matching section pairs
            let table = $(`<table class="table table-bordered">
            <thead><tr><th style='width:50%'>${leftId}!</th><th style='width:50%'>${rightId}!</th></tr></thead>
            <tbody></tbody>
        </table>`).appendTo(container).highlightReferences();
            for (let pair of pairs) {
                let sectionItems = `${pair.dynamic ? " - see item differences below" : ""}`;
                if (pair.left && pair.right) {
                    if (pair.left.html.html() == pair.right.html.html()) {
                        $(`<tr><td colspan=2><b>${pair.left.title}</b> did not change${sectionItems} <span class="viewHtml">(view rendered text)</span>.</td></tr>`)
                            .appendTo($("tbody", table))
                            .data("single", pair.left);
                    }
                    else {
                        $(`<tr><td colspan=2><b>${pair.left.title}</b> has changed${sectionItems} <span class="compareHtml">(compare rendered text)</span>.</td></tr>`)
                            .appendTo($("tbody", table))
                            .data("pair", pair);
                    }
                }
                else if (pair.left) {
                    $(`<tr><td><b>${pair.left.title}</b> does not exist in other${sectionItems} <span class="viewHtml">(view rendered text)</span>.</td><td>n/a</td></tr>`)
                        .appendTo($("tbody", table))
                        .data("single", pair.left);
                }
                else {
                    $(`<tr><td>n/a</td><td><b>${pair.right.title}</b> does not exist in other${sectionItems} <span class="viewHtml">(view rendered text)</span>.</td></tr>`)
                        .appendTo($("tbody", table))
                        .data("single", pair.right);
                }
            }
            $(".compareHtml").click((event) => {
                that.compareHtmlSection(event, leftId, rightId);
            });
            $(".viewHtml").click((event) => {
                that.viewHtmlSection(event);
            });
        }
        // goes from ".subchapter,.subsubchapter" and takes all until end or next  ".subchapter,.subsubchapter", 
        getHtmlFromSection(section) {
            if (section.hasClass("checksection")) {
                return section.clone();
            }
            let div = $("<div>");
            let next = section.next();
            while (next && next.length) {
                if (next.hasClass("subchapter") || next.hasClass("subsubchapter") || next.hasClass("checksection")) {
                    next = null;
                }
                else {
                    let after = next.next();
                    if (next[0].nodeName != "HR") { // there are some HRs in the html rendering between sections to make it pretty
                        div.append(next.clone());
                    }
                    next = after.length ? after : null;
                }
            }
            return div;
        }
        getTitleFromSection(section) {
            if (section.hasClass("checksection")) {
                return $("b", section).text();
            }
            else {
                return section.text();
            }
        }
        // view a rendered html section
        compareHtmlSection(event, leftId, rightId) {
            let btn = $(event.delegateTarget);
            let pair = btn.closest("tr").data("pair");
            let left = new index_4.HTMLCleaner(pair.left.html.html(), false).getClean(index_4.HTMLCleaner.CleanLevel.Strict, true);
            let right = new index_4.HTMLCleaner(pair.right.html.html(), false).getClean(index_4.HTMLCleaner.CleanLevel.Strict, true);
            let param = {
                arg: JSON.stringify({ versions: [left, right] })
            };
            globals_1.app.compareHTML(param).done(function (result) {
                let dlg = $("<div>").appendTo($("body"));
                let content = $(`<table class="table table-bordered">
                <thead><tr></tr></thead>
                <tbody></tbody>
            </table>`);
                $("thead tr", content).append($("<th style='width:50%'>").append(matrixlib_1.ml.Item.renderLink(leftId, null, true)));
                $("thead tr", content).append($("<th style='width:50%'>").append(matrixlib_1.ml.Item.renderLink(rightId, null, true)));
                $(`<tr><td>${result.html[0]}</td><td>${result.html[1]}</td></tr>`)
                    .appendTo($("tbody", content));
                matrixlib_1.ml.UI.showDialog(dlg, "Section Compare", content, $(document).width() * 0.85, globals_1.app.itemForm.height() * 0.85, [{
                        text: "Ok",
                        class: 'btnDoIt',
                        click: function () {
                            dlg.dialog("close");
                        }
                    }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { dlg.remove(); }, () => { }, () => { });
            });
        }
        // view a rendered html section
        viewHtmlSection(event) {
            let btn = $(event.delegateTarget);
            let single = btn.closest("tr").data("single");
            let dlg = $("<div>").appendTo($("body"));
            let content = $("<div>").append($("<div class='redlineView'>").append(single.html));
            matrixlib_1.ml.UI.showDialog(dlg, "Section Content '" + single.title + "'", content, 800, globals_1.app.itemForm.height() * 0.90, [{
                    text: "Ok",
                    class: 'btnDoIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { dlg.remove(); }, () => { }, () => { });
        }
        // returns a section type of a document section
        getTypeFromClass(css, allSections) {
            // here I could remove other classes...
            if (!css)
                return "";
            let classes = css.split(" ");
            for (let cls of classes) {
                if (allSections.indexOf(cls) != -1) {
                    return cls;
                }
            }
            // no known section
            return "";
        }
        // show a list of items side by side
        showDetailedItemChanges(container, leftId, rightId, leftCreationDate, rightCreationDate, leftHTML, rightHTML) {
            let that = this;
            let step3 = matrixlib_1.ml.UI.getSpinningWait("Retrieving all changed items");
            container.append(step3);
            globals_1.restConnection.getProject("tree?fancy&atDate=" + new Date(leftCreationDate).toISOString()).done(function (leftTree) {
                if (that.documentCompareCanceled)
                    return;
                globals_1.restConnection.getProject("tree?fancy&atDate=" + new Date(rightCreationDate).toISOString()).done(function (rightTree) {
                    if (that.documentCompareCanceled)
                        return;
                    // this are all the link ids in any of the documents + some which might be false positives
                    let leftLinks = that.extractLinks(leftHTML);
                    let rightLinks = that.extractLinks(rightHTML);
                    // let step3 = ml.UI.getSpinningWait( "1/4 Getting details " + rightId);
                    // report.append( step2 );
                    let leftVersions = [];
                    let rightVersions = [];
                    that.createItemsFromTree(leftTree, leftVersions);
                    that.createItemsFromTree(rightTree, rightVersions);
                    // filter the items from a certain time by those in the actual documents
                    leftVersions = leftVersions.filter(version => leftLinks[version.ref]);
                    rightVersions = rightVersions.filter(version => rightLinks[version.ref]);
                    let leftDisplay = leftId + "! (" + matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(leftCreationDate), false) + ")";
                    let rightDisplay = rightId + "! (" + matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(rightCreationDate), false) + ")";
                    container.html('<h1>Referenced items</h1>');
                    let warning = $("<div>").appendTo(container);
                    if (leftVersions.length == 0 && rightVersions.length == 0) {
                        warning.html("Neither document contains any items.");
                        return;
                    }
                    that.addFilters(container, leftId, rightId);
                    let diffTable = $("<div>").appendTo(container);
                    that.showDifferences(diffTable, leftVersions, rightVersions, leftDisplay, rightDisplay);
                    that.hideShow();
                });
            });
        }
        // gets all the potential hyperlinks in a <a>XXX-YY</a>
        extractLinks(html) {
            let links = {};
            $.each($("a,.smartreplace", $(html)), (idx, item) => {
                let linkText = $(item).text();
                if (linkText) {
                    let beforeSpace = linkText.split(" ")[0];
                    if (!beforeSpace.match(/[^A-Z0-9\-]/)) {
                        // potential link only letters, digits and -
                        links[beforeSpace] = true;
                    }
                }
            });
            return links;
        }
        // retrieve a list of included items
        getIncludedItems(leftId, rightId) {
            let that = this;
            let res = $.Deferred();
            globals_1.restConnection.getProject("itemlist/" + leftId).done(function (leftItems) {
                if (that.documentCompareCanceled)
                    return;
                globals_1.restConnection.getProject("itemlist/" + rightId).done(function (rightItems) {
                    if (that.documentCompareCanceled)
                        return;
                    // the list might have some duplicates...
                    that.selectedOnly = rightItems.items.map(item => item.ref).concat(leftItems.items.map(item => item.ref));
                    res.resolve();
                });
            });
            return res;
        }
        // project pages show in the top in Projects, Reports and Documents
        renderProjectPage(options) {
            let that = this;
            if (options.controlState === globals_1.ControlState.Print) {
                return;
            }
            document.title = "Redline - " + globals_1.matrixSession.getProject();
            options.control.html("");
            options.control.prepend(matrixlib_1.ml.UI.getPageTitle("Change between two dates"));
            if (matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                $(".toolbarButtons .buttonCTA").remove();
                $(".toolbarButtons").append(matrixlib_1.ml.UI.DateTime.getTimeZoneCTA());
            }
            this.panel = $('<div class="panel-body-v-scroll fillHeight" style="padding: 0 12px;">').appendTo(options.control);
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                $("<h2>Browse tree to find changes done after: " + matrixlib_1.ml.UI.DateTime.renderCustomerHumanDate(new Date(globals_1.globalMatrix.ItemConfig.getTimeWarp()), false) + "</h2>").appendTo(this.panel);
                $("<div>The tree shows items in red if they changed after the above date</div>").appendTo(this.panel);
                $("<div>History of items shows the last change before the date in red, versions after in grey.</div>").appendTo(this.panel);
                return;
            }
            let report = $("<div>");
            this.showDateSelection(report);
            this.panel.append(report);
        }
        addFilters(report, leftId, rightId) {
            let that = this;
            let filters = $("<div class='hideCopy'>").appendTo(report);
            $('<div class="alignHorizontal" ><div class="checkbox" ><label><input type="checkbox" class="checkboxFilter" data-hide="unchanged" >show identical</label></div></div>').appendTo(filters);
            $('<div class="alignHorizontal" ><div class="checkbox" ><label><input type="checkbox" class="checkboxFilter" data-hide="column1_not_included" checked >show added</label></div></div>').appendTo(filters);
            $('<div class="alignHorizontal" ><div class="checkbox" ><label><input type="checkbox" class="checkboxFilter" data-hide="column2_not_included" checked >show removed</label></div></div>').appendTo(filters);
            $('<div class="alignHorizontal" ><div class="checkbox" ><label><input type="checkbox" class="checkboxFilter" data-hide="changed" checked >show changed</label></div></div>').appendTo(filters);
            if (leftId && rightId) {
                $('<div class="alignHorizontal" ><div class="checkbox" ><label><input disabled type="checkbox" class="selectedOnly">selected items only</label></div></div>').appendTo(filters);
                this.getIncludedItems(leftId, rightId).done(() => {
                    matrixlib_1.ml.UI.setEnabled($(".selectedOnly"), true);
                });
            }
            $("input", report).change(function () {
                that.hideShow();
            });
            matrixlib_1.ml.UI.copyBuffer(filters, "copy to clipboard", report, this.panel);
        }
        hideShow() {
            let that = this;
            $("tr", this.panel).show();
            // by default show all
            $(".compareItem").show().removeClass("hideCopy");
            $.each($(".checkboxFilter", this.panel), function (idx, input) {
                if ($(input).data("hide")) {
                    let sh = $("." + $(input).data("hide"), that.panel);
                    if ($(input).prop("checked")) {
                        sh.show();
                        sh.removeClass("hideCopy");
                    }
                    else {
                        sh.hide();
                        sh.addClass("hideCopy");
                    }
                }
            });
            if ($(".selectedOnly").prop("checked")) {
                $(".compareItem").each((idx, ci) => {
                    if (that.selectedOnly.indexOf($(ci).data("ci")) == -1) {
                        $(ci).hide().addClass("hideCopy");
                    }
                });
            }
        }
        showDateSelection(report) {
            let that = this;
            let bc = $('<div class="baseControl">').appendTo(this.panel);
            let p = $("<p>").appendTo(bc);
            $('<span class="">From </span>').appendTo(p);
            let fromDate = $("<input type='text' class='form-control redlineDates'>").appendTo(p);
            $('<span class=""> to </span>').appendTo(p);
            let toDate = $("<input type='text' class='form-control redlineDates'>").appendTo(p);
            let goButton = $('<button style="margin-left: 12px" type="button" class="btn btn-success">Compare</button>').appendTo(p);
            let timeWarp = $('<span>').appendTo(p);
            fromDate.datetimepicker({ format: matrixlib_1.ml.UI.DateTime.getSimpleDateTimeFormatMoment() });
            toDate.datetimepicker({
                defaultDate: new Date(),
                useCurrent: false,
                format: matrixlib_1.ml.UI.DateTime.getSimpleDateTimeFormatMoment()
            });
            matrixlib_1.ml.UI.setEnabled(goButton, fromDate.data("DateTimePicker").date() && toDate.data("DateTimePicker").date());
            timeWarp.hide();
            fromDate.on("dp.change", function (e) {
                toDate.data("DateTimePicker").minDate(e.date);
                matrixlib_1.ml.UI.setEnabled(goButton, fromDate.data("DateTimePicker").date() && toDate.data("DateTimePicker").date());
                if (fromDate.data("DateTimePicker").date()) {
                    timeWarp.html("<a style='margin-left: 12px' type='button' class='showMore' >Time warp</a>: show project as it was at " + matrixlib_1.ml.UI.DateTime.renderCustomerHumanDate(new Date(fromDate.data("DateTimePicker").date()), false));
                    timeWarp.show();
                }
                else {
                    timeWarp.hide();
                }
            });
            toDate.on("dp.change", function (e) {
                fromDate.data("DateTimePicker").maxDate(e.date);
                matrixlib_1.ml.UI.setEnabled(goButton, fromDate.data("DateTimePicker").date() && toDate.data("DateTimePicker").date());
            });
            goButton.click(function () {
                that.createRedLineDates(report, fromDate.data("DateTimePicker").date(), toDate.data("DateTimePicker").date());
            });
            timeWarp.click(function () {
                let win = window.open(globals_1.globalMatrix.matrixBaseUrl + "/" + globals_1.matrixSession.getProject() + "?atDate=" + fromDate.data("DateTimePicker").date().toISOString(), '_blank');
                if (win) {
                    //Browser has allowed it to be opened
                    win.focus();
                }
                else {
                    //Browser has blocked it
                    alert('Please allow popups for this site');
                }
            });
        }
        createRedLineDates(report, fromDate, toDate) {
            let that = this;
            report.html("");
            report.append(matrixlib_1.ml.UI.getSpinningWait("retrieving changes between the dates"));
            // get the tree at both dates 
            globals_1.restConnection.getProject("tree?fancy&atDate=" + fromDate.toISOString()).done(function (fromTree) {
                globals_1.restConnection.getProject("tree?fancy&atDate=" + toDate.toISOString()).done(function (toTree) {
                    fromTree = index_3.RestDB.filterLegacyReportCat(fromTree);
                    toTree = index_3.RestDB.filterLegacyReportCat(toTree);
                    report.html("");
                    that.addFilters(report);
                    let diffTable = $("<div>").appendTo(report);
                    let fromItems = [];
                    let toItems = [];
                    that.createItemsFromTree(fromTree, fromItems);
                    that.createItemsFromTree(toTree, toItems);
                    that.showDifferences(diffTable, fromItems, toItems, matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(fromDate.toISOString()), false), matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date(toDate.toISOString()), false));
                    that.hideShow();
                });
            });
        }
        createItemsFromTree(tree, items) {
            let that = this;
            $.each(tree, function (idx, node) {
                if (node.children) {
                    // this is a folder
                    that.createItemsFromTree(node.children, items);
                }
                else {
                    // this is a leaf
                    items.push({
                        author: "",
                        birth: "",
                        ref: node.id,
                        title: node.title,
                        version: (node.version ? Number(node.version.split("/")[0]) : 0)
                    });
                }
            });
        }
        showDifferences(diffTable, fromItems, toItems, fromText, toText) {
            let fromIds = fromItems.map(function (item) { return item.ref; }).sort(function (a, b) { return matrixlib_1.ml.Item.sort(a, b); });
            let toIds = toItems.map(function (item) { return item.ref; }).sort(function (a, b) { return matrixlib_1.ml.Item.sort(a, b); });
            // create a sorted list of ids (every id only once)
            let fromToIdsAll = fromIds.concat(toIds);
            let fromToIds = [];
            $.each(fromToIdsAll, function (ftidx, ft) {
                if (fromToIds.indexOf(ft) == -1)
                    fromToIds.push(ft);
            });
            fromToIds = fromToIds.sort(function (a, b) { return matrixlib_1.ml.Item.sort(a, b); });
            // build table header
            let table = $("<table class='table table-bordered'>").appendTo(diffTable);
            let head = $("<thead>").appendTo(table);
            let trh = $("<tr>").appendTo(head);
            $("<th>").html("Item").appendTo(trh);
            // build table body
            let tbody = $("<tbody>").appendTo(table);
            $("<th>").html(fromText).appendTo(trh);
            $("<th>").html(toText).appendTo(trh);
            this.addItems(tbody, fromToIds, fromItems, toItems);
            $("<th class='hideCopy'>").html("Changes").appendTo(trh);
            $(".showMore", table).click(function (event) {
                var ht = new ItemHistoryView_1.HistoryTools();
                let link = $(event.delegateTarget);
                ht.compareVersions(link.data("item"), link.data("v0"), link.data("v1"));
            });
            table.highlightReferences();
        }
        addItems(tbody, fromToRefs, fromRefs, toRefs) {
            let that = this;
            $.each(fromToRefs, function (ftIdx, ft) {
                // left column / first doc
                let fromDetails = fromRefs.filter(function (ref) { return ref.ref == ft; });
                // right column / second doc
                let toDetails = toRefs.filter(function (ref) { return ref.ref == ft; });
                // check which version is in which column (if included)
                let both = 0;
                let afterIdx = 0;
                let beforeIdx = 0;
                let existsInFirst = false;
                let tr = $(`<tr class="compareItem" data-ci="${ft}">`).appendTo(tbody);
                let itemColumn = $("<td>").appendTo(tr);
                itemColumn.append($("<span class='hideCopy'>").html(ft + "!"));
                itemColumn.append($("<span class='replaceCopy'>").data("with", ft + "!"));
                if (fromDetails.length != 1) {
                    $("<td>").html("not included").appendTo(tr);
                    tr.addClass("column1_not_included");
                }
                else {
                    existsInFirst = true;
                    both++;
                    beforeIdx = fromDetails[0].version;
                    $("<td>").html("v" + beforeIdx).appendTo(tr);
                }
                if (toDetails.length != 1) {
                    $("<td>").html("not included").appendTo(tr);
                    tr.addClass("column2_not_included");
                }
                else {
                    both++;
                    afterIdx = toDetails[0].version;
                    $("<td>").html("v" + afterIdx).appendTo(tr);
                }
                // add changes column
                let td = $("<td class='hideCopy'>").appendTo(tr);
                if (both != 2) {
                    // not included in both docs - no need to show changes between
                    if (existsInFirst) {
                        td.html("deleted/excluded");
                    }
                    else {
                        td.html("added/included");
                    }
                }
                else if (afterIdx != beforeIdx) {
                    let compare = $("<span class='showMore' data-item='" + ft + "' data-v0=" + beforeIdx + " data-v1=" + afterIdx + ">compare versions</span>");
                    tr.addClass("changed");
                    td.append(compare);
                }
                else {
                    td.html("no changes");
                    tr.addClass("unchanged");
                }
            });
        }
    }
    exports.Redlining = Redlining;
    function initialize() {
        index_1.plugins.register(new Redlining());
    }
    exports.initialize = initialize;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 52 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.Hidden = void 0;
    class Hidden {
        renderControl(ctrl, ctrlParameter) { ctrl.control.hidden(ctrlParameter); }
        updateXmlValue(ctrl) { }
        getConfig(ctrl) {
            return {};
        }
        addSignatures(signatures, currentValue) { }
        showSpecificSettings(ctrl, ctrlParameter, custom) { }
        saveSpecificSettings(ctrl, ctrlParameter, custom) { return false; }
        verifyContent(ctrl) { }
    }
    exports.Hidden = Hidden;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 53 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializePluginManagerFormulas = exports.tableMath = exports.TableMath = void 0;
    class TableMath {
        constructor() {
            this.functions = {};
        }
        /** allow to add new functions:  */
        registerFunction(functionId, execute) {
            this.functions[functionId] = execute;
        }
        /** executes function on a table */
        execute(functionId, table, parameterJson) {
            if (!this.functions[functionId]) {
                return `called function "${functionId}" does not exist!`;
            }
            return this.functions[functionId](table, parameterJson);
        }
    }
    exports.TableMath = TableMath;
    var tableMath;
    exports.tableMath = tableMath;
    function InitializePluginManagerFormulas() {
        exports.tableMath = tableMath = new TableMath();
        tableMath.registerFunction("percent", (table, parameterJson) => {
            for (let row of table) {
                if (row.y == 0)
                    return `The value in fy cannot be 0!`;
                row.z = Math.round(100 * Number(row.x) / Number(row.y));
            }
            return "";
        });
    }
    exports.InitializePluginManagerFormulas = InitializePluginManagerFormulas;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 54 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(19), __webpack_require__(7), __webpack_require__(13), __webpack_require__(1), __webpack_require__(45), __webpack_require__(55), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ProjectViewDefines_1, MatrixRequirementsAPI_1, PluginManager_1, matrixlib_1, ItemSelectionView_1, TestManager_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializeTasks = exports.mTasks = exports.Tasks = void 0;
    ;
    ;
    class Tasks {
        constructor() {
            //
            // ****************************************
            // standard plugin interface
            // ****************************************
            this.isDefault = true;
        }
        initItem(_item, _jui) {
            this.item = _item;
            this.jui = _jui;
        }
        reset() {
            this.item = null;
            this.jui = null;
        }
        initServerSettings(serverSettings) {
        }
        updateMenu(ul, hook) {
            let that = this;
            if (hook !== PluginManager_1.pluginHooks.shares) {
                return;
            }
            if (!this.item || globals_1.app.isFolder(this.item.id)) {
                return; // do not show tasks for folders
            }
            if (!globals_1.matrixSession.isEditor() || !Tasks.tasksConfiguration || Tasks.tasksConfiguration.length == 0) {
                return;
            }
            var miDivider = $('<li class="divider"></li>');
            ul.append(miDivider);
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.catFieldMapping && config.catFieldMapping[that.item.type]) {
                    $($(`<li><span class="toolmenu">Push to ${config.pluginName}</span></li>`)).click(() => {
                        that.pushIssueDlg(config);
                    }).appendTo(ul);
                }
                if (!config.hideCreateTask) {
                    if (config.handleAsLink) {
                        $(`<li><span class="toolmenu">Add web link</span></li>`)
                            .appendTo(ul)
                            .data("config", config)
                            .click(function (event) {
                            Tasks.createAndLinkWebDlg($(event.delegateTarget).data("config"), null, function (linkTitle, linkUrl) {
                                let extItem = {
                                    externalItemId: "" + new Date().getTime(),
                                    externalItemTitle: linkTitle,
                                    externalItemUrl: linkUrl,
                                    externalDescription: "",
                                    externalDone: false,
                                    plugin: config.pluginId
                                };
                                Tasks.postCreateLinks(that.item.id, [extItem]).done(function (allITems) {
                                    that.updateUI(allITems);
                                    that.jui.dialog("close");
                                });
                            });
                        });
                    }
                    else {
                        $(`<li><span class="toolmenu">Create and link ${config.pluginName} task</span></li>`)
                            .appendTo(ul)
                            .data("config", config)
                            .click(function (event) {
                            that.createAndLinkIssueDlg($(event.delegateTarget).data("config"));
                        });
                    }
                }
                if (config.nativeCreateUrl && config.nativeCreateSearch) {
                    var dev = $(`<li><span class="toolmenu">Open ${config.pluginName} create page</span></li>`)
                        .appendTo(ul)
                        .data("config", config)
                        .click(function (event) {
                        that.createSearchAndLinkIssueDlg($(event.delegateTarget).data("config"));
                    });
                }
                if (!config.hideSearchTasks && !config.handleAsLink) {
                    var dev = $(`<li><span class="toolmenu">Link to existing ${config.pluginName} task</span></li>`)
                        .appendTo(ul)
                        .data("config", config)
                        .click(function (event) {
                        that.searchAndLinkIssueDlg($(event.delegateTarget).data("config"));
                    });
                }
            });
            return;
        }
        supportsControl(ctrlType) {
            return (ctrlType === 'tasksControl');
        }
        createControl(ctrl, options) {
            ctrl.tasksControl(options);
        }
        initProject() {
            Tasks.tasksConfiguration = [];
            let pluginSettings = globals_1.globalMatrix.ItemConfig.getPluginSettings();
            // setup highlight rules
            $.each(pluginSettings, function (tidx, plugin) {
                if (plugin.pluginId > 200) {
                    let a;
                    // version 2 plugin
                    var clientConfig = {};
                    var enabled = false;
                    // get client config setting and find out if enabled
                    $.each(plugin.settings, function (idx, setting) {
                        if (setting.setting === "clientConfig" && setting.value) {
                            clientConfig = JSON.parse(setting.value);
                        }
                        else if (setting.setting === "clientEnabled") {
                            enabled = matrixlib_1.ml.JSON.isTrue(setting.value);
                        }
                    });
                    if (enabled) {
                        clientConfig.pluginId = plugin.pluginId;
                        $.each(clientConfig.smartLinks, function (idx, smartLink) {
                            // in case there are some hypelinks configured
                            addHighlightRegex(smartLink.regex, smartLink.url);
                        });
                        // unless names are defined, use server's default
                        if (!clientConfig.pluginLongName) {
                            clientConfig.pluginLongName = plugin.pluginLongName;
                        }
                        if (!clientConfig.pluginName) {
                            clientConfig.pluginName = plugin.pluginShortName;
                        }
                        if (typeof clientConfig.handleAsLink == 'undefined') {
                            clientConfig.handleAsLink = plugin.capabilities.handleAsLink;
                        }
                        if (typeof clientConfig.hideCreateTask == 'undefined') {
                            clientConfig.hideCreateTask = !plugin.capabilities.canCreate && !clientConfig.handleAsLink;
                        }
                        if (typeof clientConfig.hideSearchTasks == 'undefined') {
                            clientConfig.hideSearchTasks = !plugin.capabilities.canFind;
                        }
                        /*if ( typeof clientConfig.createBacklinks == 'undefined') {
                           clientConfig.createBacklinks = plugin.capabilities.canCreateBacklinks;
                        }
                        */
                        // need to run again though settings                    
                        $.each(plugin.settings, function (idx, setting) {
                            if (setting.setting === "projectFilter") {
                                clientConfig.projectFilter = setting.value ? setting.value.split(",") : [];
                            }
                        });
                        if (typeof clientConfig.hasMeta == 'undefined') {
                            clientConfig.hasMeta = plugin.capabilities.hasMeta;
                        }
                        $.each(plugin.computedSettings, function (idx, setting) {
                            if (setting.setting === "nativeCreateUrl" && !clientConfig.nativeCreateUrl) {
                                // client does not overwrite capability, so take default from server
                                clientConfig.nativeCreateUrl = setting.value;
                            }
                            if (setting.setting === "nativeCreateSearch" && !clientConfig.nativeCreateSearch) {
                                // client does not overwrite capability, so take default from server
                                clientConfig.nativeCreateSearch = setting.value;
                            }
                        });
                        Tasks.tasksConfiguration.push(clientConfig);
                    }
                }
            });
        }
        // project pages show in the top in Projects, Reports and Documents
        getProjectPages() {
            let that = this;
            var pages = [];
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                // remove the pages - too complicated
                return pages;
            }
            $.each(Tasks.tasksConfiguration, function (idx, conf) {
                pages.push({
                    id: "TASKS" + conf.pluginId,
                    title: conf.pluginName + " addon", folder: "ADDONS",
                    order: 1000 + conf.pluginId, icon: "fal fa-external-link-square",
                    usesFilters: false,
                    render: (options) => that.renderProjectPage(options)
                });
            });
            return pages;
        }
        // this function goes through all tests steps and applies all smartlink rules to find hyperlinks to issues
        preSaveHook(isItem, type, controls) {
            let that = this;
            var res = $.Deferred();
            if (isItem && TestManager_1.mTM.isXTC(type)) {
                let linksToBeCreated = []; // array of matches
                for (var idx = 0; idx < controls.length; idx++) {
                    if (controls[idx].ctrlType === "test_steps_result") {
                        var val = controls[idx].control.getController().getValue();
                        var v = JSON.parse(val);
                        for (var step = 0; step < v.length; step++) {
                            var comment = v[step].comment;
                            if (comment && comment !== "") {
                                // find matches
                                $.each(Tasks.tasksConfiguration, function (tidx, config) {
                                    $.each(config.smartLinks, function (idx, smartLink) {
                                        var re = new RegExp(smartLink.regex, "g");
                                        var hits = comment.match(re);
                                        if (hits) {
                                            $.each(hits, function (hidx, hit) {
                                                if (linksToBeCreated.indexOf(hit) === -1) {
                                                    linksToBeCreated.push(hit);
                                                }
                                            });
                                        }
                                    });
                                });
                            }
                        }
                    }
                }
                if (linksToBeCreated.length > 0) {
                    that.createLinksAsync(linksToBeCreated).done(function () {
                        res.resolve();
                    }).fail(function () {
                        res.reject();
                    });
                }
                else {
                    res.resolve();
                }
            }
            else {
                res.resolve();
            }
            return res;
        }
        // ****************************************
        // Misc functions for jiraPlugin (running inside JIRA)
        // ****************************************
        isPluginEnabled(pluginId) {
            let enabled = false;
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.pluginId == pluginId) {
                    enabled = true;
                }
            });
            return enabled;
        }
        // ****************************************
        // Misc functions for matrixreq and others
        // ****************************************
        // verifies if a save comment has all required task id's if not 
        evaluateTaskIds(comment) {
            let issues = [];
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.requireCommitTicket) {
                    let hasId = false;
                    $.each(config.smartLinks, function (sidx, smartLink) {
                        var re = new RegExp(smartLink.regex, "g");
                        var hits = comment.match(re);
                        if (hits) {
                            hasId = true;
                        }
                    });
                    if (!hasId) {
                        issues.push(`missing task id for ${config.pluginName}`);
                    }
                }
            });
            return issues;
        }
        // test if a dropped URL is a link to an issue -> if so convert it to externalitem struct
        static externalItemFromUrl(url) {
            let matches = null;
            let priority = 0;
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                $.each(config.smartUrls, function (sidx, smartUrl) {
                    if (!matches || priority < (smartUrl.priority ? smartUrl.priority : 0)) {
                        let re = new RegExp(smartUrl.regex);
                        let ma = url.match(re);
                        if (ma) {
                            // it matches: replace all palceholders, $0, $1, $2, with matching groups
                            let issueId = smartUrl.issueId;
                            let issueProjectId = smartUrl.issueProjectId;
                            let title = smartUrl.title ? smartUrl.title : "";
                            for (var i = 0; i < Math.min(ma.length, 10); i++) {
                                let rep = new RegExp("\\$" + i, "g");
                                issueProjectId = issueProjectId.replace(rep, ma[i]);
                                issueId = issueId.replace(rep, ma[i]);
                                title = title.replace(rep, ma[i]);
                            }
                            priority = smartUrl.priority ? smartUrl.priority : 0;
                            matches = {
                                plugin: config.pluginId,
                                externalProject: issueProjectId,
                                externalItemId: issueId,
                                externalItemUrl: url,
                                externalDescription: "",
                                externalItemTitle: title,
                                externalDone: false,
                                externalType: ""
                            };
                        }
                    }
                });
            });
            return matches;
        }
        addCommentToAllLinkedIssues(config, comment, whatChanged, version) {
            let that = this;
            let versionStr = version ? `to version v${version}` : "";
            if (comment == undefined) {
                comment = "";
                if (Tasks.getConfig(config.pluginId).defaultComment != undefined) {
                    comment = Tasks.getConfig(config.pluginId).defaultComment;
                }
                comment += `*${globals_1.app.getCurrentItemId()} - ${globals_1.app.getCurrentTitle().trim()}*  has been updated ${versionStr}\n *See :* ${globals_1.globalMatrix.matrixBaseUrl}/${globals_1.matrixSession.getProject()}/${globals_1.app.getCurrentItemId()} \n----`;
            }
            if (whatChanged != undefined)
                comment += "\n" + whatChanged;
            Tasks.getTasks(that.item.id, [config.pluginId]).then((externalItems) => {
                externalItems.forEach((externalItem => {
                    let job = {
                        pluginId: config.pluginId,
                        action: "AddComment",
                        matrixItem: {
                            project: globals_1.matrixSession.getProject()
                        },
                        externalItem: {
                            externalItemId: externalItem.externalItemId
                        },
                        more: [
                            { key: "comment", value: comment },
                        ]
                    };
                    globals_1.globalMatrix.wfgwConnection.postServer("?" + jQuery.param({ payload: JSON.stringify(job) }), job, true).done(() => {
                        console.log("Comment added! ");
                    }).fail(function (jqxhr, textStatus, error) {
                        Tasks.showError("AddComment failed", jqxhr, textStatus, error);
                    });
                }));
            });
        }
        /** this creates a new item and jira and sets the define fields with values coming from Matrix */
        pushIssueDlg(config) {
            let that = this;
            let options = "";
            // create project / type drop down menu
            $.each(config.projectsCreate, function (i, project) {
                $.each(project.taskTypes, function (j, taskType) {
                    let oName = [];
                    if (project.projectName)
                        oName.push(project.projectName);
                    if (taskType.taskTypeName)
                        oName.push(taskType.taskTypeName);
                    options += "<option value='" + project.projectId + "|" + taskType.taskTypeId + "' " + (i + j == 0 ? "selected" : "") + ">" + oName.join(" / ") + "</option>";
                });
            });
            let form = $(`<div class="container" style="width:100%;height:100%">
                        <div class="row optionsSelectRow" style="margin-top:4px;margin-bottom:6px">
                            <div class="col-md-2" style="margin-top: 6px;"><label style="white-space: nowrap" for="inputType"
                                    class="control-label">Issue Type:</label></div>
                            <div class="col-md-10"><select class="form-control inputType" style="width:100%;height:32px" id="inputType">
                                    ${options}
                                </select></div>
                        </div>
                    </div>`);
            this.jui.html("");
            this.jui.removeClass("dlg-v-scroll");
            this.jui.addClass("dlg-no-scroll");
            this.jui.append(form);
            this.jui.dialog({
                autoOpen: true,
                title: "Create linked task",
                height: 200,
                width: 600,
                modal: true,
                open: function () { },
                close: function () { },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            let title = globals_1.app.getCurrentTitle();
                            let type = ($(".inputType", that.jui)).val();
                            let where = type.split("|");
                            Tasks.postPushIssue(config.pluginId, that.item.id, title, "", where[0], where[1]).done(function (newTask) {
                                that.updateUI(newTask);
                            });
                            that.jui.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.jui.dialog("close");
                        }
                    }]
            });
        }
        ;
        static postPushIssue(pluginId, itemId, title, description, projectId, taskTypeId) {
            let res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                pluginId: pluginId,
                action: "CreateIssue",
                matrixItem: {
                    project: project,
                    matrixItem: itemId
                },
                externalItem: { externalItemTitle: title, externalDescription: description },
                more: [
                    { key: "project", value: projectId },
                    { key: "issueType", value: taskTypeId }
                ]
            };
            let cat = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (Tasks.getConfig(pluginId).catFieldMapping) {
                let fm = Tasks.getConfig(pluginId).catFieldMapping[cat];
                if (fm) {
                    let uMap = Tasks.getConfig(pluginId).userMapping;
                    for (let key of Object.keys(fm)) {
                        let field = globals_1.globalMatrix.ItemConfig.getFieldByName(cat, key);
                        let value = undefined;
                        if (field && field.id) {
                            value = globals_1.app.getFieldValue(field.id);
                        }
                        // current User is gotten from session
                        if (!value && fm[key].converter == "currentUser") {
                            if (!uMap[globals_1.matrixSession.getUser()]) {
                                matrixlib_1.ml.UI.showError(`No user mapped for user '${globals_1.matrixSession.getUser()}'`, "Please ask your administrator to check that your user ID is correclty mapped in Jira Cloud extension configuration.");
                                res.reject("current user is not mapped in Jira");
                                return res;
                                ;
                            }
                            value = JSON.stringify({ "accountId": uMap[globals_1.matrixSession.getUser()] });
                        }
                        if (value) {
                            switch (fm[key].converter) {
                                case "plaintext":
                                    value = $("<div>").html(value).text();
                                    break;
                                case "dropdown":
                                    if (fm[key].ddMapping && fm[key].ddMapping[value])
                                        value = JSON.stringify({ "id": fm[key].ddMapping[value] });
                                    else {
                                        console.info("Cannot convert " + value + " to dropdown value");
                                        value = undefined;
                                    }
                                    break;
                                case "tags":
                                    value = JSON.stringify(value.replace(" ", "_").split(","));
                                    break;
                                case "labels": // converter something to jira tags
                                    let labelList = JSON.parse(value);
                                    if (labelList && labelList.length > 0) {
                                        // whatever it is jira tags cannot have spaces
                                        value = JSON.stringify(labelList.map((l) => l.replace(" ", "_")));
                                    }
                                    break;
                                case "multiselect":
                                    let values = value.split(",");
                                    if (fm[key].ddMapping) {
                                        let valuesMapped = values.map((v) => { return { "id": fm[key].ddMapping[v] }; });
                                        if (value.filter((v) => { return v.id == null || v.id == undefined; }).length == 0) {
                                            value = JSON.stringify(valuesMapped);
                                        }
                                        else {
                                            // there's at least one missing mapping
                                            console.info(`Cannot convert '${value}' to dropdown value -> there is a missing mapping`);
                                            value = undefined;
                                        }
                                    }
                                    else {
                                        console.info("Cannot convert " + value + " to dropdown value");
                                        value = undefined;
                                    }
                                    break;
                                case "currentUser":
                                    // handled before switch statement
                                    break;
                                case "user":
                                    if (uMap && uMap[value]) {
                                        value = JSON.stringify({ "accountId": uMap[value] });
                                    }
                                    else {
                                        console.info("Cannot convert " + value + " to mapped user");
                                        value = undefined;
                                    }
                                    break;
                            }
                        }
                        if (value != undefined) {
                            job.more.push({ key: fm[key].extFieldId, value: value });
                        }
                    }
                }
            }
            globals_1.globalMatrix.wfgwConnection.postServer("?" + jQuery.param({ payload: JSON.stringify(job) }), job, true).done(function (task) {
                res.resolve(task);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Creating issue failed", jqxhr, textStatus, error);
            });
            return res;
        }
        subscribe() {
            let that = this;
            MatrixRequirementsAPI_1.MR1.onAfterSave().subscribe(this, function (event) {
                try {
                    that.afterSaveHookAddComment(event);
                }
                catch (ex) {
                    console.log("failed to update the task:");
                    console.log(ex);
                }
            });
        }
        afterSaveHookAddComment(event) {
            let that = this;
            let message = "";
            // message += "-------------------------------------------------------------------------- \n";
            if (event.before.title != event.after.title) {
                message += `*Title has been updated*
                            _Old value for title_
                            {{${event.before.title}}}
                            _New value for title_
                            {{${event.before.title}}}\n----\n`;
            }
            // API is not symmetric so before and after are handled differently
            let labelsBefore = (event.before.labels && event.before.labels.length > 0) ? event.before.labels.join(",") : "[no labels set]";
            let labelsAfter = (event.after.labels && event.before.labels.length > 0) ? event.after.labels : "[no labels set]";
            if (labelsBefore != labelsAfter) {
                message += `*Labels has been updated*
                        _Old value for labels_
                        {{${labelsBefore}}}
                        _New value for labels_
                        {{${labelsAfter}}}\n----\n`;
            }
            for (let key of Object.keys(event.after)) { // in theory we need to check both before and after keys (to handle rollbacks...)
                if (Number.isSafeInteger(parseInt(key))) {
                    // event after/before field values are strings or boolean (as far as we see...)
                    let valueBefore = (event.before[key] != undefined && event.before[key].length > 0) ? event.before[key] : "[value not set]";
                    let valueAfter = (event.after[key] != undefined && event.after[key].length > 0) ? event.after[key] : "[value not set]";
                    if (valueBefore.toString() != valueAfter.toString()) {
                        let ref = matrixlib_1.ml.Item.parseRef(that.item.id);
                        if (!ref.isFolder) {
                            let field = globals_1.globalMatrix.ItemConfig.getFieldById(ref.type, parseInt(key));
                            if (field != undefined) {
                                message += `*Field '${field.label}' has been updated*
                                    _Old value for ${field.label}_
                                    {{${$("<div>").html(valueBefore).text()}}}
                                    _New value for ${field.label}_
                                    {{${$("<div>").html(valueAfter).text()}}}\n----\n`;
                            }
                        }
                    }
                }
            }
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.autoAddCommentOnSave) {
                    that.addCommentToAllLinkedIssues(config, undefined, message, event.after.maxVersion);
                }
            });
        }
        // convert url to linked external item
        static createTaskFromUrl(itemId, url) {
            let externalItem = Tasks.externalItemFromUrl(url);
            if (externalItem) {
                Tasks.postCreateLinks(itemId, [externalItem]).done(function (createdTasks) {
                    mTasks.updateUI(createdTasks);
                });
            }
        }
        // check if a string is an id of an external item
        static isTaskId(someId) {
            let isId = false;
            $.each(Tasks.tasksConfiguration, function (tidx, config) {
                $.each(config.smartLinks, function (idx, smartLink) {
                    var re = new RegExp(smartLink.regex, "g");
                    var hits = someId.match(re);
                    if (hits && hits[0] == someId) {
                        isId = true;
                        return;
                    }
                });
            });
            return isId;
        }
        static getOne2OneTask(externalItemId) {
            let res = $.Deferred();
            let handled = false;
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.one2OneMapping) {
                    handled = true;
                    Tasks.getMeta(config.pluginId, externalItemId).done(function (externalItem) {
                        res.resolve(externalItem);
                    }).fail(function () {
                        res.reject("failed to retrieve one to one mapping status for " + externalItemId);
                    });
                    return;
                }
            });
            if (!handled) {
                res.reject("no one 2 one mapping configured");
            }
            return res;
        }
        static createOne2OneTask(itemId) {
            let res = $.Deferred();
            let handled = false;
            $.each(Tasks.tasksConfiguration, function (idx, config) {
                if (config.one2OneMapping) {
                    handled = true;
                    let taskTitle = "workflow status for " + itemId;
                    let taskDescription = "";
                    Tasks.postPushIssue(config.pluginId, itemId, taskTitle, taskDescription, config.one2OneMapping.projectId, config.one2OneMapping.taskTypeId).done(function (newTasks) {
                        res.resolve(newTasks[0]);
                    }).fail(function () {
                        res.reject("failed to create task for one to one mapping");
                    });
                    return;
                }
            });
            if (!handled) {
                res.reject("no one 2 one mapping configured");
            }
            return res;
        }
        static getOne2OneRenderInfo(task) {
            let renderInfo = {
                text: "click to link",
                color: "grey",
                background: "transparent",
                strikethrough: false
            };
            if (task) {
                renderInfo.text = task.externalItemId;
                renderInfo.color = "black";
                $.each(task.more, function (idx, val) {
                    if (val.key === "status") {
                        $.each(Tasks.tasksConfiguration, function (idx2, config) {
                            if (config.one2OneMapping) {
                                $.each(config.one2OneMapping.statusOverwrites, function (idx3, statusOverwrite) {
                                    if (statusOverwrite.externalStatusName == val.value) {
                                        renderInfo = matrixlib_1.ml.JSON.clone(statusOverwrite);
                                        if (config.one2OneMapping.showId) {
                                            renderInfo.text = task.externalItemId + ":" + renderInfo.text;
                                        }
                                    }
                                });
                            }
                        });
                    }
                });
            }
            return renderInfo;
        }
        // ****************************************
        // Misc functions called by task control  
        // to create / refresh UI components
        // ****************************************
        static showTasks(itemId, control, canEdit, pluginFilter) {
            let that = this;
            if (!Tasks.tasksConfiguration || Tasks.tasksConfiguration.length == 0) {
                control.append('<div style="color: #bbb;font-size: 12px;">no valid configuration</div>');
                return;
            }
            Tasks.getTasks(itemId, pluginFilter).done(function (tasks) {
                Tasks.renderTasks(itemId, tasks, control, canEdit, false);
            }).fail(function (message) {
                if (message) {
                    matrixlib_1.ml.Logger.log("error", "Could not retrieve tasks for " + itemId);
                    matrixlib_1.ml.Logger.log("error", "Error was:" + message);
                }
            });
        }
        // ****************************************
        // private functions 
        // ****************************************
        /*** UI
         *
         */
        createAndLinkIssueDlg(config) {
            let that = this;
            let options = "";
            let ocount = 0;
            // create project / type drop down menu
            $.each(config.projectsCreate, function (i, project) {
                $.each(project.taskTypes, function (j, taskType) {
                    ocount++;
                    let oName = [];
                    if (project.projectName)
                        oName.push(project.projectName);
                    if (taskType.taskTypeName)
                        oName.push(taskType.taskTypeName);
                    options += "<option value='" + project.projectId + "|" + taskType.taskTypeId + "' " + (i + j == 0 ? "selected" : "") + ">" + oName.join(" / ") + "</option>";
                });
            });
            // define default title
            let iTitle = config.useEmptyTitle ? "" : globals_1.app.getCurrentTitle();
            // define default content
            let iContent = "";
            if (config.useAsDescription == "text") {
                let descriptionFields = globals_1.globalMatrix.ItemConfig.getFieldsOfType("richtext", this.item.type);
                if (descriptionFields.length > 0) {
                    let html = globals_1.app.getFieldValue(descriptionFields[0].field.id);
                    let tempdiv = $("<div style='display:none'>").html(html).appendTo("body");
                    iContent = tempdiv.text();
                    tempdiv.remove();
                }
            }
            var form = $('<div class="container" style="width:100%;height:100%">' +
                '<div class="row optionsSelectRow" style="margin-top:4px;margin-bottom:6px">' +
                '    <div class="col-md-2" style="margin-top: 6px;"><label style="white-space: nowrap" for="inputType" class="control-label">Issue Type:</label></div>' +
                '    <div class="col-md-10"><select  class="form-control inputType" style="width:100%;height:32px" id="inputType">' +
                options +
                '        </select></div>' +
                '  </div>' +
                '  <div class="row">' +
                '    <div class="col-md-2" style="margin-top: 6px;"><label style="white-space: nowrap" for="inputTitle" class="control-label">Title:</label></div>' +
                '    <div class="col-md-10"><input autocomplete="off" type="text" class="form-control inputTitle" id="inputTitle" placeholder="enter title"></div>' +
                '  </div>' +
                '<div class="row jira-description">' +
                '    <div class="col-md-12"  style="height:100%"><textarea class="jira-textarea inputComment" placeholder="enter description">' + iContent + '</textarea></div>' +
                '</div></div>');
            this.jui.html("");
            this.jui.removeClass("dlg-v-scroll");
            this.jui.addClass("dlg-no-scroll");
            this.jui.append(form);
            $(".inputTitle", this.jui).val(iTitle);
            let height = 500;
            if (config.useAsDescription == "hide") {
                $(".jira-description", this.jui).hide();
                height -= 300;
            }
            if (ocount == 1) {
                $(".optionsSelectRow", this.jui).hide();
                height -= 30;
            }
            this.jui.dialog({
                autoOpen: true,
                title: "Create linked task",
                height: height,
                width: 600,
                modal: true,
                open: function () { },
                close: function () { },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            var title = $("#inputTitle", that.jui).val();
                            var type = ($(".inputType", that.jui)).val();
                            var description = $(".inputComment", that.jui).val();
                            var where = type.split("|");
                            Tasks.postCreateIssue(config.pluginId, that.item.id, title, description, where[0], where[1]).done(function (newTask) {
                                that.updateUI(newTask);
                            });
                            that.jui.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.jui.dialog("close");
                        }
                    }]
            });
        }
        ;
        static createAndLinkWebDlg(config, task, changeFunction) {
            var form = $('<div class="container" style="width:100%;height:100%;position:relative">' +
                '  <div class="row"><br/>' +
                '  </div>' +
                '  <div class="row">' +
                '    <div style="padding:0" class="col-md-1"><label style="white-space: nowrap;padding-top:6px" for="inputTitle" class="control-label">Text:</label></div>' +
                '    <div class="col-md-11"><input autocomplete="off" type="text" class="form-control" id="inputTitle" placeholder="enter text to display"></div>' +
                '  </div>' +
                '  <div class="row"><br/>' +
                '  </div>' +
                '  <div class="row">' +
                '    <div style="padding:0" class="col-md-1"><label style="white-space: nowrap;padding-top:6px" for="inputUrl" class="control-label">Url:</label></div>' +
                '    <div class="col-md-11"><input autocomplete="off" type="text" class="form-control" id="inputUrl" placeholder="enter link address"></div>' +
                '  </div>' +
                '</div>');
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-v-scroll");
            globals_1.app.dlgForm.addClass("dlg-no-scroll");
            globals_1.app.dlgForm.append(form);
            var emptyTitle = !task || !task.externalItemTitle;
            $("#inputTitle").on("mouseup keyup mouseout", function () {
                emptyTitle = $("#inputTitle").val() === "";
            });
            $('#inputUrl').on("mouseup keyup mouseout", function () {
                if (emptyTitle) {
                    $("#inputTitle").val($('#inputUrl').val());
                }
                updateCanOK();
            });
            $("#doSearch").prop("disabled", true);
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Add web link",
                height: 250,
                width: 600,
                modal: true,
                resizeStop: function () { },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            let newUrl = $('#inputUrl').val();
                            let newTitle = $("#inputTitle").val() ? $("#inputTitle").val() : newUrl;
                            changeFunction(newTitle, newUrl);
                            $("button", globals_1.app.dlgForm).prop("disabled", true);
                            window.setTimeout(function () {
                                globals_1.app.dlgForm.dialog("close");
                            }, 300);
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }],
                open: function () {
                    if (task) {
                        if (task.externalItemUrl) {
                            $("#inputUrl").val(task ? task.externalItemUrl : "");
                        }
                        if (task.externalItemTitle) {
                            $("#inputTitle").val(task ? task.externalItemTitle : "");
                        }
                    }
                    updateCanOK();
                    $("#inputUrl").focus();
                }
            });
            function updateCanOK() {
                var okButton = $(".btnDoIt", globals_1.app.dlgForm.parent());
                matrixlib_1.ml.UI.setEnabled(okButton, $('#inputUrl').val() !== "");
            }
            ;
        }
        ;
        createSearchAndLinkIssueDlg(config) {
            let that = this;
            // open new page
            var win = window.open(config.nativeCreateUrl);
            this.waitForNewTaskOrWindowCloseActive = true;
            // show wait dialog
            let form = matrixlib_1.ml.UI.getSpinningWait("Opened native create in other browser tab. Waiting for task to be created or tab to be closed.");
            this.jui.html("");
            this.jui.removeClass("dlg-v-scroll");
            this.jui.addClass("dlg-no-scroll");
            this.jui.append(form);
            this.jui.dialog({
                autoOpen: true,
                title: "Wait for new task from other tab",
                height: 300,
                width: 600,
                modal: true,
                buttons: [{
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.waitForNewTaskOrWindowCloseActive = false;
                            window.clearTimeout(that.waitForNewTaskOrWindowCloseTimer);
                            that.jui.dialog("close");
                        }
                    }],
                open: function () {
                },
                close: function () {
                    matrixlib_1.ml.UI.setEnabled($(".btnDoIt", globals_1.app.dlgForm.parent()), true);
                }
            });
            // run the config.nativeCreateSearch to get a list of hits BEFORE user can create an issue
            Tasks.getFindTasks(config.pluginId, config.nativeCreateSearch, 0).done(function (result) {
                that.waitForNewTaskOrWindowClose(config, win, result);
            });
        }
        waitForNewTaskOrWindowClose(config, win, taskSearchBefore) {
            let that = this;
            if (!this.waitForNewTaskOrWindowCloseActive) {
                // the wait has been handled, e.g. by closing the dialogs
                return;
            }
            if (win.closed !== false) { // !== is required for compatibility with Opera
                this.waitForNewTaskOrWindowCloseActive = false;
                window.clearTimeout(this.waitForNewTaskOrWindowCloseTimer);
                that.jui.dialog("close");
                this.searchAndLinkIssueDlg(config, config.nativeCreateSearch);
            }
            else {
                Tasks.getFindTasks(config.pluginId, config.nativeCreateSearch, 0).done(function (result) {
                    if (!that.waitForNewTaskOrWindowCloseActive) {
                        // the wait has been handled, e.g. by closing the dialogs
                        return;
                    }
                    if (result.tasks.length > taskSearchBefore.tasks.length ||
                        (result.tasks.length > 0 && result.tasks[0].externalItemId !== taskSearchBefore.tasks[0].externalItemId)) {
                        that.waitForNewTaskOrWindowCloseActive = false;
                        window.clearTimeout(that.waitForNewTaskOrWindowCloseTimer);
                        that.jui.dialog("close");
                        that.searchAndLinkIssueDlg(config, config.nativeCreateSearch);
                    }
                    else {
                        that.waitForNewTaskOrWindowCloseTimer = window.setTimeout(function () {
                            that.waitForNewTaskOrWindowClose(config, win, result);
                        }, 300);
                    }
                });
            }
        }
        searchAndLinkIssueDlg(config, showSearch) {
            let that = this;
            // help jira: https://matrixreq.atlassian.net/wiki/x/AwD3
            var jh = config.searchHelp ? ("<a style='margin-left:10px' href='" + config.searchHelp + "' target='_blank'><span class='fal fa-info-circle'></span></a>") : "";
            let defaultSearch = (config.defaultSearches && config.defaultSearches.length > 0) ? config.defaultSearches[0] : "";
            if (showSearch) {
                defaultSearch = { name: showSearch, expression: showSearch };
            }
            let form = $('<div style="width:100%;height:100%;position:relative">')
                .append(this.getSearchField(config, refreshSearch));
            let results = $('<div class="row taskFit">')
                .appendTo(form);
            let moreInfo = $('<div class="moreTasks" style="width: 100%;text-align: center;"><br/>enter search term</div>')
                .appendTo(results);
            this.jui.html("");
            this.jui.removeClass("dlg-v-scroll");
            this.jui.addClass("dlg-no-scroll");
            this.jui.append(form);
            var start = 0;
            var select = [];
            this.jui.dialog({
                autoOpen: true,
                title: "Search tasks",
                height: 500,
                width: 600,
                modal: true,
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            matrixlib_1.ml.UI.setEnabled($(".btnDoIt", globals_1.app.dlgForm.parent()), false);
                            Tasks.postCreateLinks(that.item.id, select).done(function () {
                                that.updateUI(select);
                                that.jui.dialog("close");
                            });
                            results.html("");
                            results.append(matrixlib_1.ml.UI.getSpinningWait("creating links..."));
                            matrixlib_1.ml.UI.setEnabled($("button", that.jui.parent()), false);
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.jui.dialog("close");
                        }
                    }],
                open: function () {
                    updateCanOK();
                    if (showSearch) {
                        refreshSearch(showSearch, true);
                    }
                    else if (config.defaultSearches && config.defaultSearches.length > 0 && config.autoSearch) {
                        refreshSearch(config.defaultSearches[0].expression, true);
                    }
                    else {
                        $("#inputSearch").focus();
                    }
                },
                close: function () {
                    matrixlib_1.ml.UI.setEnabled($(".btnDoIt", globals_1.app.dlgForm.parent()), true);
                }
            });
            function updateCanOK() {
                matrixlib_1.ml.UI.setEnabled($(".btnDoIt", globals_1.app.dlgForm.parent()), (select.length > 0));
            }
            ;
            function refreshSearch(searchExpression, reset) {
                select = [];
                updateCanOK();
                moreInfo.remove();
                if (reset) {
                    // user launched a new search, need to get rid of previous results
                    start = 0;
                }
                if (start == 0) {
                    results.html("").append(moreInfo);
                }
                moreInfo.html("").append(matrixlib_1.ml.UI.getSpinningWait("searching...")).appendTo(results);
                Tasks.getFindTasks(config.pluginId, searchExpression, start).done(function (result) {
                    moreInfo.remove();
                    if (result.tasks.length === 0) {
                        results.append('<br/><br/><div class="moreTasks">no (more) results have been found</div><br/><br/>');
                        results.scrollTop(results[0].scrollHeight);
                        return;
                    }
                    let more = result.tasks.length == result.maxResults;
                    $.each(result.tasks, function (ridx, task) {
                        var res = $("<div style='cursor:pointer'>").append(Tasks.renderTask(that.item.id, task, false, true, true));
                        results.append(res);
                        res.data("task", task);
                        res.dblclick(function (event) {
                            $(".selectedIssue").removeClass("selectedIssue");
                            select = [$(event.delegateTarget).data("task")];
                            $(event.delegateTarget).addClass("selectedIssue");
                            updateCanOK();
                            $(".ui-dialog-buttonpane button:contains('Ok')", globals_1.app.dlgForm.parent()).trigger("click");
                        }).click(function (event) {
                            // MATRIX-1367: attaching existing jira issues: allow multi select
                            // $(".selectedIssue").removeClass("selectedIssue"); 
                            $(event.delegateTarget).toggleClass("selectedIssue");
                            select = [];
                            $.each($(".selectedIssue"), function (idx, si) {
                                select.push($(si).data("task"));
                            });
                            updateCanOK();
                        });
                    });
                    results.highlightReferences({ noExternals: true });
                    if (more) {
                        start += result.maxResults;
                        let next = "get more results...";
                        moreInfo = $("<div class='moreTasks' style='cursor:pointer'>").html(next);
                        moreInfo.appendTo(results).click(function (event) {
                            moreInfo.html("").append(matrixlib_1.ml.UI.getSpinningWait("searching..."));
                            refreshSearch(searchExpression, false);
                        });
                    }
                    // dont scroll down to "get more results..." button:
                    // results.scrollTop(results[0].scrollHeight);
                }).fail(function (result) {
                    results.html(result);
                });
            }
            ;
        }
        ;
        static getConfig(pluginId) {
            for (var idx = 0; idx < Tasks.tasksConfiguration.length; idx++) {
                if (Tasks.tasksConfiguration[idx].pluginId == pluginId) {
                    return Tasks.tasksConfiguration[idx];
                }
            }
            return null;
        }
        renderProjectPage(options) {
            let that = this;
            if (options.controlState === globals_1.ControlState.Print) {
                return;
            }
            let pluginId = Number(options.type.replace("_TASKS", ""));
            options.control.html("").append(matrixlib_1.ml.UI.getSpinningWait("retrieving tasks"));
            // get all tasks for plugin
            Tasks.getAllTasksProject(pluginId).done(function (alltasks) {
                let selectedFolders = [];
                let textFilter = "";
                let TaskStatus;
                (function (TaskStatus) {
                    TaskStatus["All"] = "All";
                    TaskStatus["Open"] = "Open";
                    TaskStatus["Closed"] = "Closed";
                })(TaskStatus || (TaskStatus = {}));
                ;
                let activeStatusFilter = TaskStatus.All;
                options.control.html("");
                if (alltasks.length === 0) {
                    options.control.append("<b>There are no tasks for this project!</b>");
                    return;
                }
                const folderPlaceHolderText = "Select folders to include";
                const removeLinksByStatus = (task) => {
                    if (activeStatusFilter === TaskStatus.All) {
                        return task;
                    }
                    const copy = JSON.parse(JSON.stringify(task));
                    copy.links = copy.links.filter(link => {
                        switch (activeStatusFilter) {
                            case TaskStatus.All:
                                return true;
                            case TaskStatus.Closed:
                                return link.externalDone;
                            case TaskStatus.Open:
                                return !link.externalDone;
                        }
                    });
                    return copy;
                };
                const removeItemsWithoutLinks = (task) => task.links.length > 0;
                const removeLinksByText = (task) => {
                    const loweredFilter = textFilter.toLowerCase();
                    const matrixItemMatches = (task.matrixItem.title && task.matrixItem.title.toLowerCase().indexOf(loweredFilter) !== -1) ||
                        (task.matrixItem.matrixItem && task.matrixItem.matrixItem.toLowerCase().indexOf(loweredFilter) !== -1);
                    if (matrixItemMatches) {
                        // The matrix item matches, return all links
                        return task;
                    }
                    else {
                        const copy = JSON.parse(JSON.stringify(task));
                        copy.links = copy.links.filter(link => (link.externalItemTitle && link.externalItemTitle.toLowerCase().indexOf(loweredFilter) !== -1) ||
                            (link.externalDescription && link.externalDescription.toLowerCase().indexOf(loweredFilter) !== -1) ||
                            (link.externalItemId && link.externalItemId.toLocaleLowerCase().indexOf(loweredFilter) !== -1));
                        return copy;
                    }
                };
                let tableItem = null;
                const renderTable = () => {
                    const buttonText = selectedFolders.length > 0 ? selectedFolders.join(",") : folderPlaceHolderText;
                    folderSelectionButton.text(buttonText);
                    if (tableItem)
                        tableItem.remove();
                    const filteredTasks = alltasks
                        .map(removeLinksByStatus)
                        .filter(removeItemsWithoutLinks)
                        .map(removeLinksByText)
                        .filter(removeItemsWithoutLinks);
                    // console.log("Filtered tasks", filteredTasks);
                    tableItem = Tasks.renderTasksInTable(filteredTasks, selectedFolders, (folderAdd) => {
                        if (selectedFolders.indexOf(folderAdd.id) === -1) {
                            selectedFolders.push(folderAdd.id);
                        }
                        renderTable();
                    });
                    options.control.append(tableItem);
                };
                const filterToolbar = $("<div id='taskFilterToolbar' style='padding: 5px;display: flex;'>");
                const itemSelection = new ItemSelectionView_1.ItemSelectionTools();
                const categories = globals_1.globalMatrix.ItemConfig.getCategories(true).map(cat => ({ type: cat }));
                const selectOptions = {
                    selectMode: ProjectViewDefines_1.SelectMode.folders,
                    linkTypes: categories,
                    focusOn: globals_1.globalMatrix.ItemConfig.getCategories(true)[0],
                    autoScroll: false,
                    getSelectedItems: () => selectedFolders.map(folder => ({ to: folder, title: folder })),
                    selectionChange: (newSelection) => {
                        // console.log("Selected items", newSelection);
                        selectedFolders = newSelection.map(selection => selection.to);
                        renderTable();
                    }
                };
                const treeFilterGroup = $("<div class='btn-group' style='max-width: 75%; display: flex;'>");
                const folderSelectionButton = $("<button class='btn btn-default btn-xs' style='text-align: left; " +
                    "overflow:hidden; text-overflow: ellipsis; min-width: 20em;'>")
                    .text(folderPlaceHolderText)
                    .click(() => {
                    itemSelection.showDialog(selectOptions);
                });
                treeFilterGroup.append(folderSelectionButton);
                const clearButton = $("<button class='btn btn-default btn-xs' style='flex-grow: 0; flex-shrink: 0;'>").text("Clear")
                    .click(() => {
                    selectedFolders = [];
                    renderTable();
                });
                treeFilterGroup.append(clearButton);
                filterToolbar.append(treeFilterGroup);
                const selectStatus = $("<select class='form-control input-sm' style='height: 22px; width: 12em; margin: 0; margin-right: 5px;'>")
                    .change(ev => {
                    activeStatusFilter = $(ev.target).val();
                    renderTable();
                });
                Object.keys(TaskStatus).forEach(value => selectStatus.append(`<option ${activeStatusFilter == value ? "selected" : ""}>${value}</option>`));
                filterToolbar.append(selectStatus);
                // From https://davidwalsh.name/javascript-debounce-function
                function debounce(func, wait, immediate = false) {
                    var timeout;
                    return function () {
                        var context = this, args = arguments;
                        var later = function () {
                            timeout = null;
                            if (!immediate)
                                func.apply(context, args);
                        };
                        var callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = window.setTimeout(later, wait);
                        if (callNow)
                            func.apply(context, args);
                    };
                }
                ;
                const filterTextInput = $("<input type='text' class='form-control input-sm' placeholder='Filter by Title' " +
                    "style='height: 22px;margin-top: 0px;'>")
                    .val(textFilter).keyup(debounce(function (ev) {
                    textFilter = $(ev.target).val();
                    renderTable();
                }, 250));
                filterToolbar.append(filterTextInput);
                options.control.append(filterToolbar);
                renderTable();
            }).fail(function (errorMsg) {
                options.control.html("");
                options.control.append("<b>Failed to retrieve tasks!</b><br>Error was:" + errorMsg);
            });
        }
        /* helper */
        updateUI(tasks) {
            let that = this;
            var ctrls = globals_1.matrixApplicationUI.lastMainItemForm.getControls("tasksControl");
            for (var idx = 0; idx < ctrls.length; idx++) {
                let filter = ctrls[idx].getController().getPluginFilter();
                let ul = $(".ticket-list", ctrls[idx]);
                if (ul.length == 0) {
                    // list still empty
                    ul = $("<ul class='ticket-list baseControl'>");
                    $("ul", ctrls[idx]).replaceWith(ul);
                }
                $.each(tasks, function (idx, task) {
                    if (!filter || filter.length == 0 || filter.indexOf(task.plugin) !== -1) {
                        // Check if the task is already displayed
                        const matchingTasks = ul.children().filter((index, child) => {
                            const segments = child.innerText.split("\n");
                            return segments.length > 0 && segments[0] == task.externalItemId;
                        });
                        if (matchingTasks.length == 0) {
                            var item = $("<li class='taskDisplayContainer'>").append(Tasks.renderTask(that.item.id, task, true, false));
                            ul.append(item);
                        }
                    }
                });
            }
        }
        static getTaskDefinition(task) {
            let res;
            $.each(Tasks.tasksConfiguration, function (tci, tc) {
                $.each(tc.projectsCreate, function (i, project) {
                    if (project.projectId == task.externalProject) {
                        $.each(project.taskTypes, function (j, taskType) {
                            if (taskType.taskTypeId == task.externalType) {
                                res = taskType;
                            }
                        });
                    }
                });
            });
            return res;
        }
        // render a bunch of tasks in a list
        static renderTasks(itemId, linkedTasks, root, canEdit, fullWidth) {
            if (linkedTasks.length > 0) {
                var items = $("<ul class='ticket-list'></ul>").addClass("baseControl");
                root.append(items);
                for (var tidx = 0; tidx < linkedTasks.length; tidx++) {
                    var item = $("<li class='taskDisplayContainer'>").append(Tasks.renderTask(itemId, linkedTasks[tidx], canEdit, fullWidth));
                    items.append(item);
                }
            }
            else {
                var items = $("<ul style='margin-top:0px;margin-bottom:0px'></ul>").addClass("baseControl");
                root.append(items);
                items.append($("<li>").append('<div style="color: #bbb;font-size: 12px;">no tasks linked</div>'));
            }
        }
        // From Tom Gruner @ http://stackoverflow.com/a/12034334/1660815
        static escapeHtml(source) {
            var entityMap = {
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
            };
            return String(source).replace(/[<>"'\/]/g, s => entityMap[s]);
        }
        // render a single task, maybe with option to unlink
        static renderTask(itemId, task, unlink, fullWidth, tinyLink) {
            function showDescription(id, task) {
                let prefix = "";
                if (task.externalProject) {
                    prefix = task.externalProject + "-";
                }
                matrixlib_1.ml.UI.showTaskAsTooltip(prefix + task.externalItemId, task.externalItemTitle, task.externalItemUrl, '<div>' + matrixlib_1.ml.UI.getSpinningWait("loading description...").html() + '</div>', id);
                Tasks.getMeta(task.plugin, task.externalItemId).done(function (externalData) {
                    let status = "";
                    if (task.externalMeta) {
                        // "{"issueType":"Task","status":"Backlog"}"
                        let metaJson = JSON.parse(task.externalMeta);
                        status = `<span class='taskStatus' >${metaJson.status}</span> `;
                    }
                    matrixlib_1.ml.UI.showTaskAsTooltip(prefix + task.externalItemId, task.externalItemTitle, task.externalItemUrl, `<div> ${externalData.externalDescription} </div><span style="position:absolute;top:6px;right:18px;" >${status}</span>`, id);
                });
                return "";
            }
            let ret = $("<span class='taskDisplay'>").data("externalItemId", task.externalItemId);
            let taskTypeDef = Tasks.getTaskDefinition(task);
            let config = this.getConfig(task.plugin);
            if (!config) {
                return ret;
            }
            let hiddenStyle = "";
            // there is no external project known here when showing external links from server... so let's not do anything
            //if ( config.projectFilter && config.projectFilter.length > 0 && config.projectFilter.indexOf(task.externalProject) == -1) {
            //    hiddenStyle = "color:#ccc !important";
            //}
            let isWebLink = config && config.handleAsLink;
            let icon = '<i class="ticket-icon-icon fal fa-thumbtack">';
            if (isWebLink) {
                let fixIcon = "$(this).css('display','none').parent().addClass('fal fa-external-link')";
                icon = '<i class="ticket-icon-icon fal fa-external-link">';
                try {
                    icon = '<span><img class="" src="https://www.google.com/s2/favicons?domain_url=' + encodeURIComponent(new URL(task.externalItemUrl).hostname) + '" onerror="' + fixIcon + '" /></span>';
                }
                catch (e) {
                    // probably a bad URL
                }
            }
            if (taskTypeDef && taskTypeDef.iconClass) {
                icon = '<i class="ticket-icon-icon ' + taskTypeDef.iconClass + '">';
            }
            else if (taskTypeDef && taskTypeDef.iconUrl) {
                icon = '<img class="ticket-icon-icon" src="' + taskTypeDef.iconUrl + '">';
            }
            ret.append("<span class='ticket-icon'>" + icon + "<span class='ticket-key'>");
            if (isWebLink) {
                let id = $(`<span title='${config.pluginName}' class='ticket-id'><b style='${task.externalDone ? "text-decoration:line-through" : ""}'>${task.externalItemTitle}</b></span>`);
                id.tooltip({ placement: "bottom", container: "body" });
                ret.append(id);
                if (task.externalItemUrl) {
                    id.data("url", task.externalItemUrl).click(function (event) {
                        window.open($(event.delegateTarget).data("url"), '_blank');
                    });
                }
            }
            else {
                let ttip = "hold shift to see a preview";
                if (!config.hasMeta) {
                    ttip = "click to follow link";
                }
                // tiny links are used to have a selectable row in jira addon for example (when clicking on ticket it should not follow the link but select the row)
                let id = tinyLink
                    ? $(`<span class='tinylinkc'><b style='${hiddenStyle};${task.externalDone ? "text-decoration: line-through" : ""}'>${task.externalItemId}</b><a class='ticket-id fas fa-arrow-to-right' data-original-title="${ttip}" title="${ttip}"></a></span>`)
                    : $(`<a class='ticket-id' data-original-title="${ttip}" title="${ttip}"><b style='${hiddenStyle};${task.externalDone ? "text-decoration: line-through" : ""}'>${task.externalItemId}</b></a>`);
                id.tooltip({ placement: "bottom", container: "body" });
                if (config.hasMeta) {
                    id.hover(() => {
                        if (globals_1.globalMatrix.globalShiftDown)
                            showDescription(id, task);
                    }, () => {
                        if (!globals_1.globalMatrix.globalShiftDown) {
                            setTimeout(() => { matrixlib_1.ml.UI.hideTooltip(); }, 1000);
                        }
                    });
                }
                ret.append(id);
                if (task.externalItemUrl) {
                    let clickHandler = tinyLink ? $("a", id) : id;
                    clickHandler.data("url", task.externalItemUrl).click(function (event) {
                        window.open($(event.delegateTarget).data("url"), '_blank');
                        if (event.preventDefault)
                            event.preventDefault();
                        if (event.stopPropagation)
                            event.stopPropagation();
                    });
                }
                ret.append("<span class='ticket-title " + (fullWidth ? "ticket-title-full" : "") + "'>" + Tasks.escapeHtml(task.externalItemTitle) + "</span>");
                if (config.hasMeta && config.showStatus) {
                    if (task.externalMeta) {
                        // "{"issueType":"Task","status":"Backlog"}"
                        let metaJson = JSON.parse(task.externalMeta);
                        $(".ticket-title", ret).append(`<span class='taskStatus' >${metaJson.status}</span> `);
                    }
                }
            }
            if (task.externalUser) {
                ret.append("<span class='ticket-user'>(" + task.externalUser + ")</span>");
            }
            if (unlink) {
                var ulb = $("<span style='padding-left:20px' title='remove link'><i class='fal fa-unlink'></i></span>").click(function (event) {
                    let theButton = $(event.delegateTarget);
                    let theRow = theButton.closest('.taskDisplayContainer');
                    let theItem = theButton.data("itemId");
                    let theTask = theButton.data("task");
                    matrixlib_1.ml.UI.showConfirm(3, { title: "Remove link to '" + theTask.externalItemId + " " + theTask.externalItemTitle + "'?", ok: "Remove" }, function () {
                        theButton.replaceWith($("<span class='fal fa-sync-alt refresh-animate'>"));
                        Tasks.deleteLink(theItem, theTask).done(function () {
                            theRow.css("display", "none");
                        }).fail(function (message) {
                            matrixlib_1.ml.UI.showError("Cannot remove link: ", message);
                        });
                    }, function () {
                        // nothing to do...
                    });
                }).tooltip().data("task", task).data("itemId", itemId);
                ret.append($("<span class='ticket-unlink'>").append(ulb));
                if (isWebLink) {
                    let editb = $("<span style='padding-left:20px' title='edit link'><i class='fal fa-pencil'></i></span>").click(function (event) {
                        let theButton = $(event.delegateTarget);
                        let theRow = theButton.closest('.taskDisplayContainer');
                        let theItem = theButton.data("itemId");
                        let theConfig = theButton.data("config");
                        let theTask = theButton.data("task");
                        Tasks.createAndLinkWebDlg(theConfig, task, function (linkTitle, linkUrl) {
                            // create a copy of the old task (to delete it later)
                            let oldTask = matrixlib_1.ml.JSON.clone(theTask);
                            // update the task
                            theTask.externalItemId = "" + new Date().getTime();
                            theTask.externalItemTitle = linkTitle;
                            theTask.externalItemUrl = linkUrl;
                            Tasks.postCreateLinks(theItem, [theTask]).done(function (results) {
                                $.each(results, function (tidx, task) {
                                    // overwrite the task with the data fromt he server (e.g. the plugin might change the done status)
                                    if (task.externalItemId == theTask.externalItemId) {
                                        theTask = task;
                                    }
                                });
                                Tasks.deleteLink(theItem, oldTask).done(function () {
                                    $(".ticket-id", theRow)
                                        .data("url", theTask.externalItemUrl)
                                        .html("<b style='" + (theTask.externalDone ? "text-decoration: line-through" : "") + "'>" + theTask.externalItemTitle + "</b></span>");
                                    theButton.data("task", theTask);
                                });
                            });
                        });
                    }).tooltip().data("config", config).data("task", task).data("itemId", itemId);
                    ret.append($("<span class='ticket-unlink'>").append(editb));
                }
            }
            return ret;
        }
        getSearchField(config, searchFunction) {
            let that = this;
            var inputSpace = $('<div class="input-group">');
            var textInput = $('<input autocomplete="off" type="text" autofocus="autofocus" name="search" placeholder="Search..." class="form-control searchNoX" style="height:36px">')
                .appendTo(inputSpace)
                .on("mouseup keyup mouseout", function () {
                mir_btn.prop("disabled", !config.allowEmptySearches && textInput.val().length < 3);
            }).keypress(function (e) {
                if (e.which == 13) {
                    mir_btn.trigger("click");
                }
            });
            var mir_btn = $('<span class="btn btn-sm taskSearch" type="button" data-toggle="tooltip" data-placement="bottom" title="Search for tasks"><i style="position:relative;top:4px;color:#bbb" class="fal fa-file-alt"></i><i style="position:relative;margin-left:-7px" class="fal fa-search"></span>')
                .appendTo(inputSpace)
                .click(function () {
                searchFunction(textInput.val(), true);
            })
                .prop("disabled", true);
            var dropDown = $('<span class="btn btn-sm taskDropdown" type="button" data-toggle="dropdown"><span class="caret"></span></span>');
            var ul = $(' <ul class="dropdown-menu dropdown-menu-sub pull-right role="menu"> ');
            $.each(config.defaultSearches, function (idx, search) {
                if (search.name) {
                    $('<li title="Search for ' + search.expression + '"><a href="javascript:void(0)">' + search.name + '</a></li>')
                        .appendTo(ul)
                        .data("expression", search.expression)
                        .click(function (event) {
                        textInput.val($(event.delegateTarget).data("expression"));
                        mir_btn.trigger("click");
                    });
                }
            });
            if (config.defaultSearches && config.defaultSearches.length > 0 && config.defaultSearches[0].name) {
                textInput.val(config.defaultSearches[0].expression);
            }
            if (config.searchHelp) {
                var help = $('<li title="Search help" ><a class="documentationLink" href="javascript:void(0)">Search Help</a></li>');
                ul.append(help);
                help.click(function () {
                    window.open(config.searchHelp);
                });
            }
            if (ul.children().length > 0) {
                inputSpace.append($("<div class='taskSearchAddon taskDropDownGroup'>").append(dropDown).append(ul));
            }
            return inputSpace;
        }
        // this function receives a list of smart links to tasks as defined by the user in test results
        // it must take these tasks and create something the server can link to
        createLinksAsync(linksToBeCreated) {
            let that = this;
            let linkJobs = [];
            // build a list of link job tupels, which plugin and with which 'command'
            $.each(Tasks.tasksConfiguration, function (tidx, config) {
                $.each(config.smartLinks, function (sidx, smartLink) {
                    $.each(linksToBeCreated, function (idx, ltc) {
                        var re = new RegExp(smartLink.regex);
                        let ma = ltc.match(re);
                        if (ma) {
                            // it matches: replace all placeholders, $0, $1, $2, with matching groups
                            let issueProjectId = smartLink.issueProjectId;
                            let issueId = smartLink.issueId;
                            let url = smartLink.url;
                            let title = smartLink.title;
                            for (var i = 0; i < Math.min(ma.length, 10); i++) {
                                let rep = new RegExp("\\$" + i, "g");
                                issueProjectId = issueProjectId.replace(rep, ma[i]);
                                issueId = issueId.replace(rep, ma[i]);
                                url = url.replace(rep, ma[i]);
                                title = title.replace(rep, ma[i]);
                            }
                            linkJobs.push({
                                plugin: config.pluginId,
                                externalProject: issueProjectId,
                                externalItemId: issueId,
                                externalItemUrl: url,
                                externalDescription: "",
                                externalItemTitle: title,
                                externalDone: false,
                                externalType: ""
                            });
                        }
                    });
                });
            });
            return Tasks.postCreateLinks(this.item.id, linkJobs).done(function (createdTasks) {
                that.updateUI(createdTasks);
            });
        }
        /** rest api */
        // this links one matrix item to multiple issues in multiple plugins
        // not private: used by jiraPlugin.js
        static postCreateLinks(itemId, tasksToLink) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            $.each(tasksToLink, function (tidx, task) {
                if (!task.externalItemId || task.externalItemId == " ") {
                    task.externalItemId = "" + new Date().getTime();
                }
            });
            let job = {
                action: "CreateLinks",
                matrixItem: {
                    project: project,
                    matrixItem: itemId
                },
                externalItems: tasksToLink
            };
            globals_1.globalMatrix.wfgwConnection.postServer("?" + jQuery.param({ payload: JSON.stringify(job) }, true)).done(function (results) {
                let nt = [];
                $.each(tasksToLink, function (idx, link) {
                    link.matrixItemIds = [itemId];
                    nt.push(link);
                });
                res.resolve(nt);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Creating link(s) to issue(s) failed", jqxhr, textStatus, error);
                res.reject(jqxhr);
            });
            return res;
        }
        // this creates an issue in a specified plugin and links it to the item
        static postCreateIssue(pluginId, itemId, title, description, projectId, taskTypeId) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            // Tasks.getConfig(pluginId).createBacklinks;
            let job = {
                pluginId: pluginId,
                action: "CreateIssue",
                matrixItem: {
                    project: project,
                    matrixItem: itemId
                },
                externalItem: { externalItemTitle: title, externalDescription: description },
                more: [
                    { key: "project", value: projectId },
                    { key: "issueType", value: taskTypeId }
                ]
            };
            globals_1.globalMatrix.wfgwConnection.postServer("?" + jQuery.param({ payload: JSON.stringify(job) }), job, true).done(function (task) {
                res.resolve(task);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Creating issue failed", jqxhr, textStatus, error);
            });
            return res;
        }
        // this gets linked tasks of a matrix item from multiple plugins. if no item is specified it gets all tasks...
        // not private: used by jiraPlugin.js    
        static getTasks(itemId, pluginFilter) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                action: "GetIssues",
                matrixItem: {
                    project: project,
                    matrixItem: itemId
                },
            };
            let nt = [];
            globals_1.globalMatrix.wfgwConnection.getServer("?" + jQuery.param({ payload: JSON.stringify(job) }, true)).done(function (links) {
                $.each(links, function (idx, hit) {
                    $.each(hit.links, function (jdx, link) {
                        if (!pluginFilter || pluginFilter.length == 0 || pluginFilter.indexOf(link.plugin) != -1) {
                            nt.push(link);
                        }
                    });
                });
                res.resolve(nt);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Getting issues failed", jqxhr, textStatus, error);
            });
            return res;
        }
        static getAllTasksProject(plugin) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                pluginId: plugin,
                action: "GetIssues",
                matrixItem: {
                    project: project
                },
            };
            globals_1.globalMatrix.wfgwConnection.getServer("?" + jQuery.param({ payload: JSON.stringify(job) }, true)).done(function (links) {
                res.resolve(links);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Getting all issues failed", jqxhr, textStatus, error);
            });
            return res;
        }
        // this finds tasks in one plugin
        static getFindTasks(pluginId, search, startAt) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                pluginId: pluginId,
                action: "FindIssues",
                matrixItem: {
                    project: project
                },
                startAt: startAt,
                searchTerm: search
            };
            globals_1.globalMatrix.wfgwConnection.getServer("?" + jQuery.param({ payload: JSON.stringify(job) }, true)).done(function (results) {
                res.resolve({ startAt: startAt, maxResults: 50, tasks: results });
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Search failed", jqxhr, textStatus, error);
            });
            return res;
        }
        static showError(text, jqxhr, textStatus, error) {
            let details = matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error);
            if (details) {
                matrixlib_1.ml.UI.showError(text, details);
            }
            else {
                matrixlib_1.ml.UI.showError(text, jqxhr ? jqxhr.statusText : "Server error");
            }
        }
        static deleteLink(itemId, task) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                pluginId: task.plugin,
                action: "BreakLinks",
                matrixItem: {
                    project: project,
                    matrixItem: itemId
                },
                externalItems: [task]
            };
            globals_1.globalMatrix.wfgwConnection.deleteServerAsync("", job, true).done(function () {
                res.resolve();
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Removing link failed", jqxhr, textStatus, error);
            });
            return res;
        }
        static getMeta(pluginId, externalItemId) {
            var res = $.Deferred();
            let project = globals_1.matrixSession.getProject();
            let job = {
                pluginId: pluginId,
                action: "GetMeta",
                matrixItem: {
                    project: project
                },
                externalItem: {
                    externalItemId: externalItemId
                },
            };
            globals_1.globalMatrix.wfgwConnection.getServer("?" + jQuery.param({ payload: JSON.stringify(job) }, true)).done(function (result) {
                res.resolve(result);
            }).fail(function (jqxhr, textStatus, error) {
                Tasks.showError("Getting meta info of issue failed", jqxhr, textStatus, error);
            });
            return res;
        }
        static fillTree(tree, alltasks) {
            return tree.reduce((accumulator, item) => {
                if (item.id.indexOf("_") === 0) {
                    // Ingore these
                }
                else if (item.id && item.id.indexOf("F-") === 0) {
                    const children = Tasks.fillTree(item.children, alltasks);
                    if (children.length > 0) {
                        accumulator.push({
                            name: item.title,
                            id: item.id,
                            children: children
                        });
                    }
                }
                else {
                    const issues = alltasks.filter(taskItem => taskItem.matrixItem.matrixItem === item.id);
                    if (issues.length > 0) {
                        if (issues.length !== 1) {
                            console.error("Filter by ID returned more than 1 result. Check!!!", item.id);
                        }
                        const issueItem = issues[0];
                        accumulator.push(issueItem);
                    }
                }
                return accumulator;
            }, []);
        }
        static isFolder(item) {
            return item.hasOwnProperty("name");
        }
        static appendIssueItems(parentElement, folderItems, selectedFolders, folderChangeCallback, folders = []) {
            folderItems.forEach((item) => {
                if (Tasks.isFolder(item)) {
                    Tasks.appendIssueItems(parentElement, item.children, selectedFolders, folderChangeCallback, folders.concat(item));
                }
                else {
                    $.each(item.links, function (midx, task) {
                        const tr = $("<tr class='taskDisplayContainer'>");
                        const folderColumn = $("<td>");
                        const previousFolders = [];
                        folders.forEach(folder => {
                            if (previousFolders.length !== 0) {
                                folderColumn.append($("<span>/</span>"));
                            }
                            previousFolders.push(folder);
                            const folderLink = $("<span style='cursor: pointer; color: var(--BlueLink);font-weight: 700;font-size: 14px;'>")
                                .text(folder.name).click(ev => {
                                // console.log("Click on folder", previousFolders.join("/"));
                                folderChangeCallback(folder);
                            });
                            folderColumn.append(folderLink);
                        });
                        const matrix = $("<td>").append(matrixlib_1.ml.Item.renderLink(item.matrixItem.matrixItem, item.matrixItem.title));
                        const link = $("<td>").append(Tasks.renderTask(item.matrixItem.matrixItem, task, true, false));
                        const thisFolderPath = previousFolders.map(f => f.id).join("/");
                        if (Tasks.thisFolderPathIsInSelection(thisFolderPath, selectedFolders)) {
                            parentElement.append(tr.append(folderColumn).append(matrix).append(link));
                        }
                    });
                }
            });
        }
        static renderTasksInTable(alltasks, selectedFolders, folderChangeCallback) {
            const tableContainer = $("<div id='tablecontainer' style='height: 100%; overflow: hidden; padding-bottom: 15px;'>");
            var table = $("<table class='table'><thead><tr><th>Folder</th><th>Matrix Item</th><th>Task</th><th></th></tr></thead></table>");
            var items = $("<tbody>");
            table.append(items);
            const expandedFolders = Tasks.expandFolders(globals_1.app.getTree(), selectedFolders, []);
            // console.log("Expanded Folders", expandedFolders);
            let folderItems = Tasks.fillTree(globals_1.app.getTree(), alltasks);
            // console.log("Item Tree:", folderItems);
            Tasks.appendIssueItems(items, folderItems, expandedFolders, folderChangeCallback);
            var scroller = $("<div class='panel-body-v-scroll' style='height:100%'>");
            tableContainer.append(scroller.append(table));
            table.tablesorter({ sortList: [[0, 0], [1, 0], [2, 0]] });
            return tableContainer;
        }
        static expandFolders(tree, selectedFolders, prefix) {
            const folders = [];
            tree.forEach(treeitem => {
                if (treeitem.id.indexOf("F-") === 0) {
                    const newPrefix = prefix.concat(treeitem.id);
                    if (selectedFolders.indexOf(treeitem.id) !== -1) {
                        folders.push(newPrefix.join("/"));
                    }
                    folders.push(...Tasks.expandFolders(treeitem.children, selectedFolders, newPrefix));
                }
            });
            return folders;
        }
        static thisFolderPathIsInSelection(thisFolderPath, selectedFolders) {
            if (selectedFolders.length === 0) {
                return true;
            }
            const matchingFolders = selectedFolders.filter(folder => thisFolderPath.indexOf(folder) === 0);
            return matchingFolders.length > 0;
        }
    }
    exports.Tasks = Tasks;
    var mTasks;
    exports.mTasks = mTasks;
    function InitializeTasks() {
        exports.mTasks = mTasks = new Tasks();
        globalThis.Tasks = mTasks;
        // register the engine as plugin
        PluginManager_1.plugins.register(mTasks);
        mTasks.subscribe();
    }
    exports.InitializeTasks = InitializeTasks;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 55 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(17), __webpack_require__(16), __webpack_require__(13), __webpack_require__(15), __webpack_require__(1), __webpack_require__(10), __webpack_require__(20), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, DBCache_1, PluginManager_1, RestDB_1, matrixlib_1, RefLinkDefines_1, ItemCreationView_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializeTestManager = exports.mTM = exports.TestManager = void 0;
    class TestManager {
        constructor() {
            this.inputItems = []; // e.g. [{to: "F-TC-1"}, {to: "F-UC-1"}];// by default all
            this.isDefault = true;
            this.XTCconfig = {};
        }
        initItem(item, jui) {
            this.item = item;
            this.jui = jui;
        }
        updateMenu(ul, hook) {
            let that = this;
            if (hook !== PluginManager_1.pluginHooks.shares) {
                return;
            }
            if (!globals_1.matrixSession.isEditor()) {
                return;
            }
            if (!this.item || globals_1.app.isFolder(this.item.id)) {
                if (this.XTCconfig && this.XTCconfig.reExecute && this.isXTC(this.item.type)) {
                    var miReExecute = $('<li><a href="javascript:void(0)" id="toolXtcRedo">Redo failed tests</a></li>').click(function () {
                        that.redoFailed(that.item.id);
                    }).appendTo(ul);
                }
                return;
            }
            if (this.isCloneSource(this.item.type)) {
                var miExecute = $('<li><a href="javascript:void(0)" id="toolXtc">Prepare for test run</a></li>').click(function () {
                    globals_1.app.canNavigateAwayAsync().done(function () {
                        that.ConvertAll(null, that.item.id);
                    }).fail(function () {
                    });
                }).appendTo(ul);
            }
        }
        supportsControl(ctrl) {
            return (ctrl === 'test_steps' || ctrl === 'test_steps_result' || ctrl === 'test_result');
        }
        createControl(ctrl, options) {
            if (options.fieldType === "test_steps") {
                ctrl.tableCtrl(matrixlib_1.ml.JSON.setOptions(options, { parameter: this.getTestStepsConfig(options.type) }));
            }
            else if (options.fieldType === "test_steps_result") {
                ctrl.tableCtrl(matrixlib_1.ml.JSON.setOptions(options, { parameter: this.getTestStepsResultsConfig() }));
            }
            else if (options.fieldType === "test_result") {
                options.parameter.options = this.getTestRunResultOptions();
                options.parameter.sort = false;
                options.parameter.placeholder = this.getTestRunResultPlaceholder(this.item ? this.item[options.fieldId] : null); // item is null for tooltips
                ctrl.mxDropdown(options);
            }
        }
        initProject(project) {
            this.XTCconfig = globals_1.globalMatrix.ItemConfig.getTestConfig();
            if (!this.XTCconfig) {
                // default until 1.3
                this.XTCconfig = {
                    "xtcType": "XTC",
                    "cloneSources": ["TC", "UC"],
                    "columnsSteps": [{ "name": "Action", "field": "action", "editor": "text" },
                        { "name": "Expected Result", "field": "expected", "editor": "text" }],
                    "columnsStepsResult": [{ "name": "Action", "field": "action", "editor": "none" },
                        { "name": "Expected Result", "field": "expected", "editor": "none" },
                        { "name": "Passed/Failed", "field": "result", "editor": "result" },
                        { "name": "Comment", "field": "comment", "editor": "text" }],
                    "automatic": [],
                    "manual": [
                        { "human": "passed", "command": "passed", "render": "ok", "code": "p" },
                        { "human": "failed", "command": "failed", "render": "error", "code": "f" },
                        { "human": "", "command": "not executed", "render": "warning", "code": "" }
                    ],
                    "perStep": [
                        { "human": "passed", "command": "passed", "render": "ok", "code": "p", "key": "p", "image": "success.png" },
                        { "human": "failed", "command": "failed", "render": "error", "code": "f", "key": "f", "image": "fail.png" },
                        { "human": "", "command": "not executed", "render": "warning", "code": "", "key": "r", "image": "" }
                    ]
                };
            }
        }
        getProjectPages() {
            return [];
        }
        // this function is executed before an executed test case is saved. 
        // it allows set the test result ("test_result" field) from test steps results 
        // in the test table ("test_steps_result" field) if it is set to automatic
        preSaveHook(isItem, type, controls) {
            var res = $.Deferred();
            if (isItem && type === this.XTCconfig.xtcType &&
                this.XTCconfig.automatic && this.XTCconfig.automatic.length > 0) {
                this.computeOverallResult(controls);
            }
            this.createHumanValues(controls);
            res.resolve();
            return res;
        }
        renderActionButtons(options, body, controls) {
            let that = this;
            if (!this.isXTC(options.type)) {
                return false;
            }
            if (options.isItem || !options.item) {
            }
            else {
                if (options.controlState === globals_1.ControlState.FormEdit) {
                    // render controls for a folder
                    body.append($("<span class='baseControlHelp'>Tools</span>"));
                    var folderEdit = $("<div class='hidden-print baseControl'></div>");
                    body.append(folderEdit);
                    var createTools = new ItemCreationView_1.ItemCreationTools();
                    createTools.renderButtons({
                        parent: options.item.id,
                        dontOpenNewItem: false,
                        control: folderEdit,
                        linkTypes: [
                            { type: options.item.type, name: "Test Run Folder", folder: true }
                        ]
                    });
                    var testCreateUI = $("<div  class='hidden-print'></div>");
                    body.append(testCreateUI);
                    testCreateUI.append("<hr/>");
                    testCreateUI.append('<span class="baseControlHelp">Select Test and Use Cases to Run</span>');
                    testCreateUI.append("<br/>");
                    testCreateUI.append("<br/>");
                    var _createTestRun = $('<button class="buttonCreateSelect btn btn-default sel_create_TestForms">Create <b>Test Forms</b></button>').click(function () {
                        that.ConvertAll(options.item.id);
                    });
                    testCreateUI.append(_createTestRun);
                }
            }
            return true;
        }
        // **********************
        // public functions
        // todo: this should be done through plugin interface
        // **********************
        // check if the category is an executed test case (usually this will mean category type XTC)
        isXTC(type) {
            return this.XTCconfig.xtcType && this.XTCconfig.xtcType.toLowerCase() === type.toLowerCase();
        }
        // check if this is a test case, use case, or something else which can be converted to a TC
        isTC(type) {
            return this.isCloneSource(type);
        }
        // return the executed test case category type, (usually this will mean type XTC)
        getXTCType() {
            return this.XTCconfig.xtcType;
        }
        // return a simple array of all categories which can be converted to XTC
        getCloneSources() {
            return this.XTCconfig.cloneSources;
        }
        redoFailed(fromFolder) {
            let that = this;
            // get all failed tests
            globals_1.restConnection.getProject("needle?search=" + that.XTCconfig.reExecute + "&links=up").done(function (results) {
                let tcs = [];
                // get all tests in selected folder
                let xtcs = globals_1.app.getChildrenIdsRec(fromFolder);
                $.each(results.needles, function (idx, needle) {
                    // for all failed tests in selected folder 
                    let xtcId = matrixlib_1.ml.Item.parseRef(needle.itemOrFolderRef).id;
                    if (xtcs.indexOf(xtcId) != -1) {
                        $.each(needle.upLinkList, function (uidx, ul) {
                            // get all uplinks which are tests - if there are more than one only use the one in the title 
                            // this can happen if a TC includes others
                            let ulItem = matrixlib_1.ml.Item.parseRef(ul.itemRef);
                            if (that.isCloneSource(ulItem.type) && (needle.upLinkList.length == 1 || needle.title.indexOf("(" + ulItem.id + ")") != -1) && tcs.indexOf(ulItem.id) == -1) {
                                tcs.push(ulItem.id);
                            }
                        });
                    }
                });
                if (tcs.length == 0) {
                    matrixlib_1.ml.UI.showSuccess("All tests passed in this folder");
                }
                else {
                    that.ConvertAll("F-" + that.item.type + "-1", null, tcs);
                }
            }).fail(function () {
            });
        }
        // target folder is a folder or an item (TC) which should be converted to XTC
        // if sourceTC is set to a TC it is executed without letting the user choose a TC in the dialog and no parent folder is created
        ConvertAll(targetFolderId, sourceTC, preselectTC) {
            let that = this;
            let okButton;
            let exeParams = {};
            let tree;
            let wizardStep = 0;
            let niceSize = matrixlib_1.ml.UI.getNiceDialogSize(730, 450);
            // decide which fields to map from use cases and test cases to XTC
            this.prepareMapping();
            // prepare dialog (wizard step 1)
            matrixlib_1.ml.Search.searchInDialog();
            // reading values from step one and preparation of step 2
            function convertAllNext() {
                // change wizard button, start phase 2
                var hasUserChoice = false;
                wizardStep++;
                okButton.html('<span class="ui-button-text">Finish</span>');
                // prepare parameter
                exeParams = {};
                if (sourceTC) {
                    exeParams.single = 1;
                    exeParams.input = [sourceTC];
                    exeParams.output = that.XTCconfig.xtcType;
                    exeParams.parentFolder = "F-" + that.XTCconfig.xtcType + "-1"; // root folder of category
                }
                else {
                    // get values step 1, clean ui
                    var newSelection = tree.getController().getValue();
                    var ul = $("<ul>");
                    var inputItems = [];
                    for (var idx = 0; idx < newSelection.length; idx++) {
                        inputItems.push(newSelection[idx].to);
                        let link = $("<div>").refLink({
                            folder: false,
                            id: newSelection[idx].to,
                            title: newSelection[idx].title,
                            style: RefLinkDefines_1.refLinkStyle.link,
                            tooltip: RefLinkDefines_1.refLinkTooltip.html,
                            callback: function () {
                            }
                        });
                        ul.append($("<li>").append(link));
                    }
                    $(".fancytree-icontext", ul).remove();
                    exeParams.input = inputItems;
                    exeParams.output = that.XTCconfig.xtcType;
                    exeParams.parentFolder = (preselectTC && preselectTC.length > 0) ? "F-" + that.XTCconfig.xtcType + "-1" : targetFolderId;
                    tree.hide();
                }
                // prepare step 2 UI
                globals_1.app.dlgForm.addClass("dlg-v-scroll").removeClass("dlg-no-scroll");
                var scrollPanel = $('<div class="layoutContainerScroll"></div>');
                globals_1.app.dlgForm.append(scrollPanel);
                // selected items
                if (!sourceTC) {
                    scrollPanel.append($('<span class="baseControlHelp">Items to convert</span>'));
                    scrollPanel.append(ul);
                    // filter options 
                    var relevant_labels = matrixlib_1.ml.LabelTools.getLabelDefinitions(that.XTCconfig.cloneSources); // labels of UC, TC, ...
                    if (relevant_labels.length > 0) {
                        hasUserChoice = true;
                        // filtering execution by label
                        var filters = matrixlib_1.ml.LabelTools.getFilter().split(","); // currently selected filter
                        exeParams.filter = [];
                        scrollPanel.append($('<span class="baseControlHelp">Convert only items with all of these labels</span>'));
                        var useFilters = {};
                        $.each(relevant_labels, function (rlidx, rl) {
                            var set = filters.indexOf(rl.label) > -1;
                            if (set) {
                                exeParams.filter.push(rl.label);
                            }
                            var useFilter = $("<div>");
                            var name = rl.reportName;
                            if (rl.style && rl.style.filter && rl.style.filter.on && rl.style.filter.on.displayName) {
                                name = rl.style.filter.on.displayName;
                            }
                            useFilter.checkBox({
                                controlState: globals_1.ControlState.FormEdit,
                                canEdit: true,
                                fieldValue: set ? "true" : "false",
                                help: name,
                                valueChanged: function () {
                                    exeParams.filter = [];
                                    $.each(useFilters, function (ufid, uf) {
                                        if (uf.getController().getValue() === true) {
                                            exeParams.filter.push(ufid);
                                        }
                                    });
                                }
                            });
                            useFilter.css("margin-bottom", "-16px"); // make list more compact
                            useFilters[rl.label] = useFilter;
                            scrollPanel.append(useFilter);
                        });
                    }
                }
                var fieldList = globals_1.globalMatrix.ItemConfig.getItemConfiguration(that.XTCconfig.xtcType).fieldList;
                // preset field options
                exeParams.itemPresets = [];
                var defaultTestResult = that.XTCconfig.defaultTestResultResult ? that.XTCconfig.defaultTestResultResult : "";
                var testResultFieldId = 0;
                for (var tfi = 0; tfi < fieldList.length; tfi++) {
                    if (fieldList[tfi].fieldType === "test_result") {
                        testResultFieldId = fieldList[tfi].id;
                    }
                }
                if (testResultFieldId && defaultTestResult) {
                    exeParams.itemPresets.push({ field: testResultFieldId, value: defaultTestResult });
                }
                var presetFields = [];
                if (that.XTCconfig.presetFields) {
                    var inputCtrls = $("<div>");
                    var ctrl;
                    ctrl = new index_1.ItemControl({
                        control: inputCtrls,
                        controlState: globals_1.ControlState.DialogCreate,
                        parent: "",
                        type: that.XTCconfig.xtcType,
                        isItem: true,
                        changed: function () {
                            if (ctrl) {
                                var val = ctrl.getValues({});
                                // reset defaults
                                exeParams.itemPresets = [];
                                // set default result
                                if (testResultFieldId && defaultTestResult) {
                                    exeParams.itemPresets.push({ field: testResultFieldId, value: defaultTestResult });
                                }
                                // set defaults of entered values
                                $.each(presetFields, function (pfidx, pf) {
                                    exeParams.itemPresets.push({ field: pf, value: val[pf] });
                                });
                            }
                        }
                    });
                    scrollPanel.append(inputCtrls);
                    $(".panel-body-v-scroll", inputCtrls).removeClass("panel-body-v-scroll");
                    // hide all ctrls by default
                    hasUserChoice = showOnlyWantedFields(ctrl, inputCtrls, fieldList, presetFields);
                }
                return hasUserChoice;
            }
            function showOnlyWantedFields(ctrl, inputCtrls, fieldList, presetFields) {
                let hasUserChoice = false;
                $(".itemTitleBarNoTools", ctrl).hide();
                $(".baseControlHelp", inputCtrls).parent().hide();
                $.each(ctrl.getControls(), function (cidx, c) {
                    c.getController().disableDelayedShow = true;
                });
                $.each(fieldList, function (tfi, tf) {
                    $.each(that.XTCconfig.presetFields, function (csi, preset) {
                        var preset = that.XTCconfig.presetFields[csi];
                        if ((preset.field.toLowerCase() === "name" && tf.label.toLowerCase() === preset.value.toLowerCase()) ||
                            (preset.field.toLowerCase() === "meaning" && tf.parameterJson && tf.parameterJson.fieldMeaning && tf.parameterJson.fieldMeaning.toLowerCase() === preset.value.toLowerCase())) {
                            $.each($(".baseControlHelp", inputCtrls), function (bchidx, bch) {
                                if ($(bch).html().toLowerCase() === tf.label.toLowerCase() ||
                                    (bch.firstChild && bch.firstChild.textContent && bch.firstChild.textContent.toLowerCase() == tf.label.toLowerCase())) {
                                    $(bch).parent().show();
                                    presetFields.push(tf.id);
                                    hasUserChoice = true;
                                }
                            });
                        }
                    });
                });
                return hasUserChoice;
            }
            function convertFinish() {
                exeParams.itemFieldMapping = that.getMappingItems();
                globals_1.matrixSession.getCommentAsync().done(function (comment) {
                    exeParams.reason = comment;
                    matrixlib_1.ml.UI.setEnabled($("button", globals_1.app.dlgForm.parent()), false);
                    globals_1.restConnection.postProject("execute", exeParams, true).done(function (newXTC) {
                        if (newXTC.xtcInError && newXTC.xtcInError.length > 0) {
                            let issues = "";
                            $.each(newXTC.xtcInError, function (eidx, err) {
                                issues += `<b>${err.key}</b><br><ul style="text-align:left">`;
                                $.each(err.errors, function (edidx, errd) {
                                    issues += `<li>${errd}</li>`;
                                });
                                issues += "</ul>";
                            });
                            if (newXTC.folder != " -- ")
                                matrixlib_1.ml.UI.showAck(-1, issues, "Warning: issues during XTC generation");
                        }
                        if (newXTC.folder == " -- ") {
                            // after removing all the ugly things nothing left to create
                            matrixlib_1.ml.UI.showError("No XTCs were created", "None of the selected tests had all the selected labels, therefore no XTCs have been created");
                            globals_1.app.dlgForm.html("");
                            globals_1.app.dlgForm.dialog("close");
                            return;
                        }
                        globals_1.restConnection.getProject("tree?fancy").done(function (result) {
                            var pdb = new DBCache_1.DBCache();
                            result = RestDB_1.RestDB.filterLegacyReportCat(result);
                            pdb.initMatrixTree(result, false);
                            if (exeParams.single) {
                                // find new items in folder and copy them into F-XTC-1
                                var current = globals_1.app.getChildrenIds(newXTC.folder);
                                var newItem = "";
                                $.each(pdb.getChildrenIds(newXTC.folder), function (cidx, cid) {
                                    if (current.indexOf(cid) === -1) {
                                        globals_1.app.copyFrom(exeParams.parentFolder, pdb.getItemFromCache(cid));
                                        newItem = cid;
                                    }
                                });
                                globals_1.app.canNavigateAwayAsync().done(function () {
                                    globals_1.app.treeSelectionChangeAsync(newItem);
                                }).fail(function () {
                                });
                            }
                            else {
                                // copy the new tree in the folder
                                var newFolder = pdb.getItemFromCache(newXTC.folder);
                                // insert stuff in folder
                                globals_1.app.copyFrom(exeParams.parentFolder, newFolder);
                                // show folder if you can navigate away...
                                globals_1.app.canNavigateAwayAsync().done(function () {
                                    globals_1.app.treeSelectionChangeAsync(newXTC.folder);
                                }).fail(function () {
                                });
                            }
                        });
                        matrixlib_1.ml.UI.showSuccess("Test " + (sourceTC ? "form was" : "forms were") + " generated");
                        matrixlib_1.ml.UI.setEnabled($("button", globals_1.app.dlgForm.parent()), true);
                        globals_1.app.dlgForm.html("");
                        globals_1.app.dlgForm.dialog("close");
                    }).fail(function (jqxhr, textStatus, error) {
                        matrixlib_1.ml.UI.showError("Error", "Status:" + textStatus + "<br/>Error was:" + error);
                        matrixlib_1.ml.UI.setEnabled($("button", globals_1.app.dlgForm.parent()), true);
                        globals_1.app.dlgForm.html("");
                        globals_1.app.dlgForm.dialog("close");
                    });
                });
            }
            // show dialog
            function updateOkButton(enabled) {
                if (okButton) {
                    okButton.prop("disabled", !enabled);
                    if (enabled) {
                        okButton.removeClass("ui-state-disabled");
                    }
                    else {
                        okButton.addClass("ui-state-disabled");
                    }
                }
            }
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-v-scroll");
            globals_1.app.dlgForm.addClass("dlg-no-scroll");
            if (!sourceTC) {
                let treeConfig = {
                    tree: globals_1.app.getTree(this.XTCconfig.cloneSources),
                    controlState: globals_1.ControlState.DialogCreate,
                    canSelectItems: true,
                    selectMode: index_1.SelectMode.auto,
                    collectionChanged: function (count) {
                        updateOkButton(count > 0);
                    }
                };
                if (preselectTC) {
                    treeConfig.selectedItems = preselectTC.map(function (tc) { return { to: tc, title: "" }; });
                }
                tree = $("<div>").projectView(treeConfig);
                globals_1.app.dlgForm.append(tree);
            }
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Create Test Form" + (sourceTC ? "" : "s"),
                height: niceSize.height,
                width: niceSize.width,
                modal: true,
                close: function () {
                    globals_1.app.dlgForm.parent().html('');
                    globals_1.app.dlgForm.css('display', "none");
                    // dlg is gone, remove highlights and back to global highlighting
                    matrixlib_1.ml.Search.endSearchInDialog();
                },
                resizeStop: function () {
                    globals_1.app.dlgForm.resizeDlgContent([tree]);
                },
                open: function () {
                    okButton = $(".ui-dialog-buttonpane button:contains('Next')", globals_1.app.dlgForm.parent());
                    if (sourceTC) {
                        // skip step 0;
                        var hasUserInput = convertAllNext();
                        updateOkButton(true);
                        if (!hasUserInput) {
                            // no need to wait  / ask the user for more
                            convertFinish();
                        }
                    }
                    else {
                        // wait for user to select item (unless something was from pre-selection)
                        updateOkButton(preselectTC && preselectTC.length > 0);
                    }
                },
                buttons: [{
                        text: 'Next',
                        class: 'btnDoIt',
                        click: function () {
                            if (wizardStep === 0) {
                                var hasUserInput = convertAllNext();
                                updateOkButton(true);
                                if (!hasUserInput) {
                                    // no need to wait / ask the user for more
                                    convertFinish();
                                }
                            }
                            else {
                                convertFinish();
                            }
                        },
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.matrixSession.stopCommitTransaction();
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            }).resizeDlgContent(tree ? [tree] : [], false);
        }
        isCloneSource(category) {
            if (!this.XTCconfig.cloneSources) {
                return false;
            }
            for (var csi = 0; csi < this.XTCconfig.cloneSources.length; csi++) {
                if (this.XTCconfig.cloneSources[csi] === category) {
                    return true;
                }
            }
            return false;
        }
        // get the configuration for a test definition table (e.g. test actions and expected results)
        getTestStepsConfig(category) {
            if (this.XTCconfig.render && this.XTCconfig.render[category]) {
                return this.XTCconfig.render[category];
            }
            // this is actually a fallback for project created with version 1.5 or before
            // these project can be upgraded by just replacing the xtc_config with the latest version
            // UNLESS column names have been changed (which never happend)....
            return {
                columns: (category === this.XTCconfig.xtcType) ? this.XTCconfig.columnsStepsResult : this.XTCconfig.columnsSteps
            };
        }
        // get definition for a test execution table (e.g. including columns with results/comments)
        getTestStepsResultsConfig() {
            return {
                canBeModified: false,
                columns: this.getTestStepsConfig(this.XTCconfig.xtcType).columns,
                passFailEditorConfig: this.XTCconfig.perStep
            };
        }
        // returns possible values for the drop down of the completed test case
        getTestRunResultOptions() {
            var opts = [];
            if (this.XTCconfig.automatic && this.XTCconfig.automatic.length > 0) {
                opts.push({ id: "a", label: "automatic" });
            }
            for (var idx = 0; idx < this.XTCconfig.manual.length; idx++) {
                opts.push({ id: this.XTCconfig.manual[idx].code, label: this.XTCconfig.manual[idx].command });
            }
            return opts;
        }
        // returns place holder text if no value is selected
        getTestRunResultPlaceholder(value) {
            var code = value ? (value.split("|")[0]) : "";
            if (this.XTCconfig.automatic && this.XTCconfig.automatic.length > 0) {
                for (var idx = 0; idx < this.XTCconfig.automatic.length; idx++) {
                    if (this.XTCconfig.automatic[idx].code === code) {
                        return "automatic - was '" + this.XTCconfig.automatic[idx].human + "' when last saved";
                    }
                }
            }
            return "select test result";
        }
        // creates a search expression needed to find XTCs with state new,progress,ok,error,warning 
        getSearchExpression(resultType, notEqual) {
            let fields = globals_1.globalMatrix.ItemConfig.getFieldsOfType("test_result");
            let compare = notEqual ? '!=' : '=';
            if (fields.length != 1) {
                return ""; // there needs to be exactly one XTC type with on test result field
            }
            // test result field with quotes around
            let fieldName = '"' + fields[0].field.label + '"';
            // all searches are "fieldname"="expression" or "fieldname"!="expression" -> sb + expression + sa
            let sb = fieldName + compare + '"';
            let sa = '"';
            let opts = [];
            // collect different possible results 
            if (resultType == "new") {
                opts.push(sb + this.XTCconfig.defaultTestResultResult + sa);
                opts.push(sb + "r" + sa); // r = special code: reset -> not executed not started
            }
            else if (resultType == "progress") {
                if (this.XTCconfig.automatic.length) {
                    // by default the last means automatic  means, undecided = in progress
                    let autoProgress = this.XTCconfig.automatic[this.XTCconfig.automatic.length - 1];
                    opts.push(sb + autoProgress.code + "|" + autoProgress.render + "|" + autoProgress.human + sa);
                }
                opts.push(sb + "i" + sa); // i = special code: in progress
            }
            else {
                $.each(this.XTCconfig.automatic, function (idx, result) {
                    if (result.render == resultType) {
                        opts.push(sb + result.code + "|" + result.render + "|" + result.human + sa);
                    }
                });
                $.each(this.XTCconfig.manual, function (idx, result) {
                    if (result.render == resultType) {
                        opts.push(sb + result.code + sa);
                    }
                });
            }
            // combine with and or or
            return " (" + (notEqual ? opts.join(" and ") : opts.join(" or ")) + ") ";
        }
        // **********************
        // helper functions to convert test case to executed test cases 
        // this could happen on the server
        // create an automatic mapping of properties to be copied 
        // the mapping is done 
        // - if the items fields have the same label (e.g. Description to Description)
        // - from field_type "test_steps" to "test_steps_result"
        // - NOT from JIRA and maybe other items 
        prepareMapping() {
            var fieldList = globals_1.globalMatrix.ItemConfig.getItemConfiguration(this.XTCconfig.xtcType).fieldList;
            this.lookup = {};
            for (var csi = 0; csi < this.XTCconfig.cloneSources.length; csi++) {
                var cs = globals_1.globalMatrix.ItemConfig.getItemConfiguration(this.XTCconfig.cloneSources[csi]).fieldList;
                for (var csfi = 0; csfi < cs.length; csfi++) {
                    var csf = cs[csfi];
                    for (var tfi = 0; tfi < fieldList.length; tfi++) {
                        var tf = fieldList[tfi];
                        if (tf.label.toLowerCase() !== "jira") {
                            if ((tf.fieldType === "test_steps_result" && csf.fieldType === "test_steps") ||
                                (tf.label === csf.label)) {
                                this.lookup[csf.id] = tf.id;
                            }
                        }
                    }
                }
            }
            return this.lookup;
        }
        getMappingItems() {
            this.prepareMapping();
            var mapping = [];
            $.each(this.lookup, function (lidx, l) {
                if (l) {
                    mapping.push({ fromId: lidx, toId: l });
                }
            });
            return mapping;
        }
        // **********************
        // helper functions to compute the values of the overall "test_result" field from
        // in the test table ("test_steps_result" field) 
        // **********************
        getResultInfo(val) {
            if (val === "a") {
                return { automatic: true, label: "automatic" }; // automatic never changed
            }
            for (var idx = 0; idx < this.XTCconfig.automatic.length; idx++) {
                if (this.XTCconfig.automatic[idx].code === val) {
                    return { automatic: true, label: this.XTCconfig.automatic[idx].human };
                }
            }
            for (var idx = 0; idx < this.XTCconfig.manual.length; idx++) {
                if (this.XTCconfig.manual[idx].code === val) {
                    return { automatic: false, label: this.XTCconfig.manual[idx].human };
                }
            }
            return { automatic: false, label: "please select result" };
        }
        allTestSteps(controls, code) {
            for (var idx = 0; idx < controls.length; idx++) {
                if (controls[idx].ctrlType === "test_steps_result") {
                    var val = controls[idx].control.getController().getValue();
                    var v = JSON.parse(val);
                    for (var step = 0; step < v.length; step++) {
                        if (v[step].result !== code) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        oneTestStep(controls, code) {
            for (var idx = 0; idx < controls.length; idx++) {
                if (controls[idx].ctrlType === "test_steps_result") {
                    var val = controls[idx].control.getController().getValue();
                    var v = JSON.parse(val);
                    for (var step = 0; step < v.length; step++) {
                        if (v[step].result === code) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        computeOverallResult(controls) {
            // this should only happen if the value is not set to a manual
            for (var cidx = 0; cidx < controls.length; cidx++) {
                if (controls[cidx].ctrlType === "test_result") {
                    var resultInfo = this.getResultInfo(controls[cidx].control.getController().getValueRaw());
                    if (resultInfo.automatic) {
                        // apply rules to find a value
                        for (var r = 0; r < this.XTCconfig.automatic.length; r++) {
                            var rule = this.XTCconfig.automatic[r];
                            // rule: {human:"not started", code:"an", render:"warning", rule:"all", param:""},
                            // no specifc rule... default 
                            if (rule.rule === "") {
                                controls[cidx].control.getController().setValue(rule.code, true);
                                return;
                            }
                            // all: check if it applies: all elements need to be set to a value
                            if (rule.rule === "all" && this.allTestSteps(controls, rule.param)) {
                                controls[cidx].control.getController().setValue(rule.code, true);
                                return;
                            }
                            // one: check if it applies: at least one need to be set to a value
                            if (rule.rule === "one" && this.oneTestStep(controls, rule.param)) {
                                controls[cidx].control.getController().setValue(rule.code, true);
                                return;
                            }
                        }
                    }
                }
            }
        }
        // create for each test step a column human which has the test result as human readable string
        createHumanValues(controls) {
            for (var ci = 0; ci < controls.length; ci++) {
                if (controls[ci].ctrlType === "test_steps_result") {
                    var val = controls[ci].control.getController().getValue();
                    var tsr = JSON.parse(val);
                    for (var step = 0; step < tsr.length; step++) {
                        for (var idx = 0; idx < this.XTCconfig.perStep.length; idx++) {
                            if (this.XTCconfig.perStep[idx].code === tsr[step].result) {
                                tsr[step].human = this.XTCconfig.perStep[idx].human;
                                tsr[step].render = this.XTCconfig.perStep[idx].render;
                            }
                        }
                    }
                    controls[ci].control.getController().setValue(JSON.stringify(tsr));
                }
                else if (controls[ci].ctrlType === "test_result") {
                    var tr = controls[ci].control.getController().getValue();
                    for (var idx = 0; idx < this.XTCconfig.automatic.length; idx++) {
                        if (this.XTCconfig.automatic[idx].code === tr) {
                            controls[ci].control.getController().setValue(tr + "|" + this.XTCconfig.automatic[idx].render + "|" + this.XTCconfig.automatic[idx].human, true);
                        }
                    }
                    for (var idx = 0; idx < this.XTCconfig.manual.length; idx++) {
                        if (this.XTCconfig.manual[idx].code === tr) {
                            controls[ci].control.getController().setValue(tr + "|" + this.XTCconfig.manual[idx].render + "|" + this.XTCconfig.manual[idx].human);
                        }
                    }
                }
                else if (this.XTCconfig.autoFillTester && controls[ci].ctrlType === "user") {
                    // set the test to the first user saving it
                    let tester = controls[ci].control.getController().getValue();
                    let config = globals_1.globalMatrix.ItemConfig.getFieldById("XTC", controls[ci].fieldId);
                    if (config && config.parameterJson && config.parameterJson.fieldMeaning == "tester") {
                        if ((this.XTCconfig.autoFillTester == "first" && this.item.history.length == 1 && // first version 
                            (tester == this.item[config.id] || //  and the field is still the preset (from the creation)
                                !tester) // or the field is still empty
                        ) || this.XTCconfig.autoFillTester == "last") { // last
                            controls[ci].control.getController().setValue(globals_1.matrixSession.getUser());
                        }
                    }
                }
            }
        }
    }
    exports.TestManager = TestManager;
    var mTM;
    exports.mTM = mTM;
    function InitializeTestManager() {
        exports.mTM = mTM = new TestManager();
        PluginManager_1.plugins.register(mTM);
    }
    exports.InitializeTestManager = InitializeTestManager;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 56 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.InitializeTrainingManager = exports.ContextFrameManager = void 0;
    class ContextFrameManagerImpl {
        constructor() {
            this.pages = [];
        }
        getPages() {
            return this.pages;
        }
        // register a plugin providing  a context page
        register(plugin) {
            this.pages.push(plugin);
        }
        // check if a context page is supplied by plugin 
        implements(id) {
            return !!this.getPlugin(id);
        }
        renderTab(panel, id, config, context) {
            let p = this.getPlugin(id);
            p.onUpdate(panel, config, context);
        }
        // return a context page plugin of a given type
        getPlugin(id) {
            for (var idx = 0; idx < this.pages.length; idx++) {
                if (this.pages[idx].id == id) {
                    return this.pages[idx];
                }
            }
            return null;
        }
    }
    var ContextFrameManager;
    exports.ContextFrameManager = ContextFrameManager;
    function InitializeTrainingManager() {
        exports.ContextFrameManager = ContextFrameManager = new ContextFrameManagerImpl();
    }
    exports.InitializeTrainingManager = InitializeTrainingManager;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 57 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.BranchingHelper = exports.BranchingConstants = exports.EMergeType = exports.EMergeActionChoice = exports.EItemChangeState = exports.EMergeChangeStatus = void 0;
    class BranchingConstants {
    }
    exports.BranchingConstants = BranchingConstants;
    BranchingConstants.BRANCH_INFO_SETTING = "branch_info_02";
    // this indicated how items changed between the last sync point and now
    var EMergeChangeStatus;
    (function (EMergeChangeStatus) {
        EMergeChangeStatus[EMergeChangeStatus["deleted"] = 0] = "deleted"; // item was deleted since last merge/branching off
        EMergeChangeStatus[EMergeChangeStatus["created"] = 1] = "created"; // item was created (or restored) since last merge/branching off
        EMergeChangeStatus[EMergeChangeStatus["changed"] = 2] = "changed"; // item was changed since last merge/branching off
        EMergeChangeStatus[EMergeChangeStatus["unchanged"] = 3] = "unchanged"; // item was not changed since last merge/branching off
        EMergeChangeStatus[EMergeChangeStatus["notExist"] = 4] = "notExist"; // item did not and is not existing nor and at last merge/branching off
    })(EMergeChangeStatus || (EMergeChangeStatus = {}));
    exports.EMergeChangeStatus = EMergeChangeStatus;
    var EItemChangeState;
    (function (EItemChangeState) {
        EItemChangeState[EItemChangeState["never"] = 0] = "never";
        EItemChangeState[EItemChangeState["notNow"] = 1] = "notNow";
        EItemChangeState[EItemChangeState["now"] = 2] = "now"; // exists now
    })(EItemChangeState || (EItemChangeState = {}));
    exports.EItemChangeState = EItemChangeState;
    // that's is the user decision on how to handle a situation
    var EMergeActionChoice;
    (function (EMergeActionChoice) {
        EMergeActionChoice[EMergeActionChoice["noActionNeeded"] = -1] = "noActionNeeded"; // if there's no action needed
        EMergeActionChoice[EMergeActionChoice["undecided"] = 0] = "undecided"; // if there's no default suggested action (this cannot be the final choice though!)
        EMergeActionChoice[EMergeActionChoice["ignore"] = 1] = "ignore"; // don't merge a difference from the branch to the mainline
        EMergeActionChoice[EMergeActionChoice["add_restore"] = 2] = "add_restore"; // add an item from the branch to the mainline. there it might be a deleted (to be restored) or a new item (to be created with) with the same id
        EMergeActionChoice[EMergeActionChoice["replace"] = 3] = "replace"; // update the mainline item to match the branch
        EMergeActionChoice[EMergeActionChoice["delete"] = 4] = "delete"; // delete the mainline item to match the delete in the branch
    })(EMergeActionChoice || (EMergeActionChoice = {}));
    exports.EMergeActionChoice = EMergeActionChoice;
    var EMergeType;
    (function (EMergeType) {
        EMergeType[EMergeType["undefined"] = 0] = "undefined";
        EMergeType[EMergeType["merge"] = 1] = "merge";
        EMergeType[EMergeType["push"] = 2] = "push";
    })(EMergeType || (EMergeType = {}));
    exports.EMergeType = EMergeType;
    // Helper functions used by UI that expose branching.
    class BranchingHelper {
        static addMergeDetail(ul, detail, targetProject, isFromBranch) {
            if (detail.error) {
                if (detail.error.indexOf("doesn't exist") != -1) {
                    $("<li>").appendTo(ul).html(`Not updated (strict mode) request was: ${detail.request}`);
                }
                else {
                    $("<li>").appendTo(ul).html(`Error ${detail.action}: ${detail.error}`);
                }
                return;
            }
            let fromWhere = isFromBranch ? "branch" : "mainline";
            try {
                switch (detail.action) {
                    case "created":
                        ul.append($("<li>").html(`${detail.action} ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} based on ${fromWhere} revision ${matrixlib_1.ml.Item.parseRef(detail.branchItem).version}`));
                        break;
                    case "deleted":
                        ul.append($("<li>").html(`${detail.action} ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} revision ${matrixlib_1.ml.Item.parseRef(detail.mainlineItem).version}`));
                        break;
                    case "moved":
                        ul.append($("<li>").html(`${detail.action} ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} to ${BranchingHelper.renderItemLink(detail.mainlineFolder, targetProject)}`));
                        break;
                    case "merge_restore":
                        ul.append($("<li>").html(`restored ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} revision ${matrixlib_1.ml.Item.parseRef(detail.mainlineItem).version} based on ${fromWhere} revision ${matrixlib_1.ml.Item.parseRef(detail.branchItem).version}`));
                        break;
                    case "merge_update":
                        ul.append($("<li>").html(`updated ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} to revision ${matrixlib_1.ml.Item.parseRef(detail.mainlineItem).version} based on ${fromWhere} revision ${matrixlib_1.ml.Item.parseRef(detail.branchItem).version}`));
                        break;
                    case "link_added":
                        ul.append($("<li>").html(`added link from ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} to  ${BranchingHelper.renderItemLink(matrixlib_1.ml.Item.parseRef(detail.mainlineItem2).id, targetProject)}`));
                        break;
                    case "link_removed":
                        ul.append($("<li>").html(`removed link from ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} to  ${BranchingHelper.renderItemLink(matrixlib_1.ml.Item.parseRef(detail.mainlineItem2).id, targetProject)}`));
                        break;
                    default:
                        ul.append($("<li>").html(`${detail.action} ${BranchingHelper.renderItemLink(detail.mainlineItem, targetProject)} revision ${matrixlib_1.ml.Item.parseRef(detail.mainlineItem).version} based on ${fromWhere} revision ${matrixlib_1.ml.Item.parseRef(detail.branchItem).version}`));
                        break;
                }
            }
            catch (e) {
                console.log("Merge/Push Error");
                console.log(detail);
                $("<li>").appendTo(ul).html(`Request ${detail.request ? detail.request : ""}`);
            }
        }
        static renderItemLink(fullItem, otherProject) {
            // this item is in the project the user is looking at
            if (!otherProject)
                return matrixlib_1.ml.Item.parseRef(fullItem).id;
            // or in the other project
            return "#" + otherProject + "/" + matrixlib_1.ml.Item.parseRef(fullItem).id + "#";
        }
    }
    exports.BranchingHelper = BranchingHelper;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 58 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(32)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ProjectSettings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ItemConfiguration = void 0;
    class ItemConfiguration {
        constructor(logger, json) {
            this.configuration = {};
            this.settingsString = {};
            this.settingsJSON = {};
            this.users = []; // server
            this.userList = []; // cleaned up
            this.userGroups = [];
            this.logger = logger;
            this.json = json;
        }
        isConfigured() {
            return this.getCategories() && this.getCategories().length > 0;
        }
        addUsers(userPermission, groupPermission) {
            this.userGroups = groupPermission;
            this.users = userPermission;
            this.userList = [];
            if (userPermission) {
                for (var idx = 0; idx < this.users.length; idx++) {
                    var ignore = false;
                    if (this.users[idx].permission === 3) {
                        // 3 is an admin without write write access
                        ignore = true;
                    }
                    for (var ex = 0; !ignore && ex < this.userList.length; ex++) {
                        if (this.userList[ex].login.toLowerCase() === this.users[idx].login.toLowerCase() || this.userList[ex].id === this.users[idx].id) {
                            // somethings wrong here...
                            this.logger.log("warning", "Ignoring duplicate user... login:" + this.userList[ex].id + " ID:" + this.users[idx].login);
                            ignore = true;
                        }
                    }
                    if (!ignore) {
                        this.userList.push({
                            id: this.users[idx].id,
                            login: this.users[idx].login.toLowerCase(),
                            email: this.users[idx].email,
                            permission: this.users[idx].permission,
                            firstName: this.users[idx].firstName,
                            lastName: this.users[idx].lastName
                        });
                    }
                }
            }
        }
        getUserInfo(login) {
            let theUser = null;
            for (let user of this.getUserNames()) {
                if (user.login.toLowerCase() === login.toLowerCase()) {
                    theUser = user;
                }
            }
            return theUser;
        }
        getFullName(login) {
            let user = this.getUserInfo(login);
            if (user === null) {
                return login;
            }
            else {
                let name = (user.firstName ? user.firstName : "") + " " + (user.lastName ? user.lastName : "");
                return user.login + (name == " " ? "" : (" - ") + name);
            }
        }
        // TODO(modules): we need a single place in the code that does this, but ItemConfiguration doesn't
        // seem like the best (it is a global aspect of the software, not project).
        groupIdToName(groupId) {
            return `g_${groupId}_g`;
        }
        hasGroupInfo(group) {
            return this.getUserGroups().findIndex((g) => { return this.groupIdToName(g.groupId) === group.toLowerCase(); }) > -1;
        }
        // {login} may have been deleted or doesn't exist.
        hasUserInfo(login) {
            return this.getUserInfo(login) !== null;
        }
        getUserIds() {
            return this.getUserNames().map(function (user) { return user.login; });
        }
        getEmail(user) {
            let email = "";
            for (let otherUser of this.getUserNames()) {
                if (otherUser.login.toLowerCase() === user.toLowerCase()) {
                    email = otherUser.email;
                }
            }
            return email;
        }
        activateTimewarp(date) {
            this.timewarpDate = date;
        }
        getTimeWarp() {
            return this.timewarpDate;
        }
        isAfterTimeWarp(date) {
            return this.timewarpDate && new Date(date) > new Date(this.timewarpDate);
        }
        hasWriteAccess(user) {
            if (!user || this.timewarpDate) {
                return false;
            }
            let permission = this.getPermission(user);
            // -1 super admin, 2 read write, 3 admin
            return permission == -1 || permission == 2 || permission == 3;
        }
        getPermission(user) {
            let permission = -1; // (in case the user does not exists, it's a super admin)
            // get permission directly for user
            for (var idx = 0; idx < this.users.length; idx++) {
                if (this.users[idx].login.toLowerCase() === user.toLowerCase()) {
                    permission = this.users[idx].permission;
                }
            }
            // now go through all groups, maybe it's better
            for (let ug of this.getUserGroups()) {
                if (ug.membership.map(member => member.login.toLowerCase()).indexOf(user.toLowerCase()) != -1) {
                    // user is in this group, let's see if we can bump him up
                    if (ug.permission == 3)
                        permission = 3;
                    if (ug.permission == 2 && permission != 3)
                        permission = 2;
                    if (ug.permission == 1 && permission <= 0)
                        permission = 1;
                }
            }
            return permission;
        }
        getUserNames(sorted) {
            let users = this.json.clone(this.userList);
            // add users from user groups if they are not directly in
            for (let ug of this.getUserGroups()) {
                for (let m of ug.membership) {
                    if (users.map(user => user.login).indexOf(m.login) == -1) {
                        users.push({
                            id: -1,
                            login: m.login,
                            email: m.email,
                            permission: -1,
                            firstName: m.firstName,
                            lastName: m.lastName
                        });
                    }
                }
            }
            if (sorted) {
                users.sort(function (a, b) { if (a.login < b.login)
                    return -1;
                else
                    return 1; });
            }
            return users;
        }
        getUserGroups() {
            return this.userGroups;
        }
        // TODO(modules): This is a performance hack. Better if private.
        addGroupMember(gid, user) {
            let gs = this.userGroups.filter(g => g.groupId == gid && g.membership.map(u => u.login).indexOf(user) == -1);
            if (gs.length) {
                gs[0].membership.push({ login: user });
            }
        }
        // TODO(modules): This is a performance hack. Better if private.
        removeGroupMember(gid, user) {
            let gs = this.userGroups.filter(g => g.groupId == gid && g.membership.map(u => u.login).indexOf(user) != -1);
            if (gs.length) {
                gs[0].membership = gs[0].membership.filter(m => m.login != user);
            }
        }
        // TODO(modules): This is a performance hack. Better if private.
        addSettings(s) {
            let that = this;
            this.settings = s;
            this.settingsString = {};
            this.settingsJSON = {};
            if (s.settingList) {
                for (let setting of s.settingList) {
                    that.settingsString[setting.key] = setting.value;
                    if (setting.value && setting.value.indexOf('{') !== -1 && setting.value.indexOf('<') !== 0) {
                        // assume it a json
                        var val = this.json.fromString(setting.value);
                        if (val.status === "ok") {
                            that.settingsJSON[setting.key] = val.value;
                        }
                    }
                }
            }
        }
        getSettings() {
            return this.settings.settingList;
        }
        getSetting(s) {
            return this.settingsString[s];
        }
        getSettingJSON(s, def) {
            return this.settingsJSON[s] ? this.settingsJSON[s] : def;
        }
        getDropDowns(dropdownId) {
            let that = this;
            let dropdowns = [];
            for (let key of Object.keys(this.settingsJSON)) {
                let setting = that.settingsJSON[key];
                if (setting.options && (!dropdownId || dropdownId == key)) {
                    dropdowns.push({
                        id: key,
                        label: key,
                        value: setting
                    });
                }
            }
            return dropdowns;
        }
        getTasksConfig() {
            return this.getSettingJSON("task_config");
        }
        getDHFConfig() {
            return this.getSettingJSON("dhf_config");
        }
        getExtrasConfig() {
            let extras = this.getSettingJSON("extras");
            return (extras ? extras : {});
        }
        getLabelsConfig() {
            return this.getSettingJSON("labels");
        }
        getIncludeConfig() {
            let conf = this.getSettingJSON("imports");
            return (conf ? conf : {
                copies: {
                    importMasters: [],
                    lockLabel: ""
                }, includes: {
                    importMasters: [],
                    lockLabel: ""
                }
            });
        }
        getQMSConfig() {
            // get qms config (as project setting, handle 2.1 and earlier setting in category setting)
            let setting = this.getSettingJSON("qms_config");
            if (!setting) {
                setting = ProjectSettings_1.qmsDefaultConfig; // as in 2.1 and earlier
            }
            for (let p of setting.publications) {
                if (p.publisher == "_") {
                    let legacy = this.getCategorySetting(p.toCategory, "publish");
                    p.publisher = legacy ? legacy.publisher : "";
                }
            }
            return setting;
        }
        getRiskConfig() {
            return this.getSettingJSON("risk_config");
        }
        getCategoryGroupConfig() {
            return this.getSettingJSON("category_groups");
        }
        getACLConfig() {
            return this.getSettingJSON(ProjectSettings_1.ACL_SETTING);
        }
        getTraceConfig() {
            return this.getSettingJSON("trace_config");
        }
        getNavigationBarConfig() {
            return this.getSettingJSON("nav_config");
        }
        getContextPagesConfig() {
            return this.getSettingJSON("project_help");
        }
        getMailConfig() {
            return this.getSettingJSON(ProjectSettings_1.mailConfigSetting);
        }
        getSearchConfig() {
            return this.getSettingJSON("search_config");
        }
        getLabelLockConfig() {
            return this.getSettingJSON("lockingLabels");
        }
        getTestConfig() {
            return this.getSettingJSON("xtc_config");
        }
        setSettingJSON(key, valueJSON) {
            this.settingsString[key] = JSON.stringify(valueJSON);
            this.settingsJSON[key] = valueJSON;
        }
        getSmartText() {
            return this.getSettingJSON(ProjectSettings_1.smartTextConfigSetting);
        }
        addCategorySetting(categorySetting) {
            if (!this.settings || !this.settings.categorySettingList) {
                return;
            }
            this.settings.categorySettingList.push(categorySetting);
        }
        getCategorySettings(category) {
            if (!this.settings || !this.settings.categorySettingList) {
                return [];
            }
            for (var idx = 0; idx < this.settings.categorySettingList.length; idx++) {
                if (this.settings.categorySettingList[idx].categoryShort === category && this.settings.categorySettingList[idx].settingList) {
                    return this.settings.categorySettingList[idx].settingList;
                }
            }
            return [];
        }
        // return the setting for a plugin or null if plugin or setting does not exist
        // TODO(modules): is this ever called?
        getPluginSetting(pluginId, setting) {
            /*
             * pluginSettingsList: [
                {
                    pluginId: 101,
                    settings: [ {
                        setting: "serverType",
                        value: "medical",
                        encrypted: false
                    }, {
                    setting: "baseUrl",
                        value: "https://matrixtest.atlassian.net",
                        encrypted: false
                    } ]
                }
            ]
             */
            if (!this.settings || !this.settings.pluginSettingsList) {
                return null;
            }
            for (var idx = 0; idx < this.settings.pluginSettingsList.length; idx++) {
                var ps = this.settings.pluginSettingsList[idx];
                if (ps.pluginId == pluginId) {
                    for (var jdx = 0; jdx < ps.settings.length; jdx++) {
                        if (ps.settings[jdx].setting === setting) {
                            return ps.settings[jdx].value;
                        }
                    }
                }
            }
            return null;
        }
        getPluginSettings() {
            return this.settings.pluginSettingsList;
        }
        // return tuples {category, field} of all categories which use a type
        // used for tisk traceability in DHF
        getFieldsOfType(fieldType, categoryType) {
            var hits = [];
            if (!this.settings) {
                return hits;
            }
            for (var idx = 0; idx < this.settings.categorySettingList.length; idx++) {
                var category = this.settings.categorySettingList[idx].categoryShort;
                if (!categoryType || categoryType === category) {
                    var cc = this.getItemConfiguration(category);
                    if (cc) {
                        var fields = cc.fieldList;
                        for (var fdx = 0; fdx < fields.length; fdx++) {
                            if (fields[fdx].fieldType === fieldType) {
                                //    var jconfig = this.json.fromString(fields[fdx].parameter);
                                hits.push({ category: category, field: fields[fdx] });
                            }
                        }
                    }
                }
            }
            return hits;
        }
        getCategorySetting(category, setting) {
            var catSettings = this.getCategorySettings(category);
            for (var idx = 0; idx < catSettings.length; idx++) {
                if (catSettings[idx].key === setting) {
                    var jconfig = this.json.fromString(catSettings[idx].value);
                    if (jconfig.status === 'ok') {
                        // apparently parsing went well
                    }
                    else if (jconfig.status === 'error') {
                        this.logger.log("error", "The category setting '" + catSettings[idx].key + "' has an invalid value. Ignoring it.");
                    }
                    else {
                        this.logger.log("warning", "The category setting '" + catSettings[idx].key + "' is empty.");
                    }
                    return jconfig.value;
                }
            }
            return null;
        }
        getCategories(noFolders) {
            let catgories = Object.keys(this.configuration);
            if (noFolders) {
                catgories.splice(catgories.indexOf("FOLDER"), 1);
            }
            return catgories;
        }
        getCategoryLabel(category) {
            if (this.configuration[category]) {
                return this.configuration[category].label;
            }
            return "";
        }
        getCategoryId(category) {
            let cd = this.settings.categoryList.categoryExtended.filter(function (cat) { return cat.category.shortLabel == category; });
            if (cd.length == 1) {
                return "" + cd[0].category.id;
            }
            return "";
        }
        // links for 1.5 and earlier (configured as category setting)
        getDownLinkTypes(category, required) {
            if (required) {
                return this.configuration[category].downLinksRequired;
            }
            return this.configuration[category].downLinksOptional;
        }
        // links for 1.5 and earlier (configured as category setting)
        getUpLinkTypes(category, required) {
            var up = [];
            for (var key in this.configuration) {
                if (key && key != category && this.configuration[key]) {
                    if (required && this.configuration[key].downLinksRequired.indexOf(category) != -1) {
                        up.push(key);
                    }
                    if (!required && this.configuration[key].downLinksOptional.indexOf(category) != -1) {
                        up.push(key);
                    }
                }
            }
            return up;
        }
        addCategories(config) {
            for (var idx = 0; config.categoryList.categoryExtended != undefined && idx < config.categoryList.categoryExtended.length; idx++) {
                this.addCategory(config.categoryList.categoryExtended[idx]);
            }
        }
        init(config) {
            this.addCategories(config);
            this.addSettings(config);
            this.addUsers(config.userPermission, config.groupPermission);
        }
        canEdit(category) {
            return this.canDo(category, "edit");
        }
        canEditTitle(category) {
            return this.canDo(category, "rename");
        }
        canMove(category) {
            return this.canDo(category, "move");
        }
        canCreate(category) {
            return this.canDo(category, "create");
        }
        canDelete(category) {
            return this.canDo(category, "delete");
        }
        canModifyLabels(category) {
            return this.canDo(category, "label");
        }
        canSign(category) {
            return this.canDo(category, "sign");
        }
        canReport(category) {
            return this.canDo(category, "report");
        }
        canDo(category, task) {
            if (!this.configuration[category])
                return false;
            if (!this.configuration[category].enable)
                return true; // no limitation specified for this user
            if (this.configuration[category].enable.indexOf(task) != -1)
                return true;
            return false;
        }
        addCategory(config) {
            this.configuration[config.category.shortLabel] = {
                fieldList: [],
                label: config.category.label,
                downLinksRequired: [],
                downLinksOptional: [],
                enable: config.enable
            };
            var fieldList = config.fieldList.field;
            if (!fieldList) {
                fieldList = [];
            }
            for (var idx = 0; idx < fieldList.length; idx++) {
                var jconfig = this.json.fromString(fieldList[idx].parameter);
                if (jconfig.status === 'ok') {
                    // apparently parsing went well
                }
                else if (jconfig.status === 'error') {
                    this.logger.log("error", "The field with id '" + fieldList[idx].id + "' has an invalid value. Ignoring it.");
                }
                else {
                    // quite normal
                }
                fieldList[idx].parameterJson = jconfig.value;
                this.configuration[config.category.shortLabel].fieldList.push(fieldList[idx]);
                if (fieldList[idx].fieldType === "links") {
                    if (fieldList[idx].parameterJson && fieldList[idx].parameterJson.linkTypes) {
                        for (var l = 0; l < fieldList[idx].parameterJson.linkTypes.length; l++) {
                            var dl = fieldList[idx].parameterJson.linkTypes[l];
                            if (this.json.isTrue(dl.required)) {
                                this.configuration[config.category.shortLabel].downLinksRequired.push(dl.type);
                            }
                            else {
                                this.configuration[config.category.shortLabel].downLinksOptional.push(dl.type);
                            }
                        }
                    }
                }
            }
        }
        getItemConfiguration(category) {
            return this.configuration[category];
        }
        getFieldId(category, fieldLabel) {
            var cc = this.getItemConfiguration(category);
            if (!cc) {
                return 0;
            }
            var fields = cc.fieldList;
            for (var idx = 0; idx < fields.length; idx++) {
                if (fields[idx].label.toLowerCase() === fieldLabel.toLowerCase()) {
                    return fields[idx].id;
                }
            }
            return 0;
        }
        getFields(category) {
            var cc = this.getItemConfiguration(category);
            if (!cc) {
                return null;
            }
            return cc.fieldList;
        }
        getFieldByName(category, name) {
            let fields = this.getFields(category).filter(function (field) { return field.label && field.label.toLowerCase() == name.toLowerCase(); });
            if (fields.length == 1)
                return fields[0];
            return undefined;
        }
        getFieldById(category, fieldId) {
            var cc = this.getItemConfiguration(category);
            if (!cc) {
                return null;
            }
            let fields = cc.fieldList.filter(function (field) { return field.id == fieldId; });
            return fields.length ? fields[0] : null;
        }
        getFieldConfig(fieldId) {
            for (let category of this.getCategories()) {
                let field = this.getFieldById(category, fieldId);
                if (field) {
                    return field.parameterJson;
                }
            }
            return null;
        }
        getFieldName(fieldId) {
            for (let category of this.getCategories()) {
                let field = this.getFieldById(category, fieldId);
                if (field) {
                    return field.label;
                }
            }
            return "";
        }
        getFieldType(category, fieldId) {
            var cc = this.getItemConfiguration(category);
            if (!cc) {
                return null;
            }
            var fields = cc.fieldList;
            for (var idx = 0; idx < fields.length; idx++) {
                // note this is ==: sometimes it is an int sometimes a string 
                if (fields[idx].id == fieldId) {
                    return fields[idx].fieldType;
                }
            }
            return null;
        }
        // gets required or optional up or downlink categories for a given category
        // it uses the project setting for the trace configuration if existing,
        // the category setting (1.5 and earlier) otherwise
        getLinkTypes(category, down, required) {
            var tc = this.getTraceConfig();
            if (!tc) {
                // use 1.5 and before rules
                if (down) {
                    return this.getDownLinkTypes(category, required);
                }
                else {
                    return this.getUpLinkTypes(category, required);
                }
            }
            // get the up/down rule from project setting
            var updown;
            for (let rule of tc.rules) {
                if (rule.category === category) {
                    updown = down ? rule.down_rules : rule.up_rules;
                }
            }
            if (!updown) {
                // no rules.. 
                return [];
            }
            var result = [];
            // rules exist get all required or option links
            for (let updownRule of updown) {
                if (updownRule.rule === "must_have" && updownRule.any_of && required) {
                    for (let any of updownRule.any_of) {
                        // add to must have
                        if (result.indexOf(any) === -1) {
                            result.push(any);
                        }
                    }
                }
                else if (updownRule.rule === "can_have" && updownRule.any_of && !required) {
                    for (let any of updownRule.any_of) {
                        // add to can have
                        if (result.indexOf(any) === -1) {
                            result.push(any);
                        }
                    }
                }
            }
            return result;
        }
        // gets required or optional up or downlink categories for a given category
        // including reason why they should / could exist
        // it uses the project setting for the trace configuration if existing,
        // the category setting (1.5 and earlier) otherwise
        getLinkInfo(category, down, required, groupByRule) {
            var tc = this.getTraceConfig();
            if (!tc) {
                var links = [];
                // use 1.5 and before rules
                if (down) {
                    links = this.getDownLinkTypes(category, required);
                }
                else {
                    links = this.getUpLinkTypes(category, required);
                }
                var result = [];
                for (var idx = 0; idx < links.length; idx++) {
                    result.push({ category: links[idx], reason: (required ? "required" : "optional") });
                }
                return result;
            }
            // get the up/down rule from project setting
            var updown;
            for (let rule of tc.rules) {
                if (rule.category === category) {
                    updown = down ? rule.down_rules : rule.up_rules;
                }
            }
            if (!updown) {
                // no rules.. 
                return [];
            }
            var linkInfo = [];
            // rules exist get all required or optional links
            for (let updownRule of updown) {
                if (updownRule.rule === "must_have" && updownRule.any_of && required) {
                    if (groupByRule) {
                        linkInfo.push({ category: updownRule.any_of, reason: updownRule.name });
                    }
                    else {
                        for (let anys of updownRule.any_of) {
                            // add to must have
                            linkInfo.push({ category: anys, reason: updownRule.name });
                        }
                    }
                }
                else if (updownRule.rule === "can_have" && updownRule.any_of && !required) {
                    if (groupByRule) {
                        linkInfo.push({ category: updownRule.any_of, reason: updownRule.name });
                    }
                    else {
                        for (let anys of updownRule.any_of) {
                            // add to can have
                            linkInfo.push({ category: anys, reason: updownRule.name });
                        }
                    }
                }
            }
            return linkInfo;
        }
        getMitigations() {
            let risk_config = this.getRiskConfig();
            // get the mitigations from the project setting
            let global = [];
            if (risk_config && risk_config.mitigationTypes) {
                global = risk_config.mitigationTypes.map(function (mt) { return mt.type; });
            }
            // for each field, check if there's a field setting, if not use the global setting
            let mitCats = {};
            for (let riskFieldInfo of this.getFieldsOfType("risk2")) {
                mitCats[riskFieldInfo.category] = [];
                let fieldConfig = riskFieldInfo.field.parameterJson;
                if (fieldConfig && fieldConfig.riskConfig) {
                    mitCats[riskFieldInfo.category] =
                        fieldConfig.riskConfig.mitigationTypes.map(mt => mt.type);
                }
                else {
                    mitCats[riskFieldInfo.category] = global;
                }
            }
            return mitCats;
        }
        /** return cleanup rules, if there's a project setting that wins, if there's no rules or it's disabled it returns -1 */
        getCleanupRules() {
            return this.getSettingJSON("htmlCleanup");
        }
    }
    exports.ItemConfiguration = ItemConfiguration;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 59 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(58), __webpack_require__(6), __webpack_require__(4), __webpack_require__(1), __webpack_require__(21), __webpack_require__(13), __webpack_require__(14), __webpack_require__(3), __webpack_require__(54), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ItemConfiguration_1, globals_1, index_1, matrixlib_1, MainTree_1, PluginManager_1, PluginManagerDocuments_1, MatrixLibInterfaces_1, Tasks_1, Components_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.MatrixReq = void 0;
    class MatrixReq {
        constructor(dataSource) {
            this._itemId = ""; //currently selected item id. this should come from URL
            this._needsSave = false; // the current status of the rendered item 
            this.lastState = "";
            this.mainApp = true;
            this.itemForm = $("#itemDetails");
            this.printForm = $("#appPrint");
            this.dlgForm = $("#appPopup");
            this.mainTreeLoaded = false;
            this.dbConnection = dataSource;
        }
        // allow to overwrite cache (for JIRA cloud plugin)
        setCache(externalCache) {
            this.dbConnection.setCache(externalCache);
        }
        // store the project of this session
        loadProject(project, item) {
            let that = this;
            if (item && item == "null") {
                item = null;
            }
            // reset to avoid ping to non existing item
            this._itemId = "";
            globals_1.setIC(new ItemConfiguration_1.ItemConfiguration(matrixlib_1.ml.Logger, matrixlib_1.ml.JSON));
            // make the database to load the project
            globals_1.matrixApplicationUI.destroyOldControls();
            MainTree_1.NavigationPanel.destroy();
            // this will show the tree and select the item
            // if the user logs in / is logged in
            this.loadTreeAndItem(project, item).done(function (itemToShow) {
                // show a logo if there is any
                let logo = globals_1.globalMatrix.matrixBaseUrl + "/static/img/" + globals_1.globalMatrix.matrixProduct + ".png";
                let logoSetting = globals_1.globalMatrix.ItemConfig.getSetting("projectLogo");
                if (logoSetting) {
                    if (logoSetting.indexOf("{") !== -1) {
                        var rjs = matrixlib_1.ml.JSON.fromString(logoSetting);
                        if (rjs.status === 'ok') {
                            if (rjs.value.fileId) {
                                logo = globals_1.globalMatrix.matrixRestUrl + "/" + project + "/file/" + (rjs.value.fileId);
                            }
                        }
                    }
                    else { // legacy
                        logo = logoSetting;
                    }
                }
                $(".brandLogo").attr("src", logo);
                that.updateFavicon(project, false);
                // show and apply project filters
                if (!globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                    $("#globalProjectFilter").html('');
                    var labelFilter = matrixlib_1.ml.LabelTools.getFilter();
                    if (labelFilter && labelFilter.length > 0 && matrixlib_1.ml.LabelTools.getFilterColor()) {
                        $("header").css("background-color", matrixlib_1.ml.LabelTools.getFilterColor());
                    }
                    else {
                        $("header").css("background-color", "");
                    }
                    // show the filters -> if someone uses them, reload  the project with the filter
                    new index_1.LabelSwitches($("#globalProjectFilter"), true, null, (labelFilter && labelFilter.length > 0) ? labelFilter.split(",") : [], "project_filter", function (newSelection) {
                        that.canNavigateAwayAsync().done(function () {
                            matrixlib_1.ml.LabelTools.setFilter(newSelection);
                            that.loadProject(project, that._itemId);
                        }).fail(function () {
                            matrixlib_1.ml.UI.showError("Filter was not activated.", "To activate reload project after saving the item!");
                        });
                    });
                    $("#globalProjectFilter >> button").attr("disabled", "disabled");
                }
                else {
                    // no filters
                    $("#projectTree").addClass("timewarp");
                }
                // render the item and the reduced tree
                that.showTree(item, itemToShow);
                // find a place to add a progress
                let loadTreeProgress = $("<div id='treeLoadWait'>").append($("<div>").append(matrixlib_1.ml.UI.getSpinningWait(" ")));
                $("#projectTree .listContent").after(loadTreeProgress);
                // render the full tree and color some items by executing searches
                window.setTimeout(() => {
                    that.loadTreeWithSearches(item).always(() => {
                        // configure highlighting of links in rich text boxes
                        var cats = globals_1.globalMatrix.ItemConfig.getCategories();
                        for (var idx = 0; idx < cats.length; idx++) {
                            addHighlightLink(cats[idx], globals_1.globalMatrix.matrixBaseUrl + "/" + project + "/");
                        }
                        globals_1.matrixApplicationUI.refreshLinks();
                        loadTreeProgress.remove();
                    });
                }, 1);
            }).fail(function () {
                matrixlib_1.ml.UI.hideSuccess();
            });
        }
        loadTree(project) {
            this.dbConnection.setProject(project);
            return this.dbConnection.retrieveTreeAsync();
        }
        // load item and the tree for the item
        loadTreeAndItem(project, item) {
            this.dbConnection.setProject(project);
            return this.dbConnection.retrieveTreeAndItem(item);
        }
        updateFavicon(project, notification) {
            // get the base icon (default or from project setting)
            let iconPath = globals_1.globalMatrix.matrixBaseUrl + "/favicon_medical.ico";
            let logoSetting = globals_1.globalMatrix.ItemConfig.getSetting("projectLogo");
            let customPath = MatrixReq.getProjectIcon(logoSetting);
            if (customPath) {
                iconPath = globals_1.globalMatrix.matrixRestUrl + "/" + project + "/file/" + customPath;
            }
            let iconNode = $("link[rel*='icon']");
            iconNode.attr("href", iconPath);
            // if there's neither a notification or a custom path I am done
            if (!notification && customPath) {
                return;
            }
            let canvas = document.createElement('canvas');
            if (canvas.getContext) {
                let img = document.createElement('img');
                img.onload = function () {
                    canvas.height = img.height;
                    canvas.width = img.width;
                    let radius = img.width / 6;
                    let boxHeight = img.width / 10;
                    let boxIndent = img.width / 10;
                    let ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    if (notification) {
                        ctx.fillStyle = MatrixLibInterfaces_1.UIToolsConstants.CIColors.RedPersimmon.color;
                        ctx.beginPath();
                        ctx.arc(img.width - 2 * radius + 3, radius - 1, radius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    if (!customPath) {
                        // draw a box with project colors
                        let color = globals_1.matrixSession.getProjectColor(project);
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.rect(0 + boxIndent, img.height - boxHeight - 1, img.width - 1 - 2 * boxIndent, boxHeight);
                        ctx.fill();
                    }
                    iconNode.attr("href", canvas.toDataURL('image/png'));
                };
                img.src = iconPath;
            }
        }
        waitForMainTree(callback) {
            if (callback) {
                if (globals_1.app.mainTreeLoaded) {
                    callback();
                }
                else {
                    document.addEventListener("mainTreeLoaded", () => {
                        callback();
                    });
                }
            }
        }
        // load the full tree and colors items with search results if some are defined
        loadTreeWithSearches(item) {
            let that = this;
            const mainTreeLoadedEvent = new Event('mainTreeLoaded');
            let res = $.Deferred();
            that.dbConnection.retrieveTreeAsync().done(function () {
                that.colorBySearches(item, 0).done(() => {
                    MainTree_1.NavigationPanel.render();
                    Components_1.NavBar.init();
                    MainTree_1.NavigationPanel.select(item);
                    res.resolve();
                    //Raise an event when the tree is loaded
                    that.mainTreeLoaded = true;
                    document.dispatchEvent(mainTreeLoadedEvent);
                    globals_1.matrixApplicationUI.highlightReferences();
                });
            });
            return res;
        }
        colorBySearches(item, idx) {
            let that = this;
            let res = $.Deferred();
            let search = globals_1.globalMatrix.ItemConfig.getSearchConfig();
            // Fix failed tests query (MATRIX-3926)
            if (search != undefined && search.searches != undefined) {
                let index = search.searches.findIndex((s => { return s.name == "failed tests" && s.expr == "mrql:'testResult'='error'"; }));
                if (index >= 0) {
                    search.searches[index].expr = 'mrql:"test run result"~"error"';
                }
            }
            // no more searches defined: time to return and to render the tree
            if (!search || !search.init || search.init.length <= idx) {
                res.resolve();
                return res;
            }
            // run the next search, color the tree and continue
            globals_1.app.searchAsyncMinimalOutput(search.init[idx].expr).done(function (items) {
                globals_1.app.setStyle(items, search.init[idx].style, search.init[idx].computeFolder);
                that.colorBySearches(item, idx + 1).always(() => {
                    res.resolve();
                });
            }).fail(function () {
                res.resolve();
            });
            return res;
        }
        // render the tree
        showTree(item, cached) {
            let that = this;
            // render the selected item, if there is any
            MainTree_1.NavigationPanel.render();
            Components_1.NavBar.init();
            if (item) {
                if (this.dbConnection.doesExist(item)) {
                    this._itemId = item;
                    if (typeof globals_1.globalMatrix.mobileApp !== "undefined") {
                        globals_1.globalMatrix.mobileApp.ShowMobileUI();
                    }
                    else {
                        MainTree_1.NavigationPanel.select(item);
                        this.renderItem(cached);
                    }
                }
                else {
                    globals_1.globalMatrix.projectStorage.setItem('SessionLastItem', "");
                    if (typeof globals_1.globalMatrix.mobileApp !== "undefined") {
                        globals_1.globalMatrix.mobileApp.ShowMobileUI();
                    }
                    this.getItemAsync(item).done(function (_data) {
                        globals_1.matrixApplicationUI.renderErrorControl(that.itemForm, "Item " + item + " does not exist anymore", "It was deleted, check the 'CHANGES Dashboard' or 'Deleted Items' if you are interested in when or why it was deleted.");
                    }).fail(function () {
                        globals_1.matrixApplicationUI.renderErrorControl(that.itemForm, "Item " + item + " does not exist", "Incorrect item id.");
                    });
                }
            }
        }
        // *********************************************
        // calls from item AND Tree
        // *********************************************
        getTree(subtreeFilter) {
            return this.dbConnection.getTree(subtreeFilter);
        }
        // api get a simple tree structure of item ids
        getSubTree(itemId) {
            let that = this;
            let tree = { itemId: itemId, title: this.getItemTitle(itemId) };
            if (matrixlib_1.ml.Item.parseRef(itemId).isFolder) {
                tree.children = [];
                $.each(globals_1.app.getChildrenIds(itemId), function (idx, id) {
                    tree.children.push(that.getSubTree(id));
                });
                return tree;
            }
            else {
                return tree;
            }
        }
        // *********************************************
        // calls from item
        // *********************************************
        getAuditDetailsAsync(auditId, ignoreErrors) {
            return this.dbConnection.getAuditDetailsAsync(auditId);
        }
        getItemAsync(itemId, version, ignoreErrors, noHistory) {
            let that = this;
            var res = $.Deferred();
            if (typeof version !== 'undefined') {
                this.dbConnection.getVersionAsync(itemId, version, !noHistory).done(function (result) {
                    res.resolve(result);
                });
            }
            else {
                this.dbConnection.getItemAsync(itemId, ignoreErrors, !noHistory).done(function (result) {
                    that.setHiddenLink(itemId, result.isUnselected);
                    res.resolve(result);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            return res;
        }
        /** get the source of an item */
        getImportSource(item) {
            if (!item)
                return null;
            if (!item.crossLinks)
                return null;
            let clones = item.crossLinks.filter(cl => cl.upItem.projectShort == globals_1.matrixSession.getProject());
            if (clones.length == 0)
                return null;
            if (clones.length != 1) {
                console.log("Warning: more than one import sources");
                console.log(clones);
            }
            // return the clone info
            return clones[0];
        }
        /** get the source of an item */
        getUsedBy(item) {
            if (!item)
                return null;
            if (!item.crossLinks)
                return null;
            let clones = item.crossLinks.filter(cl => cl.downItem.projectShort == globals_1.matrixSession.getProject());
            if (clones.length == 0)
                return null;
            // return the clone info
            return clones;
        }
        getNeedlesAsync(searchExpr, up, down, fields, labels, ignoreFilters) {
            return this.dbConnection.getNeedlesAsync(searchExpr, up, down, fields, labels, ignoreFilters);
        }
        getItemProjectAsync(project, itemId, ignoreErrors) {
            let that = this;
            var res = $.Deferred();
            this.dbConnection.getItemProjectAsync(project, itemId, ignoreErrors, true).done(function (result) {
                that.setHiddenLink(itemId, result.isUnselected);
                res.resolve(result);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        getProjectItemAsync(project, itemId, version, includeHistory) {
            let that = this;
            var res = $.Deferred();
            if (typeof version !== 'undefined') {
                this.dbConnection.getProjectVersionAsync(project, itemId, version, includeHistory).done(function (result) {
                    res.resolve(result);
                });
            }
            else {
                this.dbConnection.getProjectItemAsync(project, itemId, true).done(function (result) {
                    res.resolve(result);
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            return res;
        }
        getProjectCatFields(project) {
            var res = $.Deferred();
            this.dbConnection.getProjectCat(project).done(function (result) {
                let found = false;
                res.resolve(result.categoryList.categoryExtended);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        getItemFromTree(itemId) {
            return this.dbConnection.getItemFromTree(itemId);
        }
        // get children Ids
        getChildrenIds(parentId) {
            return this.dbConnection.getChildrenIds(parentId);
        }
        getChildrenIdsRec(itemId) {
            let that = this;
            if (matrixlib_1.ml.Item.parseRef(itemId).isFolder) {
                let treeFlat = [];
                $.each(globals_1.app.getChildrenIds(itemId), function (idx, id) {
                    treeFlat = treeFlat.concat(that.getChildrenIdsRec(id));
                });
                return treeFlat;
            }
            else {
                return [itemId];
            }
        }
        getParentId(itemId) {
            return this.dbConnection.getParentId(itemId);
        }
        // return a list of item, parent of item, parent of parent of item...
        getCategoryBreadcrumbs(category) {
            return this.dbConnection.getCategoryBreadcrumbs(category);
        }
        // return a list of item, parent of item, parent of parent of item...
        getBreadcrumbs(itemId) {
            return this.dbConnection.getBreadcrumbs(itemId);
        }
        /* set style of item / folder
            computeFolder: 0=look (folder style from lookup)
            computeFolder: 1=all (all children in folder have style: folder has style)
            computeFolder: 2=any (any of the children has style: folder has style) */
        setStyle(itemIds, style, computeFolder) {
            return this.dbConnection.setStyle(itemIds, style, computeFolder);
        }
        getRootOfType(category) {
            return this.dbConnection.getRootOfType(category);
        }
        startReportAsync(itemId, reportOptions) {
            return this.dbConnection.startReportAsync(itemId, reportOptions);
        }
        canLaunchReport() {
            var res = $.Deferred();
            this.dbConnection.canLaunchReport().done(function (result) {
                res.resolve(result.runningJobs <= result.maxRunningJobs);
            }).fail(function () {
                res.resolve(false);
            });
            return res;
        }
        startCreateDocumentAsync(itemId, reportOptions) {
            return this.dbConnection.startCreateDocumentAsync(itemId, reportOptions);
        }
        getReportDetails(jobId) {
            return this.dbConnection.getReportDetails(jobId);
        }
        compareHTML(compareParams) {
            return this.dbConnection.compareHTML(compareParams);
        }
        isFolder(itemId) {
            return this.dbConnection.isFolder(itemId);
        }
        getItemTitle(itemId, display) {
            let title = this.dbConnection.getItemTitle(itemId);
            return display ? matrixlib_1.ml.UI.lt.forUI(title, 0) : title;
        }
        download(jobId, file, param) {
            this.dbConnection.download(jobId, file, param);
        }
        downloadFromUrl(url, param) {
            this.dbConnection.downloadFromUrl(url, param);
        }
        downloadInMemory(jobId, file, dataType) {
            return this.dbConnection.downloadInMemory(jobId, file, dataType);
        }
        downloadInMemoryFromUrl(url) {
            return this.dbConnection.downloadInMemoryFromUrl(url);
        }
        searchAsync(term, filter, ignoreFilters, fieldList, crossProject, labels, down, up, treeOrder) {
            return this.dbConnection.searchAsync(term, filter, ignoreFilters, fieldList, crossProject, labels, down, up, treeOrder);
        }
        searchAsyncMinimalOutput(term, filter, ignoreFilters, crossProject) {
            return this.dbConnection.searchAsyncMinimalOutput(term, filter, ignoreFilters, crossProject);
        }
        updateItemInDBAsync(itemJson, auditAction, requireVersion) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.updateItemAsync(itemJson, comment, auditAction, requireVersion).done(function (result) {
                    MainTree_1.NavigationPanel.update(itemJson);
                    res.resolve(result);
                }).fail(function () {
                    // MATRIX-3815
                    res.reject("saving failed");
                });
            }).fail(function () {
                // rien a fair 
                res.reject("user cancelled");
            });
            return res;
        }
        async getItemFromDBAsync(itemId) {
            let type = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (!type || globals_1.globalMatrix.ItemConfig.getCategories(true).indexOf(type) == -1) {
                matrixlib_1.ml.Logger.error(`This is not possibly an item in this project: "${itemId}"!`);
                return;
            }
            return await this.getItemAsync(itemId);
        }
        async getFieldFromDBAsync(itemId, fieldName) {
            let type = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (!type || globals_1.globalMatrix.ItemConfig.getCategories(true).indexOf(type) == -1) {
                matrixlib_1.ml.Logger.error(`This is not possibly an item in this project: "${itemId}"!`);
                return;
            }
            let fieldId = globals_1.globalMatrix.ItemConfig.getFieldId(type, fieldName);
            if (!fieldId) {
                matrixlib_1.ml.Logger.error(`"${fieldName}" is not a field of this item "${itemId}"!`);
                return;
            }
            let item = await this.getItemAsync(itemId);
            return item[fieldId];
        }
        async setFieldInDBAsync(itemId, fieldName, value) {
            return this.setFieldsInDBAsync(itemId, [{ fieldName: fieldName, value: value }]);
        }
        async setFieldsInDBAsync(itemId, data) {
            let res = $.Deferred();
            let update = {
                id: itemId,
                onlyThoseFields: 1,
                onlyThoseLabels: 1
            };
            let type = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (!type) {
                matrixlib_1.ml.Logger.error(`This is not possibly an item in this project: "${itemId}"!`);
                res.reject();
                return res;
            }
            for (let s of data) {
                let fieldId = globals_1.globalMatrix.ItemConfig.getFieldId(type, s.fieldName);
                if (!fieldId) {
                    matrixlib_1.ml.Logger.error(`"${s.fieldName}" is not a field of this item "${itemId}"!`);
                    res.reject();
                    return res;
                }
                update["fx" + fieldId] = s.value;
            }
            return globals_1.app.updateItemInDBAsync(update, "edit");
        }
        createItemOfTypeAsync(category, itemJson, actions, parentId, dontFailOnCleanup) {
            let that = this;
            var res = $.Deferred();
            itemJson.type = category;
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.createItemAsync(itemJson, comment, actions, parentId, dontFailOnCleanup).done(function (result) {
                    // verify if new item needs to be filtered in tree
                    if (new index_1.LabelTools().isFiltered(category, itemJson.labels)) {
                        that.dbConnection.setHiddenLink(result.item.id, 1);
                    }
                    // show it in tree
                    that.insertInTree(result);
                    res.resolve(result);
                });
            }).fail(function () {
                // rien a fair 
                res.reject("user cancelled");
            });
            return res;
        }
        restoreItemAsync(itemId, title, version) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.restoreItemAsync(itemId, title, version, comment).done(function (result) {
                    if (result) {
                        var itemJson = {
                            id: itemId,
                            title: title,
                            type: matrixlib_1.ml.Item.parseRef(itemId).type
                        };
                        var newItem = {
                            parent: result.response.newParent,
                            position: result.response.newOrder,
                            item: itemJson
                        };
                        if (result.version) {
                            MainTree_1.NavigationPanel.update(itemJson);
                            that.renderItem();
                        }
                        else {
                            that.insertInTree(newItem);
                        }
                    }
                    res.resolve(result);
                });
            }).fail(function () {
                // rien a fair 
                res.reject();
            });
            return res;
        }
        deleteItem(itemId) {
            let res = $.Deferred();
            let that = this;
            if (this.dbConnection.hasChildren(itemId)) {
                // MATRIX-920 Allow to delete non-empty folders
                this.verifyNoLockedItems(itemId).done(function () {
                    window.setTimeout(function () {
                        matrixlib_1.ml.UI.showConfirm(7, { title: "The folder is not empty! <b>Delete anyway?</b>", ok: "Delete" }, function () {
                            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                                that.dbConnection.deleteItemAsync(itemId, comment, true).done(function (parent) {
                                    that.removedFromTree(itemId, parent);
                                    res.resolve();
                                }).fail(function () {
                                    res.reject();
                                });
                            }).fail(function () {
                                res.reject();
                                // rien a fair 
                            });
                        }, function () {
                            res.reject();
                        });
                    }, 1000);
                }).fail(function () {
                    res.reject();
                });
                return res;
            }
            if (globals_1.matrixApplicationUI.lastMainItemForm && this._needsSave) {
                matrixlib_1.ml.UI.showError("Item was modifed.", "Save item first or cancel changes.");
                res.reject();
                return res;
            }
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.deleteItemAsync(itemId, comment, false).done(function (parent) {
                    that.removedFromTree(itemId, parent);
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        verifyNoLockedItems(folderId) {
            let res = $.Deferred();
            // check if there are any locks
            let ll = globals_1.globalMatrix.ItemConfig.getLabelLockConfig();
            if (!ll || !ll.locks || ll.locks.length == 0) {
                res.resolve();
                return res;
            }
            // create a list of locking labels
            let locks = ll.locks.map(function (lock) { return lock.label; });
            this.getNeedlesAsync("folderm=" + folderId, false, false, "", true, true).done(function (results) {
                let itemsWithLocks = [];
                $.each(results, function (idx, result) {
                    if (result.labels.filter(function (label) { return locks.indexOf(label) != -1; }).length > 0) {
                        itemsWithLocks.push(result.id);
                    }
                });
                if (itemsWithLocks.length) {
                    matrixlib_1.ml.UI.showError("Deleted failed", "Some of the items are locked. Please unlock before deleting. Item(s) with locks: " + itemsWithLocks.join(","));
                    res.reject();
                }
                else {
                    res.resolve();
                }
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        uploadFileProjectAsync(file, progress) {
            return this.dbConnection.uploadFileProjectAsync(file, progress);
        }
        fetchFileAsync(url, progress) {
            return this.dbConnection.fetchFileAsync(url, progress);
        }
        resizeItem(force) {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                globals_1.matrixApplicationUI.lastMainItemForm.resizeItem(force);
            }
        }
        itemChanged(needsSave) {
            this._needsSave = needsSave;
            this.resizeItem();
            globals_1.matrixApplicationUI.updateMainUI();
        }
        // this is called after an item has been reloaded and the rendering must be updated
        updateItem(newItem) {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                globals_1.matrixApplicationUI.lastMainItemForm.updateItem(newItem);
            }
        }
        // sets a value of a field, the field must exist and have a setValue function
        setFieldValue(fieldId, newValue) {
            globals_1.matrixApplicationUI.lastMainItemForm.setFieldValue(fieldId, newValue);
        }
        // get value from current UI
        getFieldValue(fieldId) {
            return globals_1.matrixApplicationUI.lastMainItemForm.getFieldValue(fieldId);
        }
        getCurrentTitle() {
            return globals_1.matrixApplicationUI.lastMainItemForm.getCurrentTitle();
        }
        isConfigApp() {
            return false;
        }
        addDownLinkAsync(fromId, toId) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.addDownLinkAsync(fromId, toId, comment).done(function () {
                    that.refreshUIAsync(fromId, toId);
                    res.resolve();
                }).fail(function (jqxhr, textStatus, error) {
                    if (jqxhr.responseText.indexOf("This link already exists") > -1) {
                        // not really a failure so ignore
                        res.resolve();
                    }
                    else {
                        res.reject(jqxhr, textStatus, error);
                    }
                });
            }).fail(function () {
                res.reject("user cancelled");
            });
            return res;
        }
        removeDownLinkAsync(fromId, toId) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.removeDownLinkAsync(fromId, toId, comment).done(function () {
                    that.refreshUIAsync(fromId, toId);
                    res.resolve();
                    /*
                    WorkflowEngine.applyCommentAsync(fromId, "removedownlink|" + toId, comment);
                    */
                }).fail(function () {
                    res.reject();
                });
            }).fail(function () {
                // rien a fair 
                res.reject("user cancelled");
            });
            return res;
        }
        setSettingJSON(key, valueJSON) {
            return this.dbConnection.setSettingJSON(key, valueJSON);
        }
        readSettingJSONAsync(key, otherProject, noRetry) {
            return this.dbConnection.readSettingJSONAsync(key, otherProject, noRetry);
        }
        setSettingCustomerJSON(key, valueJSON) {
            return this.dbConnection.setSettingCustomerJSON(key, valueJSON);
        }
        readSettingCustomerJSONAsync(key) {
            return this.dbConnection.readSettingCustomerJSONAsync(key);
        }
        // *********************************************
        // manage references either from up to 1.6 category params
        // or 1.6 and later json setting
        // 
        // 
        /*  "rules": [
         {"category": "MREQ",
         "down_rules": [
         {
         "rule":"must_have",
         "any_of": [ "FREQ", "TREQ" ]
         },
         {
         "rule":"can_have",
         "any_of": [ "UC" ]
         },
         {
         "rule":"can_have",
         "any_of": [ "TC" ]
         }]
         */
        // *********************************************
        getMissingUpLinks(item) {
            var upMissing = [];
            var ulTypes = globals_1.globalMatrix.ItemConfig.getLinkTypes(item.type, false, true);
            for (var ulidx = 0; ulidx < ulTypes.length; ulidx++) {
                var missing = true;
                for (var idx = 0; idx < item.upLinks.length; idx++) {
                    if (item.upLinks[idx].to.indexOf(ulTypes[ulidx] + "-") === 0) {
                        missing = false;
                    }
                }
                if (missing) {
                    upMissing.push(ulTypes[ulidx]);
                }
            }
            return upMissing;
        }
        // check is a required uplink is missing
        isUpLinkMissing(item) {
            var result = this.evaluateTraceRule(item, false);
            if (result) {
                return !result.valid;
            }
            return this.getMissingUpLinks(item).length > 0;
        }
        getMissingDownLinks(item) {
            var result = this.evaluateTraceRule(item, true);
            if (result) {
                return result.missingMustHaveCategories;
            }
            var downMissing = [];
            var dlTypes = globals_1.globalMatrix.ItemConfig.getDownLinkTypes(item.type, true);
            for (var dlidx = 0; dlidx < dlTypes.length; dlidx++) {
                var missing = true;
                for (var idx = 0; idx < item.downLinks.length; idx++) {
                    if (item.downLinks[idx].to.indexOf(dlTypes[dlidx] + "-") === 0) {
                        missing = false;
                    }
                }
                if (missing) {
                    downMissing.push(dlTypes[dlidx]);
                }
            }
            return downMissing;
        }
        // return a list of required and optional downlinks
        getLinkCategories(item, ctrlParameter) {
            var result = this.evaluateTraceRule(item, true);
            if (result) {
                var resultLinks = [];
                var links = [];
                $.each(result.mustHaveCategories, function (catIdx, cat) {
                    if (links.indexOf(cat) === -1) {
                        links.push(cat);
                        resultLinks.push({
                            name: globals_1.globalMatrix.ItemConfig.getCategoryLabel(cat),
                            required: true,
                            type: cat
                        });
                    }
                });
                $.each(result.canHaveCategories, function (catIdx, cat) {
                    if (links.indexOf(cat) === -1) {
                        links.push(cat);
                        resultLinks.push({
                            name: globals_1.globalMatrix.ItemConfig.getCategoryLabel(cat),
                            required: false,
                            type: cat
                        });
                    }
                });
                return resultLinks;
            }
            // legacy
            return ctrlParameter.parameter.linkTypes ? ctrlParameter.parameter.linkTypes : [];
        }
        isDownLinkMissing(item) {
            var result = this.evaluateTraceRule(item, true);
            if (result) {
                return !result.valid;
            }
            return this.getMissingDownLinks(item).length > 0;
        }
        // returns true if any down or uplink is outdated
        isAnyLinkOutdated(item) {
            var resultDown = this.evaluateTraceRule(item, true);
            if (resultDown) {
                var resultUp = this.evaluateTraceRule(item, false);
                return resultDown.outdatedReferences.length + resultUp.outdatedReferences.length > 0;
            }
            var itemDate = new Date(item.modDate);
            for (var idx = 0; idx < item.downLinks.length; idx++) {
                var refDate = new Date(item.downLinks[idx].modDate);
                if (itemDate > refDate) {
                    return true;
                }
            }
            for (var idx = 0; idx < item.upLinks.length; idx++) {
                var refDate = new Date(item.upLinks[idx].modDate);
                if (itemDate < refDate) {
                    return true;
                }
            }
            return false;
        }
        hasLinks(item) {
            var result = this.evaluateTraceRule(item, false);
            if (result) {
                if (result.canHaveCategories.length > 0)
                    return true;
                if (result.mustHaveCategories.length > 0)
                    return true;
                result = this.evaluateTraceRule(item, true);
                if (result.canHaveCategories.length > 0)
                    return true;
                if (result.mustHaveCategories.length > 0)
                    return true;
                // todo ... maybe manage in 
                if (item.type === "XTC" || (PluginManagerDocuments_1.mDHF && PluginManagerDocuments_1.mDHF.isSignedType(item.type))) {
                    // special case
                    return true;
                }
                return false;
            }
            if (globals_1.globalMatrix.ItemConfig.getDownLinkTypes(item.type, false).length > 0) {
                return true;
            }
            if (globals_1.globalMatrix.ItemConfig.getDownLinkTypes(item.type, true).length > 0) {
                return true;
            }
            if (globals_1.globalMatrix.ItemConfig.getUpLinkTypes(item.type, false).length > 0) {
                return true;
            }
            if (globals_1.globalMatrix.ItemConfig.getUpLinkTypes(item.type, true).length > 0) {
                return true;
            }
            if (item.type === "XTC" || (PluginManagerDocuments_1.mDHF && PluginManagerDocuments_1.mDHF.isSignedType(item.type))) {
                // special case
                return true;
            }
            return false;
        }
        isHiddenLink(itemId) {
            return this.dbConnection.isHiddenLink(itemId);
        }
        setHiddenLink(itemId, hidden) {
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp())
                return;
            this.dbConnection.setHiddenLink(itemId, hidden);
            MainTree_1.NavigationPanel.updateItemIsUnselected(itemId, hidden !== 0);
        }
        // *********************************************
        // calls from outer UI 
        // *********************************************
        saveAsync(sendUnEdit) {
            let that = this;
            var res = $.Deferred();
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                globals_1.matrixSession.updateWatchItemVersion(globals_1.app.getCurrentItemId(), -1);
                globals_1.matrixApplicationUI.lastMainItemForm.saveAsync(null, null).done(function (result) {
                    globals_1.matrixSession.updateWatchItemVersion(result.id, result.maxVersion);
                    if (sendUnEdit) {
                        globals_1.matrixSession.pushMessages.unEditItem();
                    }
                    that.setHiddenLink(result.id, result.isUnselected);
                    // that will send a new watching message after the unEdit above
                    that.renderItem(result);
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }
            else {
                res.resolve();
            }
            return res;
        }
        // this is brutal, it just cancels all edits and set's the item to readonly
        // happens at start of download
        forceReadonly(itemId) {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                this._needsSave = false;
                globals_1.matrixApplicationUI.forceReadonly(itemId);
            }
        }
        cancel() {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                this.renderItem(null);
            }
        }
        // this is called if two users watches the same item, one edits and saves it... 
        someOneElseChanged() {
            let that = this;
            if (this.waitingForEditRights) {
                matrixlib_1.ml.UI.closeConfirmSpinningWait();
            }
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                if (this.needsSave()) {
                    matrixlib_1.ml.UI.showConfirm(-1, { title: "Someone just changed the item.", ok: "Update to latest", nok: "Ignore and merge later" }, () => {
                        // reload the item
                        that.renderItem(null);
                    }, () => {
                        // do nothing... user will pay the price later
                    });
                }
                else {
                    // the item changed, time to reload the new version
                    this.renderItem(null);
                }
            }
        }
        someOneIsChangingTheItem() {
            let that = this;
            if (globals_1.matrixApplicationUI.lastMainItemForm && !this.waitingForEditRights) {
                if (this.needsSave()) {
                    matrixlib_1.ml.UI.showConfirm(-1, { title: "Someone else is changing this item.", ok: "Update to latest", nok: "Wait and merge" }, () => {
                        // reload the item
                        that.renderItem(null);
                    }, () => {
                        that.waitForEditRights();
                    });
                }
                else {
                    // the item changed, time to reload the new version
                    this.renderItem(null);
                }
            }
        }
        waitForEditRights() {
            let that = this;
            this.waitingForEditRights = true;
            matrixlib_1.ml.UI.showConfirm(-1, { title: matrixlib_1.ml.UI.getSpinningWait("Waiting for other user to stop editing").html(),
                ok: "Cancel" }, () => {
                // reload the item
                that.waitingForEditRights = false;
                that.renderItem(null);
            }, () => { });
        }
        // someone else started to change
        someOneElseIsChanging(watcherInfo) {
            let that = this;
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                if (this.needsSave()) {
                    // this should not happen
                    matrixlib_1.ml.UI.showConfirm(-1, { title: watcherInfo.editor.user + " started editing the item", ok: "Cancel my Edit", nok: "Edit and merge later" }, () => {
                        // reload the item
                        that.updateItemDisplay(watcherInfo);
                    }, () => {
                        // do nothing... user will pay the price later
                    });
                }
                else {
                    // someone else started to edit the item, make it readonly for this user to avoid conflicts
                    this.updateItemDisplay(watcherInfo);
                }
            }
        }
        someOneElseWasChanging(watcherInfo) {
            let that = this;
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                if (this.needsSave()) {
                    if (that.freezeDuringSave) {
                        // this is a race condition we can live with
                        return;
                    }
                    // this should not happen
                    matrixlib_1.ml.UI.showConfirm(-1, { title: " Someone else changed the item in the meantime. You won't be able to save!", ok: "Load updated item", nok: "Do not yet update" }, () => {
                        // reload the item
                        that.cancel();
                    }, () => {
                        // do nothing... user will pay the price later
                    });
                }
                else {
                    // someone else started to edit the item, make it readonly for this user to avoid conflicts
                    this.updateItemDisplay(watcherInfo);
                }
            }
        }
        // someone else stopped editing the same item, but apparently canceled the edit, or session timed out
        someOneElseStoppedEditing(watcherInfo, previousWatcherInfo) {
            matrixlib_1.ml.Logger.log("info", previousWatcherInfo.editor.user + " stopped editing");
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                if (this.needsSave()) {
                    matrixlib_1.ml.Logger.log("info", "user was also editing nothing I can do");
                    // just let the user do it thing it might cause issues to save later
                    // but nothing we can do
                }
                else {
                    // reload the latest version of the item, and make sure it writeable (if user has write access)
                    // this is not really necessary, since the item should not have changed, so we could also just switch the user from
                    // readonly to write (if needed)
                    this.updateItemDisplay(watcherInfo);
                }
            }
        }
        // just update the list of items
        updateItemViewers(watcherInfo) {
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                this.updateItemDisplay(watcherInfo);
            }
        }
        updateItemDisplay(watcherInfo) {
            globals_1.matrixApplicationUI.updateControl(watcherInfo, this.itemChanged.bind(this));
        }
        getVersion() {
            return $("meta[name='mx-version']").attr('content');
        }
        getVersionQualifier() {
            return $("meta[name='mx-version-qualifier']").attr('content');
        }
        getNeedsSave() {
            return this._needsSave;
        }
        getType(itemId) {
            return this.dbConnection.getType(itemId);
        }
        getAvailableReportsAsync() {
            return this.dbConnection.getAvailableReportsAsync();
        }
        getDeletedItemsAsync(insertInList, progress, deleteLog, startAt) {
            let that = this;
            var res = $.Deferred();
            if (typeof startAt === 'undefined') {
                startAt = 0;
            }
            if (typeof deleteLog === 'undefined') {
                deleteLog = [];
            }
            var cats = globals_1.globalMatrix.ItemConfig.getCategories();
            this.dbConnection.getAuditLogAsync(startAt, 1000, { deleteOnly: "yes" }).done(function (result) {
                progress.apply(that, [(startAt + result.audit.length) * 100 / result.totalResults]);
                if (result) {
                    for (var idx = 0; idx < result.audit.length; idx++) {
                        if (result.audit[idx].action === "delete" && result.audit[idx].itemBefore) {
                            var ir = matrixlib_1.ml.Item.parseRef(result.audit[idx].itemBefore.itemOrFolderRef);
                            var itemId = ir.id;
                            var version = ir.version;
                            if (!ir.isFolder && cats.indexOf(ir.type) !== -1) {
                                // verify that the id is not in the current project (as it was undeleted) or already in the list of deleted objects
                                var found = false;
                                for (var di = 0; di < deleteLog.length; di++) {
                                    if (deleteLog[di].id == itemId) {
                                        found = true;
                                    }
                                }
                                found = found || that.dbConnection.doesExist(itemId);
                                if (!found) {
                                    var item = {
                                        action: 'delete',
                                        id: itemId,
                                        title: result.audit[idx].itemBefore.title,
                                        user: result.audit[idx].userLogin,
                                        date: result.audit[idx].dateTime,
                                        dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                        comment: result.audit[idx].reason,
                                        version: version,
                                        fullVersion: result.audit[idx].itemBefore.itemOrFolderRef,
                                        auditId: result.audit[idx].auditId,
                                        tags: result.audit[idx].tags
                                    };
                                    insertInList.apply(that, [item]);
                                    deleteLog.push(item);
                                }
                            }
                        }
                        if (result.audit[idx].action === "merge" && result.audit[idx].itemsDeletedByMerge) {
                            for (let idbm of result.audit[idx].itemsDeletedByMerge) {
                                var ir = matrixlib_1.ml.Item.parseRef(idbm.ref);
                                var itemId = ir.id;
                                var version = ir.version;
                                if (!ir.isFolder && cats.indexOf(ir.type) !== -1) {
                                    // verify that the id is not in the current project (as it was undeleted) or already in the list of deleted objects
                                    var found = false;
                                    for (var di = 0; di < deleteLog.length; di++) {
                                        if (deleteLog[di].id == itemId) {
                                            found = true;
                                        }
                                    }
                                    found = found || that.dbConnection.doesExist(itemId);
                                    if (!found) {
                                        var item = {
                                            action: 'delete',
                                            id: itemId,
                                            title: idbm.title,
                                            user: result.audit[idx].userLogin,
                                            date: result.audit[idx].dateTime,
                                            dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                            comment: result.audit[idx].reason,
                                            version: version,
                                            fullVersion: idbm.ref,
                                            auditId: result.audit[idx].auditId,
                                            tags: result.audit[idx].tags
                                        };
                                        insertInList.apply(that, [item]);
                                        deleteLog.push(item);
                                    }
                                }
                            }
                        }
                    }
                    if (result.totalResults > startAt + result.audit.length) {
                        that.getDeletedItemsAsync(insertInList, progress, deleteLog, startAt + result.audit.length).done(function (recResult) {
                            res.resolve();
                        });
                    }
                    else {
                        res.resolve();
                    }
                }
                else {
                    res.resolve();
                }
            });
            return res;
        }
        getActivityAsync(insertInList, startAt, count, auditIdMin, auditIdMax) {
            let that = this;
            var res = $.Deferred();
            var cats = globals_1.globalMatrix.ItemConfig.getCategories();
            var param = {};
            if (auditIdMin) {
                param.auditIdMin = auditIdMin;
            }
            if (auditIdMax) {
                param.auditIdMax = auditIdMax;
            }
            param.include = globals_1.globalMatrix.historyFilter;
            this.dbConnection.getAuditLogAsync(startAt, count, param).done(function (result) {
                for (var idx = 0; idx < result.audit.length; idx++) {
                    var itemDetails = null;
                    var addedLink = null;
                    var removedLink = null;
                    switch (result.audit[idx].action) {
                        case "delete":
                            if (result.audit[idx].entity === "item_link") {
                                removedLink = result.audit[idx].itemDown.itemOrFolderRef;
                            }
                            else {
                                itemDetails = result.audit[idx].itemBefore;
                            }
                            break;
                        case "add":
                            if (result.audit[idx].entity === "item_link") {
                                if (!result.audit[idx].itemDown) {
                                    matrixlib_1.ml.Logger.log("warning", "add item_link but no details");
                                    break;
                                }
                                addedLink = result.audit[idx].itemDown.itemOrFolderRef;
                            }
                            else {
                                itemDetails = result.audit[idx].itemAfter;
                            }
                            break;
                        case "undelete":
                        case "edit":
                        case "reviewed": // reviewed is used by review labels
                        case "execute":
                        case "signature":
                        case "touch":
                            itemDetails = result.audit[idx].itemAfter;
                            break;
                        case "report":
                            // we simulate the ItemAfter object for print jobs, that is not generated by the API anymore
                            itemDetails = new Object();
                            itemDetails['job'] = result.audit[idx].reportJobId;
                            itemDetails['itemOrFolderRef'] = result.audit[idx].reportRef + "-v0";
                            itemDetails['title'] = result.audit[idx].reportTitle;
                            break;
                        case "move":
                            // drag and drop of item
                            // I don't get the before / after so I just ignore it 
                            break;
                        case "merge":
                            // branch was merged 
                            if (result.audit[idx].entity == "begin_merge") {
                                // that's a "fake" change just before the merge
                            }
                            else {
                                let merge = {
                                    action: result.audit[idx].action,
                                    id: null,
                                    title: null,
                                    user: result.audit[idx].userLogin,
                                    date: result.audit[idx].dateTime,
                                    dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                    comment: result.audit[idx].reason,
                                    version: null,
                                    fullVersion: null,
                                    job: null,
                                    reason: result.audit[idx].reason,
                                    tags: result.audit[idx].tags,
                                    auditId: result.audit[idx].auditId
                                };
                                insertInList.apply(that, [merge]);
                            }
                            break;
                        case "report udpate":
                            // this is a change to a doc's structure: changed in 1.9 to use just normal edit
                            //we just ignore it
                            break;
                        case "udpate":
                            // this is a change to a project setting
                            //we just ignore it
                            break;
                        default:
                            matrixlib_1.ml.Logger.log("warning", "ACTIVITY: " + result.audit[idx].action);
                    }
                    if (itemDetails) {
                        let ir = matrixlib_1.ml.Item.parseRef(itemDetails.itemOrFolderRef);
                        if (cats.indexOf(ir.type) !== -1) {
                            let item = {
                                action: result.audit[idx].action,
                                id: ir.id,
                                title: itemDetails.title,
                                user: result.audit[idx].userLogin,
                                date: result.audit[idx].dateTime,
                                dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                comment: result.audit[idx].reason,
                                version: ir.version,
                                fullVersion: itemDetails.itemOrFolderRef,
                                job: itemDetails['job'],
                                reason: result.audit[idx].reason,
                                tags: result.audit[idx].tags,
                                auditId: result.audit[idx].auditId
                            };
                            insertInList.apply(that, [item]);
                        }
                    }
                    else if (addedLink) {
                        insertInList.apply(that, [null, null, null, {
                                added: true,
                                fromId: result.audit[idx].itemUp.itemOrFolderRef,
                                toId: addedLink,
                                date: result.audit[idx].dateTime,
                                dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                comment: result.audit[idx].reason,
                                user: result.audit[idx].userLogin
                            }]);
                    }
                    else if (removedLink) {
                        insertInList.apply(that, [null, null, null, {
                                added: false,
                                fromId: result.audit[idx].itemUp.itemOrFolderRef,
                                toId: removedLink,
                                date: result.audit[idx].dateTime,
                                dateUserFormat: result.audit[idx].dateTimeUserFormat,
                                comment: result.audit[idx].reason,
                                user: result.audit[idx].userLogin
                            }]);
                    }
                }
                res.resolve(result.totalResults);
            });
            return res;
        }
        ;
        // *********************************************
        // calls from tree
        // *********************************************
        canNavigateAwayAsync() {
            let that = this;
            var res = $.Deferred();
            if (globals_1.matrixApplicationUI.lastMainItemForm && this._needsSave) {
                // get errors is comment needs ticked id
                var commentNeedsTicket = [];
                commentNeedsTicket = Tasks_1.mTasks ? Tasks_1.mTasks.evaluateTaskIds(globals_1.matrixSession.getComment()) : [];
                if (localStorage.getItem('idAutoCommit') === 'true' &&
                    !(this.commentRequired() && globals_1.matrixSession.getComment() == "") && commentNeedsTicket.length === 0) {
                    that.freezeDuringSave = true;
                    globals_1.matrixApplicationUI.lastMainItemForm.saveAsync(null, null).done(function (result) {
                        that.setHiddenLink(result.id, result.isUnselected);
                        that._needsSave = false;
                        res.resolve(); // no problem, changes were saved automatically
                    }).fail(function (error) {
                        matrixlib_1.ml.UI.showError("Save failed!", error);
                        res.reject();
                    }).always(function () {
                        that.freezeDuringSave = false;
                    });
                }
                else {
                    if (localStorage.getItem('idAutoCommit') === 'true') {
                        if (commentNeedsTicket.length > 0) {
                            matrixlib_1.ml.UI.showError("You need to save first! Enter a session comment with a ticket id", commentNeedsTicket.join(" "));
                        }
                        else {
                            matrixlib_1.ml.UI.showError("You need to save first!", "Enter a session comment to use autosave");
                        }
                    }
                    else {
                        matrixlib_1.ml.UI.showError("You need to save first!", "Tip: enable autosave");
                    }
                    res.reject();
                }
            }
            else {
                res.resolve(); // no changes -> no problem
            }
            return res;
        }
        ;
        treeSelectionChangeAsync(newItemId) {
            let that = this;
            var res = $.Deferred();
            if (this.freezeDuringSave) {
                // we are saving... just ignore the click
                res.reject();
                return res;
            }
            this.canNavigateAwayAsync().done(function () {
                that._itemId = newItemId;
                that.renderItem();
                that._needsSave = false;
                // select in tree but do not trigger a reload
                MainTree_1.NavigationPanel.select(newItemId);
                // Automatically switch to item when mobileLayout
                let mobileLayout = localStorage.getItem("mobileLayout");
                if (mobileLayout && mobileLayout != "" && that._itemId.indexOf("F-") != 0) {
                    localStorage.setItem("mobileLayout", "0");
                    window.applyResponsiveView();
                }
                res.resolve();
            }).fail(function () {
                // select in tree but do not trigger a reload
                window.setTimeout(function () {
                    MainTree_1.NavigationPanel.select(that.getCurrentItemId());
                }, 1);
                res.reject();
            });
            return res;
        }
        ;
        moveItemsAsync(itemIds, newFolder, newPosition, useComment) {
            let that = this;
            var res = $.Deferred();
            if (useComment) {
                that.dbConnection.moveItemsAsync(itemIds, newFolder, newPosition, useComment).done(function (result) {
                    that.updateMaxVersion(itemIds).always(function () {
                        res.resolve();
                    });
                }).fail(function () {
                    res.reject();
                });
            }
            else {
                globals_1.matrixSession.getCommentAsync().done(function (comment) {
                    that.dbConnection.moveItemsAsync(itemIds, newFolder, newPosition, comment).done(function (result) {
                        that.updateMaxVersion(itemIds).always(function () {
                            res.resolve();
                        });
                    }).fail(function () {
                        res.reject();
                    });
                }).fail(function () {
                    res.reject();
                });
            }
            return res;
        }
        ;
        // MATRIX-3728 e.g. after an item move, the item's history count might be increased 
        // let's update it to avoid merge dialog when editing after
        updateMaxVersion(itemId) {
            let res = $.Deferred();
            if (globals_1.app.getCurrentItemId() != itemId) {
                // nothing to do
                res.reject();
                return res;
            }
            globals_1.app.getItemAsync(itemId, undefined, true, true).done(function (updatedItem) {
                globals_1.matrixSession.updateWatchItemVersion(itemId, updatedItem.maxVersion);
                res.resolve();
            }).fail(function () {
                // nothing i wan't to do...
                res.reject();
            });
            return res;
        }
        // *********************************************
        // calls from database to update tree or item
        // *********************************************
        removedFromTree(itemId, parentId) {
            // called after an item has been deleted
            // make sure trees get informed (and remove it)
            MainTree_1.NavigationPanel.remove(itemId);
            // select the parent
            if (this._itemId === itemId) {
                this._itemId = parentId;
                this.treeSelectionChangeAsync(this._itemId).done(function () {
                }).fail(function () {
                });
            }
        }
        insertInTree(newItem) {
            if (newItem.item.children) {
                // 'inherit' folder icon from parent
                newItem.item.icon = this.dbConnection.getIcon(newItem.parent);
            }
            // make sure trees get informed)
            MainTree_1.NavigationPanel.insertInTree(newItem);
        }
        // replaces the target, a child inside the target or creates a new child with source
        copyFrom(target, source) {
            if (this.dbConnection.copyFrom(target, source)) {
                // make sure trees get informed
                MainTree_1.NavigationPanel.insertUpdateTreeRec(target, source);
            }
        }
        updateCache(newItem) {
            this.dbConnection.updateCache(newItem);
        }
        // *********************************************
        // helper functions
        // *********************************************
        createItemUrl(itemId, crossProject) {
            return globals_1.globalMatrix.matrixBaseUrl + "/" + (crossProject ? crossProject : globals_1.matrixSession.getProject()) + (itemId ? ("/" + itemId) : "") + window.location.search;
        }
        renderItem(cachedItem) {
            if (!globals_1.matrixSession.duringBrowserNavigation && this.lastState !== this._itemId) {
                this.lastState = this._itemId;
                window.history.pushState(null, null, this.createItemUrl(this._itemId));
            }
            globals_1.globalMatrix.projectStorage.setItem('SessionLastItem', this._itemId);
            var folderType = this.dbConnection.getType(this._itemId);
            globals_1.matrixApplicationUI.createControl(folderType, this._itemId, this.itemChanged.bind(this), cachedItem);
        }
        print() {
            window.print();
        }
        touchAsync(itemOrFolderId, depth) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.touchAsync(itemOrFolderId, depth, comment).done(function (result) {
                    that.renderItem();
                    res.resolve(result);
                }).fail(function (error) {
                    res.reject(error);
                });
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        // saves item, but instead of getting labels from ui, it uses the passed on values
        setLabels(newLabels) {
            let that = this;
            var res = $.Deferred();
            if (globals_1.matrixApplicationUI.lastMainItemForm) {
                globals_1.matrixApplicationUI.lastMainItemForm.saveAsync(null, "reviewed", newLabels).done(function (result) {
                    that.setHiddenLink(result.id, result.isUnselected);
                    that.renderItem(result);
                    res.resolve();
                }).fail(function () {
                    res.reject();
                });
            }
            else {
                res.resolve();
            }
            return res;
        }
        needsSave() {
            return this._needsSave;
        }
        signItemAsync(itemId, password, meaning) {
            let that = this;
            var res = $.Deferred();
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                that.dbConnection.signItemAsync(itemId, password, comment, meaning).done(function (result) {
                    res.resolve(result);
                }).fail(function (error) {
                    res.reject(error);
                });
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        checkPassword(password) {
            return this.dbConnection.checkPassword(password);
        }
        convertDocAsync(fileNo, targetDocumentFolder, useOriginal) {
            let that = this;
            var res = $.Deferred();
            that.dbConnection.convertDocAsync(fileNo, "import for conversion", targetDocumentFolder, useOriginal).done(function (result) {
                res.resolve(result);
            }).fail(function (error) {
                res.reject(error);
            });
            return res;
        }
        pingCurrentItem() {
            let that = this;
            // do not ping special items like -1,-2,-3 (virtual folders)
            if (this._itemId && this._itemId.indexOf("-") !== 0 && !matrixlib_1.ml.UI.widgetPluginsContainer.visible) {
                var type = this.dbConnection.getType(this._itemId);
                if (type[0] !== "_") {
                    // in case the type is a valid category get this setting (if not it will just return null, which is fine to)
                    let concurrentEdit = globals_1.globalMatrix.ItemConfig.getCategorySetting(type, "concurrentEdit");
                    if (concurrentEdit && concurrentEdit.disabled) {
                        // if concurrent editing is possible (warning the flag is kind of negated) no need to do something
                        return;
                    }
                    // don't ping special meta folders like _PROJECT
                    this.getItemAsync(this._itemId).done(function (item) {
                        that.updateItem(item);
                    });
                }
            }
        }
        getCurrentItemId() {
            return this._itemId;
        }
        ;
        /** sessions */
        commitChangeListAsync(changeList) {
            var res = $.Deferred();
            globals_1.matrixSession.startCommitTransaction();
            this.commitChangeListRec(changeList, 0).done(function () {
                globals_1.matrixSession.stopCommitTransaction();
                res.resolve();
            }).fail(function (error, stepsDone) {
                globals_1.matrixSession.stopCommitTransaction();
                res.reject(error, stepsDone);
            });
            return res;
        }
        /**
         *  product variations
         * */
        isMedical(strict) {
            if (globals_1.globalMatrix.matrixProduct.toLowerCase() === "medical") {
                return true;
            }
            if (strict) {
                return false;
            }
            return globals_1.globalMatrix.matrixProduct.toLowerCase() === "tachyscp";
        }
        commentRequired() {
            return this.isMedical();
        }
        touchToolAvailable(item) {
            if (item.cloneSource)
                return false;
            return this.canEditItem(item) && this.isMedical();
        }
        auditTrailAvailable() {
            return this.isMedical();
        }
        mailToolAvailable() {
            return this.isMedical();
        }
        postLogin(user) { }
        canDeleteItem(item) {
            if (!globals_1.matrixSession.isEditor() || !globals_1.globalMatrix.ItemConfig.canDelete(item.type)) {
                return false;
            }
            return true;
        }
        canViewItem(item) {
            return true;
        }
        canEditItem(item) {
            if (!globals_1.matrixSession.isEditor() || !globals_1.globalMatrix.ItemConfig.canEdit(item.type)) {
                return false;
            }
            return true;
        }
        canCreateItemType(category, folder) {
            if (!globals_1.matrixSession.isEditor() && !globals_1.globalMatrix.ItemConfig.canCreate(category)) {
                return false;
            }
            return true;
        }
        canDragDrop(category, id) {
            if (!globals_1.matrixSession.isEditor() || !globals_1.globalMatrix.ItemConfig.canMove(category)) {
                return false;
            }
            return true;
        }
        canSeeField(category, field) {
            return true;
        }
        canEditField(category, field) {
            return true;
        }
        refreshUIAsync(fromId, toId) {
            let that = this;
            clearTimeout(this.forceUIRefreshTimer);
            this.forceUIRefreshTimer = window.setTimeout(function () {
                // refresh - but only if an item is still selected...
                if (that._itemId === fromId || (toId && that._itemId === toId)) {
                    that.getItemAsync(that._itemId).done(function (result) {
                        that.updateItem(result);
                        PluginManager_1.plugins.updateItem(result);
                    });
                }
            }, 1000);
        }
        // return null if there is no project trace_config setting (project before 1.5, not upgraded)
        // if not return an jsob object with all trace information for the item
        evaluateTraceRule(item, checkDownRule) {
            var tc = globals_1.globalMatrix.ItemConfig.getTraceConfig();
            if (!tc) {
                return null;
            }
            var result = {
                valid: true,
                mustHaveCategories: [],
                canHaveCategories: [],
                exstingCategories: [],
                missingMustHaveCategories: [],
                missingCanHaveCategories: [],
                outdatedReferences: []
            };
            if (!item || !item.modDate) {
                // this can happen during item creation... no worries, we cannot create links
                return result;
            }
            var itemDate = new Date(item.modDate);
            // build a list of all existing up or downlink categories
            // and a list of all out dated references
            var existing = checkDownRule ? item.downLinks : item.upLinks;
            if (existing) {
                $.each(existing, function (idx, link) {
                    // list of existing categories
                    var cat = matrixlib_1.ml.Item.parseRef(link.to).type;
                    if (result.exstingCategories.indexOf(cat) === -1) {
                        result.exstingCategories.push(cat);
                    }
                    // list of outdated links
                    var refDate = new Date(link.modDate);
                    if ((checkDownRule && itemDate > refDate) || (!checkDownRule && itemDate < refDate)) {
                        result.outdatedReferences.push(link.to);
                    }
                });
            }
            // get the up/down rule from project setting
            var updown;
            $.each(tc.rules, function (ruleIdx, rule) {
                if (rule.category === item.type) {
                    updown = checkDownRule ? rule.down_rules : rule.up_rules;
                }
            });
            if (!updown) {
                // no rules.. results are complete: no mustHaveCategories, no canHaveCategories, missingCategories
                return result;
            }
            $.each(updown, function (updownIdx, updownRule) {
                if (updownRule.rule === "must_have" && updownRule.any_of) {
                    var hasMustHave = false;
                    $.each(updownRule.any_of, function (anyIdx, anyOf) {
                        // add to must have
                        if (result.mustHaveCategories.indexOf(anyOf) === -1) {
                            result.mustHaveCategories.push(anyOf);
                        }
                        // check if rule is followed
                        if (result.exstingCategories.indexOf(anyOf) !== -1) {
                            hasMustHave = true;
                        }
                    });
                    if (!hasMustHave) {
                        // problem: a must have rules is not followed
                        // add categories to missing categoires
                        $.each(updownRule.any_of, function (anyIdx, any) {
                            if (result.missingMustHaveCategories.indexOf(any) === -1) {
                                result.missingMustHaveCategories.push(any);
                            }
                        });
                        result.valid = false;
                    }
                }
                if (updownRule.rule === "can_have" && updownRule.any_of) {
                    var hasCanHave = false;
                    $.each(updownRule.any_of, function (anyIdx, anyOf) {
                        // add to can have
                        if (result.canHaveCategories.indexOf(anyOf) === -1) {
                            result.canHaveCategories.push(anyOf);
                        }
                        // check if rule is followed
                        if (result.exstingCategories.indexOf(anyOf) !== -1) {
                            hasCanHave = true;
                        }
                    });
                    if (!hasCanHave) {
                        // problem: a must have rules is not followed
                        // add categories to missing categoires
                        $.each(updownRule.any_of, function (anyIdx, anyOf) {
                            if (result.missingCanHaveCategories.indexOf(anyOf) === -1) {
                                result.missingCanHaveCategories.push(anyOf);
                            }
                        });
                    }
                }
            });
            return result;
        }
        commitChangeListRec(changeList, todo) {
            let that = this;
            var res = $.Deferred();
            if (todo >= changeList.length) {
                // all done!
                res.resolve(null, todo);
            }
            else {
                if (changeList[todo].action === 'removeLink') {
                    this.removeDownLinkAsync(changeList[todo].fromId, changeList[todo].toId).done(function () {
                        that.commitChangeListRec(changeList, todo + 1).done(function () {
                            res.resolve();
                        }).fail(function (error, done) {
                            res.reject(error, done);
                        });
                    }).fail(function () {
                        res.reject("Could not remove link from " + changeList[todo].fromId + " to " + changeList[todo].toId, todo);
                    });
                }
                else if (changeList[todo].action === 'addLink') {
                    this.addDownLinkAsync(changeList[todo].fromId, changeList[todo].toId).done(function () {
                        that.commitChangeListRec(changeList, todo + 1).done(function () {
                            res.resolve();
                        }).fail(function (error, done) {
                            res.reject(error, done);
                        });
                    }).fail(function (jqxhr, textStatus, error) {
                        res.reject("Could not add link from " + changeList[todo].fromId + " to " + changeList[todo].toId, todo);
                    });
                }
            }
            return res;
        }
        static getProjectIcon(customLogo, alternateValue = "") {
            if (customLogo && customLogo.indexOf("{") !== -1) {
                var rjs = matrixlib_1.ml.JSON.fromString(customLogo);
                if (rjs.status === 'ok') {
                    return rjs.value.logoId ? rjs.value.logoId : alternateValue;
                }
            }
            return alternateValue;
        }
        static getProjectLogo(customLogo) {
            var rjs = matrixlib_1.ml.JSON.fromString(customLogo);
            if (rjs.status === 'ok') {
                return rjs.value.fileId ? rjs.value.fileId : "";
            }
            else {
                return customLogo; // legacy
            }
        }
    }
    exports.MatrixReq = MatrixReq;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 60 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(61), __webpack_require__(62), __webpack_require__(1), __webpack_require__(21), __webpack_require__(63), __webpack_require__(39), __webpack_require__(32), __webpack_require__(29), __webpack_require__(64), __webpack_require__(13), __webpack_require__(3), __webpack_require__(54), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ProjectStorage_1, PushMessages_1, matrixlib_1, MainTree_1, TokenControl_1, UserControl_1, ProjectSettings_1, Notifications_1, ProjectStorageMobile_1, PluginManager_1, MatrixLibInterfaces_1, Tasks_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.MatrixSession = void 0;
    class MatrixSession {
        constructor() {
            this.quiet = false;
            this.CurrentUser = "";
            this.customerAdmin = false;
            this.superAdmin = false;
            this.duringBrowserNavigation = false;
            this.lastManualComment = "";
            this.myTodoCount = [];
            this.myTodos = [];
            this.customParams = {};
            let that = this;
            window.addEventListener("message", this.receiveMessage, false);
            this.licensedModules = [];
            this.quiet = typeof globals_1.globalMatrix.jiraPlugin !== "undefined";
            globals_1.matrixApplicationUI.updateMainUI(true);
            $.ajaxPrefilter(function (options) {
                if (!options.beforeSend) {
                    options.beforeSend = function (xhr) {
                        var csrfToken = that.getCsrfCookie();
                        xhr.setRequestHeader('x-csrf', csrfToken);
                    };
                }
            });
            this.tryReconnect().done(function () {
                // a session exists (e.g. F5 was pressed or a new url entered)
                // a list of project from this server is known and stored in ProjectList
                // the comment is the last one shown in the UI, should be reused in other tabs
                that.CurrentComment = localStorage.getItem("CurrentComment");
                that.updateUI(false);
            });
        }
        getCsrfCookie() {
            var csrfToken = ($).cookie("csrf"); // i put that in the call to get the latest cookie with each request (see B below)
            return csrfToken;
        }
        startCommitTransaction() {
            this.CommitTransaction = true;
            this.CommitTransactionComment = "";
            this.CommitTransactionCancelled = false;
        }
        stopCommitTransaction() {
            this.CommitTransaction = false;
            this.CommitTransactionComment = "";
            this.CommitTransactionCancelled = false;
        }
        getUser() {
            return this.CurrentUser;
        }
        setUser(login) {
            this.CurrentUser = login ? login.toLowerCase() : "";
        }
        setDateInfo(di) {
            this.dateInfo = di;
            matrixlib_1.ml.UI.DateTime.initDateTimeSettings();
        }
        getDateInfo() {
            return this.dateInfo;
        }
        setCustomerSettings(customerSettings) {
            let that = this;
            this.customerSettingsString = {};
            this.customerSettingsJSON = {};
            if (customerSettings) {
                $.each(customerSettings, function (idx, setting) {
                    that.customerSettingsString[setting.key] = setting.value;
                    if (setting.key !== "js_plugins" && setting.value && setting.value.indexOf('{') !== -1) {
                        // assume it a json
                        var val = matrixlib_1.ml.JSON.fromString(setting.value);
                        if (val.status === "ok") {
                            that.customerSettingsJSON[setting.key] = val.value;
                        }
                    }
                });
            }
        }
        setCustomerSettingJSON(s, setting) {
            this.customerSettingsJSON[s] = setting;
        }
        getCustomerSetting(s) {
            return this.customerSettingsString[s];
        }
        getCustomerSettingJSON(s, defaultValue) {
            return this.customerSettingsJSON[s] ? this.customerSettingsJSON[s] : defaultValue;
        }
        getMailSettings() {
            let projectMailConfig = globals_1.globalMatrix.ItemConfig.getMailConfig();
            let serverMailConfig = this.getCustomerSettingJSON(ProjectSettings_1.mailConfigSetting, { canned: {} });
            if (projectMailConfig != undefined && projectMailConfig.canned != undefined) {
                for (let key in projectMailConfig.canned) {
                    serverMailConfig.canned[key] = projectMailConfig.canned[key];
                }
            }
            if (projectMailConfig != undefined && projectMailConfig.defaultCC != undefined) {
                serverMailConfig.defaultCC = projectMailConfig.defaultCC;
            }
            return serverMailConfig;
        }
        getUISettings(defaultValues) {
            let ui = globals_1.matrixSession.getCustomerSettingJSON("ui", {});
            if (defaultValues) {
                $.each(defaultValues, function (key, defaultValue) {
                    if (ui[key] == undefined) {
                        ui[key] = defaultValue;
                    }
                });
            }
            return ui;
        }
        setUISetting(setting, value) {
            let that = this;
            let ui = globals_1.matrixSession.getCustomerSettingJSON("ui", {});
            ui[setting] = value;
            globals_1.app.setSettingCustomerJSON("ui", ui).done(function () {
                console.log("New setting");
                console.log(ui);
                that.customerSettingsJSON[setting] = ui;
            }).fail(function () {
                console.log("Error applying setting");
            });
        }
        showUISettings() {
            let ui = globals_1.matrixSession.getCustomerSettingJSON("ui", {});
            console.log(ui);
        }
        isEditor() {
            return globals_1.globalMatrix.ItemConfig.hasWriteAccess(this.getUser());
        }
        isCustomerAdmin() {
            return this.customerAdmin;
        }
        isSuperAdmin() {
            return this.superAdmin;
        }
        // super admin or customer admin
        isAdmin() {
            return this.isCustomerAdmin() || this.isSuperAdmin();
        }
        getProject() {
            return this.CurrentProject;
        }
        setProject(projectId) {
            // this should (only be used by JIRA plugin)
            this.CurrentProject = projectId;
        }
        getCommentAsync() {
            let that = this;
            var res = $.Deferred();
            // get errors is comment needs ticked id
            var commentNeedsTicket = Tasks_1.mTasks ? Tasks_1.mTasks.evaluateTaskIds(globals_1.matrixSession.getComment()) : [];
            if (this.CurrentComment && commentNeedsTicket.length === 0) {
                res.resolve(this.CurrentComment);
            }
            else if (this.CommitTransaction && this.CommitTransactionComment) {
                res.resolve(this.CommitTransactionComment);
            }
            else if (!globals_1.app.commentRequired()) {
                res.resolve("no comment specified");
            }
            else {
                if (commentNeedsTicket.length > 0) {
                    matrixlib_1.ml.UI.showError("You need a comment with a ticket id!", commentNeedsTicket.join(" "));
                }
                let oked = false;
                matrixlib_1.ml.UI.showDialogDes({
                    container: $("#saveDlg"),
                    minMaxHeight: -350,
                    minMaxWidth: -500,
                    buttons: [{
                            text: 'Save',
                            class: 'btnDoIt',
                            click: function () {
                                oked = true;
                                var comment = $("#commentDlgTextSave").val().replace(/</g, "&lt;");
                                // remember for automation  
                                that.lastManualComment = comment;
                                commentNeedsTicket = Tasks_1.mTasks ? Tasks_1.mTasks.evaluateTaskIds(comment) : [];
                                if (!comment && globals_1.app.commentRequired()) {
                                    matrixlib_1.ml.UI.showError("Comment required!", "");
                                }
                                else if (commentNeedsTicket.length > 0) {
                                    matrixlib_1.ml.UI.showError("You need a comment with a ticket id!", commentNeedsTicket.join(" "));
                                }
                                else {
                                    if ($("#idSessionComment").prop('checked')) {
                                        that.setComment($("#commentDlgTextSave").val().replace(/</g, "&lt;"));
                                    }
                                    if (that.CommitTransaction) {
                                        that.CommitTransactionComment = $("#commentDlgTextSave").val().replace(/</g, "&lt;");
                                    }
                                    $("#saveDlg").dialog("close");
                                    res.resolve($("#commentDlgTextSave").val().replace(/</g, "&lt;"));
                                }
                            }
                        }, {
                            text: 'Cancel',
                            class: 'btnCancelIt',
                            click: function () {
                                $("#saveDlg").dialog("close");
                            }
                        }],
                    title: "Enter a change comment to save",
                    onOpen: () => {
                        let dl = $("#saveDlg").closest(".ui-dialog").addClass("saveDlg");
                        dl[0].style.setProperty('z-index', '20000', 'important');
                        $("#commentDlgTextSave").val(that.getComment().replace(/&lt;/g, "<")).focus();
                    },
                    onClose: () => {
                        if (!oked) {
                            if (that.CommitTransaction) {
                                that.CommitTransactionCancelled = true;
                            }
                            res.reject(that.CommitTransactionCancelled);
                        }
                    },
                    onResize: () => {
                        $("#saveDlg").css("width", "100%");
                    }
                });
            }
            return res;
        }
        getComment() {
            var comment = this.CurrentComment ? this.CurrentComment : "";
            return comment;
        }
        makeTeaser(comment) {
            if (!comment || comment.length < 30) {
                return comment; //.replace(/</g,"&lt;");
            }
            return (comment.substring(0, 30 - 3) + "..."); //.replace(/</g,"&lt;");
        }
        getCommentTeaser() {
            return this.makeTeaser(this.getComment());
        }
        setComment(comment, internal) {
            this.CurrentComment = comment ? comment : "";
            $("#comment").val(this.getCommentTeaser().replace(/&lt;/g, "<"));
            if (!this.isConfigClient()) {
                localStorage.setItem("CurrentComment", this.CurrentComment);
            }
            if (comment && !internal) {
                var newComments = [];
                newComments.push(comment);
                var lastComments = this.getLastComments();
                for (var idx = 0; idx < lastComments.length && idx < 9; idx++) {
                    var exists = false;
                    for (var ni = 0; ni < newComments.length; ni++) {
                        exists = exists || (newComments[ni] === lastComments[idx]);
                    }
                    if (!exists) {
                        newComments.push(lastComments[idx]);
                    }
                }
                globals_1.globalMatrix.serverStorage.setItem("lastComments", JSON.stringify(newComments));
            }
            $("#comment").change();
        }
        isGroup() {
            return this.licensedModules.indexOf("qms") != -1 || this.licensedModules.indexOf("acl") != -1 || this.licensedModules.indexOf("groups") != -1;
        }
        isQMS() {
            return this.licensedModules.indexOf("qms") != -1;
        }
        isMerge() {
            return this.licensedModules.indexOf("merge") != -1;
        }
        isReview() {
            return this.licensedModules.indexOf("review") != -1;
        }
        isACL() {
            return this.licensedModules.indexOf("acl") != -1;
        }
        isQMSProject(project) {
            if (!project) {
                project = this.getProject();
            }
            for (var idx = 0; idx < this.ProjectList.length; idx++) {
                if (this.ProjectList[idx].shortLabel == project)
                    return this.ProjectList[idx].qmsProject;
            }
            return false;
        }
        limitAdmin() {
            return this.licensedModules.indexOf("limitadmin") == -1;
        }
        hasRisks() {
            return this.licensedModules.indexOf("risk") != -1;
        }
        hasVariants() {
            return this.licensedModules.indexOf("labels") != -1;
        }
        hasDocs() {
            return this.licensedModules.indexOf("doc") != -1;
        }
        hasAgileSync() {
            return this.licensedModules.indexOf("agilerocks") != -1;
        }
        setModules(startupInfo) {
            this.licensedModules = startupInfo.license.options;
        }
        getLastComments() {
            var lastComments = globals_1.globalMatrix.serverStorage.getItem("lastComments");
            if (!lastComments) {
                return [];
            }
            else {
                return JSON.parse(lastComments);
            }
        }
        tryReconnect() {
            let that = this;
            var res = $.Deferred();
            this.updateSettings().done(function () {
                res.resolve();
            }).fail(function () {
                PluginManager_1.plugins.initServerSettings();
                that.requestLogin(res);
            });
            return res;
        }
        signInAfterTimeout() {
            let that = this;
            var res = $.Deferred();
            this.requestLogin(res);
            return res;
        }
        ;
        triggerLoginWithDialog() {
            let that = this;
            globals_1.app.canNavigateAwayAsync().done(function () {
                let res = $.Deferred();
                res.done(function () {
                    if (that.isConfigClient()) {
                        globals_1.app.postLogin(that.getUser());
                    }
                    else {
                        that.updateUI();
                        that.loadProject(null, location.href);
                    }
                });
                that.requestLogin(res);
            }).fail(function () {
                matrixlib_1.ml.UI.showError("You have unsaved changes.", "Save or cancel before signing out.");
            });
        }
        ;
        changePassword() {
            UserControl_1.userControls.editUserDetails("useredit", this.getUser(), function () {
            }, function () {
            });
        }
        getProjectList(readOrWriteOnly) {
            return readOrWriteOnly ? this.ProjectList.filter(function (project) { return project.accessType == "write" || project.accessType == "read"; }) : this.ProjectList;
        }
        // return true if a user has access to a given project
        canSeeProject(project) {
            let rw = this.getProjectList(true);
            for (var idx = 0; idx < rw.length; idx++) {
                if (rw[idx].shortLabel === project) {
                    return true;
                }
            }
            return false;
        }
        changeToken() {
            let dlg = $("<div>").appendTo($("body"));
            let ui = $("<div style='height:100%;width:100%'>");
            let currentToken = $("<div>").appendTo(ui);
            TokenControl_1.TokenControl.showUserTokens(currentToken, globals_1.matrixSession.getUser());
            matrixlib_1.ml.UI.showDialog(dlg, "Access Tokens", ui, $(document).width() * 0.9, globals_1.app.itemForm.height() * 0.9, [{
                    text: 'OK',
                    class: 'btnDoIt',
                    click: function () {
                        dlg.dialog("close");
                    }
                }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical, true, true, () => { dlg.remove(); }, () => { }, () => { });
        }
        setProjectColor(projectShort, color) {
            let projectColors = this.getCustomerSettingJSON("projectColors", {});
            projectColors[projectShort] = color;
            this.setCustomerSettingJSON("projectColors", projectColors);
        }
        getProjectColor(projectShort) {
            let projectColors = this.getCustomerSettingJSON("projectColors", {});
            if (projectColors[projectShort] != undefined)
                return projectColors[projectShort];
            else
                return matrixlib_1.ml.UI.calculateColorFrom(projectShort).color;
        }
        getImgFromProject(pRef, offsetTop = 7) {
            let that = this;
            let color = that.getProjectColor(pRef);
            let img = `<div style="background:${color};margin-top:${offsetTop}px; height: 14px;width: 14px;float: left;/* margin: 3px; */margin-right: 5px;margin-left: 8px;border-radius: 4px;"> <div></div></div>`;
            return img;
        }
        createProjectSelectLink(pRef, pName, branchParents, lastParent) {
            let that = this;
            let img = that.getImgFromProject(pRef, 5);
            var link = $("<span class='mainmenu'>" + pRef + " - " + pName + "</span>").click(function (e) {
                $(".navbar-collapse.in").removeClass("in").addClass("collapse"); // for phones, hide menu
                var project = $(e.delegateTarget).data("projectid");
                globals_1.app.canNavigateAwayAsync().done(function () {
                    if (matrixlib_1.ml.UI.widgetPluginsContainer && matrixlib_1.ml.UI.widgetPluginsContainer.visible)
                        matrixlib_1.ml.UI.widgetPluginsContainer.exit(globals_1.globalMatrix.matrixBaseUrl + "/" + project);
                    that.loadProject(project);
                }).fail(function () {
                });
            }).data("projectid", pRef);
            let li = $("<li>");
            if (branchParents[pRef]) {
                if (lastParent.length && lastParent[0] == branchParents[pRef]) {
                    li.css("padding-left", "18px");
                    //li.append($(`<span class="fal fa-code-merge">`));
                }
            }
            else {
                lastParent.splice(0, 0, pRef);
            }
            li.append($(img));
            li.append(link);
            return li;
        }
        amIAllowedUser(limitedTo) {
            let all = limitedTo ? limitedTo : [];
            if (all.length == 0) {
                // no limits
                return true;
            }
            if (this.isSuperAdmin()) {
                return true;
            }
            if (all.indexOf(this.getUser()) != -1) {
                // I am a explicitly named user!
                return true;
            }
            let userCanDo = false;
            for (let userGroup of globals_1.globalMatrix.ItemConfig.getUserGroups()) {
                if (all.indexOf(matrixlib_1.ml.UI.SelectUserOrGroup.getGroupId(userGroup)) != -1 &&
                    userGroup.membership.map(member => member.login).indexOf(this.getUser()) != -1) {
                    userCanDo = true;
                }
            }
            return userCanDo;
        }
        updateUI(afterTimeout) {
            let that = this;
            if (this.quiet) {
                if (this.getProject()) {
                    PluginManager_1.plugins.initProject(this.getProject());
                }
                return;
            }
            //  set logged in user
            this.showUserMenu();
            if (afterTimeout) {
                // we do not want to update the item tree / selected item otherwise 
                // we loose the last edits 
                if (this.getProject() && globals_1.globalMatrix.ItemConfig.isConfigured()) {
                    PluginManager_1.plugins.initProject(this.getProject());
                }
                return;
            }
            let height = Math.max(200, $("#main").height());
            // set project list
            $("#idProjectList").html("").css("max-height", height + "px");
            //Show/enable help button
            if ($('#helpBtn').length == 0) {
                that.addHelpButton();
            }
            matrixlib_1.ml.UI.setEnabled($(".bottomNavHelp"), true);
            // admin / config client, hand over control 
            if (globals_1.globalMatrix.matrixProduct === "Admin" || this.isConfigClient()) {
                globals_1.app.postLogin(this.getUser());
                //By default save save in on the left
                if (globals_1.matrixSession.getUISettings({ saveLeft: true }).saveLeft) {
                    $("#btnCancel").insertAfter($("#btnSave"));
                }
                else {
                    $("#btnCancel").insertBefore("#btnSave");
                }
                return;
            }
            // MATRIX-1892 - swap save / cancel button in UI
            if (globals_1.matrixSession.getUISettings({ saveLeft: true }).saveLeft) {
                //By default save save in on the left
                $("#btnCancel").insertBefore("#btnSave");
            }
            else {
                $("#btnCancel").insertAfter("#btnSave");
            }
            // retrieve and prepare project groups and start render tree
            var project_groups = globals_1.matrixSession.getCustomerSettingJSON("project_groups");
            let branchParents = {};
            for (let branch_info of this.branches ? this.branches : []) {
                branchParents[branch_info.branch] = branch_info.mainline;
            }
            // in the top: add the QMS project or QMS projects group (if there's one)
            let groupCount = that.addLiveQMSProjects();
            // get the define project groups
            let groups = (project_groups && project_groups.groups) ? project_groups.groups : [];
            // build a menu with project groups
            if (groupCount || groups.length) {
                $("#idProjectList").css("overflow-y", "inherit");
                groups.push({ name: "All Projects", projects: [] });
                $.each(groups, function (gird, group) {
                    let all = $('<ul class="dropdown-menu dropdown-menu-sub">');
                    let count = 0;
                    let projects = that.getProjectList(true);
                    let lastParent = [];
                    for (var idx = 0; idx < projects.length; idx++) {
                        var pRef = projects[idx].shortLabel;
                        var pName = projects[idx].label;
                        if (pRef != "EMPTY" || that.isSuperAdmin()) {
                            if (!group.projects || group.projects.length === 0 || group.projects.indexOf(pRef) !== -1) {
                                all.append(that.createProjectSelectLink(pRef, pName, branchParents, lastParent));
                                count++;
                            }
                        }
                    }
                    if (count > 0) {
                        $("#idProjectList").append($('<li class="dropdown-submenu">').
                            append('<a href="javascript:void(0)">' + group.name + '</a>').append(all));
                        groupCount++;
                    }
                    all.css("max-height", $("#main").height() - gird * 26 - 26);
                });
            }
            // there's actually only one group (that means max one qms project) 
            // so we want to render a flat list of projects
            if (groupCount < 2) {
                $("#idProjectList").css("overflow-y", "auto").html("");
                that.addLiveQMSProjects();
                let projects = this.getProjectList(true);
                let lastParent = [];
                for (var idx = 0; idx < projects.length; idx++) {
                    var pRef = projects[idx].shortLabel;
                    var pName = projects[idx].label;
                    if (pRef != "EMPTY" || this.isSuperAdmin()) {
                        $("#idProjectList").append(this.createProjectSelectLink(pRef, pName, branchParents, lastParent));
                    }
                }
            }
            // add a bit of width to the menu to avoid line breaks
            $("#idProjectList").width($("#idProjectList").width() + 30);
            // default off
            let cbAutoCommit = $("#idAutoCommit");
            let commentTb = $("#comment");
            cbAutoCommit.prop('checked', (localStorage.getItem('idAutoCommit') === 'true')).change(function () {
                localStorage.setItem('idAutoCommit', cbAutoCommit.prop('checked'));
            });
            that.updateCommentCheckboxBoxVisibility();
            commentTb.change((evt) => {
                that.updateCommentCheckboxBoxVisibility();
            });
            if (globals_1.globalMatrix.matrixProduct === "Launch") {
                // nothing to do
            }
            else {
                this.loadProject(null, location.href, false);
            }
        }
        // if there is one QMS project just add a link... if there's multiple add a menu and 'increase' the sub menu counter by one
        addLiveQMSProjects() {
            let projects = globals_1.matrixSession.getProjectList(false).filter(project => { return project.qmsProject; });
            if (projects.length > 1) {
                let all = $('<ul class="dropdown-menu dropdown-menu-sub"> </ul>');
                projects.forEach((project) => {
                    let that = this;
                    let color = that.getProjectColor(project.shortLabel);
                    let img = $('<i class="fal fa-external-link" style="font-size:13px; float:left; margin-right:5px; margin-left:5px;margin-top:7px;color:' + color + '" > </i>');
                    let link = $("<span class='mainmenu'>" + project.shortLabel + " - " + project.label + "</span>").click(function (e) {
                        $(".navbar-collapse.in").removeClass("in").addClass("collapse"); // for phones, hide menu
                        window.open(globals_1.globalMatrix.matrixBaseUrl + "/pub/" + project.shortLabel);
                    });
                    let li = $("<li>");
                    li.append(img);
                    li.append(link);
                    all.append(li);
                });
                $("#idProjectList").append($('<li class="dropdown-submenu"></li>').append($('<a href="javascript:void(0)">' + "My QMS " + ' <i class="fal fa-external-link" style="position:absolute; top:6px;right:10px;" "></i></a> ')).append(all));
                return 1;
            }
            else if (projects.length == 1) {
                let color = this.getProjectColor(projects[0].shortLabel);
                let img = $('<i class="fal fa-external-link" style="font-size:13px; float:right; margin-left:5px;margin-top:4px;color:' + color + '" > </i>');
                let link = $("<span style='padding-left: 8px;' class='mainmenu'>" + projects[0].shortLabel + " - " + projects[0].label + "</span>").click(function (e) {
                    $(".navbar-collapse.in").removeClass("in").addClass("collapse"); // for phones, hide menu
                    window.open(globals_1.globalMatrix.matrixBaseUrl + "/pub/" + projects[0].shortLabel);
                });
                let li = $("<li>").append(link.append(img));
                $("#idProjectList").append(li);
                return 0;
            }
            return 0;
        }
        updateCommentCheckboxBoxVisibility() {
            let commentTb = $("#comment");
            let cbAutoCommit = $(".autoSave");
            if (commentTb.val() === "") {
                cbAutoCommit.hide();
            }
            else {
                cbAutoCommit.show();
            }
        }
        loadProject(projectId, projectURL, setAsProjectUrl) {
            // if called from menu the projectURL is null
            // if called after page load, the projectID is null
            // if called after Sign in menu , the projectID is null
            globals_1.matrixApplicationUI.updateMainUI(true);
            //Add browser notification support
            let notificationConfig = globals_1.matrixSession.getCustomerSettingJSON(ProjectSettings_1.notificationSetting, ProjectSettings_1.defaultNotificationConfig);
            if (notificationConfig.browserNotificationDisabled == undefined || notificationConfig.browserNotificationDisabled == false) {
                if (window.Notification && window.Notification.permission !== 'granted')
                    window.Notification.requestPermission();
            }
            let parsedUrl = matrixlib_1.ml.URL.parseUrl(location.href);
            if (parsedUrl.project == "") {
                if (parsedUrl.params["dashboard"] != null) {
                    let d = parsedUrl.params["dashboard"];
                    matrixlib_1.ml.UI.widgetPluginsContainer.render(d);
                    return;
                }
            }
            // currently no link types are known for automatic highlighting
            resetHighlightLinks();
            this.CurrentProject = projectId;
            // in case projectURL is known, it or the local storage should be used
            if (projectURL) {
                this.CurrentProject = this.getProjectFromUrlOrStorage(projectURL);
            }
            if (this.CurrentProject) {
                // make sure it still exists
                var stillOK = false;
                let projects = this.getProjectList(true);
                for (var idx = 0; idx < projects.length; idx++) {
                    if (this.CurrentProject === projects[idx].shortLabel) {
                        stillOK = true;
                        $("#sidebar").show();
                        $("#main").show();
                        $("#explainOuter").hide();
                    }
                }
                if (!stillOK) {
                    this.showProjectSelectMessage();
                    $("#idProject").html('<div class="btn btn-xs" style="padding-top:6px"><span>Select project </span><span class="caret"></span></div>');
                    globals_1.matrixApplicationUI.destroyOldControls();
                    MainTree_1.NavigationPanel.destroy();
                    matrixlib_1.ml.UI.showError("Project does not exist!", "The project '" + this.CurrentProject + "' either does not exist or you have no read/write access to it.");
                    setTimeout(function () {
                        matrixlib_1.ml.UI.showSuccess("Select a another project");
                    }, 3000);
                    return;
                }
            }
            else {
                this.showProjectSelectMessage();
                $("#idProject").html('<div class="btn btn-xs" style="padding-top:6px"><span>Select project </span><span class="caret"></span></div>');
                globals_1.matrixApplicationUI.destroyOldControls();
                MainTree_1.NavigationPanel.destroy();
                matrixlib_1.ml.UI.showSuccess("select a project");
                return;
            }
            if (!projectURL) {
                projectURL = globals_1.app.createItemUrl();
                history.pushState(null, null, projectURL);
            }
            else if (setAsProjectUrl) {
                history.pushState(null, null, globals_1.globalMatrix.matrixBaseUrl + "/" + projectURL);
            }
            let projectName = globals_1.matrixSession.getProject();
            let foundProjects = globals_1.matrixSession.getProjectList(false).filter(o => { o.shortLabel == projectName; });
            let logoSetting = foundProjects != undefined && foundProjects.length > 0 ? foundProjects[0].projectLogo : "";
            var img = this.getImgFromProject(projectName);
            let projectNameTitleCtrl = `<div id="projectNameTitleContainer" class="btn btn-xs" >
                   <div id="projectNameTitle">
                       ${img}
                       <span> ${projectName}</span>
                       <span class="caret"/>
                   </div>
               </div>`;
            let color = globals_1.matrixSession.getProjectColor(projectName);
            $("header").css("border-top", "solid 5px " + color);
            $("#tooltip_panel").css("border", "solid 5px " + color);
            $("#scrollBarStyle").remove();
            $("body").append("<style id='scrollBarStyle'>::-webkit-scrollbar-track{ background-color: " + color + "}</style>");
            $("#idProject").html(projectNameTitleCtrl); //://"<i class='fas fa-book'></i>");
            globals_1.globalMatrix.serverStorage.setItem('SessionLastProject', this.CurrentProject);
            if (typeof globals_1.globalMatrix.mobileApp !== "undefined") {
                globals_1.globalMatrix.projectStorage = new ProjectStorageMobile_1.ProjectStorageMobile(this.CurrentProject);
            }
            else {
                globals_1.globalMatrix.projectStorage = new ProjectStorage_1.ProjectStorage(this.CurrentProject);
            }
            // if url specifies it use the item if not use last item from storage for project
            var item = this.getItemFromUrlOrStorage(projectURL);
            globals_1.globalMatrix.projectStorage.setItem('SessionLastItem', item);
            globals_1.app.loadProject(this.CurrentProject, item);
            // auto run search
            function runSearch() {
                $("#projectTree input[name=search]").val(search);
                $("#projectTree .btn-sssearch>i").trigger("click");
            }
            let search = matrixlib_1.ml.URL.parseUrl(projectURL).params.search;
            if (search) {
                globals_1.app.waitForMainTree(runSearch);
            }
            // Store params for later use
            this.customParams = matrixlib_1.ml.URL.parseUrl(projectURL).params;
            // Automatically switch to item when mobileLayout
            let mobileLayout = localStorage.getItem("mobileLayout");
            if (mobileLayout && mobileLayout != "") {
                localStorage.setItem("mobileLayout", "1");
                window.applyResponsiveView();
            }
        }
        ;
        oAuthOnly() {
            return globals_1.globalMatrix.mxOauth == "mandatory";
        }
        showProjectSelectMessage(forceIntro) {
            $("#sidebar").hide();
            $("#main").hide();
            $("#contextframe").addClass("hidden");
            $("#contextframesizer").addClass("hidden");
            $("#explainOuter").show();
            $("#explain").html("");
            function showimg(img) {
                $(".explainimg").html("<img src='" + globals_1.globalMatrix.matrixBaseUrl + "/img/" + img + "'/>");
                $("#imgModal").modal();
            }
            $("#explain").height($("#explainOuter").height());
            let projectsRW = this.getProjectList(true);
            if (!projectsRW || projectsRW.length === 0) {
                $("#explain").append("<div class='explainh1'>Welcome to Matrix Requirements</div>");
                // Get qms viewer only
                var projectListQms = globals_1.matrixSession.getProjectList(false).filter(item => item.accessType == "qmsviewer");
                if (projectListQms.length > 0) {
                    var ul = $("<ul class='explainMore'/>");
                    $("#explain").append("<div class='explainh2'>You can access  to these projects as a QMS viewer</div>");
                    $("#explain").append(ul);
                    projectListQms.forEach((item) => {
                        ul.append("<li class='explainmore'><a href='" + globals_1.globalMatrix.matrixBaseUrl + "/pub/" + item.shortLabel + "'>" + item.shortLabel + " </a> - " + item.label + "</li>");
                    });
                }
                else {
                    $("#explain").append("<div class='explainh2'>You do not have access to any projects. Please contact your Matrix Requirements administrator.</div>");
                }
            }
            else if (globals_1.globalMatrix.matrixExpress || forceIntro) {
                let projects = projectsRW.map(function (ple) { return ple.shortLabel; });
                $("#explain").append("<div class='explainh1'>Welcome to Matrix Requirements</div>");
                $("#explain").append("<div class='explainh2'>Below are a few examples for project configurations. They have different item categories and traceability rules. Your actual project structure will most likely be different - Ask us, we help you to set it up quickly!</div>");
                //$("#explain").append( "<div class='explainh3'>The item categories define what kind of items you can store in the database. The traceability rules define which up and downstream links between the categories can or must exist. This can be changed in the admin client, but before getting into that ask us </div>" );
                $("#explain").append("<div class='explainh1'>MatrixALM - Design History Files and more</div>");
                if (projects.indexOf("SIMPLEST") == -1 && projects.indexOf("DEFAULT") == -1 && projects.indexOf("MREQPROJ") == -1) {
                    $("#explain").append("<div class='explainh2'>The ALM module is not enabled - let us know if you want to get it!</div>");
                }
                else {
                    var ul = $("<ul>");
                    $("#explain").append($("<div class='explainh2'>").append(ul));
                    if (projects.indexOf("SIMPLEST") != -1)
                        ul.append($("<li class='explainmore'>SIMPLEST: covers requirements, specification, tests (<span class='explainImg' data-src='simplest.png' >show</span> - <span class='explainProject' data-src='SIMPLEST' >open project</span>)</li>"));
                    if (projects.indexOf("DEFAULT") != -1)
                        ul.append($("<li class='explainmore'>DEFAULT: covers risks, requirements, specification, tests and use cases (<span class='explainImg' data-src='default.png' >show</span> - <span class='explainProject' data-src='DEFAULT' >open project</span>)</li>"));
                    if (projects.indexOf("MREQPROJ") != -1)
                        ul.append($("<li class='explainmore'>MREQPROJ: covers risks, user and system requirements, specification, tests and use cases (<span class='explainImg' data-src='mreq.png' >show</span> - <span class='explainProject' data-src='MREQPROJ' >open project</span>)</li>"));
                    $("#explain").append("<div class='explainh3'>If you need more projects, different types of categories, input fields, traceability rules or risk formulas please do not hesitate to contact us.</div>");
                }
                $("#explain").append("<div class='explainh1'>MatrixQMS - Quality System, CAPAs and more</div>");
                if (projects.indexOf("QMS") == -1 && projects.indexOf("CAPA") == -1 && projects.indexOf("QMS_FILE") == -1 && projects.indexOf("HR_FILE") == -1) {
                    $("#explain").append("<div class='explainh2'>The QMS module is not enabled - let us know if you want to get it!</div>");
                }
                else {
                    var ul = $("<ul>");
                    $("#explain").append($("<div class='explainh2'>").append(ul));
                    if (projects.indexOf("QMS") != -1)
                        ul.append($("<li class='explainmore'>QMS: all your standards, procedures, work instructions, procedural risks, etc ... (<span class='explainProject' data-src='QMS' >open project</span>)</li>"));
                    if (projects.indexOf("CAPA") != -1)
                        ul.append($("<li class='explainmore'>CAPA: Corrective and preventive action forms (<span class='explainProject' data-src='CAPA' >open project</span>)</li>"));
                    if (projects.indexOf("QMS_FILE") != -1)
                        ul.append($("<li class='explainmore'>QMS_FILE: the place for QMS records (<span class='explainProject' data-src='QMS_FILE' >open project</span>)</li>"));
                    if (projects.indexOf("HR_FILE") != -1)
                        ul.append($("<li class='explainmore'>HR_FILE: human resource records (<span class='explainProject' data-src='HR_FILE' >open project</span>)</li>"));
                }
                let modal = `
                <div class="modal fade  modal-lg" id="imgModal" tabindex="-1" role="dialog">
                    <div class="modal-dialog   explain-modal" role="document">
                <div class="modal-content  explain-modal">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myModalLabel">Configuration Preview</h4>
                </div>
                <div class="modal-body">
                    <div class='explainimg'></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                </div>
                </div>
            </div>
            </div>`;
                $("#explain").append(modal);
                $(".explainImg").click(function (event) { showimg($(event.delegateTarget).data("src")); });
                $(".explainProject").click(function (event) { window.open(globals_1.globalMatrix.matrixBaseUrl + "/" + $(event.delegateTarget).data("src"), "_blank"); });
            }
            else {
                $("#explain").append("<div class='explainh1'>Welcome to Matrix Requirements</div>");
                $("#explain").append("<div class='explainh2' style='text-align: center;'>Please select a project from the project menu in the top.</div>");
                $("#comment").prop('disabled', false);
            }
        }
        filterProjects(projectList) {
            let dp = globals_1.matrixSession.getCustomerSettingJSON("deleted_projects");
            if (!dp) {
                return projectList;
            }
            // filter project by deleted ones
            return projectList.filter(function (pli) { return dp.deleted.indexOf(pli.shortLabel) == -1; });
        }
        getItemFromUrlOrStorage(projectURL) {
            if (!projectURL) {
                return null;
            }
            let parsedUrl = matrixlib_1.ml.URL.parseUrl(projectURL);
            if (parsedUrl.item) {
                return parsedUrl.item;
            }
            return globals_1.globalMatrix.projectStorage.getItem('SessionLastItem');
        }
        getProjectFromUrlOrStorage(projectURL) {
            let project = null;
            let parsedUrl = matrixlib_1.ml.URL.parseUrl(projectURL);
            if (parsedUrl.project) {
                project = parsedUrl.project;
            }
            else {
                project = globals_1.globalMatrix.serverStorage.getItem('SessionLastProject');
            }
            if (project == "#") {
                project = null;
                window.history.pushState(null, null, window.location.href.replace("#", ""));
            }
            return project;
        }
        browserNavigation() {
            var item = this.getItemFromUrlOrStorage(location.href);
            var project = this.getProjectFromUrlOrStorage(location.href);
            if (this.CurrentProject !== project) {
                this.loadProject(null, location.href);
                return;
            }
            this.duringBrowserNavigation = true;
            globals_1.app.treeSelectionChangeAsync(item);
            this.duringBrowserNavigation = false;
        }
        signOut(requestAdminRights) {
            let that = this;
            globals_1.app.canNavigateAwayAsync().done(function () {
                $("#idProject").html("");
                globals_1.matrixApplicationUI.destroyOldControls();
                $("#user").html("");
                $("#mainUserMenu").html("");
                MainTree_1.NavigationPanel.destroy();
                matrixlib_1.ml.UI.setEnabled($(".bottomNavHelp"), false);
                globals_1.restConnection.postServer("user/" + that.getUser() + "/logout").done(function () {
                    var res = $.Deferred();
                    that.signOutCleanUp();
                    res.done(function () {
                        that.updateUI();
                    });
                    that.requestLogin(res, requestAdminRights);
                });
            }).fail(function () {
                matrixlib_1.ml.UI.showError("You have unsaved changes.", "Save or cancel before signing out.");
            });
        }
        editComment() {
            let that = this;
            var lastCommentsSession = this.getLastComments();
            // dropdown select last comment
            $("#recentCommentChange").find("li").remove();
            for (var idx = 0; idx < lastCommentsSession.length; idx++) {
                var option = $('<li><a data-target="#">' + this.makeTeaser(lastCommentsSession[idx]) + '</a></li>')
                    .click(function (e) {
                    $("#commentDlgText").val($(e.delegateTarget).data("full").replace(/&lt;/g, "<"));
                })
                    .data("full", lastCommentsSession[idx]);
                $("#recentCommentChange").append(option);
            }
            $("#commentDlgText").val(this.getComment().replace(/&lt;/g, "<"));
            matrixlib_1.ml.UI.showDialogDes({
                container: $("#commentDlg"),
                minMaxHeight: -400,
                minMaxWidth: -550,
                buttons: [{
                        text: 'Save',
                        class: 'btnDoIt',
                        click: function () {
                            that.setComment($("#commentDlgText").val().replace(/</g, "&lt;"));
                            $("#commentDlg").dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            $("#commentDlg").dialog("close");
                        }
                    }],
                title: "Enter comment used when saving",
                onOpen: () => {
                    window.setTimeout(function () { $("#commentDlgText").select(); }, 100);
                },
                onClose: () => {
                },
                onResize: () => {
                    $("#commentDlg").css("width", "100%");
                }
            });
        }
        showLoginWindow() {
            if (matrixlib_1.ml.UI.widgetPluginsContainer && matrixlib_1.ml.UI.widgetPluginsContainer.visible) {
                matrixlib_1.ml.UI.widgetPluginsContainer.exit("");
            }
            const loginFrame = $("#loginFrame");
            const loginBox = loginFrame.contents().find(".login-full-box");
            if (loginBox.length === 0) {
                // Not loaded yet
                console.info("LOGIN: Not ready yet, try again");
                window.setTimeout(() => this.showLoginWindow(), 100);
                return;
            }
            if (loginFrame.is(":visible") && loginBox.is(":visible")) {
                // nothing to do
                console.info("LOGIN: Already visible, nothing to do");
                return;
            }
            loginFrame.show();
            loginBox.show();
        }
        hideLoginWindow() {
            const loginFrame = $("#loginFrame");
            const loginBox = loginFrame.contents().find(".login-full-box");
            if (loginBox.length === 0) {
                // Not loaded yet
                console.info("LOGIN: Not ready yet, try again");
                window.setTimeout(() => this.hideLoginWindow(), 100);
                return;
            }
            if (loginFrame.is(":hidden") && loginBox.is(":hidden")) {
                // nothing to do
                console.info("LOGIN: Already hidden, nothing to do");
                return;
            }
            loginFrame.hide();
            loginBox.hide();
        }
        requestLogin(res, requestAdminRights) {
            let that = this;
            const loginFrame = $("#loginFrame");
            if (!loginFrame.length)
                return; // for unit tests
            this.showLoginWindow();
            that.postConnect = res;
            loginFrame[0].contentWindow.postMessage("activateUser", window.location.origin);
            if (requestAdminRights) {
                window.setTimeout(function () {
                    // give the frame some time to load...
                    loginFrame[0].contentWindow.postMessage("admin", window.location.origin);
                }, 1000);
            }
        }
        receiveMessage(event) {
            let that = this;
            if (event.origin == window.location.origin && event.data == "login") {
                // login successful
                $("#loginFrame").hide();
                // prepare next login ()
                $("#loginFrame")[0].contentWindow.location.reload();
                globals_1.matrixSession.setComment(localStorage.getItem(globals_1.globalMatrix.matrixBaseUrl + "_useComment"));
                // if there is a specific point to continue.. go for it
                globals_1.matrixSession.updateSettings().done(function () {
                    globals_1.matrixSession.showUserMenu();
                    // retrieved some settings, go back to start
                    if (globals_1.matrixSession.postConnect) {
                        globals_1.matrixSession.postConnect.resolve();
                    }
                }).fail(function () {
                    // this should not really happen (since we just logged in...)
                    globals_1.matrixSession.requestLogin(globals_1.matrixSession.postConnect);
                });
            }
            else if (event.origin == window.location.origin && event.data == "login-failed") {
                matrixlib_1.ml.UI.showError("SSO Login failed", "Unable to login via external authentication system.");
            }
            else if (event.origin == window.location.origin && event.data == "loginDetails") {
                // test if something should be announced
                if (Number(localStorage.getItem("badLogins")) > 0) {
                    matrixlib_1.ml.UI.showSuccess("Before this successful login " + localStorage.getItem("badLogins") + " unsuccessful login attempts have been done.", 4000);
                }
                let expire = Number(localStorage.getItem("expiration"));
                if (expire > -1) {
                    matrixlib_1.ml.UI.showError("Password will expire soon!", "Your password will expire in " + expire + " days.", 4000);
                }
            }
        }
        addHelpButton() {
            var dropDownHtml = '<div class="btn-group dropup navbarCtrl mainHelp" style="float:right">' +
                '    <button type="button" class="bottomNavHelp btn  btn-warning dropdown-toggle" data-toggle="dropdown">' +
                '        <span id="helpBtn">Help</span> <span class="caret"></span>' +
                '    </button>' +
                this.getHelpButton() +
                '</div>';
            $('.navbar-fixed-bottom .navbar-right:has(#btnSave)').prepend(dropDownHtml);
        }
        getHelpButton() {
            return '    <ul id="mainHelpBtnMenu" class="dropdown-menu dropdown-menu-main usermenu" role="menu" id="helpUL">' +
                '    <li><a id="" href="https://urlshort.matrixreq.com/d23/faq" target="_blank">FAQ</a></li>' +
                '    <li><a id="" href="https://urlshort.matrixreq.com/d23/manual" target="_blank">User guide</a></li>' +
                '    <li><a id="" href="https://urlshort.matrixreq.com/d23/admin" target="_blank">Administrative guide</a></li>' +
                '    <li class="divider" style="display: list-item;"></li>' +
                '    <li><a id="" href="https://urlshort.matrixreq.com/contact" target="_blank">Contact us</a></li>' +
                '    <li><a id="" href="https://urlshort.matrixreq.com/helpdesk" target="_blank">Service desk</a></li>' +
                '    </ul>';
        }
        showUserMenu() {
            let that = this;
            var info = that.getUser();
            // display current user name
            $("#user").html("");
            $("#user").append(matrixlib_1.ml.UI.getAvatar(info, 32));
            // fill user menu
            $("#mainUserMenu").html("");
            // add sign out
            $('<li id="signoutcommand"><span class="mainmenu">Sign out <i class="fal fa-sign-out-alt" style="float: right;font-size: 17px;"></i> </span></li>').appendTo($("#mainUserMenu")).click(function () {
                that.signOut(false);
            });
            if (!that.isConfigClient()) {
                $('<li class="divider" style="display: list-item;"></li>').appendTo($("#mainUserMenu"));
                // add change user profile
                if (globals_1.globalMatrix.matrixBaseUrl.indexOf('demo.matrixreq.com') === -1 || that.getUser() != "demo") {
                    $('<li class="changepasswordmenu"><span id="myprofile" class="mainmenu">My Profile<i class="fal fa-user" style="float: right;font-size: 17px;"></i></span></li>').appendTo($("#mainUserMenu")).click(function () {
                        that.changePassword();
                    });
                }
                let settingsToken = this.getCustomerSettingJSON("settingsToken");
                if (settingsToken && settingsToken.enabled && (settingsToken.users.length == 0 || settingsToken.users.indexOf(globals_1.matrixSession.getUser()) != -1)) {
                    $('<li class="changetoke"><span id="mytoken" class="mainmenu">My Tokens<i class="fal fa-key" style="float: right;font-size: 17px;"></i></span></li>').appendTo($("#mainUserMenu")).click(function () {
                        that.changeToken();
                    });
                }
                if (globals_1.matrixSession.getUISettings().widgetDashboardOption) {
                    $('<li class="divider" style="display: list-item;"></li>').appendTo($("#mainUserMenu"));
                    let dashboardList = globals_1.matrixSession.getCustomerSettingJSON("dashboardSettings");
                    if (dashboardList != null && dashboardList.dashboards != null) {
                        for (let d in dashboardList.dashboards) {
                            let icon = '<i class="fal fa-columns" style="float: right;font-size: 17px;"></i>';
                            if (dashboardList.dashboards[d].icon != undefined) {
                                icon = '<i class="' + dashboardList.dashboards[d].icon + '" style="float: right;font-size: 17px;"></i>';
                            }
                            let msg = "<span class='mainmenu'>" + dashboardList.dashboards[d].displayString + icon + "</span> ";
                            $('<li style="position: relative;">' + msg + '</li>').appendTo($("#mainUserMenu")).click(function (event) {
                                matrixlib_1.ml.UI.widgetPluginsContainer.render(d);
                            });
                        }
                    }
                }
                // add admin client
                if (this.isCustomerAdmin() || this.isSuperAdmin()) {
                    $('<li class="divider" style="display: list-item;"></li>').appendTo($("#mainUserMenu"));
                    $('<li class="adminsettings"><a id="serveradmin" href="' + globals_1.globalMatrix.matrixBaseUrl + '/adminConfig' + '" target="_blank">Server Administration <i class="fal fa-cog" style="float: right;font-size: 17px;"></i></a></li>').appendTo($("#mainUserMenu"));
                    $("#serveradmin").click((evt) => {
                        if (globals_1.globalMatrix.globalShiftDown && globals_1.matrixSession.getProject()) {
                            window.open(globals_1.globalMatrix.matrixBaseUrl + "/adminConfig/" + globals_1.matrixSession.getProject(), "_blank");
                            evt.preventDefault();
                            return false;
                        }
                    });
                }
            }
        }
        setNotificationCounts(todos) {
            this.myTodoCount = todos;
        }
        getNotificationCounts() {
            return this.myTodoCount;
        }
        getNotifications() {
            return this.myTodos;
        }
        setNotifications(todos) {
            this.myTodos = todos;
        }
        initPushMessaging() {
            let that = this;
            let res = $.Deferred();
            if (this.pushMessages) {
                res.resolve();
                this.pushMessages.newConnection();
                return res;
            }
            this.pushMessages = new PushMessages_1.PushMessages();
            this.pushMessages.newConnection().always(function () {
                res.resolve();
                // handle todos
                that.pushMessages.onTodoChanged(function () {
                    Notifications_1.NotificationList.updateNotifications();
                });
                // handle item changes
                that.pushMessages.onItemUpdated(function (changed) {
                    // also update the tree, rename the item if needed
                    if (globals_1.app.getItemTitle(changed.item)) {
                        MainTree_1.NavigationPanel.update({ id: changed.item, title: changed.title });
                        that.updateWatchItemVersion(changed.item, changed.version);
                    }
                });
                // handle new items 
                that.pushMessages.onItemCreated(function (changed) {
                    let itemJson = {
                        id: changed.item,
                        title: changed.title,
                        type: matrixlib_1.ml.Item.parseRef(changed.item).type
                    };
                    if (matrixlib_1.ml.Item.parseRef(changed.item).isFolder) {
                        itemJson["children"] = [];
                    }
                    let newItem = {
                        parent: changed.parent,
                        position: 10000,
                        item: itemJson
                    };
                    window.setTimeout(function () {
                        // wait a bit more than a typical round trip to server before the update
                        // maybe the item was already created by some other action (e.g. it's a XTC execution the user did himself) 
                        if (!globals_1.app.getItemTitle(changed.item)) {
                            globals_1.app.insertInTree(newItem);
                            globals_1.app.updateCache(newItem);
                        }
                    }, 500);
                });
                // handle deleting items
                that.pushMessages.onItemDeleted(function (changed) {
                    // we need to wait a bit, cause if I deleted it, it will go away by itself
                    window.setTimeout(function () {
                        if (globals_1.app.getItemTitle(changed.item)) {
                            // otherwise I deleted it...
                            MainTree_1.NavigationPanel.remove(changed.item);
                            if (globals_1.app.getCurrentItemId() == changed.item) {
                                matrixlib_1.ml.UI.showAck(-1, "Someone just deleted the item you are looking at: " + changed.item);
                            }
                        }
                    }, 1000);
                });
                // show people watching items
                that.pushMessages.onItemWatched(function (watchInfo) {
                    if (watchInfo.item == globals_1.app.getCurrentItemId()) {
                        if (watchInfo.editor && !watchInfo.editor.thisSocket) {
                            // apparently someone else is editing the item...
                            // make it readonly, maybe update it, indicate editor
                            globals_1.app.someOneElseIsChanging(watchInfo);
                        }
                        else if (watchInfo.editor && watchInfo.editor.thisSocket) {
                            // i got notified that I am editing an item, I don't care
                            // unless someone else modified the item in the mean time
                            if (that.lastWatchInfo && // I watch something (not very first item load)
                                that.lastWatchInfo.item == globals_1.app.getCurrentItemId() && // and what I watch is displayed (should always be the case)
                                watchInfo.item == that.lastWatchInfo.item && // and the news is still for that item
                                watchInfo.version != that.lastWatchInfo.version && // but the news is that the version is not what I displayed
                                that.lastWatchInfo.version > 0 // this means it's not currently saving
                            ) {
                                // I got disconnected while editing (and someone else made a change before I logged on again)
                                globals_1.app.someOneElseWasChanging(watchInfo);
                            }
                            else {
                                // all good  make sure list with editors / viewers is up-to-date
                                globals_1.app.updateItemViewers(watchInfo);
                            }
                        }
                        else {
                            // no (more) editor
                            if (that.lastWatchInfo && that.lastWatchInfo.editor) {
                                // someone was editing before
                                if (that.lastWatchInfo.item == globals_1.app.getCurrentItemId()) {
                                    // someone (else) stopped editing (e.g. by cancelling)
                                    if (that.lastWatchInfo.editor.thisSocket) {
                                        // I stopped editing
                                        if (globals_1.app.needsSave()) {
                                            // not actually true MATRIX-3211 - we just ignore this message
                                            matrixlib_1.ml.Logger.log("warning", "received message as if I stopped editing, but not true, so I ignore it!");
                                        }
                                        // in any case update viewers
                                        globals_1.app.updateItemViewers(watchInfo);
                                    }
                                    else {
                                        globals_1.app.someOneElseStoppedEditing(watchInfo, that.lastWatchInfo);
                                    }
                                }
                                else {
                                    // someone else stopped editing another item (e.g. by cancelling)
                                    // so we don't care about stopping something but we want to show the editors of this item
                                    globals_1.app.updateItemViewers(watchInfo);
                                }
                            }
                            else {
                                // nobody edits and edited before
                                globals_1.app.updateItemViewers(watchInfo);
                            }
                        }
                        // remember last watchers
                        if (!(that.lastWatchInfo && that.lastWatchInfo.item == watchInfo.item && Math.abs(that.lastWatchInfo.version) == watchInfo.version)) {
                            // handle race conditions: keep negative version from saving
                            that.lastWatchInfo = watchInfo;
                        }
                    }
                });
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        updateWatchItemVersion(itemId, newVersion) {
            if (this.lastWatchInfo && this.lastWatchInfo.item == itemId) {
                if (newVersion == -1) {
                    newVersion = -Math.abs(this.lastWatchInfo.version);
                }
                this.lastWatchInfo.version = newVersion;
            }
        }
        isConfigClient() {
            return globals_1.globalMatrix.matrixProduct == "Configuration Client";
        }
        updateSettings() {
            let that = this;
            var res = $.Deferred();
            globals_1.restConnection.getServer("?exclude=allUsers,allTodos", true).done(function (result) {
                if (result.license.maxReadWrite < result.readWriteUsers.length) {
                    matrixlib_1.ml.UI.showError("License Issue", "There are not enough write licenses.");
                }
                that.setModules(result);
                that.serverConfig = result;
                PluginManager_1.plugins.initServerSettings(result);
                that.setUser(result.currentUser);
                that.setDateInfo(result.dateInfo);
                that.setCustomerSettings(result.customerSettings);
                let projects = result.project.map(function (pi) { return pi.shortLabel; });
                that.setNotificationCounts(result.todoCounts.filter(function (todoCount) { return projects.indexOf(todoCount.projectShort) != -1; }));
                // a session is still active
                that.ProjectList = that.filterProjects(result.project);
                that.customerAdmin = result.customerAdmin === 1;
                that.superAdmin = result.superAdmin === 1;
                if (that.isConfigClient() && !that.isAdmin() && !that.isSuperAdmin()) {
                    that.signOut(true);
                }
                else if (that.isConfigClient()) {
                    res.resolve();
                }
                else {
                    that.initPushMessaging().always(function () {
                        // in any case, software will run without websockets
                        res.resolve();
                    });
                }
                that.branches = result.branches;
                if (globals_1.matrixSession.getUISettings().widgetDashboardOption) {
                    $("img.brandLogo").css("cursor", "pointer");
                    $("img.brandLogo").off("click.toggleWidget");
                    $("img.brandLogo").on("click.toggleWidget", () => { matrixlib_1.ml.UI.widgetPluginsContainer.toggle(); });
                }
            }).fail(function (jqxhr, textStatus, error) {
                res.reject();
            });
            return res;
        }
        getBranches(mainline, branch) {
            if (!this.branches)
                return [];
            return this.branches.filter(info => (!mainline || mainline == info.mainline) && (!branch || branch == info.branch));
        }
        signOutCleanUp() {
            this.customerAdmin = false;
            this.superAdmin = false;
            this.CurrentUser = "";
        }
        getCustomParams() {
            return this.customParams;
        }
        getDashboardConfig() {
            try {
                let config = globals_1.matrixSession.getCustomerSettingJSON("dashboardSettings");
                if (config && config)
                    return config;
            }
            catch (error) {
            }
            return { dashboards: { default: { displayString: "home" } } };
        }
    }
    exports.MatrixSession = MatrixSession;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 61 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ProjectStorage = void 0;
    class ProjectStorage {
        constructor(project) {
            var vs = globals_1.app.getVersion().split(".");
            var vo = vs[0] + "." + vs[1] + ".";
            if (!localStorage.getItem(vo + "cleanup")) {
                for (var x in localStorage) {
                    if (x.indexOf("remember_selection") > 0 && localStorage[x] === "") {
                        localStorage.removeItem(x);
                    }
                    if (x.indexOf(globals_1.globalMatrix.matrixBaseUrl) === 0) {
                        var y = x.replace(globals_1.globalMatrix.matrixBaseUrl, "1.8.");
                        localStorage.setItem(y, localStorage.getItem(x));
                        localStorage.removeItem(x);
                    }
                }
                localStorage.setItem(vo + "cleanup", "done");
            }
            this.Project = vo + "_" + project + "_";
        }
        setItem(itemKey, itemVal, dontSanitize) {
            localStorage.setItem(this.Project + itemKey, dontSanitize ? itemVal : (DOMPurify.sanitize(itemVal) + ''));
        }
        getItem(itemKey, dontSanitize) {
            let val = localStorage.getItem(this.Project + itemKey);
            return dontSanitize ? val : (DOMPurify.sanitize(val) + '');
        }
        getItemDefault(itemKey, defaultValue) {
            let val = localStorage.getItem(this.Project + itemKey);
            if (!val) {
                val = defaultValue;
            }
            return DOMPurify.sanitize(val) + '';
        }
    }
    exports.ProjectStorage = ProjectStorage;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 62 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(7), __webpack_require__(1), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, MatrixRequirementsAPI_1, matrixlib_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.PushMessages = void 0;
    class PushMessages {
        constructor() {
            this.itemWatched = new MatrixRequirementsAPI_1.EventDispatcher();
            this.itemUpdated = new MatrixRequirementsAPI_1.EventDispatcher();
            this.itemCreated = new MatrixRequirementsAPI_1.EventDispatcher();
            this.itemDeleted = new MatrixRequirementsAPI_1.EventDispatcher();
            this.todoChanged = new MatrixRequirementsAPI_1.EventDispatcher();
        }
        newConnection() {
            // make sure there's nothing left of an old connection
            if (this.webSocket && this.webSocket.readyState != WebSocket.CLOSED) {
                this.webSocket.onclose = null;
                this.webSocket.onerror = null;
                this.webSocket.onmessage = null;
                this.webSocket.close();
            }
            this.webSocket = null;
            // create a new one
            return this.connect();
        }
        connect() {
            let that = this;
            let res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "Connecting to websocket");
            if (this.webSocket) {
                // something is in the bush, it tries to (re)connect 
                if (this.webSocket.readyState == WebSocket.CONNECTING) {
                    matrixlib_1.ml.Logger.log("warning", "WebSocket is in connecting state.");
                    res.resolve(WebSocket.CONNECTING);
                    return res;
                }
                else if (this.webSocket.readyState == WebSocket.CLOSING) {
                    matrixlib_1.ml.Logger.log("warning", "WebSocket is in closing state.");
                    res.resolve(WebSocket.CLOSING);
                    return res;
                }
                else if (this.webSocket.readyState == WebSocket.OPEN) {
                    matrixlib_1.ml.Logger.log("warning", "WebSocket is already opened.");
                    res.resolve(WebSocket.OPEN);
                    return res;
                }
            }
            this.webSocket = new WebSocket(globals_1.globalMatrix.matrixBaseUrl.replace("https:", "wss:").replace("http:", "ws:") + "/websocket?");
            /**
             * Binds functions to the listeners for the websocket.
             */
            this.webSocket.onerror = function (event) {
                matrixlib_1.ml.Logger.log("info", "Error from websocket");
                matrixlib_1.ml.Logger.log("info", event.data);
                res.reject();
            };
            this.webSocket.onmessage = function (event) {
                if (event.data) {
                    let message = JSON.parse(event.data);
                    console.log(message);
                    if (message && message.error == "Cannot set you as editor") {
                        // indicate at least that we are watching
                        let itemId = globals_1.app.getCurrentItemId();
                        if (itemId && matrixlib_1.ml.Item.parseRef(itemId).number) {
                            if (that.preventConcurrentEdit()) {
                                globals_1.app.someOneIsChangingTheItem();
                                that.watchItem(itemId);
                            }
                        }
                    }
                    else {
                        that.trigger(message);
                    }
                }
            };
            this.webSocket.onclose = function (event) {
                matrixlib_1.ml.Logger.log("info", "Stop listening to news from server: " + event.code);
                // check if I need to reconnect
                that.reconnectAfterCloseMessage(10);
            };
            this.webSocket.onopen = function (event) {
                matrixlib_1.ml.Logger.log("info", "Listening to news from server");
                // say hello to the server
                that.send({ verb: "openedSocket" }, 0);
                // we got (re)connected, so the server won't know in which editing states we are 
                that.sendCurrentEditingStatus();
                res.resolve(WebSocket.OPEN);
            };
            return res;
        }
        // verify if there's a category setting allowing concurrent of items of this type
        preventConcurrentEdit() {
            let itemId = globals_1.app.getCurrentItemId();
            if (!itemId)
                return true;
            let category = matrixlib_1.ml.Item.parseRef(itemId).type;
            if (!category)
                return true;
            let concurrentEditSetting = globals_1.globalMatrix.ItemConfig.getCategorySetting(matrixlib_1.ml.Item.parseRef(itemId).type, "concurrentEdit");
            if (concurrentEditSetting && concurrentEditSetting.disabled) {
                return false;
            }
            return true;
        }
        reconnectAfterCloseMessage(waitForServerRestartSeconds) {
            let that = this;
            matrixlib_1.ml.Logger.log("Info", "Waiting for new connection for " + waitForServerRestartSeconds);
            // get something from server, if connection is not ok, do not try to reconnect
            //Matrix-5036: no need to get everything from /rest/1. Server version is enough.
            globals_1.restConnection.getServer("?output=serverVersion", true).done(function () {
                // connection is still ok -> re'init the web sockets and send information about current view/edit state of an item
                that.connect().done(function (result) {
                    if (result != WebSocket.OPEN) {
                        // not normal
                        window.setTimeout(function () {
                            that.reconnectAfterCloseMessage(waitForServerRestartSeconds);
                        }, 1000);
                    }
                }).fail(function () {
                    // that's not normal...
                    window.setTimeout(function () {
                        that.reconnectAfterCloseMessage(waitForServerRestartSeconds);
                    }, 1000);
                });
            }).fail(function () {
                if (waitForServerRestartSeconds == 0) {
                    // apparently server got really disconnected
                    console.log("Server also disconnected");
                    globals_1.matrixSession.tryReconnect().done(() => {
                        // if itemDetails is empty.. this is 10 seconds after a log out, so we need a full refresh
                        globals_1.matrixSession.updateUI($("#itemDetails").html() != "");
                    });
                }
                else {
                    // maybe user logs on as other user
                    window.setTimeout(function () {
                        that.reconnectAfterCloseMessage(waitForServerRestartSeconds - 1);
                    }, 1000);
                }
            });
        }
        trigger(message) {
            if (message.subject != "todo" && message.project != globals_1.matrixSession.getProject()) {
                matrixlib_1.ml.Logger.log("info", "Message for previous project");
                return;
            }
            switch (message.subject) {
                case "todo":
                    this.todoChanged.dispatch({});
                    break;
                case "itemChanged":
                    if (this.preventConcurrentEdit()) {
                        // the user does not edit the item
                        this.itemUpdated.dispatch(message);
                    }
                    break;
                case "itemMoved":
                    globals_1.matrixApplicationUI.lastMainItemForm.addMove(message.item, message.version);
                    break;
                case "itemDeleted":
                    this.itemDeleted.dispatch(message);
                    break;
                case "itemCreated":
                    this.itemCreated.dispatch(message);
                    break;
                case "folderCreated":
                    this.itemCreated.dispatch(message);
                    break;
                case "watching":
                    if (this.preventConcurrentEdit()) {
                        this.itemWatched.dispatch(message);
                        if (message.item == globals_1.app.getCurrentItemId() && globals_1.app.needsSave() && !message.editor) {
                            // workaround MATRIX-4428 workaround: user edits an item and has another tab open with same item, user closes other tab
                            this.editItem(globals_1.app.getCurrentItemId());
                        }
                    }
                    break;
                case "folderCreated":
                    this.itemCreated.dispatch(message);
                    break;
            }
        }
        // if the user is watching or editing something, let the server know
        sendCurrentEditingStatus() {
            let itemId = globals_1.app.getCurrentItemId();
            if (itemId && matrixlib_1.ml.Item.parseRef(itemId).number) {
                if (globals_1.app.needsSave()) {
                    this.editItem(itemId);
                }
                else {
                    this.watchItem(itemId);
                }
            }
        }
        send(message, retryCount) {
            let that = this;
            message["socketId"] = "" + PushMessages.socketId;
            // make sure no old messages will be send after this
            window.clearTimeout(this.retryTimer);
            // make sure there's a good connection
            if (!this.webSocket || this.webSocket.readyState != WebSocket.OPEN) {
                // no good connection    
                if (retryCount < 10) {
                    matrixlib_1.ml.Logger.log("info", "Websocket disconnected try to reconnect");
                    this.connect().done(function (status) {
                        if (status == WebSocket.OPEN) {
                            // got a new socket! send
                            matrixlib_1.ml.Logger.log("info", "Send (after reconnect) to watcher: " + message.verb);
                            try {
                                that.webSocket.send(JSON.stringify(message));
                            }
                            catch (ex) {
                                matrixlib_1.ml.Logger.log("error", "Failing to send");
                            }
                        }
                        else {
                            that.retryTimer = window.setTimeout(function () {
                                that.send(message, retryCount + 1);
                            }, 1000);
                        }
                    }).fail(function () {
                    });
                }
                else {
                    matrixlib_1.ml.Logger.log("info", "Websocket disconnected - giving up, trying to send");
                }
                return;
            }
            matrixlib_1.ml.Logger.log("info", "Send to watcher: " + message.verb);
            try {
                this.webSocket.send(JSON.stringify(message));
            }
            catch (ex) {
                matrixlib_1.ml.Logger.log("error", "Failing to send");
            }
        }
        // start watching for item viewers
        watchItem(itemId) {
            this.send({
                verb: "watchItem",
                project: globals_1.matrixSession.getProject(),
                item: itemId
            }, 0);
        }
        // start watching for item viewers
        unWatchItem() {
            this.send({
                verb: "unwatchItem"
            }, 0);
        }
        // start edit item (user can save)
        editItem(itemId) {
            this.send({
                verb: "editItem",
                project: globals_1.matrixSession.getProject(),
                item: itemId
            }, 0);
        }
        // stop edit item (user dose not need to save anymore)
        unEditItem() {
            this.send({
                verb: "uneditItem"
            }, 0);
        }
        // event listeners
        onTodoChanged(fn) {
            this.todoChanged.subscribe(this, fn);
        }
        onItemUpdated(fn) {
            this.itemUpdated.subscribe(this, fn);
        }
        onItemCreated(fn) {
            this.itemCreated.subscribe(this, fn);
        }
        onItemDeleted(fn) {
            this.itemDeleted.subscribe(this, fn);
        }
        onItemWatched(fn) {
            this.itemWatched.subscribe(this, fn);
        }
    }
    exports.PushMessages = PushMessages;
    PushMessages.socketId = new Date().getTime();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 63 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.TokenControl = void 0;
    class TokenControl {
        static showUserTokens(container, login) {
            let table = $("<table class='table'><thead><tr><th>Purpose</th><th>Token</th><th>Valid Until</th><th>Description</th><th></th></tr></thead></table>").appendTo(container);
            let body = $("<tbody>").appendTo(table);
            globals_1.restConnection.getServer("user/" + login).done(function (user) {
                TokenControl.showTokenList(body, user.login, null, user.tokenList);
                TokenControl.showTokenAdd(body, user.login, null, () => {
                    container.html("");
                    TokenControl.showUserTokens(container, login);
                });
            });
        }
        static showTokenList(body, createUser, displayUser, tokenList) {
            if (tokenList) {
                $.each(tokenList, function (tidx, token) {
                    let row = $("<tr>").appendTo(body);
                    if (displayUser)
                        row.append("<td>" + displayUser + "</td>");
                    row.append("<td>" + token.purpose + "</td>");
                    row.append("<td>" + token.value + "</td>");
                    row.append("<td>" + token.validToUserFormat + "</td>");
                    row.append("<td>" + (token.reason ? token.reason : "") + "</td>");
                    let deleteToken = $("<i style='cursor:pointer' class='deleteToken fal fa-trash-alt' data-user='" + (displayUser ? displayUser : createUser) + "'data-token='" + token.value + "'>");
                    row.append($("<td>").append(deleteToken));
                    deleteToken.click(function (event) {
                        let tokenDel = $(event.delegateTarget);
                        globals_1.restConnection.deleteServerAsync("user/" + tokenDel.data("user") + "/token", { value: tokenDel.data("token") }).done(function () {
                            tokenDel.closest("tr").remove();
                        });
                    });
                });
            }
        }
        static showTokenAdd(body, user, allUsers, onAdded) {
            let row = $("<tr>").appendTo(body);
            let userSelect;
            if (!user) {
                let options = allUsers.map(function (user) { return { id: user.login, label: user.login }; });
                userSelect = $("<div id='tokenUser'>").mxDropdown({
                    controlState: globals_1.ControlState.FormEdit,
                    canEdit: true,
                    help: " ",
                    fieldValue: "",
                    valueChanged: function () {
                        if (userSelect) {
                            TokenControl.updateCreate(user, userSelect);
                        }
                    },
                    parameter: {
                        placeholder: 'select user',
                        maxItems: 1,
                        options: options,
                        groups: [],
                        create: false,
                        sort: true,
                        splitHuman: false
                    }
                });
                row.append($("<td id='to_user'>").append(userSelect));
            }
            row.append("<td id='to_purpose'></td>");
            row.append("<td id='to_token'></td>");
            let endDate = $("<input id='endTimePicker' type='text' class='form-control'>");
            endDate.datetimepicker({ format: matrixlib_1.ml.UI.DateTime.getSimpleDateTimeFormatMoment() });
            row.append($("<td id='to_date'>").append(endDate));
            endDate.on("dp.change", function (e) {
                TokenControl.updateCreate(user, userSelect);
            });
            let reason = $("<input id='tokenReason' type='text' class='form-control'>");
            reason.on("change keyup paste", function (event) {
                TokenControl.updateCreate(user, userSelect);
            });
            row.append($("<td id='to_reason'>").append(reason));
            row.append("<td><button class='btn btn-normal' id='tokenCreate' disabled>create</button></td>");
            $("#tokenCreate").click(function () {
                TokenControl.createToken(onAdded);
            });
        }
        // change status of create button
        static updateCreate(defaultUser, userSelect) {
            let date = $("#endTimePicker").data("DateTimePicker").date();
            let user = defaultUser ? defaultUser : userSelect.getController().getValue();
            let reason = $("#tokenReason").val();
            let f = new Date(date);
            let n = new Date();
            $("#tokenCreate").data("date", date).data("user", user).data("reason", reason);
            matrixlib_1.ml.UI.setEnabled($("#tokenCreate"), !!reason && date && !!user && Math.ceil((f.getTime() - n.getTime()) / 3600000) > 0);
        }
        // create token
        static createToken(onAdded) {
            let date = $("#tokenCreate").data("date");
            let user = $("#tokenCreate").data("user");
            let reason = $("#tokenCreate").data("reason");
            let future = new Date(date);
            let now = new Date();
            let delta = Math.ceil((future.getTime() - now.getTime()) / 3600000);
            globals_1.restConnection.postServer("user/" + user.toLowerCase() + "/token", {
                purpose: "oauth",
                validity: delta,
                reason: reason
            }).done(function (token) {
                onAdded();
            });
        }
    }
    exports.TokenControl = TokenControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 64 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ProjectStorageMobile = void 0;
    class ProjectStorageMobile {
        constructor(project) {
            this.Project = globals_1.globalMatrix.matrixBaseUrl + "_" + project + "_";
        }
        setItem(itemKey, itemVal) {
            localStorage.setItem(this.Project + itemKey, itemVal);
        }
        getItem(itemKey) {
            return localStorage.getItem(this.Project + itemKey);
        }
        getItemDefault(itemKey, defaultValue) {
            let v = localStorage.getItem(this.Project + itemKey);
            return v ? v : defaultValue;
        }
    }
    exports.ProjectStorageMobile = ProjectStorageMobile;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 65 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(43), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, ItemHistoryView_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.RestConnector = void 0;
    class RestConnector {
        constructor(config) {
            this.timer = { start: 0, end: 0, command: "", type: "" };
            this.restServer = config.server;
        }
        setProject(projectName) {
            this.restServerProject = this.restServer + "/" + projectName;
        }
        ;
        getProject(cmd, ignoreErrors, ignoreFilters) {
            var labelFilter = matrixlib_1.ml.LabelTools.getFilter();
            if (!ignoreFilters && labelFilter && labelFilter.length > 0) {
                var filter = "?";
                if (cmd.indexOf("?") !== -1) {
                    // there is already at least one parameter: so just add another
                    filter = "&";
                }
                filter += "filter=" + labelFilter;
                cmd += filter;
            }
            if (globals_1.globalMatrix.ItemConfig.getTimeWarp()) {
                var timewarp = "?";
                if (cmd.indexOf("?") !== -1) {
                    // there is already at least one parameter: so just add another
                    timewarp = "&";
                }
                timewarp += "atDate=" + globals_1.globalMatrix.ItemConfig.getTimeWarp();
                cmd += timewarp;
            }
            return this.get(this.restServerProject + "/" + cmd, ignoreErrors);
        }
        getServer(cmd, noRetry) {
            return this.get(this.restServer + "/" + cmd, noRetry);
        }
        postServer(cmd, param, payload) {
            return this.post(this.restServer + "/" + cmd, param, payload);
        }
        postProject(cmd, param, payload) {
            return this.post(this.restServerProject + "/" + cmd, param, payload);
        }
        postProjectJson(cmd, data) {
            return this.postJson(this.restServerProject + "/" + cmd, data);
        }
        putServer(cmd, param, asPayload) {
            return this.put(this.restServer + "/" + cmd, param, asPayload);
        }
        putProject(cmd, param, itemId) {
            var labelFilter = matrixlib_1.ml.LabelTools.getFilter();
            if (labelFilter && labelFilter.length > 0) {
                param["filter"] = labelFilter;
            }
            return this.put(this.restServerProject + "/" + cmd, param, null, itemId);
        }
        deleteProjectAsync(cmd, param, asString) {
            return this.deleteRestAsync(this.restServerProject + "/" + cmd, param, asString);
        }
        deleteServerAsync(cmd, param, asString) {
            return this.deleteRestAsync(this.restServer + "/" + cmd, param, asString);
        }
        // file up and download
        download(cmd, params) {
            matrixlib_1.ml.Logger.log("info", "Downloading: " + this.restServerProject + "/" + cmd);
            var iframe = $('<iframe width=1 height=1 frameborder=0 style="display:none">');
            iframe.appendTo('body');
            var form = $('<form action="' + this.restServerProject + "/" + cmd + '" method="get"></form>');
            if (params) {
                $.each(params, function (index, value) {
                    form.append($("<input name='" + index + "'>").val(value));
                });
            }
            iframe.contents().find("body").append(form);
            form.submit();
        }
        getFile(cmd, dataType) {
            let that = this;
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "GET FILE: " + this.restServerProject + "/" + cmd);
            $.ajaxSetup({ cache: false }); // avoid IE to cache rest calls
            $.ajax({ type: 'get',
                url: that.restServerProject + "/" + cmd,
                dataType: dataType
            }).done(function (data) {
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + "retrieved file from restServer...");
                res.resolve(data);
            }).fail(function (jqxhr, textStatus, error) {
                that.handleError(jqxhr, textStatus, error, "GET FILE: " + that.restServerProject + "/" + cmd).done(function () {
                    // user signed in again
                    $.ajax({ type: 'get',
                        url: that.restServerProject + "/" + cmd
                    }).done(function (data) {
                        matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                        res.resolve(data);
                    }).fail(function (jqxhr, textStatus, error) {
                        matrixlib_1.ml.UI.showError("Could not get file!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                    });
                }).fail(function () {
                    res.reject();
                });
            });
            $.ajaxSetup({ cache: true });
            return res;
        }
        uploadFileProjectAsync(file, progress) {
            return this.uploadFileServerAsync(file, progress, this.restServerProject, null, "/file");
        }
        fetchFileAsync(url, progress) {
            return this.uploadFileServerAsync(null, progress, this.restServerProject, { url: url }, "/file");
        }
        uploadFileCustomerAsync(file, progress) {
            return this.uploadFileServerAsync(file, progress, this.restServer + "/all", null, "/file");
        }
        importProjectAsync(file, progress, params) {
            return this.uploadFileServerAsync(file, progress, this.restServer + "/", params, "");
        }
        uploadFileServerAsync(file, progress, target, params, urlSuffix) {
            let that = this;
            var formData = new FormData();
            if (file) {
                formData.append("file", file);
            }
            if (params) {
                $.each(params, function (parName, parVal) {
                    formData.append(parName, parVal);
                });
            }
            matrixlib_1.ml.Logger.log("info", file ? `upload FILE: ${file.name}` : `fetch ${JSON.stringify(params)}`);
            var res = $.Deferred();
            let url = target ? target + urlSuffix : globals_1.globalMatrix.matrixRestUrl + "/all" + urlSuffix;
            $.ajax({
                url: url,
                type: 'POST',
                xhr: function () {
                    var myXhr = $.ajaxSettings.xhr();
                    if (myXhr.upload) { // Check if upload property exists
                        myXhr.upload.addEventListener('progress', progress, false);
                    }
                    return myXhr;
                },
                success: function (data, textStatus, jqXHR) {
                    res.resolve(data);
                },
                error: function (jqxhr, textStatus, error) {
                    if (that.isTimeout(jqxhr)) {
                        matrixlib_1.ml.Logger.log("info", "Trying to reconnect...");
                        globals_1.matrixSession.signInAfterTimeout().done(function () {
                            that.uploadFileServerAsync(file, progress, target, params, urlSuffix).done(function (result) {
                                res.resolve(result);
                            });
                        }).fail(function () {
                            let details = (jqxhr && jqxhr.responseJSON && jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 0 && jqxhr.responseJSON.detailsList[0]) ? (" Details " + jqxhr.responseJSON.detailsList[0]) : "";
                            res.reject("Failed to reconnect. Status:" + textStatus + ". Error was:" + error + details);
                        });
                    }
                    else {
                        let details = (jqxhr && jqxhr.responseJSON && jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 0 && jqxhr.responseJSON.detailsList[0]) ? (" Details " + jqxhr.responseJSON.detailsList[0]) : "";
                        res.reject("Upload failed. Status:" + textStatus + ". Error was:" + error + details);
                    }
                },
                complete: function (response) {
                    matrixlib_1.ml.Logger.log("info", response.responseText);
                },
                // Form data
                data: formData,
                dataType: 'json',
                //Options to tell jQuery not to process data or worry about content-type.
                cache: false,
                contentType: false,
                processData: false
            });
            return res;
        }
        convertExcelProjectAsync(file, progress) {
            return this.convertExcelServerAsync(file, progress);
        }
        convertExcelServerAsync(file, progress) {
            var formData = new FormData();
            if (file) {
                formData.append("file", file);
            }
            matrixlib_1.ml.Logger.log("info", `convert FILE: ${file.name}`);
            var res = $.Deferred();
            let url = this.restServerProject + "/excelxml";
            $.ajax({
                url: url,
                type: 'POST',
                xhr: function () {
                    var myXhr = $.ajaxSettings.xhr();
                    if (myXhr.upload) { // Check if upload property exists
                        myXhr.upload.addEventListener('progress', progress, false);
                    }
                    return myXhr;
                },
                success: function (data, textStatus, jqXHR) {
                    res.resolve(data);
                },
                error: function (jqxhr, textStatus, error) {
                    let details = (jqxhr && jqxhr.responseJSON && jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 0 && jqxhr.responseJSON.detailsList[0]) ? (" Details " + jqxhr.responseJSON.detailsList[0]) : "";
                    res.reject("Upload failed. Status:" + textStatus + ". Error was:" + error + details);
                },
                complete: function (response) {
                    matrixlib_1.ml.Logger.log("info", "completed conversion of excel");
                },
                // Form data
                data: formData,
                dataType: 'text',
                //Options to tell jQuery not to process data or worry about content-type.
                cache: false,
                contentType: false,
                processData: false
            });
            return res;
        }
        isTimeout(jqxhr) {
            if (jqxhr.status !== 403) {
                return false;
            }
            if (!jqxhr.responseText) {
                return false;
            }
            if (jqxhr.responseJSON && jqxhr.responseJSON.displayError == "Unauthorized PUT without authentication for change") {
                // CSFR token missing
                return true;
            }
            if (jqxhr.responseJSON && jqxhr.responseJSON.displayError && jqxhr.responseJSON.displayError.indexOf("session is null") == 0) {
                // CSFR token missing
                return true;
            }
            if (jqxhr.responseText.indexOf("session is null, exception in authorization decoding session is null, no authorization header") !== -1) {
                // session expired
                return true;
            }
            if (jqxhr.responseText.indexOf("session is null, exception in authorization decoding session is null, no authorization header") !== -1) {
                // google auth expired
                return true;
            }
            return false;
        }
        isGatewayTimeout(jqxhr) {
            if (jqxhr.status !== 504) {
                return false;
            }
            if (!jqxhr.responseText) {
                return false;
            }
            if (jqxhr.responseText.indexOf("Gateway Time-out") !== -1) {
                return true;
            }
            return false;
        }
        // error handling with automatic reconnect
        handleError(jqxhr, textStatus, error, cmd, param, itemId) {
            let that = this;
            var res = $.Deferred();
            // sometimes error does not arrive as json but only as text
            if (jqxhr.responseText && !jqxhr.responseJSON) {
                try {
                    jqxhr.responseJSON = JSON.parse(jqxhr.responseText);
                }
                catch (ex) {
                    // well this is no JSON
                }
            }
            if (jqxhr && jqxhr.status == 422 && jqxhr.responseJSON && jqxhr.responseJSON.fields) {
                let errors = [];
                for (let errorField of jqxhr.responseJSON.fields) {
                    console.log(JSON.stringify(errorField));
                    let fieldName = globals_1.globalMatrix.ItemConfig.getFieldName(errorField.fieldId);
                    errors.push(fieldName ? fieldName : ('' + errorField.fieldId));
                }
                matrixlib_1.ml.UI.showError("Some field(s) have invalid html tags", "Fields with bad content: " + errors.join(","));
                res.reject();
                return res;
            }
            else if (jqxhr && jqxhr.status == 500 && jqxhr.responseJSON && jqxhr.responseJSON.category) {
                if (jqxhr.responseJSON.displayError == "This item has been modified") {
                    if (itemId && globals_1.app.getCurrentItemId() == itemId) {
                        let ht = new ItemHistoryView_1.HistoryTools();
                        ht.diffAgainstLatest(param);
                    }
                    else {
                        // user double clicked in project and hell broke loose
                        // (we just ignore)
                    }
                    res.reject();
                    return res;
                }
                else if (jqxhr.responseJSON.displayError == "Last operation would overflow number of licenses (error in compute)") {
                    matrixlib_1.ml.UI.showError("Licensing Error", "You cannot change the access. There are not enough write licenses");
                    res.reject();
                    return res;
                }
                if (jqxhr.displayError) {
                    matrixlib_1.ml.UI.showError(jqxhr.responseJSON.category, jqxhr.displayError);
                    res.reject();
                    return res;
                }
                if (jqxhr.responseJSON.category == "Permission violation") {
                    matrixlib_1.ml.UI.showError(jqxhr.responseJSON.category, jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 3 ? jqxhr.responseJSON.detailsList[2] : "");
                    res.reject();
                    return res;
                }
                else if (jqxhr.responseJSON.displayError && jqxhr.responseJSON.displayError.indexOf("has no sufficient permission for this action on project") != -1) {
                    matrixlib_1.ml.UI.showError("Permission Violation", "You do not have access to this project");
                    res.reject();
                }
                else {
                    matrixlib_1.ml.UI.showError(jqxhr.responseJSON.category, jqxhr.responseJSON.detailsList && jqxhr.responseJSON.detailsList.length > 0 ? jqxhr.responseJSON.detailsList[0] : "");
                    res.reject();
                    return res;
                }
            }
            if (this.isTimeout(jqxhr)) {
                matrixlib_1.ml.Logger.log("info", "Trying to reconnect...");
                // assume this ws a sign in problem.sign in quietly if possible and do it again
                globals_1.matrixSession.signInAfterTimeout().done(function () {
                    res.resolve();
                }).fail(function () {
                    matrixlib_1.ml.UI.showError("Not signed in!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                    res.reject();
                });
            }
            else if (this.isGatewayTimeout(jqxhr)) {
                matrixlib_1.ml.Logger.log("info", "gateway timeout...");
                // assume this ws a sign in problem.sign in quietly if possible and do it again
                res.reject("gatewayTimeout");
            }
            else {
                matrixlib_1.ml.Logger.log("error", cmd);
                matrixlib_1.ml.UI.showError("Server error.", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                res.reject();
            }
            return res;
        }
        get(url, noRetry) {
            let that = this;
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "GET: " + url);
            $.ajaxSetup({ cache: false }); // avoid IE to cache rest calls
            var lastTimer = ((url.indexOf("?") !== -1) ? "&" : "?") + "td=" + (this.timer.end - this.timer.start);
            let adminUI = (globals_1.globalMatrix.matrixProduct == "Configuration Client") ? "&adminUI=1" : "";
            this.timer = {
                start: (new Date()).getTime(),
                command: encodeURIComponent(url),
                type: "get"
            };
            $.getJSON(url + lastTimer + adminUI).done(function (data) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = 200;
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                res.resolve(data);
            }).fail(function (jqxhr, textStatus, error) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = jqxhr.status;
                if (noRetry) {
                    res.reject(jqxhr, textStatus, error);
                }
                else {
                    that.handleError(jqxhr, textStatus, error, "GET: " + url).done(function () {
                        $.getJSON(url).done(function (data) {
                            matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                            res.resolve(data);
                        }).fail(function (jqxhr, textStatus, error) {
                            matrixlib_1.ml.UI.showError("Failed to get item!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                        });
                    }).fail(function () {
                        res.reject(jqxhr, textStatus, error);
                    });
                }
            });
            $.ajaxSetup({ cache: true });
            return res;
        }
        post(url, param, asPayload) {
            let that = this;
            var res = $.Deferred();
            if (typeof param !== 'undefined') {
                matrixlib_1.ml.Logger.log("info", "POST: " + url);
                param.td = (this.timer.end - this.timer.start);
                this.timer = {
                    start: (new Date()).getTime(),
                    command: encodeURIComponent(url),
                    type: "post"
                };
                //  post(url: string, data?: Object|string, success?: (data: any, textStatus: string, jqXHR: JQueryXHR) => any, dataType?: string): JQueryXHR;
                $.post(url, asPayload ? JSON.stringify(param) : param, null, asPayload ? "json" : ""
                // Note: removed since these seem not to be needed...(post only takes 4 parameters)
                //   ,'application/json'
                //   ,'json'
                ).done(function (data) {
                    that.timer.end = (new Date()).getTime();
                    that.timer.status = 200;
                    matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                    res.resolve(data);
                }).fail(function (jqxhr, textStatus, error) {
                    that.timer.end = (new Date()).getTime();
                    that.timer.status = jqxhr.status;
                    that.handleError(jqxhr, textStatus, error, "POST: " + url + "?" + jQuery.param(param, true)).done(function () {
                        $.post(url, param).done(function (data) {
                            matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                            res.resolve(data);
                        }).fail(function (jqxhr, textStatus, error) {
                            matrixlib_1.ml.UI.showError("Failed to post to server!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                        });
                    }).fail(function () {
                        res.reject(jqxhr, textStatus, error);
                    });
                });
            }
            else {
                matrixlib_1.ml.Logger.log("debug", "POST: " + url);
                var lasttimer = { td: (this.timer.end - this.timer.start) };
                this.timer = {
                    start: (new Date()).getTime(),
                    command: encodeURIComponent(url)
                };
                $.post(url, lasttimer).done(function (data) {
                    that.timer.end = (new Date()).getTime();
                    that.timer.status = 200;
                    matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                    res.resolve(data);
                }).fail(function (jqxhr, textStatus, error) {
                    that.timer.end = (new Date()).getTime();
                    that.timer.status = jqxhr.status;
                    if (url.indexOf("/logout") == url.length - 7) {
                        // attempt of logout when there's no more session, that's fine
                        res.resolve();
                    }
                    else {
                        that.handleError(jqxhr, textStatus, error, "POST: " + url).done(function () {
                            $.post(url).done(function (data) {
                                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                                res.resolve(data);
                            }).fail(function (jqxhr, textStatus, error) {
                                matrixlib_1.ml.UI.showError("Failed to post to server!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                            });
                        }).fail(function () {
                            res.reject(jqxhr, textStatus, error);
                        });
                    }
                });
            }
            return res;
        }
        postJson(url, data) {
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "POST: " + url);
            this.timer = {
                start: (new Date()).getTime(),
                command: encodeURIComponent(url),
                type: "post"
            };
            $.ajax(url, {
                type: "post",
                contentType: "application/json",
                data: JSON.stringify(data)
            }).done((result) => {
                this.timer.end = (new Date()).getTime();
                this.timer.status = 200;
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                res.resolve(result);
            }).fail((jqxhr, textStatus, error) => {
                this.timer.end = (new Date()).getTime();
                this.timer.status = jqxhr.status;
                res.reject(jqxhr, textStatus, error);
            });
            return res;
        }
        postSpecialServer(cmd, param) {
            return this.postSpecial(this.restServer + "/" + cmd, param);
        }
        postSpecial(url, param) {
            let that = this;
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "POST: " + url);
            param.td = (this.timer.end - this.timer.start);
            this.timer = {
                start: (new Date()).getTime(),
                command: encodeURIComponent(url),
                type: "post"
            };
            //  post(url: string, data?: Object|string, success?: (data: any, textStatus: string, jqXHR: JQueryXHR) => any, dataType?: string): JQueryXHR;
            $.ajax({ url: url, type: "POST", data: JSON.stringify(param), contentType: "application/json;charset=UTF-8", dataType: "json" })
                .done(function (data) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = 200;
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                res.resolve(data);
            }).fail(function (jqxhr, textStatus, error) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = jqxhr.status;
                that.handleError(jqxhr, textStatus, error, "POST: " + url + "?" + jQuery.param(param, true)).done(function () {
                    // try again after timeout
                    $.ajax({ url: url, type: "POST", data: JSON.stringify(param), contentType: "application/json;charset=UTF-8", dataType: "json" }).done(function (data) {
                        matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                        res.resolve(data);
                    }).fail(function (jqxhr, textStatus, error) {
                        matrixlib_1.ml.UI.showError("Failed to post to server!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                    });
                }).fail(function () {
                    res.reject(jqxhr, textStatus, error);
                });
            });
            return res;
        }
        put(url, param, asPayload, itemId) {
            let that = this;
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "PUT: " + url);
            param.td = (this.timer.end - this.timer.start);
            this.timer = {
                start: (new Date()).getTime(),
                command: encodeURIComponent(url),
                type: "put"
            };
            $.ajax({ type: 'put',
                url: url,
                processData: false,
                data: asPayload ? JSON.stringify(param) : jQuery.param(param, true),
                contentType: asPayload ? 'application/json; charset=UTF-8' : 'application/x-www-form-urlencoded; charset=UTF-8',
                dataType: 'json'
            }).done(function (data) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = 200;
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                res.resolve(data);
            }).fail(function (jqxhr, textStatus, error) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = jqxhr.status;
                that.handleError(jqxhr, textStatus, error, "PUT: " + url + "?" + jQuery.param(param, true), param, itemId).done(function () {
                    $.ajax({ type: 'put',
                        url: url,
                        processData: false,
                        data: jQuery.param(param, true),
                        contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                        dataType: 'json'
                    }).done(function (data) {
                        matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                        res.resolve(data);
                    }).fail(function (jqxhr, textStatus, error) {
                        matrixlib_1.ml.UI.showError("Failed to modify item!", matrixlib_1.ml.UI.getDisplayError(jqxhr, textStatus, error));
                    });
                }).fail(function (msg) {
                    res.reject(msg);
                });
            });
            return res;
        }
        deleteRestAsync(url, param, asString) {
            let that = this;
            var res = $.Deferred();
            matrixlib_1.ml.Logger.log("info", "DELETE: " + url + "?" + jQuery.param(param, true));
            param.td = (this.timer.end - this.timer.start);
            this.timer = {
                start: (new Date()).getTime(),
                command: encodeURIComponent(url),
                type: "delete"
            };
            $.ajax({ type: 'delete',
                url: url,
                processData: false,
                data: asString ? JSON.stringify(param) : jQuery.param(param, true),
                contentType: 'application/text',
                dataType: 'text'
            }).done(function (data) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = 200;
                matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                res.resolve(data);
            }).fail(function (jqxhr, textStatus, error) {
                that.timer.end = (new Date()).getTime();
                that.timer.status = jqxhr.status;
                that.handleError(jqxhr, textStatus, error, "DELETE: " + url + "?" + jQuery.param(param, true)).done(function () {
                    $.ajax({ type: 'delete',
                        url: url,
                        processData: false,
                        data: jQuery.param(param, true),
                        contentType: 'application/text',
                        dataType: 'text'
                    }).done(function (data) {
                        matrixlib_1.ml.Logger.log("debug", "RESPONSE: " + JSON.stringify(data));
                        res.resolve(data);
                    }).fail(function () {
                        res.reject();
                    });
                }).fail(function () {
                    res.reject();
                });
            });
            return res;
        }
    }
    exports.RestConnector = RestConnector;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 66 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.FileTools = void 0;
    class FileTools {
        uploadFilesAsync(files, idx) {
            let that = this;
            var res = $.Deferred();
            if (!files || files.length <= idx) {
                res.resolve(this.uploadInfo);
                return res;
            }
            globals_1.restConnection.uploadFileProjectAsync(files[idx], function (p) {
                var done = p.position || p.loaded;
                var total = p.totalSize || p.total;
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(idx, 99 * done / total);
            }).done(function (result) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(idx, 100);
                that.uploadInfo.push({
                    fileName: files[idx].name,
                    fileId: result.fileId + "?key=" + result.key,
                    uploaded: true
                });
                that.uploadFilesAsync(files, idx + 1).done(function (fini) {
                    res.resolve(fini);
                }).fail(function (fini) {
                    res.reject(fini);
                });
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(idx, 100);
            }).fail(function (error) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgressError(idx, "Failed to upload file!");
                that.uploadInfo.push({
                    fileName: files[idx].name,
                    fileId: error,
                    uploaded: false
                });
                res.reject(that.uploadInfo);
            });
            return res;
        }
        UploadFilesAsync(files) {
            var tasks = [];
            $.each(files, function (idx, file) {
                tasks.push({ name: file.name });
            });
            matrixlib_1.ml.UI.BlockingProgress.Init(tasks);
            this.uploadInfo = [];
            return this.uploadFilesAsync(files, 0);
        }
        ;
        UploadFileAsync(file) {
            var tasks = [];
            tasks.push({ name: file.name });
            matrixlib_1.ml.UI.BlockingProgress.Init(tasks);
            this.uploadInfo = [];
            return this.uploadFilesAsync([file], 0);
        }
        ;
        convertXLSXAsync(file) {
            let that = this;
            var res = $.Deferred();
            var tasks = [];
            tasks.push({ name: "converting excel ..." });
            matrixlib_1.ml.UI.BlockingProgress.Init(tasks);
            globals_1.restConnection.convertExcelProjectAsync(file, function (p) {
                var done = p.position || p.loaded;
                var total = p.totalSize || p.total;
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 99 * done / total);
            }).done(function (result) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgress(0, 100);
                res.resolve(result);
            }).fail(function (error) {
                matrixlib_1.ml.UI.BlockingProgress.SetProgressError(0, "Failed to upload file!");
                res.reject("");
            });
            return res;
        }
    }
    exports.FileTools = FileTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 67 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.HTMLCleaner = void 0;
    class HTMLCleaner {
        constructor(htmlCode, autoEscape) {
            this.cleanConfig = {
                blackLists: {
                    removeTags: ["HEAD", "FOOT", "STYLE", "SCRIPT", "IFRAME", 'applet', 'embed', 'noframes', 'noscript', 'meta', 'link', 'template'
                    ],
                    keepOnlyInside: ['font', 'a:not([href])',
                        // u: word..
                        'u'],
                    removeEmpty: ['p', 'a'],
                }, whiteLists: {
                    styles: [{ tagName: "SPAN", allowed: [
                                "font-weight:bold",
                                "font-style:italic",
                                "text-decoration:underline",
                                "text-align:right",
                                "text-align:left",
                                "text-align:center",
                                "margin-left:25px",
                                "margin-left:50px",
                                "margin-left:75px",
                                "margin-left:100px",
                                "margin-left:125px",
                                "line-height:1",
                                "line-height:1.2",
                                "line-height:1.4",
                                "line-height:1.6",
                                "line-height:1.8",
                                "line-height:2",
                                "line-height:3"
                            ]
                        }],
                    classes: [
                        { tagName: "SPAN", allowed: [
                                "captionDetails", "captionFix", "captionPre", "captionFig", "captionPost", "captionText", "referenceDetails", "referenceFix", "referencePre", "referenceFig", "referencePost", "referenceText"
                            ] },
                        { tagName: "P", allowed: ["h1", "h2", "h3", "h4", "caption"] }
                    ],
                    properties: [
                        { tagName: "IMG", allowed: ["src"] },
                        { tagName: "A", allowed: ["href", "target"] },
                        { tagName: "SPAN", allowed: ["contenteditable"] },
                        { tagName: "TD", allowed: ["colspan", "rowspan"] },
                        { tagName: "TH", allowed: ["colspan", "rowspan"] }
                    ],
                    data: [
                        { tagName: "SPAN", allowed: ["mid"] }
                    ]
                },
                tagReplacements: [
                    { what: "H1", with: "<p class='h1'>" },
                    { what: "H2", with: "<p class='h2'>" },
                    { what: "H3", with: "<p class='h3'>" },
                    { what: "H4", with: "<p class='h4'>" },
                    { what: "H5", with: "<p class='h5'>" },
                    { what: "H6", with: "<p class='h6'>" },
                    { what: "H7", with: "<p style='font-weight:bold'>" },
                    { what: "H8", with: "<p style='font-weight:bold'>" },
                    { what: "I", with: "<span style='font-style:italic'>" },
                    { what: "EM", with: "<span style='font-style:italic'>" },
                    { what: "B", with: "<span style='font-weight:bold'>" },
                    { what: "STRONG", with: "<span style='font-weight:bold'>" }
                ],
                tagReplacementsDoc: [
                    { what: "H6", with: "<p style='font-weight:bold'>" },
                    { what: "H7", with: "<p style='font-weight:bold'>" },
                    { what: "H8", with: "<p style='font-weight:bold'>" },
                    { what: "H5", with: "<h6>" },
                    { what: "H4", with: "<h5>" },
                    { what: "H3", with: "<h4>" },
                    { what: "H2", with: "<h3>" },
                    { what: "H1", with: "<h2>" },
                    { what: "I", with: "<span style='font-style:italic'>" },
                    { what: "EM", with: "<span style='font-style:italic'>" },
                    { what: "B", with: "<span style='font-weight:bold'>" },
                    { what: "STRONG", with: "<span style='font-weight:bold'>" }
                ]
            };
            this.autoEscape = autoEscape;
            this.text = htmlCode;
        }
        getClean(cleaningLevel, keepMatrix) {
            if (cleaningLevel == HTMLCleaner.CleanLevel.Server) {
                // use the server whitelists
                this.applyServerCleaning();
                return this.text;
            }
            // remove dangerous stuff (MATRIX-936 weird characters kill xml / doc generation) copy paste word
            if (keepMatrix) {
                // keep /n for table formatting...
                this.text = this.text.replace(/[\u0001-\u0009]/g, ' ');
                this.text = this.text.replace(/[\u000B-\u001F]/g, ' ');
            }
            else {
                this.text = this.text.replace(/[\u0001-\u001F]/g, ' ');
            }
            // remove some stuff which should definitely not be in like a <head>
            if (cleaningLevel == HTMLCleaner.CleanLevel.BasicSafety) {
                // meta and head need to stay to link word docs
                this.cleanConfig.blackLists.removeTags = this.cleanConfig.blackLists.removeTags.filter(function (tag) { tag.toLowerCase() != "head" && tag.toLowerCase() != "meta"; });
            }
            if (cleaningLevel != HTMLCleaner.CleanLevel.PurifyOnly) {
                this.removeTags();
            }
            if (cleaningLevel == HTMLCleaner.CleanLevel.Basic || cleaningLevel == HTMLCleaner.CleanLevel.BasicSafety) {
                return this.text;
            }
            // always sanitize
            this.text = DOMPurify.sanitize(this.text);
            if (cleaningLevel == HTMLCleaner.CleanLevel.PurifyOnly) {
                return this.text;
            }
            /*********** most code maintenance ***************/
            this.replaceNoCount("	", "");
            this.replaceNoCount("  ", " ");
            this.replaceNoCount(" \n", "\n");
            this.replaceNoCount("	\n", "\n");
            this.replaceNoCount("\n\n", "\n");
            this.replaceNoCount("  ", " ");
            // remove word specifc noise
            var tagStripper = new RegExp('<(/)*(v:|\\?xml:|st1:|o:)(.*?)>', 'gi');
            this.text = this.text.replace(tagStripper, '');
            this.replaceNoCount("<>", " ");
            if (cleaningLevel != HTMLCleaner.CleanLevel.Soft) {
                // handle word lists (needs to happen before unknown classes and comment are removed
                this.handleWordLists();
                // remove remaining comments
                this.text = this.text.replace(/<!--[^>]*-->/g, "");
                /*********** this might change the formatting ***************/
                // some things might not be in but we want to keep the inside <font>
                this.removeInsideTags();
                // clean inline stlye, classes, properties etc. according to some white lists
                if (!keepMatrix) {
                    this.cleanInlineStyle();
                    this.cleanClasses();
                    this.cleanProperties();
                }
            }
            if (!keepMatrix) {
                this.setMaxImageSize();
                this.cleanData();
            }
            this.replaceNoCount("&nbsp;&nbsp;", " ");
            this.replaceNoCount("&nbsp; ", " "),
                this.replaceNoCount(" &nbsp;", " ");
            if (cleaningLevel != HTMLCleaner.CleanLevel.Soft && !keepMatrix) {
                this.replaceTags(cleaningLevel);
            }
            this.replaceNoCount("> &nbsp;<", ">&nbsp;<");
            this.replaceNoCount(">&nbsp; <", ">&nbsp;<");
            // not good this will actually remove sometimes needed spaces ... this.replaceNoCount("> <", "><");
            this.replaceNoCount("> \n", ">\n");
            let e = 0;
            do {
                e = 0;
                e += this.replaceCount("  ", " ");
                e += this.replaceCount(" >", ">");
                e += this.replaceCount("	", "");
                e += this.replaceCount("  ", " ");
                e += this.replaceCount("&nbsp;\n", "\n");
                e += this.replaceCount(" \n", "\n");
                e += this.replaceCount("\n\n", "\n");
                e += this.replaceCount("</li></ul><ul><li>", "</li><li>"); // make real lists
            } while (e > 0);
            this.removeUseLessStuff();
            return this.text;
        }
        replaceWiki() {
            if (localStorage.getItem("wiki") != "on") {
                return this.text;
            }
            this.applyWiki();
            return this.text;
        }
        getCleanupSettings() {
            let cleanup = globals_1.globalMatrix.ItemConfig.getCleanupRules();
            if (!cleanup) {
                cleanup = globals_1.matrixSession.getCustomerSettingJSON("htmlCleanup");
            }
            if (!cleanup) {
                return null;
            }
            else if (!cleanup.cleanup) {
                return null;
            }
            return cleanup;
        }
        // returns a list of problems
        checkServerCleaning() {
            let cleaning = this.getCleanupSettings();
            if (!cleaning) {
                // the server does not care
                return [];
            }
            let results = [];
            let code = $("<div>").html(this.text);
            $("*", code).each(function (idx, node) {
                let name = node.nodeName.toLowerCase();
                if (cleaning.tags.indexOf(name) == -1) {
                    results.push(`<b>${name}</b> is not a supported tag`);
                }
                else {
                    let attrs = node.getAttributeNames();
                    // check attributes
                    for (let attIdx = 0; attIdx < attrs.length; attIdx++) {
                        let attr = attrs[attIdx].toLowerCase();
                        if ((cleaning.attributes[":all"] && cleaning.attributes[":all"].indexOf(attr) != -1) ||
                            (cleaning.attributes[name] && cleaning.attributes[name].indexOf(attr) != -1) ||
                            (cleaning.enforcedAttributes[name] && cleaning.enforcedAttributes[name].indexOf(attr) != -1)) {
                            if (cleaning.protocolAttributes) {
                                for (let protocolAttribute of cleaning.protocolAttributes.filter(p => p.element == name && p.attribute == attr)) {
                                    let supportedProtocols = protocolAttribute.protocols;
                                    let actualValue = node.getAttribute(attr);
                                    let actualProtocol = actualValue ? actualValue.split(":")[0] : "unspecified";
                                    if (supportedProtocols.indexOf(actualProtocol) == -1) {
                                        results.push(`<b>${attr}</b> of <b>${name}</b> uses an unsupported protocol: <b>${actualProtocol}</b> `);
                                    }
                                }
                            }
                        }
                        else {
                            results.push(`<b>${attr}</b> is not a supported attribute of <b>${name}</b>`);
                        }
                    }
                }
            });
            return results;
        }
        applyServerCleaning() {
            let that = this;
            let cleaning = globals_1.globalMatrix.ItemConfig.getCleanupRules();
            if (!cleaning) {
                // the server does not care
                return this.text;
            }
            this.text = DOMPurify.sanitize(this.text, { ALLOWED_TAGS: cleaning.tags });
            let code = $("<div>").html(this.text);
            $.each(this.cleanConfig.blackLists.removeTags, function (csidx, tag) {
                $(tag, code).each(function (idx, cb) { $(cb).remove(); });
            });
            this.text = code.html();
            $("*", code).each(function (idx, node) {
                let name = node.nodeName.toLowerCase();
                let attrs = node.getAttributeNames();
                // check attributes
                for (let attIdx = 0; attIdx < attrs.length; attIdx++) {
                    let attr = attrs[attIdx].toLowerCase();
                    if ((cleaning.attributes[":all"] && cleaning.attributes[":all"].indexOf(attr) != -1) ||
                        (cleaning.attributes[name] && cleaning.attributes[name].indexOf(attr) != -1) ||
                        (cleaning.enforcedAttributes[name] && cleaning.enforcedAttributes[name].indexOf(attr) != -1)) {
                        if (cleaning.protocolAttributes) {
                            for (let protocolAttribute of cleaning.protocolAttributes.filter(p => p.element == name && p.attribute == attr)) {
                                let supportedProtocols = protocolAttribute.protocols;
                                let actualValue = node.getAttribute(attr);
                                let actualProtocol = actualValue ? actualValue.split(":")[0] : "unspecified";
                                if (supportedProtocols.indexOf(actualProtocol) == -1) {
                                    node.removeAttribute(attr);
                                }
                            }
                        }
                    }
                    else {
                        node.removeAttribute(attr);
                    }
                }
            });
            this.text = code.html();
        }
        applyWiki() {
            let that = this;
            this.replaceCode();
            this.replaceList("*", "<ul>", "</ul>");
            this.replaceList("#", "<ol>", "</ol>");
            this.replaceList("?", "<ol type='A'>", "</ol>");
            this.replaceTable();
        }
        replaceCode() {
            let that = this;
            let content = $("<div>").html(this.text);
            let listLevel = 0;
            let newHTML = "";
            let inCode = false;
            let firstCodeLine = false;
            $.each(content[0].childNodes, function (childIdx, child) {
                let html = child.outerHTML ? child.outerHTML : child.textContent;
                let text = child.textContent;
                if (!inCode && text.indexOf("{{{") == 0) {
                    newHTML += "<pre>";
                    inCode = true;
                    firstCodeLine = true;
                }
                else if (inCode && text.indexOf("}}}") == 0) {
                    newHTML += "</pre>";
                    inCode = false;
                }
                else if (inCode) {
                    if (!firstCodeLine) {
                        newHTML += "\n";
                    }
                    else {
                        firstCodeLine = false;
                    }
                    newHTML += text;
                }
                else {
                    newHTML += html;
                }
            });
            // in case table did not end in text
            if (inCode) {
                newHTML += "</pre>";
            }
            this.text = newHTML;
        }
        replaceTable() {
            let that = this;
            let content = $("<div>").html(this.text);
            let listLevel = 0;
            let newHTML = "";
            let inTable = false;
            $.each(content[0].childNodes, function (childIdx, child) {
                let html = child.outerHTML ? child.outerHTML : child.textContent;
                let text = child.textContent;
                let isTableLine = text.indexOf("|") == 0 && text.split("|").length > 2; // at least 2 | one of them in first pos
                let isTableLineHeader = text.indexOf("||") == 0 && text.split("||").length > 2; // at least 2 | one of them in first pos
                if (child.nodeName == "PRE") {
                    isTableLine = false;
                    isTableLineHeader = false;
                }
                else if (inTable && !isTableLine) {
                    newHTML += "</table>";
                    newHTML += html;
                    inTable = false;
                }
                else if (!inTable && isTableLine) {
                    newHTML += "<table class='table table-bordered'>";
                    inTable = true;
                }
                if (isTableLineHeader) {
                    newHTML += "<tr>";
                    $.each(text.split("||"), function (idx, part) {
                        if (idx != 0 && (idx != text.split("||").length - 1 || part != "")) {
                            newHTML += "<td><b>" + part + "</b></td>";
                        }
                    });
                    newHTML += "</tr>";
                }
                else if (isTableLine) {
                    newHTML += "<tr>";
                    $.each(text.split("|"), function (idx, part) {
                        if (idx != 0 && (idx != text.split("|").length - 1 || part != "")) {
                            newHTML += "<td>" + part + "</td>";
                        }
                    });
                    newHTML += "</tr>";
                }
                else {
                    newHTML += html;
                }
            });
            // in case table did not end in text
            if (inTable) {
                newHTML += "</table>";
                inTable = false;
            }
            this.text = newHTML;
        }
        replaceList(bullet, ul, eul) {
            let that = this;
            let content = $("<div>").html(this.text);
            let listLevel = 0;
            let newHTML = "";
            $.each(content[0].childNodes, function (childIdx, child) {
                let html = child.outerHTML ? child.outerHTML : child.textContent;
                let text = child.textContent;
                let inner = child.innerHTML ? child.innerHTML : child.textContent;
                let lineListLevel = that.getListLevel(text, bullet);
                if (child.nodeName == "PRE") {
                    newHTML += html;
                    lineListLevel = 0;
                }
                else if (lineListLevel > 0) {
                    // insert ul's
                    for (var ill = 0; ill < lineListLevel - listLevel; ill++) {
                        newHTML += ul;
                    }
                    // or close
                    for (var ill = 0; ill < listLevel - lineListLevel; ill++) {
                        newHTML += eul;
                    }
                    // ignore the <p> and remove first lineListLevel *s
                    for (let llidx = 0; llidx < lineListLevel; llidx++) {
                        inner = inner.replace(bullet, "");
                    }
                    newHTML += "<li>" + inner + "</li>";
                }
                else {
                    // insert end ul's
                    for (var ill = 0; ill < listLevel - lineListLevel; ill++) {
                        newHTML += eul;
                    }
                    newHTML += html;
                }
                // store current list level
                listLevel = lineListLevel;
            });
            // in case list did not end in text
            for (var ill = 0; ill < listLevel; ill++) {
                newHTML += eul;
            }
            this.text = newHTML;
        }
        getListLevel(text, bullet) {
            if (!text)
                return 0;
            let idx = 0;
            while (text.length > idx && text[idx] == bullet) {
                idx++;
            }
            return idx;
        }
        getText() {
            return this.text;
        }
        setMaxImageSize() {
            let code = $("<div>").html(this.text);
            $("img", code).each(function (idx, img) {
                $(img).css("max-width", "604px"); // 16 cm
                $(img).css("max-height", "800px"); // 22 cm            
            });
            this.text = code.html();
        }
        replaceCount(what, wth) {
            let replaced = this.text.indexOf(what) != -1;
            this.replaceNoCount(what, wth);
            return replaced ? 1 : 0;
        }
        replaceNoCount(what, wth) {
            this.text = this.text.replace(new RegExp(what, 'g'), wth);
        }
        replaceTags(cleaningLevel) {
            let code = $("<div>").html(this.text);
            let count = 0;
            $.each((cleaningLevel == HTMLCleaner.CleanLevel.StrictDoc) ? this.cleanConfig.tagReplacementsDoc : this.cleanConfig.tagReplacements, function (tgidx, tr) {
                let replaced = false;
                do {
                    replaced = false;
                    $(tr.what, code).each(function (idx, x) {
                        let y = $(tr.with).html($(x).html());
                        $(x).replaceWith(y);
                        replaced = true;
                        count++;
                    });
                } while (replaced);
            });
            this.text = code.html();
            return count;
        }
        removeTags() {
            let code = this.autoEscape ? $("<div>").text(this.text) : $("<div>").html(this.text); // text escapes < 
            $.each(this.cleanConfig.blackLists.removeTags, function (csidx, tag) {
                $(tag, code).each(function (idx, cb) { $(cb).remove(); });
            });
            this.text = code.html();
        }
        removeInsideTags() {
            let that = this;
            let code = $("<div>").html(this.text);
            $.each(this.cleanConfig.blackLists.keepOnlyInside, function (csidx, tag) {
                $(tag, code).contents().unwrap();
            });
            this.text = code.html();
        }
        // clean inline style: allow only stuff which can be created with the editor
        cleanInlineStyle() {
            let that = this;
            let code = $("<div>").html(this.text);
            $("*", code).each(function (idx, node) {
                let newStyle = [];
                let style = $(node).attr("style");
                if (style) {
                    let sns = style.replace(/ /g, ""); // note this could cause problems with font names with spaces, but these are removed anyway
                    $.each(that.cleanConfig.whiteLists.styles, function (csidx, conf) {
                        if (conf.tagName === "*" || conf.tagName === $(node).prop("tagName")) {
                            $.each(conf.allowed, function (id, ks) {
                                if (sns.indexOf(ks) !== -1) {
                                    newStyle.push(ks);
                                }
                            });
                        }
                    });
                    let padded = ";" + sns + ";";
                    // background and foreground colors
                    if ($(node).prop("tagName") === "SPAN") {
                        let bc = padded.match(/;background-color[^;]+/);
                        if (bc && bc.length > 0) {
                            newStyle.push(bc[bc.length - 1].substr(1));
                        }
                        let fc = padded.match(/;color[^;]+/);
                        if (fc && fc.length > 0) {
                            newStyle.push(fc[fc.length - 1].substr(1));
                        }
                    }
                    // width and height of images
                    if ($(node).prop("tagName") === "IMG") {
                        let iw = padded.match(/;width[^;]+/);
                        if (iw && iw.length > 0) {
                            newStyle.push(iw[iw.length - 1].substr(1));
                        }
                        let ih = padded.match(/;height[^;]+/);
                        if (ih && ih.length > 0) {
                            newStyle.push(ih[ih.length - 1].substr(1));
                        }
                    }
                    if (newStyle.length > 0) {
                        $(node).attr("style", newStyle.join(";"));
                    }
                    else {
                        $(node).removeAttr("style");
                    }
                }
            });
            this.text = code.html();
        }
        // clean classes: only some classes are meaningful
        cleanClasses() {
            let that = this;
            let code = $("<div>").html(this.text);
            $("*", code).each(function (idx, node) {
                let newClasses = [];
                let cs = $(node).attr("class");
                if (cs) {
                    let classes = cs.split(" ");
                    $.each(that.cleanConfig.whiteLists.classes, function (csidx, conf) {
                        if (conf.tagName === "*" || conf.tagName === $(node).prop("tagName")) {
                            $.each(conf.allowed, function (id, ks) {
                                if (classes.indexOf(ks) !== -1) {
                                    newClasses.push(ks);
                                }
                            });
                        }
                    });
                }
                // always make nice bordered tables with full width
                if ($(node).prop("tagName") === "TABLE") {
                    newClasses.push("table");
                    newClasses.push("table-bordered");
                }
                $(node).removeAttr("class");
                if (newClasses.length > 0) {
                    $(node).attr("class", newClasses.join(" "));
                }
            });
            this.text = code.html();
        }
        // clean properties: only some properites can exist
        removeProps(node, whiteList) {
            let attributes = node[0].attributes;
            let i = attributes.length;
            while (i--) {
                var attr = attributes[i];
                if (whiteList.indexOf(attr.name) == -1 && attr.name.indexOf("data-") !== 0 && attr.name != "class" && attr.name != "style") {
                    node.removeAttr(attr.name);
                }
            }
        }
        cleanProperties() {
            let that = this;
            let code = $("<div>").html(this.text);
            $("*", code).each(function (idx, node) {
                let hasRule = false;
                $.each(that.cleanConfig.whiteLists.properties, function (csidx, conf) {
                    if (conf.tagName === $(node).prop("tagName")) {
                        hasRule = true;
                        that.removeProps($(node), conf.allowed);
                    }
                });
                if (!hasRule) {
                    that.removeProps($(node), []);
                }
                ;
            });
            this.text = code.html();
        }
        cleanData() {
            let that = this;
            let code = $("<div>").html(this.text);
            $("*", code).each(function (idx, node) {
                // node jquery getAttr(does not work for stuff like data-vr-xxxx, it will return the attribute name vrXxxx instead of vr-xxxx
                let toRemove = [];
                $.each(node.attributes, function (key, attr) {
                    if (attr.name.indexOf("data-") === 0) {
                        let attrName = attr.name.replace("data-", "");
                        let isWhiteListed = false;
                        $.each(that.cleanConfig.whiteLists.data, function (csidx, conf) {
                            if (conf.tagName === $(node).prop("tagName") && conf.allowed.indexOf(attrName) !== -1) {
                                isWhiteListed = true;
                            }
                        });
                        if (!isWhiteListed) {
                            toRemove.push(attrName);
                        }
                    }
                });
                $.each(toRemove, function (ridx, remove) {
                    node.removeAttribute("data-" + remove);
                });
            });
            this.text = code.html();
        }
        removeUseLessStuff() {
            let keepGoing = true;
            while (keepGoing) {
                let code = $("<div>").html(this.text);
                keepGoing = this.removeSpansWithoutStyle(code);
                keepGoing = keepGoing || this.removeEmpty(code);
                keepGoing = keepGoing || this.unwrapEmptyStuff(code, "div", "DIV");
                keepGoing = keepGoing || this.unwrapEmptyStuff(code, "div", "P");
                // removing the fiv with a span inside is bad, the div make a paragraph
                // keepGoing = keepGoing || this.unwrapEmptyStuff( code, "div","SPAN");
                keepGoing = keepGoing || this.unwrapEmptyStuff(code, "div", "UL");
                this.text = code.html();
                keepGoing = keepGoing || this.removeDivDiv();
            }
        }
        handleWordLists() {
            let that = this;
            /*
             *
             * <p class="MsoListParagraphCxSpFirst" style="....">
             * <!--[if !supportLists]--><span style="..;">...</span><!--[endif]-->      QMS: this is the core of the quality management system, it will contain all your SOPs, quality work instructions, forms and templates, etc.<o:p></o:p></p>
             *
             * <ul><li>QMS...</li>
      <p class="MsoListParagraphCxSpMiddle" style="text-indent:-.25in;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family: Symbol"><span style="font-variant-numeric: normal; font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &quot;Times New Roman&quot;;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><!--[endif]-->sadasdada<o:p></o:p></p>
      <p class="MsoListParagraphCxSpMiddle" style="text-indent:-.25in;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family: Symbol"><span style="font-variant-numeric: normal; font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &quot;Times New Roman&quot;;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><!--[endif]-->QMS-FILE: this project will contain the plans, reports and records of your application of the quality system, e.g. audit plans and reports, management review minutes, etc.<o:p></o:p></p>
      <p class="MsoListParagraphCxSpLast" style="text-indent:-.25in;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="font-famil
             *
             *
             */
            // replace the funny points
            this.text = this.text.replace(/<!--\[if !supportLists]-->.*?<!--\[endif]-->/g, "");
            let code = $("<div>").html(this.text);
            $.each($("[class$='CxSpFirst']", code), function (idx, li) {
                let next = $(li).next();
                let lstart = $("<ul>").append($("<li>").append(($(li).html())));
                $(li).replaceWith(lstart);
                let level = 0;
                let levelStack = [lstart];
                while (next && next.length > 0) {
                    let x = next.next();
                    if (next.is("[class$='CxSpMiddle']") || next.is("[class$='CxSpLast']")) {
                        let nextLevel = level;
                        let nextStyle = next.attr("style");
                        if (!nextStyle || nextStyle.indexOf("level1") != -1)
                            nextLevel = 0;
                        else if (nextStyle.indexOf("level2") != -1)
                            nextLevel = 1;
                        else if (nextStyle.indexOf("level3") != -1)
                            nextLevel = 2;
                        else if (nextStyle.indexOf("level4") != -1)
                            nextLevel = 3;
                        else if (nextStyle.indexOf("level5") != -1)
                            nextLevel = 4;
                        else if (nextStyle.indexOf("level6") != -1)
                            nextLevel = 5;
                        if (nextLevel === level) {
                            lstart.append($("<li>").append($(next).html()));
                        }
                        else if (nextLevel > level) {
                            // indent
                            let newStart = $("<ul>").append($("<li>").append(($(next).html())));
                            levelStack.push(newStart);
                            lstart.append(newStart);
                            lstart = newStart;
                        }
                        else {
                            // outdent
                            if (nextLevel < levelStack.length) {
                                lstart = levelStack[nextLevel]; // go back to good level and remove other lists
                                levelStack.splice(nextLevel + 1, 100);
                            }
                            else {
                                // doesn't make sense really
                                lstart = $("<ul>").append($("<li>").append(($(li).html())));
                                levelStack.push(lstart);
                            }
                            lstart.append($("<li>").append($(next).html()));
                        }
                        level = nextLevel;
                        $(next).remove();
                    }
                    next = x;
                }
            });
            this.text = code.html();
        }
        // <span>a<span> -> a
        // <span>a<span>b</span><span> -> b
        // <span>a<span style='c'>b</span><span> -> <span style='c'>b</span>
        removeSpansWithoutStyle(node) {
            let replaced = false;
            $.each($("span", node), function (idx, span) {
                let hasMeta = $(span).attr("style") || $(span).attr("class") || $(span).attr("data");
                if (!hasMeta) {
                    replaced = true;
                    $(span).replaceWith($(span).html());
                }
            });
            return replaced;
        }
        removeEmpty(node) {
            let replaced = false;
            $.each(this.cleanConfig.blackLists.removeEmpty, function (idx, re) {
                $.each($(re, node), function (idx, p) {
                    if ($(p).html() === "") {
                        replaced = true;
                        $(p).remove();
                    }
                });
            });
            return replaced;
        }
        unwrapEmptyStuff(node, outer, inner) {
            let unwraped = false;
            $(outer, node).each(function (idx, out) {
                let hasMeta = $(out).attr("style") || $(out).attr("class") || $(out).attr("data");
                if (!hasMeta && out.children.length == 1 && out.children[0].tagName === inner && out.innerHTML == out.children[0].outerHTML) {
                    //console.log( out.tagName + ": " + out.innerHTML )
                    unwraped = true;
                    $(out).contents().unwrap();
                }
            });
            return unwraped;
        }
        removeDivDiv() {
            let replaced = this.text;
            this.text = this.text.replace(/<div><\/div><div>/g, "<div>");
            //if(replaced != this.text) console.log( "removed <div></div><div></div>");
            return replaced != this.text;
        }
    }
    exports.HTMLCleaner = HTMLCleaner;
    (function (HTMLCleaner) {
        let CleanLevel;
        (function (CleanLevel) {
            CleanLevel[CleanLevel["PurifyOnly"] = 0] = "PurifyOnly";
            CleanLevel[CleanLevel["Basic"] = 1] = "Basic";
            CleanLevel[CleanLevel["Soft"] = 2] = "Soft";
            CleanLevel[CleanLevel["Strict"] = 3] = "Strict";
            CleanLevel[CleanLevel["BasicSafety"] = 4] = "BasicSafety";
            CleanLevel[CleanLevel["StrictDoc"] = 5] = "StrictDoc";
            CleanLevel[CleanLevel["Server"] = 6] = "Server"; // server like cleaning -> remove all but a whitelist
        })(CleanLevel = HTMLCleaner.CleanLevel || (HTMLCleaner.CleanLevel = {}));
    })(HTMLCleaner || (HTMLCleaner = {}));
    exports.HTMLCleaner = HTMLCleaner;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/*

known tags
----------
HR, A, SPAN, BR, TABLE, IMG, P, DIV, TR,TD, UL, OL, LI, blockquote, PRE


data
----
SPAN  data-mid="1489062317559"

*/ 


/***/ }),
/* 68 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.JSONTools = void 0;
    class JSONTools {
        constructor(logger) {
            this.logger = logger;
        }
        cloner2(src) {
            return $.extend(true, {}, { x: src }).x;
        }
        mergeOptions(defaultOptions, options) {
            let newOptions = this.clone(defaultOptions);
            // make sure there is a parameter object
            if (!newOptions.parameter) {
                newOptions['parameter'] = {};
            }
            // copy parameters one by one
            if (options.parameter) {
                for (var name in options.parameter) {
                    newOptions.parameter[name] = options.parameter[name];
                }
            }
            // copy other values
            for (var name in options) {
                if (name != 'parameter') {
                    newOptions[name] = options[name];
                }
            }
            // use parameters to overwrite some default values
            if (this.isTrue(newOptions.parameter.readonly)) {
                newOptions.canEdit = false;
            }
            return newOptions;
        }
        // overwrite default options
        setOptions(newOptions, options) {
            // make sure there is a parameter object
            if (!newOptions.parameter) {
                newOptions['parameter'] = {};
            }
            // copy parameters one by one
            if (options.parameter) {
                for (var name in options.parameter) {
                    newOptions.parameter[name] = options.parameter[name];
                }
            }
            // copy other values
            for (var name in options) {
                if (name != 'parameter') {
                    newOptions[name] = options[name];
                }
            }
            // use parameters to overwrite some default values
            if (this.isTrue(newOptions.parameter.readonly)) {
                newOptions.canEdit = false;
            }
            // handle readonly for ACLs
            if (this.isTrue(newOptions.parameter.readonlyACL)) {
                newOptions.canEdit = false;
            }
            return newOptions;
        }
        isTrue(obj) {
            if (obj && (obj.toString().toLowerCase() === "true" || obj.toString() === "1")) {
                return true;
            }
            return false;
        }
        isFalse(obj) {
            if (typeof obj == "undefined") {
                return false;
            }
            if (obj == false || obj == 0 || obj.toString().toLowerCase() === "false" || obj.toString() === "0") {
                return true;
            }
            return false;
        }
        fromString(str) {
            var result = { status: 'empty', value: {} };
            if (str && str !== "") {
                // first replace all single quotes outside of double quotes with "
                var strp = str.replace(/(')(?=(?:[^"]|"[^"]*")*$)/g, '"').replace(/(\r\n|\n|\r)/gm, "");
                try {
                    result.value = JSON.parse(strp);
                    result.status = 'ok';
                }
                catch (err) {
                    try {
                        result.value = JSON.parse(str);
                        result.status = 'ok';
                    }
                    catch (err) {
                        this.logger.log("error", "Error trying to parse configuration parameter: " + str);
                        this.logger.log("error", "Error was:" + err);
                        result.status = 'error';
                    }
                }
            }
            return result;
        }
        clone(src) {
            var b = this.cloner2(src);
            return b;
        }
    }
    exports.JSONTools = JSONTools;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 69 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(12), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, index_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.LabelSwitches = exports.LabelTools = void 0;
    class LabelTools {
        constructor() {
            this.ignoreProjectFilter = false;
            this.activeFilter = "";
            // returns the background color of the main tool bar to be used if filters are activated
        }
        getFilterColor() {
            var labels = globals_1.globalMatrix.ItemConfig.getLabelsConfig();
            if (!labels || !labels.filterBackgroundColor) {
                return null;
            }
            return labels.filterBackgroundColor;
        }
        ;
        // return list of selected filters as , separated list
        getFilter() {
            if (this.ignoreProjectFilter) {
                return "";
            }
            var filters = [];
            var labelsAll = this.getLabelNames();
            if (labelsAll.length === 0) {
                return "";
            }
            var stored = this.activeFilter;
            if (!stored || stored === "") {
                return "";
            }
            // only return filters which (still) exist 
            var cs = stored.split(",");
            $.each(cs, function (idx, sf) {
                if (labelsAll.indexOf(sf.replace("!", "")) > -1) {
                    filters.push(sf);
                }
            });
            return filters.length > 0 ? filters.join(",") : "";
        }
        ;
        getDisplayName(labelId) {
            let labels = this.getLabelList();
            let displayName = "";
            $.each(labels, function (idx, label) {
                if (label.label == labelId) {
                    displayName = label.displayName;
                    if (label.style.label.on.displayName) {
                        displayName = label.style.label.on.displayName;
                    }
                }
            });
            return displayName;
        }
        getFilterName(labelId) {
            let labels = this.getLabelList();
            let displayName = "";
            $.each(labels, function (idx, label) {
                if (label.label == labelId) {
                    displayName = label.displayName;
                    if (label.style && label.style.filter && label.style && label.style.filter.on && label.style.filter.on.displayName) {
                        displayName = label.style.filter.on.displayName;
                    }
                }
            });
            return displayName;
        }
        // return the existing labels for the passed types (or all labels if no type is passed)
        getLabelDefinitions(categories) {
            var all = this.getLabelList();
            if (!categories || categories.length === 0) {
                return all;
            }
            let relevant = [];
            let relevantLabel = [];
            $.each(all, function (lidx, label) {
                $.each(label.categories, function (cidx, category) {
                    if (categories.indexOf(category) > -1 && relevant.indexOf(label.label) === -1) {
                        relevant.push(label.label);
                        relevantLabel.push(label);
                    }
                });
            });
            return relevantLabel;
        }
        ;
        setFilter(filter) {
            this.activeFilter = filter.join(",");
        }
        ;
        /* clean up the set labels: in case a set label is in review or design review group,
            it is possible that the label is removed from the list of set labels / replaced by another label in the group.
    
            This depends on the groups's setting.
    
            @param addXor If no label is set in a xor group, the default can be automatically set.
        
            @return the list of labels after the review groups have been reset
        
         */
        resetReviewLabels(labelIds, category, addXor) {
            let that = this;
            let cleaned = [];
            // get label groups
            let groups = this.getLabelGroups();
            let labelList = this.getLabelList();
            // copy all lables besides the review labels
            $.each(labelIds, function (labeldIdx, label) {
                let isReviewLabel = false;
                for (var gid = 0; gid < groups.length; gid++) {
                    if (((groups[gid].selection === "review" && matrixlib_1.ml.JSON.isTrue(groups[gid].reset)) ||
                        (groups[gid].selection === "design_review" && !matrixlib_1.ml.JSON.isFalse(groups[gid].reset))) &&
                        groups[gid].labels.indexOf(label) !== -1) {
                        isReviewLabel = true;
                    }
                }
                if (!isReviewLabel) {
                    cleaned.push(label);
                }
            });
            // add all default review states - if no other label is set in the review group
            for (var gid = 0; gid < groups.length; gid++) {
                if ((groups[gid].selection === "review" ||
                    (addXor && groups[gid].selection === "xor")) &&
                    groups[gid].default) {
                    var groupIsSet = false;
                    $.each(cleaned, function (cleanIdx, cleanLabel) {
                        if (groups[gid].labels.indexOf(cleanLabel) !== -1) {
                            groupIsSet = true;
                        }
                    });
                    if (!groupIsSet) {
                        // verify if label actually is defined for group...
                        var defaultIsForType = false;
                        $.each(labelList, function (idx, label) {
                            if (groups[gid].default === label.label && label.categories.indexOf(category) !== -1) {
                                defaultIsForType = true;
                            }
                        });
                        if (defaultIsForType) {
                            cleaned.push(groups[gid].default);
                        }
                    }
                }
            }
            return cleaned;
        }
        ;
        /* return the list of default labels for a category */
        getDefaultLabels(category) {
            let that = this;
            // get current positive filters
            let currentFilter = this.getFilter();
            let posFilter = [];
            $.each(currentFilter.split(","), function (fi, f) {
                if (f.indexOf("!") !== 0) {
                    posFilter.push(f);
                }
            });
            // each label which is not in a xor/review group can be default
            let defaultLabels = [];
            let labelList = this.getLabelList();
            $.each(labelList, function (idx, label) {
                let group = that.getGroupOfLabel(label.label);
                if (group && label.categories.indexOf(category) !== -1 && // label must exist for cateogry type
                    (group.selection !== 'xor' && group.selection !== 'review') && // it must not be in a xor or review group
                    (matrixlib_1.ml.JSON.isTrue(label.default) || // the default value must be set to on OR 
                        (label.default === "filter" && posFilter.indexOf(label.label) !== -1))) { // the default must be filter and it must be set in the current filter
                    defaultLabels.push(label.label);
                }
            });
            return this.resetReviewLabels(defaultLabels, category, true);
        }
        ;
        hasLabels() {
            return (this.getLabelList().length > 0);
        }
        ;
        // implement logic to set labels. 
        setLabels(oldLabelIds, labels) {
            let that = this;
            let old = oldLabelIds ? oldLabelIds.split(",") : [];
            $.each(labels, function (idx, label) {
                old = that.setLabel(old, label);
            });
            return old.join(",");
        }
        // implement logic to set a label. 
        // This depends on the type of group: for xor / review labels other group members must be reset
        setLabel(oldLabelIds, label) {
            let labelIds = matrixlib_1.ml.JSON.clone(oldLabelIds);
            if (labelIds.indexOf(label) !== -1) {
                // label already set - ignore
                return labelIds;
            }
            let group = this.getGroupOfLabel(label);
            if (!group || group.selection == "or") {
                // simple label without group / or group: just set it
                labelIds.push(label);
            }
            else if (group.selection == "xor" || group.selection == "review") {
                // remove all labels from group
                $.each(group.labels, function (idx, otherLabel) {
                    labelIds = labelIds.filter(function (existingLabel) {
                        return existingLabel != otherLabel;
                    });
                });
                // set the label
                labelIds.push(label);
            }
            else {
                matrixlib_1.ml.Logger.log("warn", "setLabel: unkown group type of label: '" + label + "'");
            }
            return labelIds;
        }
        ;
        // return the last time a label was set on a given item before a revision (=0 if any)
        getLastTimeLabelWasSet(itemId, label, beforeRevision) {
            let res = $.Deferred();
            globals_1.restConnection.getProject("labelhistory?itemRef=" + itemId).done((labelHistory) => {
                let itemHistory = labelHistory.entries.filter(entry => entry.itemRef == itemId);
                if (itemHistory.length == 0) {
                    // label was never set all good
                    res.resolve(0);
                }
                else {
                    let history = itemHistory[0].labels.filter(l => l.label == label);
                    if (history.length == 0 || history[0].set.length == 0) {
                        // label was never set all good
                        res.resolve(0);
                    }
                    else {
                        // ignore all sets after the beforeRevision  (unless 0 is passed)
                        let sets = history[0].set.filter(set => !beforeRevision || set.version < beforeRevision);
                        res.resolve(sets[sets.length - 1].version);
                    }
                }
            });
            return res;
        }
        // implement logic to reset a label. 
        // This depends on the type of group: for xor / review labels a default label might need to be set
        unsetLabel(oldLabelIds, label) {
            let labelIds = matrixlib_1.ml.JSON.clone(oldLabelIds);
            if (labelIds.indexOf(label) === -1) {
                // label is not actually set - ignore
                return labelIds;
            }
            let group = this.getGroupOfLabel(label);
            // remove the label
            labelIds = labelIds.filter(function (existingLabel) {
                return existingLabel != label;
            });
            if (!group || group.selection == "or") {
                // simple label without group / or group - nothing else to do
            }
            else if (group.selection == "xor" || group.selection == "review") {
                if (group.default) {
                    labelIds.push(group.default);
                }
            }
            else {
                matrixlib_1.ml.Logger.log("warn", "unsetLabel: unkown group type of label: '" + label + "'");
            }
            return labelIds;
        }
        ;
        compareLabels(before, after) {
            let result = {
                changed: false,
                added: [],
                removed: [],
                delta: ""
            };
            before = before || [];
            after = after || [];
            let delta = [];
            for (var idx = 0; idx < after.length; idx++) {
                if (before.indexOf(after[idx]) === -1) {
                    result.added.push(after[idx]);
                    delta.push(after[idx]);
                }
            }
            for (var idx = 0; idx < before.length; idx++) {
                if (after.indexOf(before[idx]) === -1) {
                    result.removed.push(before[idx]);
                    delta.push("-" + before[idx]);
                }
            }
            result.delta = delta.join(",");
            result.changed = result.added.length + result.removed.length > 0;
            return result;
        }
        hasCombinedFilterMenu() {
            let conf = globals_1.globalMatrix.ItemConfig.getSetting("labels");
            if (!conf) {
                return false;
            }
            let confJson = matrixlib_1.ml.JSON.fromString(conf);
            if (confJson.status !== "ok") {
                return false;
            }
            return matrixlib_1.ml.JSON.isTrue(confJson.value.useFilterMenu);
        }
        getLabelList() {
            let labelsAll = globals_1.globalMatrix.ItemConfig.getSetting("labels");
            if (!labelsAll) {
                return [];
            }
            let labelsJson = matrixlib_1.ml.JSON.fromString(labelsAll);
            if (labelsJson.status !== "ok" || !labelsJson.value.labels) {
                return [];
            }
            return labelsJson.value.labels;
        }
        getLabelNames() {
            let labelList = this.getLabelList();
            let allLabels = [];
            $.each(labelList, function (idx, label) {
                allLabels.push(label.label);
            });
            return allLabels;
        }
        getDesignReviews() {
            let labelsAll = globals_1.globalMatrix.ItemConfig.getSetting("labels");
            if (!labelsAll) {
                return [];
            }
            var labelsJson = matrixlib_1.ml.JSON.fromString(labelsAll);
            if (labelsJson.status !== "ok") {
                return [];
            }
            return labelsJson.value.design_reviews ? labelsJson.value.design_reviews : [];
        }
        getDesignReview(labelId) {
            var dr = this.getDesignReviews();
            for (var idx = 0; idx < dr.length; idx++) {
                if (dr[idx].label === labelId) {
                    return dr[idx];
                }
            }
            return null;
        }
        isFiltered(category, labels) {
            let filters = this.getFilter();
            if (!filters)
                return false; // no filters -> not filtered out 
            let isFilteredOut = false;
            // there are some filters so lets check
            let labelsSet = labels ? labels.split(",") : [];
            let labelsForItem = this.getLabelDefinitions([category]).map(function (labelDef) { return labelDef.label; });
            $.each(filters.split(","), function (fidx, filter) {
                let label = filter.replace("!", ""); // to get rid of negation of filters
                if (labelsForItem.indexOf(label) == -1)
                    return; // irrelevant, try next filter
                if (label != filter) { // negative filter
                    isFilteredOut = isFilteredOut || labelsSet.indexOf(label) != -1;
                }
                else {
                    isFilteredOut = isFilteredOut || labelsSet.indexOf(label) == -1;
                }
            });
            return isFilteredOut;
        }
        getLabelsOfLabelGroupsType(labelGroupType) {
            if (!labelGroupType) {
                return [];
            }
            let labels = [];
            $.each(this.getLabelGroups(), function (lgidx, lg) {
                if (lg.groupType == labelGroupType) {
                    labels = labels.concat(lg.labels);
                }
            });
            $.each(this.getDesignReviews(), function (lgidx, lg) {
                if (lg.groupType == labelGroupType) {
                    labels.push(lg.label);
                }
            });
            return labels;
        }
        getLabelGroups(category) {
            let labelsAll = globals_1.globalMatrix.ItemConfig.getSetting("labels");
            if (!labelsAll) {
                return [];
            }
            let labelsJson = matrixlib_1.ml.JSON.fromString(labelsAll);
            if (labelsJson.status !== "ok") {
                return [];
            }
            let labelList = this.getLabelList();
            let groups = labelsJson.value.groups ? labelsJson.value.groups : [];
            let design_reviews = this.getDesignReviews();
            // by default all labels end up in the last group
            for (var gid = 0; gid < groups.length; gid++) {
                // prepare to add label definitions of actual labels to display
                groups[gid].labelDef = [];
                // by default all filters are in "or" mode
                if (!groups[gid].filterSelection) {
                    groups[gid].filterSelection = "or";
                }
            }
            // now add actual labels to display to each group, any label should be displayed at most once
            $.each(labelList, function (idx, label) {
                if (category && label.categories.indexOf(category) === -1) {
                    // this is an item, and label does not exist for item
                    return;
                }
                // check if label is in group
                for (var gid = 0; gid < groups.length; gid++) {
                    for (var lid = 0; lid < groups[gid].labels.length; lid++) {
                        if (groups[gid].labels[lid] === label.label) {
                            groups[gid].labelDef.push(label);
                            return;
                        }
                    }
                }
                // check if label is in review
                for (var gid = 0; gid < design_reviews.length; gid++) {
                    if (design_reviews[gid].label === label.label) {
                        groups.push({ selection: "design_review", labels: [label.label], filterSelection: "or", labelDef: [label], reset: design_reviews[gid].reset,
                            filterMenu: design_reviews[gid].filterMenu });
                        return;
                    }
                }
                // create a new group
                groups.push({ virtualGroup: true, selection: "or", labels: [label.label], filterSelection: "or", labelDef: [label] });
            });
            return groups;
        }
        // returns the group of a label
        getGroupOfLabel(labelID) {
            let groups = this.getLabelGroups();
            for (var gid = 0; gid < groups.length; gid++) {
                if (groups[gid].labels.indexOf(labelID) !== -1) {
                    return groups[gid];
                }
            }
            return null;
        }
    }
    exports.LabelTools = LabelTools;
    LabelTools.timeWarpLabel = "_timewarp_";
    class LabelSwitches extends LabelTools {
        constructor(ui, canEdit, category, currentLabelsOn, mode, valueChanged, item, restrictEditTo) {
            super();
            this.lexist = false;
            this.dbClickCounter = 0;
            this.canAutoFill = false;
            // get label definitions
            let labelList = this.getLabelList();
            if (labelList.length === 0) {
                return;
            }
            // get all label names 
            let allLabels = this.getLabelNames();
            if (allLabels.length === 0) {
                return;
            }
            // there are some labels
            this.lexist = true;
            this.isFilter = category === null;
            // set other parameters
            this.ui = ui;
            this.canEdit = canEdit;
            this.category = category;
            this.currentLabelsOn = currentLabelsOn;
            this.mode = mode;
            this.valueChanged = valueChanged;
            this.item = item;
            this.restrictEditTo = restrictEditTo;
            // get label groups
            this.groups = this.getLabelGroups(category);
            this.showLabels();
        }
        showLabels() {
            let setting = globals_1.globalMatrix.ItemConfig.getLabelsConfig();
            // each group is a button group with at least one button inside
            for (var gid = 0; gid < this.groups.length; gid++) {
                if (this.groups[gid].labelDef.length === 0) {
                    continue; // next group
                }
                let group;
                let selectionMethod = this.isFilter ? this.groups[gid].filterSelection : this.groups[gid].selection;
                if (selectionMethod === "design_review" && this.mode !== "item_create") {
                    group = this.create_group_design_review(gid);
                }
                else if (selectionMethod === "review" && this.mode !== "item_create") {
                    group = this.create_group_review(gid);
                }
                else if (selectionMethod === "or") {
                    group = this.create_group_or(gid);
                    if (this.mode !== "doc_filter" && this.isFilter && this.groups[gid].filterMenu) {
                        if (this.hasCombinedFilterMenu()) {
                            this.add_to_global_dropdown(gid, group);
                        }
                        else {
                            this.create_dropdown_group(gid, group);
                        }
                    }
                }
                else if (selectionMethod === "xor" || (selectionMethod === "review" && this.mode === "item_create")) {
                    group = this.create_group_xor(gid);
                    if (this.mode === "item_create" && !matrixlib_1.ml.JSON.isTrue(this.groups[gid].defaultAsk)) {
                        group.hide();
                    }
                }
                // bug fix (groups are right to left in item title bar)
                if (group && this.mode == "item_title" && !setting.invertGroups) {
                    group.css("float", "none");
                }
            }
            // hack -> hide the empty label heading if there's no labels
            if (this.mode == "item_create" && this.groups.filter(g => !!g.defaultAsk || (g.labelDef && g.labelDef.filter(l => !!l.defaultAsk).length > 0)).length == 0) {
                // use does not need to set labels when creating new items
                $(".baseControlHelp", this.ui.parent()).hide();
            }
        }
        ;
        setEnabled(enabled) {
            if (enabled) {
                $("#labelDisabler").remove();
            }
            else {
                this.ui.css("position", "relative");
                $("<div id='labelDisabler'>").appendTo(this.ui);
            }
        }
        labelsExist() {
            return this.lexist;
        }
        canEditLabel(labelId) {
            if (!this.canEdit)
                return false;
            if (!this.restrictEditTo)
                return true;
            return this.restrictEditTo.indexOf(labelId) != -1;
        }
        /**
         *  this.ui elements for different label this.groups
         */
        create_group_or(gid) {
            let that = this;
            var btnGroup = $('<div class="btn-group labelTools">');
            this.ui.append(btnGroup);
            $.each(this.groups[gid].labelDef, function (idx, label) {
                label.isNegative = that.currentLabelsOn.indexOf(("!" + label.label)) > -1;
                label.isSelected = label.isNegative || that.currentLabelsOn.indexOf(label.label) > -1;
                var switchFunction; // single click
                var invertFunction; // dbl click for filter or null
                switchFunction = function (button) {
                    let rememberBefore = matrixlib_1.ml.JSON.clone(that.currentLabelsOn);
                    if (!that.canEditLabel(label.label)) {
                        return;
                    }
                    var click_label = button.data("label");
                    var click_gid = button.data("gid");
                    $.each(that.groups[click_gid].labelDef, function (idx, label) {
                        if (label.label === click_label) {
                            label.isSelected = !label.isSelected;
                            label.isNegative = false;
                        }
                    });
                    button.tooltip('hide');
                    button.replaceWith(that.createLabel(click_label, gid, switchFunction, invertFunction));
                    if (that.valueChanged) {
                        that.updateSelection();
                        that.valueChanged(that.currentLabelsOn);
                    }
                    that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                };
                if (that.isFilter && that.canEdit) {
                    invertFunction = function (button) {
                        var click_label = button.data("label");
                        var click_gid = button.data("gid");
                        let negativePrefix = "";
                        $.each(that.groups[click_gid].labelDef, function (idx, label) {
                            if (label.label === click_label) {
                                if (label.isSelected) {
                                    label.isNegative = !label.isNegative;
                                    negativePrefix = label.isNegative ? "!" : "";
                                }
                                else {
                                    label.isSelected = true;
                                    label.isNegative = true;
                                    negativePrefix = "!";
                                }
                            }
                        });
                        button.tooltip('hide');
                        button.replaceWith(that.createLabel(negativePrefix + click_label, gid, switchFunction, invertFunction));
                        if (that.valueChanged) {
                            that.updateSelection();
                            that.valueChanged(that.currentLabelsOn);
                        }
                    };
                }
                var btn = that.createLabel((label.isNegative ? "!" : "") + label.label, gid, switchFunction, invertFunction);
                // add button to group
                btnGroup.append(btn);
                // hide button if it should not be shown in create dialog
                if (that.mode === "item_create" && !matrixlib_1.ml.JSON.isTrue(label.defaultAsk)) {
                    btn.hide();
                }
            });
            return btnGroup;
        }
        ;
        triggerLabelChanged(before, after) {
            if (this.isFilter) {
                return;
            }
            let set = after.filter(function (label) { return before.indexOf(label) == -1; });
            let unset = before.filter(function (label) { return after.indexOf(label) == -1; });
            if (set.length > 0 || unset.length > 0) {
                index_1.MR1.triggerAfterLabelChange(this.item, set, unset);
            }
        }
        create_group_xor(gid) {
            let that = this;
            var btnGroup = $('<div class="btn-group labelTools">');
            this.ui.append(btnGroup);
            let canEditGroup = false;
            $.each(this.groups[gid].labelDef, function (idx, label) {
                if (that.canEditLabel(label.label)) {
                    canEditGroup = true;
                }
            });
            $.each(this.groups[gid].labelDef, function (idx, label) {
                label.isSelected = that.currentLabelsOn.indexOf(label.label) > -1;
                var switchFunction;
                switchFunction = function (button) {
                    let rememberBefore = matrixlib_1.ml.JSON.clone(that.currentLabelsOn);
                    if (!canEditGroup) {
                        return;
                    }
                    button.tooltip('hide');
                    var click_label = button.data("label");
                    var click_gid = button.data("gid");
                    $.each(that.groups[click_gid].labelDef, function (idx, label) {
                        // not possible to unselect a label, so clicked label will always be on
                        label.isSelected = label.label === click_label;
                        var newButton = that.createLabel(label.label, gid, switchFunction);
                        label.btn.replaceWith(newButton);
                        label.btn = newButton;
                    });
                    if (that.valueChanged) {
                        that.updateSelection();
                        that.valueChanged(that.currentLabelsOn);
                    }
                    that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                };
                label.btn = that.createLabel(label.label, gid, switchFunction);
                // add button to group
                btnGroup.append(label.btn);
            });
            return btnGroup;
        }
        ;
        create_group_review(gid) {
            let that = this;
            var btnGroup = $('<div class="btn-group labelTools">');
            this.ui.append(btnGroup);
            // special handling for review labels! if no review flag is set show it in item as not set
            var color = this.groups[gid].noColor ? this.groups[gid].noColor : "red";
            var icon = this.groups[gid].noIcon ? this.groups[gid].noIcon : null;
            var name = this.groups[gid].noName ? this.groups[gid].noName : (icon ? "" : "not set");
            // this will be a drop down button
            var btn;
            if (this.mode == "item_history") {
                // in history render a simplified version of labels to be more easily comparable
                btn = this.createButton("", gid, name, "", "", icon, null, null, "labelInHistory");
            }
            else {
                btn = this.createButton("", gid, name, color, "transparent", icon, null, null, "labelIsMenu");
            }
            // for reviews it is possible that no label is set or one... 
            // the one which is set is the only one displayed
            // figure out if the user can change something in group
            // canEdit must be true
            // but if this is a lock keeper, he can undo only his locks....
            let canEditGroup = false;
            $.each(this.groups[gid].labelDef, function (idx, label) {
                if (that.canEditLabel(label.label)) {
                    canEditGroup = true;
                }
                ;
            });
            $.each(this.groups[gid].labelDef, function (idx, label) {
                label.isSelected = false;
                if (that.currentLabelsOn.indexOf(label.label) !== -1) {
                    label.isSelected = true;
                    // this is part of drop down menu.... 
                    btn = that.createLabel(label.label, gid, function () { });
                    btn.addClass("labelIsMenu");
                }
            });
            var tooltip = this.groups[gid].tooltip ? this.groups[gid].tooltip : "";
            if (tooltip) {
                btn.tooltip({ title: tooltip, placement: "bottom", container: "body" });
            }
            // check if there are defined reviewers of label
            var userCanDo = globals_1.matrixSession.amIAllowedUser(this.groups[gid].reviewers);
            if (!userCanDo || this.mode === "item_print" || !canEditGroup) {
                // we are done... this is not interactive...
                btn.css("cursor", "inherit");
                btnGroup.append(btn);
                return btnGroup; //$("");
            }
            // add drop down menu
            btn.addClass("dropdown-toggle");
            btn.attr("data-toggle", "dropdown");
            btn.append("<span class='caret' style='margin-left:5px'/>");
            var ddbtn = $('<div class="dropdown">');
            ddbtn.append(btn);
            var options = $('<ul  class="dropdown-menu">');
            $.each(this.groups[gid].labelDef, function (idx, label) {
                var icon = "<span style='margin-right:8px'/>";
                var name = label.displayName ? label.displayName : "";
                if (label && label.style && label.style.label && label.style.label.on) {
                    if (label.style.label.on.icon) {
                        var color = label.style.label.on.foreground ? "color:" + label.style.label.on.foreground + ";" : "";
                        var bg = label.style.label.on.background ? "background-color:" + label.style.label.on.background + ";" : "";
                        icon = "<i class='fal fa-" + label.style.label.on.icon + "' style='margin-left:-10px;margin-right:2px; width:22px; padding: 4px; border-radius:var(--smallBorderRadius);" + color + bg + "' ></i>";
                    }
                    if (label.style.label.on.displayName) {
                        name = label.style.label.on.displayName;
                    }
                }
                var li = $("<li class='labelMenuEntry'></li>").html('<a href="javascript:void(0)" style="min-width:100%">' + icon + name + '</a>');
                li.data("label", label.label);
                li.data("gid", gid);
                options.append(li);
                li.click(function (e) {
                    $(".tooltip").remove();
                    let rememberBefore = matrixlib_1.ml.JSON.clone(that.currentLabelsOn);
                    // set just the selected label from the group
                    var group = that.groups[$(e.delegateTarget).data("gid")];
                    var selected = $(e.delegateTarget).data("label");
                    var askForComment = group.askForComment ? group.askForComment : false;
                    $.each(group.labelDef, function (idx, label) {
                        if (label.label === selected) {
                            askForComment = label.askForComment ? label.askForComment : askForComment;
                        }
                    });
                    function setLabel(comment) {
                        let labelsOff = [];
                        $.each(group.labelDef, function (idx, label) {
                            label.isSelected = label.label === selected;
                            if (!label.isSelected) {
                                labelsOff.push(label.label);
                            }
                        });
                        // set and save label
                        that.saveAfterLabelChange(comment);
                    }
                    ;
                    if (askForComment) {
                        $('#dialog_comment_text').val(globals_1.matrixSession.getComment());
                        $('#dialog_comment_ok').off("click");
                        $('#dialog_comment_nok').off("click");
                        $('#dialog_comment_ok').one("click", function () {
                            setLabel($('#dialog_comment_text').val());
                            that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                        });
                        $('#dialog_comment_nok').one("click", function () { });
                        $('#dialog_comment').modal({ backdrop: 'static' });
                    }
                    else {
                        setLabel();
                        that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                    }
                });
            });
            btnGroup.append(ddbtn);
            if (this.groups[gid].showComments && this.item && this.item.history) {
                var history = this.item.history;
                var reviews = 0;
                $.each(history, function (hixd, h) {
                    reviews += (h.action === 'reviewed') ? 1 : 0;
                });
                if (reviews > 0) {
                    options.append($("<li class='' >").html('<hr>'));
                    $.each(history, function (hixd, h) {
                        if (h.action === 'reviewed') {
                            options.append($(" <li class='reviewedCommentMenutitem' style='display:flex'>").html("<span class='hqlu'>" + h.user + "</span> <span class='hqld' >(" + h.dateUserFormat + "):</span> <span class='hqlc'>" + h.comment + '</span>'));
                        }
                    });
                    options.width(400 + ddbtn.width());
                    options.css("left", "-400px");
                }
            }
            ddbtn.append(options);
            return btnGroup;
        }
        ;
        saveAfterLabelChange(comment) {
            let that = this;
            // set label 
            that.updateSelection();
            // save: pass the labels to the touch, this overwrites the labels
            // a normal save reset's review labels!
            var mainComment = globals_1.matrixSession.getComment();
            if (comment) {
                globals_1.matrixSession.setComment(comment);
            }
            that.setEnabled(false); // save will render labels as readonly
            globals_1.app.setLabels({ labels: that.currentLabelsOn }).done(function () {
                // after save item will be repainted
                globals_1.matrixSession.setComment(mainComment);
            }).fail(() => {
                that.setEnabled(true); // save will render labels 'normally'
            });
        }
        create_group_design_review(gid) {
            let that = this;
            var btnGroup = $('<div class="btn-group labelTools">');
            this.ui.append(btnGroup);
            $.each(this.groups[gid].labelDef, function (idx, label) {
                label.isNegative = that.currentLabelsOn.indexOf(("!" + label.label)) > -1;
                label.isSelected = label.isNegative || that.currentLabelsOn.indexOf(label.label) > -1;
                var switchFunction; // single click
                var invertFunction; // dbl click for filter or null
                switchFunction = function (button) {
                    let rememberBefore = matrixlib_1.ml.JSON.clone(that.currentLabelsOn);
                    let click_label = button.data("label");
                    if (that.mode === "item_print" || !that.canEditLabel(click_label)) {
                        return;
                    }
                    var click_gid = button.data("gid");
                    // get the label definition
                    var labelDef;
                    $.each(that.groups[click_gid].labelDef, function (idx, label) {
                        if (label.label === click_label) {
                            labelDef = label;
                        }
                    });
                    // get review job details
                    let review_job = that.getDesignReview(click_label);
                    // check if there are defined reviewers of label
                    let userCanDo = globals_1.matrixSession.amIAllowedUser(review_job.reviewerField ? that.getUsersFromField(review_job.reviewerField) : review_job.reviewers);
                    if (!userCanDo) {
                        matrixlib_1.ml.UI.showError("You do not have sufficient rights to perform review", "", 3000);
                    }
                    button.tooltip('hide');
                    function setReviewResult(comment, passed) {
                        $.each(that.groups[click_gid].labelDef, function (idx, label) {
                            if (label.label === click_label) {
                                label.isSelected = passed;
                                label.isNegative = false;
                            }
                        });
                        button.replaceWith(that.createLabel(click_label, gid, switchFunction, invertFunction));
                        // set and save label
                        that.saveAfterLabelChange(comment);
                    }
                    ;
                    // here we can show a dialog (since this never happens while creating an item
                    function reviewStatusChange() {
                        var okButton = $(".ui-dialog-buttonpane button:contains('Pass')", globals_1.app.dlgForm.parent());
                        var failButton = $(".ui-dialog-buttonpane button:contains('Fail')", globals_1.app.dlgForm.parent());
                        if (!userCanDo) {
                            okButton.prop("disabled", true);
                            okButton.addClass("ui-state-disabled");
                            failButton.prop("disabled", true);
                            failButton.addClass("ui-state-disabled");
                            return;
                        }
                        var isOk = drComment.getController().getValue() !== "";
                        if (isOk) {
                            $.each($(".drcbcontrol"), function (idx, drcb) {
                                if (!$(drcb).data("new")) { // get the value directly from control
                                    isOk = false;
                                }
                            });
                        }
                        if (isOk) {
                            okButton.prop("disabled", false);
                            okButton.removeClass("ui-state-disabled");
                        }
                        else {
                            okButton.prop("disabled", true);
                            okButton.addClass("ui-state-disabled");
                        }
                    }
                    globals_1.app.dlgForm.hide();
                    globals_1.app.dlgForm.html("");
                    globals_1.app.dlgForm.removeClass("dlg-no-scroll");
                    globals_1.app.dlgForm.addClass("dlg-v-scroll");
                    var settingsUI = $("<div>");
                    settingsUI.append($("<h2>").html(review_job.reviewHelp));
                    $.each(review_job.reviewDetails, function (idx, rd) {
                        if (rd.type == "signature") {
                            settingsUI.append($("<p style='margin:0px 20px 10px 0px;font-weight: bold;'>").html(rd.name));
                            // do not allow chrome to fill passwords (quite a hack)
                            let autoFill = globals_1.matrixSession.getCustomerSettingJSON("autoFillSettings", {});
                            that.canAutoFill = autoFill.allowAutoFill || autoFill.allowLabelSignAutoFill;
                            let form = $('<form>').appendTo(settingsUI);
                            let table = $('<div class="signatureInfo input-group" style="margin-top:12px;width:100%">').appendTo(form);
                            let name = $("<input autocomplete='off' type='text' class='signatureInfo form-control' placeholder='enter user id' style='padding:8px'>");
                            let pwd = $("<input type='" + (that.canAutoFill ? "password" : "text") + "' class='review_password form-control' placeholder='password' style='margin: 0px 20px 20px 0px; width: 200px;'>");
                            let pwdSpan = $("<span class='input-group-btn'>").append(pwd);
                            table.append(name);
                            table.append(pwdSpan);
                            pwd.on("change keyup paste", function () {
                                reviewStatusChange();
                            });
                            pwd.on("keyup paste", function () {
                                pwd.attr("type", "password");
                            });
                            // set user name and reset password (in case it is a not allowed auto fill)
                            that.initPasswordField(name, pwd);
                        }
                        else {
                            settingsUI.append($("<div class='drcbcontrol'>").checkBox({
                                controlState: globals_1.ControlState.FormEdit,
                                canEdit: userCanDo,
                                fieldValue: "false",
                                help: rd.name,
                                valueChanged: function (checked) {
                                    var comment = drComment.getController().getValue() + "\n" + rd.name + " " + (checked ? "passed" : "failed");
                                    drComment.getController().setValue(comment);
                                    reviewStatusChange();
                                }
                            }));
                        }
                        settingsUI.append($("<p style='margin:-12px 20px 10px 26px'>").html(rd.help));
                    });
                    var drComment = $("<div id='designReviewComment'>").plainText({
                        controlState: globals_1.ControlState.FormEdit,
                        canEdit: userCanDo,
                        help: review_job.commentHeading ? review_job.commentHeading : "Design Review Comment",
                        fieldValue: globals_1.matrixSession.getComment(),
                        valueChanged: function () {
                            reviewStatusChange();
                        },
                        parameter: {
                            allowResize: true
                        }
                    });
                    settingsUI.append(drComment);
                    globals_1.app.dlgForm.append(settingsUI);
                    globals_1.app.dlgForm.dialog({
                        autoOpen: true,
                        title: review_job.reviewName,
                        height: globals_1.app.itemForm.height() * 0.9,
                        width: 730,
                        modal: true,
                        open: function () {
                            reviewStatusChange();
                        },
                        close: function () {
                        },
                        resizeStop: function () { },
                        buttons: [{
                                text: 'Pass',
                                class: 'btnDoIt',
                                click: function () {
                                    if ($(".review_password", globals_1.app.dlgForm).length) {
                                        let pwd = $(".review_password", globals_1.app.dlgForm).val();
                                        globals_1.app.checkPassword(pwd).done(function () {
                                            that.verifyRevisionTable(click_label, review_job.revisionTableName).done(() => {
                                                setReviewResult(drComment.getController().getValue(), true);
                                                that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                                            });
                                            globals_1.app.dlgForm.dialog("close");
                                        }).fail(function (jqxhr, textStatus, error) {
                                            matrixlib_1.ml.UI.showError("Incorrect  password!", "");
                                        });
                                    }
                                    else {
                                        setReviewResult(drComment.getController().getValue(), true);
                                        that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                                        globals_1.app.dlgForm.dialog("close");
                                    }
                                }
                            }, {
                                text: 'Fail',
                                class: 'btnDoIt2',
                                click: function () {
                                    setReviewResult(drComment.getController().getValue(), false);
                                    that.triggerLabelChanged(rememberBefore, that.currentLabelsOn);
                                    globals_1.app.dlgForm.dialog("close");
                                }
                            }, {
                                text: 'Cancel',
                                class: 'btnCancelIt',
                                click: function () {
                                    globals_1.app.dlgForm.dialog("close");
                                }
                            }
                        ]
                    });
                };
                if (that.isFilter && that.canEdit) {
                    invertFunction = function (button) {
                        var click_label = button.data("label");
                        var click_gid = button.data("gid");
                        $.each(that.groups[click_gid].labelDef, function (idx, label) {
                            if (label.label === click_label) {
                                if (label.isSelected) {
                                    label.isNegative = !label.isNegative;
                                }
                                else {
                                    label.isSelected = true;
                                    label.isNegative = true;
                                }
                            }
                        });
                        button.tooltip('hide');
                        button.replaceWith(that.createLabel(click_label, gid, switchFunction, invertFunction));
                        if (that.valueChanged) {
                            that.updateSelection();
                            that.valueChanged(that.currentLabelsOn);
                        }
                    };
                }
                var btn = that.createLabel((label.isNegative ? "!" : "") + label.label, gid, switchFunction, invertFunction);
                // add button to group
                btnGroup.append(btn);
                // hide button if it should not be shown in create dialog
                if (that.mode === "item_create") {
                    btn.hide();
                }
            });
            return btnGroup;
        }
        ;
        verifyRevisionTable(label, revisionTableName) {
            let res = $.Deferred();
            let that = this;
            if (!that.item) {
                // nothing to worry about - we are creating a new item
                res.resolve();
                return res;
            }
            if (!revisionTableName) {
                // nothing to worry about - this is a normal label
                res.resolve();
                return res;
            }
            let revisionTableField = globals_1.globalMatrix.ItemConfig.getFieldByName(that.category, revisionTableName);
            if (!revisionTableField) {
                // nothing to worry about - there is no revision table in this category
                matrixlib_1.ml.Logger.log("warn", `Label has revisionTableName '${revisionTableName}' defined but there is no such table in ${that.category}`);
                res.resolve();
                return res;
            }
            let revisionColumn;
            if (!revisionTableField.parameterJson || !revisionTableField.parameterJson.columns) {
                // nothing to worry about - there is no columns in table in this category
                matrixlib_1.ml.Logger.log("warn", `Label has revisionTableName '${revisionTableName}' defined but there are no columns defined ${that.category}`);
                res.resolve();
                return res;
            }
            for (let column of revisionTableField.parameterJson.columns) {
                if (column.editor == "revision") {
                    revisionColumn = column.field;
                }
            }
            if (!revisionColumn) {
                // nothing to worry about - there is no revision column in table
                matrixlib_1.ml.Logger.log("warn", `Label has revisionTableName '${revisionTableName}' defined but there is no revision column in table in ${that.category}`);
                res.resolve();
                return res;
            }
            if (revisionTableField.fieldType != "steplist") {
                matrixlib_1.ml.Logger.log("warn", `Label has revisionTableName '${revisionTableName}' defined but the field is not a table in ${that.category}`);
                res.resolve();
                return res;
            }
            let revisionTableVal = globals_1.app.getFieldValue(revisionTableField.id);
            let currentValue = that.getRevisionFromTable(revisionTableVal, revisionColumn);
            if (!currentValue) {
                // empty table
                matrixlib_1.ml.UI.showConfirm(-1, { title: `No revision defined in last row of table '${revisionTableName}'!`, ok: "Set Label", nok: "Cancel" }, () => { res.resolve(); }, () => { res.reject(); });
                return res;
            }
            let empty = false;
            for (let column of revisionTableField.parameterJson.columns) {
                if (!that.getRevisionFromTable(revisionTableVal, column.field)) {
                    empty = true;
                }
            }
            if (empty) {
                matrixlib_1.ml.UI.showConfirm(-1, { title: `Last row of table '${revisionTableName} has empty cells'!`, ok: "Set Label", nok: "Cancel" }, () => {
                    $(".modal-backdrop").remove();
                    that.compareRevisions(currentValue, revisionTableField.id, revisionColumn, label).done(() => {
                        res.resolve();
                    }).fail(() => {
                        res.reject();
                    }).always(() => {
                        $(".modal-backdrop").remove();
                    });
                }, () => { res.reject(); });
            }
            else {
                that.compareRevisions(currentValue, revisionTableField.id, revisionColumn, label).done(() => {
                    res.resolve();
                }).fail(() => {
                    res.reject();
                }).always(() => {
                    $(".modal-backdrop").remove();
                });
            }
            return res;
        }
        compareRevisions(currentRevision, versionTableField, revisionTableColumn, label) {
            let res = $.Deferred();
            let that = this;
            this.getLastTimeLabelWasSet(that.item.id, label, 0).done((lastRevision) => {
                if (!lastRevision) {
                    // it was never set ... no problem
                    res.resolve();
                }
                else {
                    globals_1.app.getItemAsync(that.item.id, lastRevision).done(function (lastSetVersion) {
                        let lv = lastSetVersion[versionTableField];
                        let fieldValue = JSON.parse(lv ? lv : "{}");
                        let previousRevision = fieldValue ? that.getRevisionFromTable(JSON.stringify(fieldValue), revisionTableColumn) : "";
                        if (currentRevision != previousRevision) {
                            // we assume all is good... 
                            res.resolve(currentRevision);
                        }
                        else {
                            matrixlib_1.ml.UI.showConfirm(-1, { title: `The current revision '${currentRevision}' is the same as it was when the label '${label}' was set the last time!`, ok: "Set Label", nok: "Cancel" }, () => { res.resolve(); }, () => { res.reject(); });
                        }
                    }).fail(function (error) {
                        res.reject(error);
                    });
                }
            });
            return res;
        }
        getRevisionFromTable(revisionTableVal, revisionColumn) {
            let revisionTable = (revisionTableVal ? JSON.parse(revisionTableVal) : []);
            if (!revisionTable.length) {
                // empty table
                return "";
            }
            return revisionTable[revisionTable.length - 1][revisionColumn];
        }
        // get a list of users / user groups from a drop down field
        getUsersFromField(fieldName) {
            let cat = matrixlib_1.ml.Item.parseRef(globals_1.app.getCurrentItemId()).type;
            let field = globals_1.globalMatrix.ItemConfig.getFieldByName(cat, fieldName);
            if (!field) {
                matrixlib_1.ml.Logger.log("warning", `the field ${fieldName} does not exist in category ${cat}. Cannot get users from that field.`);
                return [];
            }
            let val = globals_1.app.getFieldValue(field.id);
            return val.split(",");
        }
        initPasswordField(name, pwd) {
            name.val(globals_1.matrixSession.getUser() + (this.canAutoFill ? "" : " ")); // the " "  makes sure the password is not filled when loading
            name.attr("readonly", "readonly");
            if (this.canAutoFill)
                return;
            pwd.val("");
        }
        // move all buttons into one dropdown (for filter)
        add_to_global_dropdown(gid, btnGroup) {
            let that = this;
            var globalFilterMenu = this.ui.find(".globalFilterMenu");
            if (globalFilterMenu.length === 0) {
                var somethingSelected = this.currentLabelsOn.length > 0 ? "Filter" : "Filter";
                var menuGroup = $('<div id="setFilter"  class="btn-group dropdown">');
                var menuBtn = $('<button class="btn btn-default btn-xs dropdown-toggle filterMenu" data-toggle="dropdown">' + somethingSelected + '&nbsp;<span class="caret"></span></button>');
                var globalFilterMenu = $('<ul class="dropdown-menu globalFilterMenu" style="max-height:' + ($(window).height() - 100) + 'px" role="menu">');
                menuGroup.append(menuBtn).append(globalFilterMenu);
                this.ui.append(menuGroup);
                if (this.currentLabelsOn.length > 0) {
                    var reset = $('<a href="javascript:void(0)" id="resetFilter">Remove all filter</a>');
                    reset.click(function () {
                        that.valueChanged([]);
                    });
                    globalFilterMenu.append($("<li>").append(reset));
                }
            }
            // create menu section:
            // add line unless this is the first thing in the menu
            if ($(".globalFilterMenu li").length > 0) {
                globalFilterMenu.append("<li class='limenuLine'><span class='menuLine'></span></li>");
            }
            // add group name if there is one
            if (this.groups[gid].filterMenu && this.groups[gid].filterMenu.displayName) {
                let lastMenuHeadings = $(".menuHeading", globalFilterMenu);
                let lastIsSame = lastMenuHeadings.length && $(lastMenuHeadings[lastMenuHeadings.length - 1]).text() == this.groups[gid].filterMenu.displayName;
                if (!lastIsSame) {
                    globalFilterMenu.append("<li><span class='menuHeading'>" + this.groups[gid].filterMenu.displayName + "</span></li>");
                }
            }
            // move all buttons in a dropdown list with buttons unless they are selected 
            btnGroup.find("button").each(function (idx, btn) {
                var label = $(btn).data("label");
                if (that.currentLabelsOn.indexOf(("!" + label)) === -1 && that.currentLabelsOn.indexOf(label) === -1) {
                    globalFilterMenu.append($("<li class='btnline'>").append($('<a href="javascript:void(0)">').append(btn)));
                    var nf = $("<span class='negativeFilter'  title data-original-title='filter by label not set' >not</span>");
                    $(btn).parent().prepend(nf);
                    nf.click(function (e) {
                        var label = $(e.delegateTarget).data("label");
                        that.currentLabelsOn.push("!" + label);
                        that.valueChanged(that.currentLabelsOn);
                    }).data("label", label)
                        .tooltip({ placement: "bottom", container: "body" });
                }
            });
            // move filter select dropdown after btn group
            $("#setFilter").insertAfter(btnGroup);
        }
        // move all labels of one group into a dropdown (rather than simple buttons)
        create_dropdown_group(gid, btnGroup) {
            let that = this;
            var somethingSelected = false;
            $.each(this.groups[gid].labelDef, function (idx, label) {
                somethingSelected = somethingSelected || that.currentLabelsOn.indexOf(("!" + label.label)) > -1 || that.currentLabelsOn.indexOf(label.label) > -1;
            });
            // modify button group to a dropdown button group
            btnGroup.addClass("dropdown");
            btnGroup.removeClass("labelTools");
            // move all buttons in a dropdown list with buttons 
            var btnUl = $('<ul class="dropdown-menu globalFilterMenu" role="menu">');
            btnGroup.find("button").each(function (idx, btn) {
                btnUl.append($("<li class='filterGroupDD'>").append(btn));
                if (that.currentLabelsOn.indexOf(("!" + $(btn).data("label"))) === -1) {
                    var nf = $("<span class='negativeFilter'  title data-original-title='filter by label not set' >not</span>");
                    $(btn).parent().prepend(nf);
                    nf.click(function (e) {
                        $(".tooltip").remove();
                        var alreadySet = that.currentLabelsOn.indexOf($(e.delegateTarget).data("label"));
                        if (alreadySet > -1) {
                            that.currentLabelsOn.splice(alreadySet, 1);
                        }
                        var label = $(e.delegateTarget).data("label");
                        that.currentLabelsOn.push("!" + label);
                        that.valueChanged(that.currentLabelsOn);
                    }).data("label", $(btn).data("label"))
                        .tooltip({ placement: "bottom", container: "body" });
                }
            });
            // create menu button
            var menuDefinition = somethingSelected ? this.groups[gid].filterMenu.on : this.groups[gid].filterMenu.off;
            if (!menuDefinition) {
                menuDefinition = {
                    foreground: "black",
                    background: "transparent",
                    displayName: this.groups[gid].filterMenu.displayName,
                    tooltip: ""
                };
            }
            var i = "";
            if (menuDefinition.icon) {
                i = "<i class='fal fa-" + menuDefinition.icon + "' style='margin-right:6px'></i>";
            }
            var tt = "";
            if (menuDefinition.tooltip) {
                tt = " title data-original-title='" + menuDefinition.tooltip + "' ";
            }
            var btn = $("<button class='btn btn-default btn-xs dropdown-toggle' data-toggle='dropdown' " + tt + ">" + i + menuDefinition.displayName + "&nbsp;<span class='caret'></span></button>");
            btn.css("background-color", menuDefinition.background).css("color", menuDefinition.foreground);
            btn.data("gid", gid);
            // append menu button
            btnGroup.append(btn);
            // append menu options
            btnGroup.append(btnUl);
            btn.tooltip({ placement: "bottom" });
        }
        // gets selection from all groups
        updateSelection() {
            this.currentLabelsOn = [];
            for (var gid = 0; gid < this.groups.length; gid++) {
                for (var lid = 0; lid < this.groups[gid].labelDef.length; lid++) {
                    if (this.groups[gid].labelDef[lid].isSelected) {
                        if (this.groups[gid].labelDef[lid].isNegative) {
                            this.currentLabelsOn.push("!" + this.groups[gid].labelDef[lid].label);
                        }
                        else {
                            this.currentLabelsOn.push(this.groups[gid].labelDef[lid].label);
                        }
                    }
                }
            }
        }
        // paint one 'normal' label button
        createButton(label, gid, name, foreground, background, icon, onClick, onDblClick, extraClass) {
            let that = this;
            var i = "";
            if (icon) {
                i = "<i class='fal fa-" + icon + "' style='" + (name ? "margin-right:6px" : "") + "'></i>";
            }
            var btn = $("<button tabindex='-1' class='btn btn-default btn-xs " + extraClass + "' " + (this.canEdit ? "" : "disabled") + ">" + i + name + "</button>");
            btn.css("background-color", background).css("color", foreground);
            btn.data("label", label);
            btn.data("gid", gid);
            btn.click(function (e) {
                $(".tooltip").remove();
                var buttonClicked = $(e.delegateTarget);
                // make sure (drop down menus don't close
                if (onDblClick) {
                    if (e.preventDefault)
                        e.preventDefault();
                    if (e.stopPropagation)
                        e.stopPropagation();
                    that.dbClickCounter++;
                    if (that.dbClickCounter === 1) {
                        that.dbClickTimer = window.setTimeout(function () {
                            // after 700 ms: reset counter and make the click
                            that.dbClickCounter = 0;
                            if (onClick) {
                                onClick(buttonClicked);
                            }
                        }, 700);
                    }
                    else {
                        // dbl click...
                        clearTimeout(that.dbClickTimer);
                        that.dbClickCounter = 0;
                        onDblClick(buttonClicked);
                    }
                }
                else if (onClick) {
                    onClick(buttonClicked);
                }
            });
            return btn;
        }
        // create one 'normal' label as button
        createLabel(labelId, gid, onClick, onDblClick) {
            var isNegative = false; // set true for negative project filters
            if (labelId.indexOf("!") !== -1) {
                labelId = labelId.replace("!", "");
                isNegative = true;
            }
            var labelList = this.getLabelList();
            var labelDef;
            $.each(this.groups[gid].labelDef, function (idx, ll) {
                if (ll.label === labelId) {
                    labelDef = ll;
                }
            });
            if (!labelDef) {
                // the label does not exist (anymore): ignore
                return $("");
            }
            if (this.mode != "project_filter" && labelDef.editors && labelDef.editors.indexOf(globals_1.matrixSession.getUser()) === -1) {
                onClick = function () { };
                onDblClick = function () { };
            }
            // figure out if label/filter should be shown as on
            var isOn = labelDef.isSelected;
            if (!isOn && this.mode === "item_print") {
                // labels is off - so it should not be shown in print mode
                return $("");
            }
            // legacy logic to retrieve names/colors/icons
            var displayName = labelDef.displayName ? labelDef.displayName : "";
            var foreground = isOn ? "white" : labelDef.color; // default: white on color is on
            var background = isOn ? labelDef.color : "transparent";
            var tooltip = labelDef.toolTipFilterOn ? labelDef.toolTipFilterOn : "";
            var icon;
            // new logic
            if (labelDef.style) {
                let stylefl = this.isFilter ? labelDef.style.filter : labelDef.style.label;
                if (stylefl) {
                    let style = isOn ? stylefl.on : stylefl.off;
                    if (style) {
                        displayName = style.displayName ? style.displayName : displayName; // overwrite name
                        foreground = style.foreground ? style.foreground : foreground;
                        background = style.background ? style.background : background;
                        icon = style.icon ? style.icon : icon;
                        tooltip = style.tooltip ? style.tooltip : tooltip;
                    }
                }
            }
            if (labelDef && labelDef.label) {
                if (tooltip) {
                    tooltip = labelDef.label + ": " + tooltip;
                }
                else {
                    tooltip = labelDef.label;
                }
            }
            let btn = null;
            // create the button
            if (icon || displayName) {
                if (isNegative) {
                    displayName = displayName ? ("NOT " + displayName) : "NOT";
                }
                var statusClass = (isNegative ? "labelIsNot " : "") + (isOn ? "labelIsOn " : "");
                if (this.mode == "item_history") {
                    // in history render a simplified version of labels to be more easily comparable
                    btn = this.createButton(labelId, gid, displayName + (isOn ? " (on)" : " (off)"), "", "", icon, onClick, onDblClick, "labelInHistory");
                }
                else {
                    btn = this.createButton(labelId, gid, displayName, foreground, background, icon, onClick, onDblClick, statusClass);
                }
                if (tooltip) {
                    btn.tooltip({ title: tooltip, placement: "bottom", container: "body" });
                }
            }
            return btn;
        }
    }
    exports.LabelSwitches = LabelSwitches;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 70 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, matrixlib_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.LoggerTools = exports.SERVER_LOG_LEVEL = void 0;
    var SERVER_LOG_LEVEL;
    (function (SERVER_LOG_LEVEL) {
        SERVER_LOG_LEVEL["WEIRD_STATE"] = "WEIRD_STATE";
        SERVER_LOG_LEVEL["BROKEN_STATE"] = "BROKEN_STATE";
    })(SERVER_LOG_LEVEL || (SERVER_LOG_LEVEL = {}));
    exports.SERVER_LOG_LEVEL = SERVER_LOG_LEVEL;
    class LoggerTools {
        constructor() {
            this.verbose = false;
            this.lastLogMsg = "none";
            this.logData = [];
            this.logIdx = 0;
            this.logSize = 50;
        }
        log(id, msg) {
            if (!this.verbose && id === "debug") {
                return;
            }
            msg = DOMPurify.sanitize(msg) + '';
            if (!msg) {
                return;
            }
            console.log(id + ":" + msg);
            if (this.lastLogMsg === msg) {
                this.logData[this.logIdx] = this.logData[this.logIdx] + ".";
            }
            else {
                this.logIdx++;
                if (this.logIdx === this.logSize) {
                    this.logIdx = 0;
                }
                this.logData[this.logIdx] = matrixlib_1.ml.UI.DateTime.renderHumanDate(new Date()) + " [" + id + "]: " + msg;
                this.lastLogMsg = msg;
            }
        }
        getCaller() {
            const stack = Error().stack.split("\n");
            if (stack.length > 4) {
                return stack[4];
            }
            else {
                return "Unknown";
            }
        }
        logServer(level, message) {
            const caller = this.getCaller();
            const messageText = `${SERVER_LOG_LEVEL[level]} (${caller}): ${message}`;
            if (globals_1.restConnection) {
                globals_1.restConnection.postServer("all/log", { message: messageText });
            }
        }
        debug(message) {
            this.log("debug", message);
        }
        info(message) {
            this.log("info", message);
        }
        warning(message) {
            this.log("warning", message);
        }
        error(message) {
            this.log("error", message);
        }
        weirdState(message) {
            this.logServer(SERVER_LOG_LEVEL.WEIRD_STATE, message);
        }
        brokenState(message) {
            this.logServer(SERVER_LOG_LEVEL.BROKEN_STATE, message);
        }
        getLog() {
            var msg = "";
            for (var idx = this.logIdx + 1; idx < this.logIdx + this.logSize + 1; idx++) {
                if (this.logData[idx % this.logSize]) {
                    msg += this.logData[idx % this.logSize] + "\n";
                }
            }
            return msg;
        }
    }
    exports.LoggerTools = LoggerTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 71 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.MailTools = void 0;
    class MailTools {
        sendMail(to, cc, bcc, subject, body, systemMail, noSuccess, noReply) {
            let that = this;
            var res = $.Deferred();
            var text = $("<div>").html(body);
            $("br", text).replaceWith("\n");
            var tol = to ? to.split(",") : [];
            var ccl = cc ? cc.split(",") : [];
            var bccl = bcc ? bcc.split(",") : [];
            let sendMailParm = {
                to: tol,
                cc: ccl,
                bcc: bccl,
                subject: subject,
                htmlbody: body,
                textbody: text.text(),
                system: systemMail,
                noreply: noReply
            };
            let queryString = "?" + (systemMail != undefined ? "system=" + systemMail + "&" : "") + (noReply != undefined ? "noreply=" + noReply : "");
            globals_1.restConnection.postSpecialServer("all/sendmail" + queryString, sendMailParm).done(function () {
                if (!systemMail && !noSuccess) {
                    matrixlib_1.ml.UI.showSuccess("Mail sent successfully.");
                }
                res.resolve();
            }).fail(function (jqxhr, textStatus, error) {
                if (!systemMail) {
                    matrixlib_1.ml.UI.showError("Error sending mail!", "Status:" + textStatus + "<br/>Error was:" + error);
                }
                res.reject();
            });
            return res;
        }
        sendMailDlg(sendTo, preSelectedUsers, subject, body, sendCc) {
            let that = this;
            function updateSend() {
                var sendButton = $(".ui-dialog-buttonpane button:contains('Send')", globals_1.app.dlgForm.parent());
                var enabled = sendTo.length && subj && subj.getController().getValue() !== "";
                sendButton.prop("disabled", !enabled);
                if (enabled) {
                    sendButton.removeClass("ui-state-disabled");
                }
                else {
                    sendButton.addClass("ui-state-disabled");
                }
            }
            var cc = sendCc ? sendCc.split(",") : [];
            let mailConf = globals_1.matrixSession.getMailSettings();
            if (mailConf && mailConf.defaultCC && mailConf.defaultCC.length) {
                cc = cc.concat(mailConf.defaultCC.filter(function (userOrGroup) { return matrixlib_1.ml.UI.SelectUserOrGroup.exists(userOrGroup); }));
            }
            if (sendTo.split(",").indexOf(globals_1.matrixSession.getUser()) === -1 && globals_1.matrixSession.getUser() !== "matrixadmin") {
                // the user himself is always on cc - by default
                cc.push(globals_1.matrixSession.getUser());
            }
            // get distinct names 
            cc = cc.filter(function (elem, pos, arr) { return arr.indexOf(elem) == pos; });
            let usel = $("<div>");
            let ccl = $("<div>");
            if (preSelectedUsers && preSelectedUsers.length) {
                // take user list from parameter (no groups possible)
                matrixlib_1.ml.UI.SelectUserOrGroup.showMultiUserSelect(usel, "To", (sendTo ? sendTo.split(",") : []), "Select To Users", "", "", true, false, (selection) => {
                    sendTo = selection.join(",");
                    updateSend();
                }, preSelectedUsers);
                matrixlib_1.ml.UI.SelectUserOrGroup.showMultiUserSelect(ccl, "Cc", cc, "Select Cc Users", "", "", true, false, (selection) => {
                    cc = matrixlib_1.ml.JSON.clone(selection);
                    updateSend();
                }, preSelectedUsers);
            }
            else {
                // take users from current project
                matrixlib_1.ml.UI.SelectUserOrGroup.showMultiUserSelect(usel, "To", (sendTo ? sendTo.split(",") : []), "Select To Users / Groups", "", "", true, true, (selection) => {
                    sendTo = selection.join(",");
                    updateSend();
                });
                matrixlib_1.ml.UI.SelectUserOrGroup.showMultiUserSelect(ccl, "Cc", cc, "Select Cc Users / Groups", "", "", true, true, (selection) => {
                    cc = matrixlib_1.ml.JSON.clone(selection);
                    updateSend();
                });
            }
            var subj = $("<div>").plainText({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: "Subject",
                fieldValue: subject,
                valueChanged: function () {
                    updateSend();
                },
                parameter: {
                    rows: 1,
                    allowResize: false
                }
            });
            var cont = $("<div>");
            cont.richText({ controlState: globals_1.ControlState.FormEdit, canEdit: true, help: "Message", fieldValue: body, valueChanged: function () { }, parameter: { tiny: true } });
            globals_1.app.dlgForm.hide();
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.append(usel);
            globals_1.app.dlgForm.append(ccl);
            // workaround for MATRIX-995 cannot edit links in sendmail
            // somehow that thing gets a focus event out of nowhere
            globals_1.app.dlgForm.append(subj);
            globals_1.app.dlgForm.append(cont);
            globals_1.app.dlgForm.addClass("dlg-no-scroll");
            globals_1.app.dlgForm.removeClass("dlg-v-scroll");
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "Send Mail",
                width: 730,
                height: 720,
                modal: true,
                resizeStop: function () { },
                open: function () {
                    window.setTimeout(function () {
                        $("input", subj).focus();
                    }, 1);
                    updateSend();
                },
                buttons: [{
                        text: 'Send',
                        class: 'btnDoIt',
                        click: function () {
                            that.sendMail(sendTo, cc.join(","), "", subj.getController().getValue(), cont.getController().getValue());
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            });
        }
        replacePlaceholders(template, itemId, rejectComment, reviewers, readers, trainers, trainees) {
            let msg = matrixlib_1.ml.Mail.getCannedMessage("", "", itemId, template);
            msg = msg.replace(new RegExp("_reject_", 'g'), rejectComment ? rejectComment : "");
            msg = msg.replace(new RegExp("_reviewers_", 'g'), reviewers ? reviewers.join() : "");
            msg = msg.replace(new RegExp("_readers_", 'g'), readers ? readers.join() : "");
            msg = msg.replace(new RegExp("_trainers_", 'g'), trainers ? trainers.join() : "");
            msg = msg.replace(new RegExp("_trainees_", 'g'), trainees ? trainees.join() : "");
            return msg;
        }
        getCannedMessage(messageId, to, itemId, custom, body = "") {
            var message = custom;
            let mailConf = globals_1.matrixSession.getMailSettings();
            if (!custom && mailConf && mailConf.canned && (mailConf.canned)[messageId]) {
                message = (mailConf.canned)[messageId];
            }
            else if (messageId === "link") {
                message = "Hello<br/><br/>please have a look at <b>_link_ _title_</b>.<br/><br/>_me.firstName_";
            }
            else if (messageId === "please_sign") {
                message = "Hello,<br/><br/>please review and sign the following document <b>_link_ _title_</b><br/><br/>_me.firstName_";
            }
            else if (messageId === "new_user") {
                message = "Hello _to.firstName_,<br/><br/>Here is your access to Matrix.<br/><br/>_userinfo_<br/><br/>You have access to these projects:<br/><br/>_projectlist_<br/>_me.firstName_";
            }
            else if (messageId === "reset_pwd") {
                message = "Hello _to.firstName_,<br/><br/>Please change your password.<br/><br/>_userinfo_<br/>";
            }
            else if (messageId === "release_note") {
                message = "Hello,<br/><br/>the document <b>_link_ _title_</b> has been released!<br/><br/>_me.firstName_";
            }
            else if (messageId === "approve_note") {
                message = "Hello ,<br/><br/>the template <b>_link_ _title_</b> waits for approval!<br/><br/>_me.firstName_";
            }
            else if (messageId === "training_reminder") {
                message = "Hello _to.firstName_,<br/><br/> You need to do the following training:<br/>_body_<br/>_me.firstName_";
            }
            else if (messageId === "review_reminder") {
                message = "Hello _to.firstName_,<br/><br/> You need to review the following :<br/>_body_<br/>_me.firstName_";
            }
            else if (messageId === "qms_published") {
                message = "Hello,<br/>_body_<br/>_me.firstName_";
            }
            else if (messageId === "gate_passed") {
                message = `Hello _to.firstName_,<br/><br/>_me.firstName_ passed the gate _body_ for <b>_link_ _title_</b>.<br/><br/>`;
            }
            else if (messageId === "empty_message") {
                message = ``;
            }
            if (body != undefined)
                message = message.replace("_body_", body);
            // address the user eg by firstName: a) get the correct user info
            var users = globals_1.globalMatrix.ItemConfig.getUserNames();
            var user;
            var me;
            let toUsers = to.split(",");
            let toFirst = [];
            let toLast = [];
            let toLogin = [];
            $.each(users, function (uidx, u) {
                if (u.login === to) {
                    user = u;
                }
                if (toUsers.indexOf(u.login) != -1) {
                    toFirst.push(u.firstName);
                    toLast.push(u.lastName);
                    toLogin.push(u.login);
                }
                if (u.login === globals_1.matrixSession.getUser()) {
                    me = u;
                }
            });
            // address the user eg by firstName: b) replace all existing keys for to
            if (user) {
                $.each(Object.keys(user), function (kidx, key) {
                    message = message.replace(new RegExp("_to." + key + "_", 'g'), user[key]);
                });
            }
            else {
                message = message.replace(new RegExp("_to_", 'g'), to);
            }
            message = message.replace(new RegExp("_to.firstName_", 'g'), toFirst.join(","));
            message = message.replace(new RegExp("_to.lastName_", 'g'), toLast.join(","));
            message = message.replace(new RegExp("_to.login_", 'g'), toLogin.join(","));
            // address the user eg by firstName: c) replace all existing keys for sender
            if (me) {
                $.each(Object.keys(me), function (kidx, key) {
                    message = message.replace(new RegExp("_me." + key + "_", 'g'), me[key]);
                });
            }
            else {
                message = message.replace(/_me.*_/g, "");
            }
            // replace other stuff 
            if (itemId) {
                message = message.replace(new RegExp("_id_", 'g'), itemId);
                message = message.replace(new RegExp("_project_", 'g'), globals_1.matrixSession.getProject());
                message = message.replace(new RegExp("_url_", 'g'), matrixlib_1.ml.Item.parseRef(itemId).url);
                message = message.replace(new RegExp("_link_", 'g'), matrixlib_1.ml.Item.parseRef(itemId).link);
                message = message.replace(new RegExp("_linkv_", 'g'), matrixlib_1.ml.Item.parseRef(itemId).linkv);
                var title = globals_1.app.getItemTitle(itemId);
                message = message.replace(new RegExp("_title_", 'g'), title);
            }
            return message;
        }
        sendMails(sendTos, subject, messages) {
            if (sendTos.length > 2) {
                matrixlib_1.ml.UI.Progress.Init("sending mails");
            }
            let mailConf = globals_1.matrixSession.getMailSettings();
            let cc = "";
            if (mailConf && mailConf.defaultCC && mailConf.defaultCC.length) {
                cc = mailConf.defaultCC.filter(function (userOrGroup) { return matrixlib_1.ml.UI.SelectUserOrGroup.exists(userOrGroup); }).join(",");
            }
            this.sendMailsRec(sendTos, cc, subject, messages, 0);
        }
        sendMailsRec(sendTos, cc, subject, messages, idx) {
            let that = this;
            if (sendTos.length > 2) {
                matrixlib_1.ml.UI.Progress.Update(idx * 100 / sendTos.length);
            }
            if (idx >= sendTos.length) {
                if (sendTos.length > 2) {
                    matrixlib_1.ml.UI.Progress.SuccessHide("Done sending mails", 1000);
                }
                else {
                    matrixlib_1.ml.UI.showSuccess("Done sending mails", 1000);
                }
                return;
            }
            this.sendMail(sendTos[idx], cc, "", subject, messages[idx], 0, true).done(function () {
                that.sendMailsRec(sendTos, cc, subject, messages, idx + 1);
            });
        }
    }
    exports.MailTools = MailTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 72 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(19), __webpack_require__(45), __webpack_require__(6), __webpack_require__(12), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, ProjectViewDefines_1, ItemSelectionView_1, globals_1, index_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ReportGeneratorTools = void 0;
    class ReportGeneratorTools {
        constructor() {
            this.reportJoblist = { allGood: true, tasks: [], doneBatch: 0 };
            this.lastReportXMLs = [];
        }
        SaveAndCreate(itemId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback) {
            let that = this;
            if (globals_1.app.getNeedsSave()) {
                globals_1.app.saveAsync(false).done(function () {
                    window.setTimeout(function () {
                        that.StartReportEngine(itemId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback);
                    }, 1000);
                });
            }
            else {
                this.StartReportEngine(itemId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback);
            }
        }
        StartReportEngine(reportId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback) {
            let that = this;
            globals_1.app.canLaunchReport().done(function (canLaunch) {
                if (canLaunch) {
                    that.StartReportEngineLaunch(reportId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback);
                }
                else {
                    matrixlib_1.ml.UI.showConfirm(1, { title: "Report engine busy. Please wait a while and try again...", ok: "Try Again" }, function () {
                        window.setTimeout(function () {
                            that.StartReportEngine(reportId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback);
                        }, 400);
                    }, function () {
                    });
                }
            });
        }
        StartReportEngineLaunch(reportId, reportOptions, progressInfo, postCreateCallback, postFailCallback, postProgressCallback) {
            let that = this;
            matrixlib_1.ml.Logger.log('debug', "starting report: " + progressInfo);
            matrixlib_1.ml.Logger.log('lastReportJobId', "");
            matrixlib_1.ml.Logger.log('lastReportFileId', "");
            matrixlib_1.ml.Logger.log('lastReportJobXML', "");
            globals_1.app.startReportAsync(reportId, reportOptions).done(function (jobId) {
                matrixlib_1.ml.Logger.log('lastReportJobId', jobId.jobId.toString());
                that.reportJoblist.tasks.push({ jobId: jobId.jobId,
                    progress: 0,
                    reportId: reportId,
                    reportOptions: reportOptions,
                    postCreateCallback: postCreateCallback,
                    postFailCallback: postFailCallback,
                    postProgressCallback: postProgressCallback
                });
                let labels = reportOptions.filter ? (" (" + reportOptions.filter + ")") : "";
                if (that.reportJoblist.tasks.length === 1) {
                    matrixlib_1.ml.UI.Progress.Init(progressInfo + labels, !!reportOptions.filter);
                    that.reportJoblist.allGood = true;
                    that.reportJoblist.doneBatch = 0;
                    clearTimeout(that.reportProc);
                    that.reportProc = window.setTimeout(function () {
                        that.waitForReports(0);
                    }, 500);
                }
            });
        }
        waitForReports(rid) {
            let that = this;
            if (this.reportJoblist.tasks.length <= rid) {
                matrixlib_1.ml.UI.Progress.ErrorHide("Error retrieving report status", 2000);
                return;
            }
            globals_1.app.getReportDetails(this.reportJoblist.tasks[rid].jobId).done(function (progress) {
                let status = that.getProgressStatus(progress.status);
                if (status === "Error" || progress.progress > 100) {
                    let details = (status && status != "Error") ? that.getError(status) : "";
                    matrixlib_1.ml.UI.showError("Error", "Failed to create " + that.reportJoblist.tasks[rid].reportId + (details ? ("<br>Error was: " + details) : ""));
                    if (that.reportJoblist.tasks[rid].postFailCallback) {
                        that.reportJoblist.tasks[rid].postFailCallback("Failed to create " + that.reportJoblist.tasks[rid].reportId + (details ? ("<br>Error was: " + details) : ""));
                    }
                    that.reportJoblist.tasks.splice(rid, 1);
                    that.reportJoblist.allGood = false;
                    that.reportJoblist.doneBatch++;
                    rid -= 1;
                }
                else if (progress.progress < 100) {
                    if (status && status.itemsProgress) {
                        console.log(JSON.stringify(status.itemsProgress, null, 2));
                    }
                    if (that.reportJoblist.tasks[rid].postProgressCallback) {
                        that.reportJoblist.tasks[rid].postProgressCallback(progress.progress);
                    }
                    that.reportJoblist.tasks[rid].progress = progress.progress;
                    var progressTotal = 100 * that.reportJoblist.doneBatch;
                    for (var idx = 0; idx < that.reportJoblist.tasks.length; idx++) {
                        progressTotal += that.reportJoblist.tasks[idx].progress;
                    }
                    matrixlib_1.ml.UI.Progress.Update(progressTotal / (that.reportJoblist.tasks.length + that.reportJoblist.doneBatch));
                }
                else { // done with at least one
                    var lastCreatedObject = progress.jobFile[progress.jobFile.length - 1];
                    matrixlib_1.ml.Logger.log('lastReportFileId', lastCreatedObject.jobFileId.toString());
                    that.lastReportXMLs.push("/job/" + that.reportJoblist.tasks[rid].jobId + "/" + progress.jobFile[0].jobFileId);
                    matrixlib_1.ml.Logger.log('lastReportJobXML', globals_1.globalMatrix.matrixRestUrl + "/" + globals_1.matrixSession.getProject() + "/job/" + that.reportJoblist.tasks[rid].jobId + "/" + progress.jobFile[0].jobFileId);
                    if (that.reportJoblist.tasks[rid].postCreateCallback) {
                        that.reportJoblist.tasks[rid].postCreateCallback(lastCreatedObject, globals_1.globalMatrix.matrixRestUrl + "/" + globals_1.matrixSession.getProject() + "/job/" + that.reportJoblist.tasks[rid].jobId + "/" + lastCreatedObject.jobFileId);
                    }
                    else {
                        globals_1.app.download(that.reportJoblist.tasks[rid].jobId, lastCreatedObject.jobFileId);
                        that.updateAfterCreatingCache(that.reportJoblist.tasks[rid].reportId);
                    }
                    that.reportJoblist.doneBatch++;
                    that.reportJoblist.tasks.splice(rid, 1);
                    rid -= 1;
                }
                if (that.reportJoblist.tasks.length > 0) {
                    that.reportProc = window.setTimeout(function () {
                        that.waitForReports((rid + 1) % that.reportJoblist.tasks.length);
                    }, 500);
                    return;
                }
                else if (that.reportJoblist.allGood) {
                    matrixlib_1.ml.UI.Progress.SuccessHide("Finished creating report/document", 2000);
                }
                else {
                    matrixlib_1.ml.UI.Progress.ErrorHide("Error creating report/document", 2000);
                }
            }).fail(function () {
                matrixlib_1.ml.UI.Progress.ErrorHide("Error retrieving report status", 2000);
            });
        }
        // this method checks if a signCache has been created during download of an item if so it updates it (without asking questions...)
        updateAfterCreatingCache(itemId) {
            // MATRIX-3721 if a signed has been downloaded, a cache has been created
            // if the same SIGN is being displayed, we need to load and display the new item, we do this as a second protection by cancelling the edits
            if (itemId && matrixlib_1.ml.Item.parseRef(itemId).type == "SIGN" && globals_1.matrixApplicationUI.lastMainItemForm && globals_1.app.getCurrentItemId() == itemId) {
                globals_1.app.cancel();
                // and we force a get the latest 
                globals_1.matrixSession.pushMessages.watchItem(itemId);
            }
        }
        getProgressStatus(text) {
            if (!text || text[0] != "{") {
                return text;
            }
            let isJson = matrixlib_1.ml.JSON.fromString(text);
            if (isJson.status == "ok") {
                return isJson.value;
            }
            return "";
        }
        getError(error) {
            if (!error.itemsProgress || error.itemsProgress.length == 0) {
                return error.errorMessage ? error.errorMessage : "";
            }
            for (let idx = 0; idx < error.itemsProgress.length; idx++) {
                if (error.itemsProgress[idx].progress == 200) {
                    // that's an error
                    return error.itemsProgress[idx].documentRef + ": " + error.itemsProgress[idx].message;
                }
            }
            return "unknown error";
        }
        CreateSignedDoc(docId, signatures, signedDocumentsControl, labelFilter, signName, transferFields, defaultLabels, docUpdateCb) {
            let that = this;
            if (globals_1.app.getNeedsSave()) {
                matrixlib_1.ml.UI.showError("You must save document", "Save document before archiving it!");
                return;
            }
            let useDefaultFolder = globals_1.globalMatrix.globalShiftDown;
            globals_1.matrixSession.getCommentAsync().done(function (comment) {
                // get the last used folders
                let signTarget = globals_1.globalMatrix.projectStorage.getItem("SignTarget") ? globals_1.globalMatrix.projectStorage.getItem("SignTarget") : "F-SIGN-1";
                // shift pressed - use default folder
                if (useDefaultFolder) {
                    that.createSIGN(signTarget, comment, docId, signatures, signedDocumentsControl, labelFilter, signName, transferFields, defaultLabels, docUpdateCb);
                }
                else {
                    var st = new ItemSelectionView_1.ItemSelectionTools();
                    st.showDialog({
                        selectMode: ProjectViewDefines_1.SelectMode.singleFolder,
                        linkTypes: [{ type: "SIGN" }],
                        selectionChange: function (newSelection) {
                            if (!newSelection.length) {
                                newSelection = [{ to: "F-SIGN-1", title: "" }];
                            }
                            signTarget = newSelection[0].to;
                            globals_1.globalMatrix.projectStorage.setItem("SignTarget", signTarget);
                            // finally
                            that.createSIGN(signTarget, comment, docId, signatures, signedDocumentsControl, labelFilter, signName, transferFields, defaultLabels, docUpdateCb);
                        },
                        getSelectedItems: function () {
                            return [{ to: signTarget, title: "" }];
                        },
                        dialogTitle: "Select target folder",
                        focusOn: signTarget
                    });
                }
            });
        }
        createSIGN(target, comment, docId, signatures, signedDocumentsControl, labelFilter, signName, transferFields, defaultLabels, docUpdateCb) {
            let that = this;
            var reportOptions = { reason: comment };
            if (labelFilter && labelFilter.length > 0) {
                reportOptions.filter = labelFilter;
            }
            if (!signatures || signatures.length === 0) {
                reportOptions["isSignedReport"] = true;
                reportOptions["includeSignatures"] = "";
            }
            else {
                reportOptions["isSignedReport"] = true;
                reportOptions["includeSignatures"] = signatures.join(',');
            }
            reportOptions["newTitle"] = signName;
            if (transferFields) {
                var trv = "";
                $.each(transferFields, function (tfIdx, tfv) {
                    if (trv !== "") {
                        trv += ";";
                    }
                    trv += "(" + tfv.fromId + "," + tfv.toId + ")";
                });
                if (trv !== "") {
                    reportOptions["copyFields"] = trv;
                }
            }
            that.StartReportEngine(docId, reportOptions, "Creating SIGNed Document", function (lastCreatedObject) {
                var newId = lastCreatedObject.visibleName;
                docUpdateCb(newId);
                // the new SIGN item id (newId) was created on the server, create the link and udpate the client
                globals_1.app.getItemAsync(newId).done(function (itemdetails) {
                    index_1.MR1.triggerAfterCreateSign(itemdetails);
                    if (defaultLabels.length > 0) {
                        globals_1.app.updateItemInDBAsync({ id: itemdetails.id, onlyThoseFields: 1, onlyThoseLabels: 1, labels: defaultLabels.join(",") }, "edit").done(function (updatedItem) {
                            that.addSignToTree(target, comment, updatedItem, signedDocumentsControl);
                        });
                    }
                    else {
                        that.addSignToTree(target, comment, itemdetails, signedDocumentsControl);
                    }
                }).fail(function () {
                    matrixlib_1.ml.UI.showError("Could not create SIGN document!", "");
                });
            });
        }
        addSignToTree(target, comment, itemdetails, signedDocumentsControl) {
            if (target != "F-SIGN-1") {
                // move it to target on server
                globals_1.app.moveItemsAsync(itemdetails.id, target, 10000, comment);
            }
            // in the meantime update the tree
            var itemJson = {
                id: itemdetails.id,
                title: itemdetails.title,
                type: itemdetails.type
            };
            var newItem = {
                parent: target,
                position: 100000,
                item: itemJson
            };
            globals_1.app.insertInTree(newItem);
            globals_1.app.updateCache(newItem);
            // and add it to the list of downlinks
            if (signedDocumentsControl) {
                var refs = signedDocumentsControl.getController().getValue();
                if (!refs) {
                    refs = [];
                }
                refs.push({
                    to: itemdetails.id,
                    title: itemdetails.title
                });
                signedDocumentsControl.getController().setValue(refs);
                matrixlib_1.ml.UI.showSuccess("Signed document " + itemdetails.id + " was created");
            }
        }
        CreateDoc(docId, format, labelFilter) {
            var reportOptions = format ? format : {};
            if (labelFilter && labelFilter.length > 0) {
                reportOptions.filter = labelFilter;
            }
            this.SaveAndCreate(docId, reportOptions, "Downloading Document", null);
        }
        CreateReport(reportId, format, inputItems, requiredItems) {
            var reportOptions = format ? format : {};
            var labelFilter = matrixlib_1.ml.LabelTools.getFilter();
            if (labelFilter && labelFilter.length > 0) {
                reportOptions.filter = labelFilter;
            }
            // only use the selected / required input 
            var list = [];
            if (inputItems) {
                for (var idx = 0; idx < inputItems.length; idx++) {
                    list.push(inputItems[idx].to);
                }
            }
            if (requiredItems) {
                for (var idx = 0; idx < requiredItems.length; idx++) {
                    list.push(requiredItems[idx].to);
                }
            }
            if (list.length > 0) {
                reportOptions["itemList"] = list.join(",");
            }
            this.SaveAndCreate(reportId, reportOptions, "Downloading Report", null);
        }
        DownloadSignedDoc(signedId, format) {
            let that = this;
            matrixlib_1.ml.Logger.log('debug', "starting signed report");
            matrixlib_1.ml.Logger.log('lastReportJobId', "");
            matrixlib_1.ml.Logger.log('lastReportFileId', "");
            matrixlib_1.ml.Logger.log('lastReportJobXML', "");
            globals_1.app.startCreateDocumentAsync(signedId, format).done(function (jobId) {
                var reportOptions = format ? format : {};
                matrixlib_1.ml.Logger.log('lastReportJobId', jobId.jobId.toString());
                that.reportJoblist.tasks.push({
                    jobId: jobId.jobId,
                    progress: 0,
                    reportId: signedId,
                    reportOptions: reportOptions,
                    postCreateCallback: null
                });
                if (that.reportJoblist.tasks.length === 1) {
                    matrixlib_1.ml.UI.Progress.Init("Downloading Document");
                    that.reportJoblist.allGood = true;
                    that.reportJoblist.doneBatch = 0;
                    clearTimeout(that.reportProc);
                    that.reportProc = window.setTimeout(function () {
                        that.waitForReports(0);
                    }, 500);
                }
            });
        }
    }
    exports.ReportGeneratorTools = ReportGeneratorTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 73 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(32), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, ProjectSettings_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.SmartTextTools = void 0;
    class SmartTextTools {
        constructor() {
            this.figureDef = { preNo: "Figure ", postNo: ": ", captionDetails: "captionDetailsFig", captionClass: "captionFig", referenceClassNo: "referenceFig" };
            this.tableDef = { preNo: "Table ", postNo: ": ", captionDetails: "captionDetailsTab", captionClass: "captionTab", referenceClassNo: "referenceTab" };
        }
        //**************************************** 
        // LEGACY summernote functions
        //***************************************
        /* summernote create menu to enter edit macros
        * docMode is true if editor/menu is a document -> in that case we support table and figure captions
        * tableMode is true if editor/menu is for a table cell  -> in that case we do not support smart text
        */
        createMenu(docMode, tableMode) {
            var hasTags = false;
            var list = '';
            var config = this.getCurrentConfig();
            let dhf_config = globals_1.globalMatrix.ItemConfig.getDHFConfig();
            // (set (default texts)
            if (dhf_config && dhf_config.captions) {
                if (dhf_config.captions.figure) {
                    this.figureDef.preNo = dhf_config.captions.figure.preNo ? dhf_config.captions.figure.preNo : this.figureDef.preNo;
                    this.figureDef.postNo = dhf_config.captions.figure.postNo ? dhf_config.captions.figure.postNo : this.figureDef.postNo;
                }
                if (dhf_config.captions.table) {
                    this.tableDef.preNo = dhf_config.captions.table.preNo ? dhf_config.captions.table.preNo : this.tableDef.preNo;
                    this.tableDef.postNo = dhf_config.captions.table.postNo ? dhf_config.captions.table.postNo : this.tableDef.postNo;
                }
            }
            var isInDialog = $(".smarttaglist").closest(".dialog-body").length > 0;
            // group them by tag type
            var groups = [];
            var gc = 0;
            $.each(config.replacements, function (optIdx, opt) {
                var tt = opt.tagType ? opt.tagType : (opt.plain ? 1 : 2);
                if (!groups[tt]) {
                    gc++;
                    groups[tt] = [];
                }
                groups[tt].push(opt);
            });
            // insert smart references
            list += '<li class="selectSmartTextGroup dropdown-submenu"><a tabindex="-1" href="javascript:void(0)">' +
                'Insert References to</a><ul style="min-width:150px;" class="dropdown-menu">';
            list += '<li class="">' +
                '<a class="selectSmartText smarttextblock" data-event="selectSmartLink" href="#" ' +
                '" data-toggle="tooltip"><span style="margin:0 80px 0 0">Item(s) in this project</span></a>' + '</li>';
            list += '<li class="">' +
                '<a class="selectSmartText smarttextblock" data-event="selectCrossLink" href="#" ' +
                '" data-toggle="tooltip"><span style="margin:0 80px 0 0">Item(s) in another project</span></a>' + '</li>';
            list += '</ul></li>';
            // insert smart text blocks
            for (var gidx = 0; !tableMode && gidx < groups.length; gidx++) {
                var group = groups[gidx];
                if (group) {
                    list += `
                <li class="selectSmartTextGroup dropdown-submenu">
                    <a tabindex="-1" href="javascript:void(0)">Insert ${this.getTooltipType(group[0])}</a>
                    <ul style="min-width:150px;" class="stsm dropdown-menu">
                        <li class="filterListList"><input autocomplete="off" placeholder="filter list" class="filterList" type="text"></li>`;
                    $.each(group, function (optIdx, opt) {
                        list += `
                    <li class="">
                        <a class="selectSmartText smarttextblock" data-event="selectSmartText" href="#" name="${opt.what}" data-value="${opt.what}" data-toggle="tooltip">
                           <span style="margin:0 80px 0 0">${opt.what}</span>
                           <i class="deleteSmartText fal fa-trash-alt"></i>
                           <i class="editSmartText fal fa-edit"></i>
                        </a>
                    </li>`;
                        hasTags = true;
                    });
                    list += '</ul></li>';
                }
            }
            // insert figures / tables 
            if (!tableMode && dhf_config && dhf_config.captions) {
                if ($("#itemDetails ." + this.figureDef.captionDetails).length > 0) {
                    list += '<li class="selectSmartTextGroup dropdown-submenu"><a tabindex="-1" href="javascript:void(0)">' +
                        'Insert Figure Reference</a><ul style="min-width:400px;max-width:450px;" class="dropdown-menu">';
                    $.each($("#itemDetails ." + this.figureDef.captionDetails), function (captIdx, caption) {
                        list += '<li class="">' +
                            '<a class="selectSmartText smarttextblock" data-event="insertFigReference" href="#" name="' + "figure" +
                            '" data-value="' + $(caption).data("mid") +
                            '" data-toggle="tooltip"><span style="white-space:normal;margin:0 80px 0 0">' + $(caption).text();
                        list += '</a>' + '</li>';
                        hasTags = true;
                    });
                    list += '</ul></li>';
                }
                if ($("#itemDetails ." + this.tableDef.captionDetails).length > 0) {
                    list += '<li class="selectSmartTextGroup dropdown-submenu"><a tabindex="-1" href="javascript:void(0)">' +
                        'Insert Table Reference</a><ul style="min-width:400px;max-width:450px;" class="dropdown-menu">';
                    $.each($("#itemDetails ." + this.tableDef.captionDetails), function (captIdx, caption) {
                        list += '<li class="">' +
                            '<a class="selectSmartText smarttextblock" data-event="insertTabReference" href="#" name="' + "table" +
                            '" data-value="' + $(caption).data("mid") +
                            '" data-toggle="tooltip"><span style="white-space:normal;margin:0 80px 0 0">' + $(caption).text();
                        list += '</a>' + '</li>';
                        hasTags = true;
                    });
                    list += '</ul></li>';
                }
            }
            if (globals_1.globalMatrix.serverStorage.getItem("copyBuffer")) {
                list += '<li><a title="paste copy buffer" data-event="pasteBuffer" href="#" data-value="">Paste ' + '</a></li>';
            }
            if (!tableMode) {
                // add menu to create new tags
                if (!hasTags) {
                    list += '<li><a href="https://urlshort.matrixreq.com/d23/manual/macros" target="_blank" class="documentationLink" >Smart Text Help</a></li>';
                }
                list += '<li><hr style="margin:0px" /></li>';
                list += '<li><a title="can only be used in rich text fields" data-event="createSmartText" href="#" data-value="">Define rich text tag ' + '</a></li>';
                list += '<li><a title="can be used in rich text fields and document properties" data-event="createPlainText" href="#" data-value="">Define plain text tag ' + '</a></li>';
                list += '<li><a title="can be used to build a dictionary of terms" data-event="createTermText" href="#" data-value="">Define term ' + '</a></li>';
                list += '<li><a title="can be used to build a dictionary of abbreviation" data-event="createAbbreviationText" href="#" data-value="">Define abbreviation ' + '</a></li>';
                if (dhf_config && dhf_config.captions) {
                    list += '<li><a title="can be used to insert a caption for a figure" data-event="createFigureCaption" href="#" data-value="">Define figure caption ' + '</a></li>';
                    list += '<li><a title="can be used to insert a caption for a table" data-event="createTableCaption" href="#" data-value="">Define table caption ' + '</a></li>';
                }
            }
            // add menu
            $(".smarttaglist").html(list);
            window.setTimeout(function () {
                // one rendered
                // avoid flickering of sub menus (at bottom of screen) 
                $.each($(".smarttaglist .stsm"), function (idx, stsm) {
                    $(stsm).css("max-height", ($(stsm).parent().parent().height() - $(stsm).parent().position().top) + "px");
                });
            }, 200);
            // implement filter
            $(".filterList").click(function (event) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            });
            $(".filterList").keyup(function (event) {
                let filterInput = $(event.delegateTarget);
                let filterText = $(event.delegateTarget).val().toLowerCase();
                $.each($("a", filterInput.closest("ul")), function (idx, st) {
                    if (!filterText) {
                        $(st).show();
                    }
                    else {
                        let key = $(st).data("value") + "";
                        let reps = config.replacements.filter(function (rep) { return rep.what == key; });
                        let rwith = $("<div>").html(reps[0].with).text().toLowerCase();
                        if (reps.length == 1 && key.toLowerCase().indexOf(filterText) == -1 && rwith.indexOf(filterText) == -1) {
                            $(st).hide();
                        }
                        else {
                            $(st).show();
                        }
                    }
                });
                return false;
            });
            // add tooltips
            $.each(config.replacements, function (optIdx, opt) {
                var replace = opt.with;
                if (opt.tagType === 3 || opt.tagType === 4) {
                    replace += "<hr style='margin:0px'><div class='smarttext-menu-tt'>" + opt.description + "</div>";
                }
                $("a[name=" + opt.what + "]", $(".smarttaglist")).tooltip({
                    html: true,
                    title: replace,
                    placement: "right",
                    container: 'body',
                    template: '<div class="tooltip smarttext-tooltip" role="tooltip"><div class="tooltip-arrow smarttext-tooltip-arrow"></div><div class="tooltip-inner smarttext-tooltip-inner"></div></div>'
                });
            });
        }
        // summernote create menu to get rid of a macro
        deleteTag(what) {
            let that = this;
            function deleteIt() {
                var config = globals_1.globalMatrix.ItemConfig.getSmartText();
                if (!config || !config.replacements) {
                    config = { "replacements": [] };
                }
                var replacements = [];
                $.each(config.replacements, function (optIdx, opt) {
                    if (opt.what + "" !== what + "") {
                        replacements.push(opt);
                    }
                });
                $('[data-value="' + what + '"]').parent().remove();
                config.replacements = replacements;
                globals_1.app.setSettingJSON("rtf", config);
            }
            globals_1.app.searchAsync("_" + what + "_").done(function (results) {
                if (results.length > 0) {
                    matrixlib_1.ml.UI.showConfirm(5, { title: "The smart text tag <b>" + what + "</b> is currently used " + results.length + " or more times. Delete anyway?", ok: "Delete" }, function () {
                        deleteIt();
                    }, function () {
                    });
                }
                else {
                    deleteIt();
                }
            });
        }
        ;
        // summernote insert a figure reference
        insertFigReference(reference, editor, editable) {
            let ref = $(`#itemDetails .${this.figureDef.captionDetails}[data-mid='${reference}']`); /// Figure X: Explain
            this.insertReference(ref, this.figureDef, editor, editable);
        }
        // summernote insert a table of reference 
        insertTabReference(reference, editor, editable) {
            let ref = $(`#itemDetails .${this.tableDef.captionDetails}[data-mid='${reference}']`); /// Table X: Explain
            this.insertReference(ref, this.tableDef, editor, editable);
        }
        //  summernote menu to paste from internal buffer
        pasteBuffer(editor, editable) {
            let html = $(globals_1.globalMatrix.serverStorage.getItem("copyBuffer"));
            editor.insertNode(editable, $(html)[0], true);
        }
        insertReference(source, def, editor, editable) {
            let id = source.data("mid");
            let text = $(".captionText", source).html();
            let reference = `<span class="referenceDetails" data-mid="${id}">
                <span class="referenceFix" contenteditable="false">
                    <span class="referencePre">${def.preNo}</span>
                    <span  class="${def.referenceClassNo}" data-mid="${id}"></span>
                    <span class="referencePost">${def.postNo}</span>
                </span>
                <span class="referenceText">${text}</span>
            </span> `;
            editor.insertNode(editable, $(reference)[0], true);
            editor.insertNode(editable, $("<span>&nbsp;</span>")[0], true);
            // put in current number
            this.updateCaptionsAndReferences();
        }
        // insert a caption for table or image
        createCaption(isTable, editor, editable) {
            let nowms = new Date().getTime();
            let def = isTable ? this.tableDef : this.figureDef;
            let caption = `<p class="caption">
            <span class="${def.captionDetails}" data-mid="${nowms}">
                <span class="captionFix" contenteditable="false">
                    <span class="captionPre">${def.preNo}</span>
                    <span  class="${def.captionClass}" data-mid="${nowms}"></span>
                    <span class="captionPost">${def.postNo}</span>
                </span>
                <span class="captionText">${isTable ? "Table Caption" : "Figure Caption"}</span>
            </span></p>`;
            editor.insertNode(editable, $(caption)[0], true);
            this.updateCaptionsAndReferences();
        }
        //  summernote update numbers for tables and figure references
        updateCaptionsAndReferences() {
            $.each($("#itemDetails .captionFig"), function (idx, obj) {
                $(obj).html("");
                let mid = $(obj).data("mid");
                if (mid) {
                    $(obj).html(idx + 1);
                    $(`#itemDetails .referenceFig[data-mid='${mid}']`).html(idx + 1);
                }
            });
            $.each($("#itemDetails .captionTab"), function (idx, obj) {
                $(obj).html("");
                let mid = $(obj).data("mid");
                if (mid) {
                    $(obj).html(idx + 1);
                    $(`#itemDetails .referenceTab[data-mid='${mid}']`).html(idx + 1);
                }
            });
        }
        //  summernote function to create or modify tags
        createEditTag(tagType, what, data, saveFct, forceTiny) {
            // tagType:
            // 0 edit existing tag
            // 1 new plain text tag
            // 2 new rich text tag
            // 3 new term tag
            // 4 abbreviation tag
            // what is either the macro id or the item to be edited, the later is the case if a saveFct is passed
            // saveFct: optional function to save creation / changes, if not saved in project settings
            let that = this;
            let dlg = $("#smartTextDlg");
            dlg.hide();
            dlg.html("");
            dlg.removeClass("dlg-no-scroll");
            dlg.addClass("dlg-v-scroll");
            var body = `<div class="form-group row-fluid">
                <div class="smarttext-tag-name" ></div>
                <div class="smartEditor" ></div>
                <div class="tagDescription" ></div>
            </div>
            <div class="checkbox">
                <label><input type="checkbox">Show me current value before creating signed documents</label>
            </div>`;
            dlg.append(body);
            var smartEditor = $('.smartEditor', dlg);
            var tagDescription = $('.tagDescription', dlg);
            var warnCheckbox = $('[type=checkbox]', dlg);
            let newTagName = $(".smarttext-tag-name", dlg);
            var content = "";
            var description = "";
            var warn = false;
            var dlgTitle = "Edit ";
            // define default content: get it from selection of rich text editor
            if ((tagType === 1 || tagType === 2 || tagType === 4) && window.getSelection().rangeCount) {
                dlgTitle = "Create ";
                var range = window.getSelection().getRangeAt(0);
                try {
                    var fragment = range.cloneContents();
                    var div = document.createElement('div');
                    div.appendChild(fragment.cloneNode(true));
                    content = (tagType === 1) ? div.innerText : div.innerHTML;
                }
                catch (ex) {
                    // nothing selected
                }
            }
            else if (tagType === 0 && what) {
                // it is an edit... replace it with the actual tag type which is stored in the database
                var opt = data ? data : this.getReplacement(what);
                tagType = opt.tagType ? opt.tagType : (opt.plain ? 1 : 2);
                description = opt.description ? opt.description : "";
                content = opt.with ? opt.with : "";
                warn = opt.warn ? opt.warn : false;
                what = opt.what;
            }
            if (tagType === 1) {
                dlgTitle += "Plain Text";
            }
            else if (tagType === 4) {
                dlgTitle += "Abbreviation";
            }
            else if (tagType === 2) {
                dlgTitle += "Smart Text";
            }
            else if (tagType === 3) {
                dlgTitle += "Term";
            }
            dlg.dialog({
                autoOpen: true,
                title: dlgTitle,
                width: 716,
                height: 580,
                resizeStop: function () { },
                modal: true,
                open: function () {
                    matrixlib_1.ml.UI.pushDialog(dlg);
                    // enable or set tag name input field
                    warnCheckbox.prop("checked", warn);
                    // set editor to plain text or html
                    smartEditor.html("");
                    if (tagType === 1) {
                        smartEditor.plainText({ fieldValue: content, canEdit: true, help: "Plain Text", valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                    }
                    else if (tagType === 2) {
                        smartEditor.richText({ fieldValue: content, canEdit: true, help: "Rich Text", parameter: { noConvertTiny: !forceTiny }, valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                    }
                    else if (tagType === 3) {
                        smartEditor.plainText({ fieldValue: content, canEdit: true, help: "Term", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                        tagDescription.richText({ fieldValue: description, canEdit: true, help: "Explanation", parameter: { height: 200, noConvertTiny: !forceTiny }, valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                    }
                    else if (tagType === 4) {
                        smartEditor.plainText({ fieldValue: content, canEdit: true, help: "Short Name", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                        tagDescription.plainText({ fieldValue: description, canEdit: true, help: "Full Name", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(newTagName, smartEditor, tagDescription); } });
                    }
                    that.addEnter(newTagName, smartEditor, tagDescription, what);
                    if (what) {
                        // edit existing tag
                        newTagName.getController().setValue(what);
                    }
                    matrixlib_1.ml.UI.setEnabled($(".btnDoIt", $("#smartTextDlg").parent()), false);
                },
                close: function () { matrixlib_1.ml.UI.popDialog(dlg); },
                buttons: [{
                        text: 'Save',
                        class: 'btnDoIt',
                        click: function () {
                            var html = smartEditor.getController().getValue();
                            var description = (tagType === 3 || tagType === 4) ? tagDescription.getController().getValue() : "";
                            var tag = newTagName.getController().getValue();
                            var warn = warnCheckbox.prop("checked");
                            var newRTF = { "what": tag, "with": html, "warn": warn, tagType: tagType, description: description, when: (new Date()).toISOString() };
                            if (saveFct) {
                                if (saveFct(newRTF)) {
                                    dlg.dialog("close");
                                }
                            }
                            else {
                                that.saveTag(newRTF);
                                dlg.dialog("close");
                            }
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            dlg.dialog("close");
                        }
                    }]
            });
        }
        //**************************************** 
        // tiny rich text functions
        // *************************************** /
        // tiny: dialog to manipulate tags
        selectEditCreateTag(mode, tagType, tagSelected) {
            // mode:
            // 0 insert
            // 1 add
            // 2 edit
            // tagType:
            // 1 new plain text tag
            // 2 new rich text tag
            // 3 new term tag
            // 4 abbreviation tag
            // saveFct: function returning the selected macro
            let that = this;
            // get existing options
            let existing = [];
            let allTagIds = [];
            var config = that.getCurrentConfig();
            $.each(config.replacements, function (optIdx, opt) {
                allTagIds.push(opt.what);
                let tt = opt.tagType ? opt.tagType : (opt.plain ? 1 : 2);
                if (tt == tagType) {
                    existing.push(opt);
                }
            });
            let previous = matrixlib_1.ml.JSON.clone(existing);
            // prepare dialog
            let dlg = $("#smartTextDlg");
            dlg.hide();
            dlg.html("");
            dlg.removeClass("dlg-no-scroll");
            dlg.addClass("dlg-v-scroll");
            var body = `<div class="form-group row-fluid">
            <div class="smartSelect" ></div>
            <div class="smartEditor" ></div>
            <div class="tagDescription" ></div>
        </div>
        <div class="checkbox">
            <label><input type="checkbox">Show me current value before creating signed documents</label>
        </div>`;
            dlg.append(body);
            var smartSelect = $('.smartSelect', dlg);
            var smartEditor = $('.smartEditor', dlg);
            var tagDescription = $('.tagDescription', dlg);
            var warnCheckbox = $('[type=checkbox]', dlg);
            var content = "";
            var description = "";
            var warn = false;
            var dlgTitle = "";
            if (tagType === 1) {
                dlgTitle += "Plain Text";
            }
            else if (tagType === 4) {
                dlgTitle += "Abbreviation";
            }
            else if (tagType === 2) {
                dlgTitle += "Smart Text";
            }
            else if (tagType === 3) {
                dlgTitle += "Term";
            }
            let dialogOptions = {
                autoOpen: true,
                title: dlgTitle,
                width: 716,
                height: 600,
                resizeStop: function () { },
                modal: true,
                open: function () {
                    matrixlib_1.ml.UI.pushDialog(dlg);
                    // enable or set tag name input field
                    warnCheckbox.prop("checked", warn);
                    // set editor to plain text or html
                    smartEditor.html("");
                    if (tagType === 1) {
                        smartEditor.plainText({ fieldValue: content, canEdit: (mode > 0), help: "Plain Text", valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                        tagDescription.hidden({});
                    }
                    else if (tagType === 2) {
                        smartEditor.richText({ fieldValue: content, canEdit: (mode > 0), help: "Rich Text", parameter: { tableMode: true, tiny: true }, valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                        tagDescription.hidden({});
                    }
                    else if (tagType === 3) {
                        smartEditor.plainText({ fieldValue: content, canEdit: (mode > 0), help: "Term", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                        tagDescription.richText({ fieldValue: description, canEdit: (mode > 0), help: "Explanation", parameter: { height: 120, tiny: true }, valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                    }
                    else if (tagType === 4) {
                        smartEditor.plainText({ fieldValue: content, canEdit: (mode > 0), help: "Short Name", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                        tagDescription.plainText({ fieldValue: description, canEdit: (mode > 0), help: "Full Name", parameter: { rows: 1, allowResize: false }, valueChanged: () => { that.calculateButtonEnable(smartSelect, smartEditor, tagDescription); } });
                    }
                    if (mode == 0 /* insert */ || mode == 2 /* add */) {
                        that.addSelect(smartSelect, existing, tagType, smartEditor, tagDescription, warnCheckbox);
                    }
                    else {
                        that.addEnter(smartSelect, smartEditor, tagDescription, "");
                    }
                    matrixlib_1.ml.UI.setEnabled($(".btnDoIt", $("#smartTextDlg").parent()), false);
                },
                close: function () { matrixlib_1.ml.UI.popDialog(dlg); },
                buttons: [{
                        text: 'Close',
                        class: 'btnCancelIt',
                        click: function () {
                            dlg.dialog("close");
                        }
                    }]
            };
            if (mode == 0 /* insert */) {
                dialogOptions.buttons.splice(0, 0, {
                    text: 'Insert',
                    class: 'btnDoIt',
                    click: function () {
                        let html = that.removeOuterParagraph(smartEditor.getController().getValue());
                        var description = (tagType === 3 || tagType === 4) ? tagDescription.getController().getValue() : "";
                        var tag = smartSelect.getController().getValue();
                        var warn = warnCheckbox.prop("checked");
                        // update the current if there's one
                        let exists = existing.filter(function (repl) { return repl.what == tag; });
                        if (exists.length) {
                            exists[0].description = description;
                            exists[0].with = html;
                            exists[0].warn = warn;
                        }
                        if (exists.length) {
                            tagSelected(exists[0]);
                        }
                        that.updateTags(tagType, previous, existing);
                        dlg.dialog("close");
                    }
                });
            }
            else if (mode == 1 /* edit */ || mode == 2 /* add */) {
                dialogOptions.buttons.splice(0, 0, {
                    text: 'Save',
                    class: 'btnDoIt',
                    click: function () {
                        let html = that.removeOuterParagraph(smartEditor.getController().getValue());
                        var description = (tagType === 3 || tagType === 4) ? tagDescription.getController().getValue() : "";
                        var tag = smartSelect.getController().getValue();
                        var warn = warnCheckbox.prop("checked");
                        // update the current if there's one
                        let existsAsAnyType = allTagIds.indexOf(tag) != -1;
                        let exists = existing.filter(function (repl) { return repl.what == tag; });
                        if (mode == 1 && existsAsAnyType) { // create
                            matrixlib_1.ml.UI.showError("Tag id exists already", "There is already a tag with id '" + tag + "'");
                            return false;
                        }
                        else if (mode == 2 && exists.length == 0 && existsAsAnyType) { // edit dialog, trying to add something which exists as other type
                            matrixlib_1.ml.UI.showError("Tag id exists already", "There is already another tag with id '" + tag + "'");
                            return false;
                        }
                        else if (exists.length) { // the tag already exist as same type
                            exists[0].description = description;
                            exists[0].with = html;
                            exists[0].warn = warn;
                        }
                        else {
                            // create new
                            existing.push({
                                tagType: tagType,
                                what: tag,
                                description: description,
                                with: html,
                                warn: warn,
                                when: (new Date()).toISOString()
                            });
                        }
                        that.updateTags(tagType, previous, existing);
                        dlg.dialog("close");
                        return true;
                    }
                });
            }
            dlg.dialog(dialogOptions);
        }
        // tiny: figure out if tag can be inserted
        calculateButtonEnableInsert(option) {
            let btnEnabled = !!option;
            matrixlib_1.ml.UI.setEnabled($(".btnDoIt", $("#smartTextDlg").parent()), btnEnabled);
        }
        // tiny: figure out if tag can be created
        calculateButtonEnable(tagName, smartEditor, tagDescription) {
            let btnEnabled = true;
            if (smartEditor.getController().getValue() == "") {
                btnEnabled = false;
            }
            if ($("input", tagDescription).is(":visible") && tagDescription.getController().getValue() == "") {
                btnEnabled = false;
            }
            if (tagName.getController && tagName.getController().getValue() == "") {
                btnEnabled = false;
            }
            if (!tagName.getController && tagName.val() == "") {
                btnEnabled = false;
            }
            matrixlib_1.ml.UI.setEnabled($(".btnDoIt", $("#smartTextDlg").parent()), btnEnabled);
        }
        // tiny: get rid of <p>tag around rich text (if there are not 2 paragraphs)
        removeOuterParagraph(edit) {
            if (edit.length < 8)
                return edit; // no <p>something</p>
            if (edit.substr(0, 3) != "<p>")
                return edit; // no <p>something</p>
            if (edit.substr(edit.length - 4, 4) != "</p>")
                return edit; // no <p>something</p>
            if (edit.indexOf("<p", 1) != -1)
                return edit; // <p>something</p><p> xxx</p>
            return edit.substr(3, edit.length - 7);
        }
        // tiny: create dropdown with existing tags
        addSelect(container, existing, tagType, replace, description, warn) {
            let that = this;
            let options = existing.map(function (st, idx) { return { id: st.what, label: (st.projectSetting ? st.what : (st.what + " (server)")) }; });
            let last = "";
            let dd = container.mxDropdown({
                help: "Macro Name",
                canEdit: true,
                parameter: {
                    placeholder: "select macro",
                    create: true,
                    options: options,
                    maxItems: 1,
                    sort: true
                }, valueChanged: function () {
                    let val = dd.getController().getValue();
                    var before = existing.filter(function (sm) { return sm.what == last; });
                    if (before.length) {
                        // update the previously selected
                        before[0].with = replace.getController().getValue();
                        before[0].description = that.removeOuterParagraph(description.getController().getValue());
                        before[0].warn = warn.prop("checked");
                    }
                    var after = existing.filter(function (sm) { return sm.what == val; });
                    if (after.length) {
                        // load the new one
                        replace.getController().setValue(after[0].with);
                        description.getController().setValue(after[0].description);
                        warn.prop("checked", after[0].warn);
                    }
                    last = val;
                    that.calculateButtonEnableInsert(val);
                },
                fieldValue: ""
            });
            return dd;
        }
        // tiny: field to enter tag name
        addEnter(container, replace, description, text) {
            let that = this;
            let last = "";
            let dd = container.plainText({
                id: "",
                help: "New Macro Name:",
                parameter: { rows: 1, allowResize: false },
                controlState: globals_1.ControlState.DialogCreate,
                valueChanged: () => {
                    let val = dd.getController().getValue();
                    let clean = val ? val.replace(/[^a-zA-Z0-9]/g, '') : "";
                    if (clean && last != clean) {
                        last = clean;
                        dd.getController().setValue(clean);
                    }
                    that.calculateButtonEnable(container, replace, description);
                },
                canEdit: text ? false : true,
                validate: false, noAutoActivation: true,
                fieldValue: text ? text : ""
            });
            return dd;
        }
        //**************************************** 
        // both editors (sumernote+tiny) functions
        // *************************************** /
        replaceTextFragments(text, showTooltips, encoded) {
            let that = this;
            var textFragments = this.getCurrentConfig();
            if (textFragments && textFragments.replacements) {
                $.each(textFragments.replacements, function (replacementIdx, replacement) {
                    let resolved = that.resolveRec(replacement.with, textFragments.replacements, 5);
                    let rwith = "<span class='macro' data-macro='_" + replacement.what + "_'>" + resolved + "<span class='" +
                        (showTooltips ? 'smart-replace' : '') +
                        "' data-toggle='tooltip'  data-what='" + replacement.what + "' data-placement='auto top' >" +
                        (showTooltips ? '*' : '') + "</span></span>";
                    if (encoded) {
                        rwith = JSON.stringify(rwith);
                        rwith = rwith.substr(1, rwith.length - 2);
                    }
                    text = text.replace(new RegExp("_" + replacement.what + "_", 'g'), rwith);
                });
            }
            return text;
        }
        resolveRec(text, replace, levels) {
            if (!levels) {
                // no more replacements
                return text;
            }
            let org = text;
            for (let rep of replace) {
                text = text.replace(new RegExp("_" + rep.what + "_", 'g'), rep.with);
            }
            // if something was replaced go on
            return org == text ? org : this.resolveRec(text, replace, levels - 1);
        }
        showTooltips(node, noContainer) {
            let that = this;
            $.each($(".smart-replace", node), function (tti, tt) {
                const what = $(tt).data("what");
                const rwith = that.getReplacement(what);
                if (rwith) {
                    const tagType = rwith.tagType ? rwith.tagType : (rwith.plain ? 1 : 2);
                    let tooltip = "<div class='smarttext_what'>_" + what + "_ (" + that.getTooltipType(rwith) + ")</div>";
                    if (tagType === 3 || tagType === 4) {
                        tooltip += "<div class='smarttext_description'>" + rwith.description + "</div>";
                    }
                    $(tt).tooltip({
                        html: true,
                        title: tooltip,
                        container: noContainer ? false : "body",
                        template: '<div class="tooltip smarttext-tooltip" role="tooltip"><div class="tooltip-arrow smarttext-tooltip-arrow"></div><div class="tooltip-inner smarttext-tooltip-inner"></div></div>'
                    });
                }
            });
        }
        ;
        prepareForReadReadRender(itemDetails) {
            // replace all form fields with static html to so that they can be easily copied
            $("select", itemDetails).each(function (idx, select) { $(select).replaceWith("<div>" + matrixlib_1.ml.UI.lt.forDB($("option:selected", $(select)).text(), 0) + "</div>"); });
            $("textarea", itemDetails).each(function (idx, select) { $(select).replaceWith("<div>" + matrixlib_1.ml.UI.lt.forDB($(select).val(), 0).replace(/\n/g, "<br>") + "</div>"); });
            // line input fields
            $("input[type!=checkbox]", itemDetails).each(function (idx, select) { $(select).replaceWith("<div>" + matrixlib_1.ml.UI.lt.forDB($(select).val(), 0) + "</div>"); });
            // checkboxes
            $("input[type=checkbox]:not(.showHideAdmin)", itemDetails).each(function (idx, select) { $(select).replaceWith("<span class='" + ($(select).is(':checked') ? "	fal fa-check-square" : "fal fa-square") + "'> </span>"); });
            // cache html
            itemDetails.parent().data("originalHTML", itemDetails.html());
        }
        getTooltipType(repl) {
            var tagType = repl.tagType ? repl.tagType : (repl.plain ? 1 : 2);
            switch (tagType) {
                case 1:
                    return "Plain Text Replacement";
                case 2:
                    return "Rich Text Replacement";
                case 3:
                    return "Term Definition";
                case 4:
                    return "Abbreviation";
            }
            return "";
        }
        getCurrentConfig() {
            var config = { replacements: [] };
            if (globals_1.globalMatrix.ItemConfig == undefined)
                return config;
            var sconfig = globals_1.globalMatrix.ItemConfig.getSmartText();
            if (sconfig && sconfig.replacements && sconfig.replacements.length > 0) {
                // mark the project wide settings
                config = matrixlib_1.ml.JSON.clone(sconfig);
                $.each(config.replacements, function (optIdx, opt) {
                    opt.projectSetting = true;
                });
            }
            // check if there are server/customer settings and merge them in (project have precedence)
            var sc = globals_1.matrixSession.getCustomerSettingJSON("rtf");
            if (sc && sc.replacements) {
                $.each(sc.replacements, function (csidx, cs) {
                    var found = false;
                    $.each(config.replacements, function (optIdx, opt) {
                        if (opt.what + "" === cs.what + "") { // make sure both are strings
                            found = true;
                        }
                    });
                    if (!found) {
                        config.replacements.push(cs);
                    }
                });
            }
            // sort
            config.replacements = config.replacements.sort(function (a, b) {
                return (a.what > b.what) ? 1 : ((a.what < b.what) ? -1 : 0);
            });
            return config;
        }
        // update and add new tags
        updateTags(tagType, previous, updated) {
            globals_1.restConnection.getProject("setting").done(function (result) {
                globals_1.globalMatrix.ItemConfig.addSettings(result);
                var config = globals_1.globalMatrix.ItemConfig.getSmartText();
                if (!config || !config.replacements || config.replacements.length === 0) {
                    config = { replacements: [] };
                }
                let changed = false;
                $.each(updated, function (eIdx, update) {
                    let found = false;
                    let previously = previous.filter(function (prev) { return prev.what == update.what; });
                    let unChanged = (previously.length && previously[0].with == update.with && previously[0].description == update.description && previously[0].warn == update.warn);
                    if (!unChanged) {
                        // either replace the old from the project setting ...
                        $.each(config.replacements, function (optIdx, current) {
                            if (current.what == update.what) {
                                if (current.with != update.with || current.description != update.description || current.warn != update.warn) {
                                    // update the project setting
                                    found = true;
                                    changed = true;
                                    current.with = update.with;
                                    current.description = update.description;
                                    current.warn = update.warn;
                                    current.when = (new Date()).toISOString();
                                }
                            }
                        });
                        // ... or create a new one
                        if (!found) {
                            // we need to create a new project setting
                            changed = true;
                            config.replacements.push({ what: update.what, with: update.with, warn: update.warn, tagType: tagType, description: update.description, when: (new Date()).toISOString() });
                        }
                    }
                });
                if (changed) {
                    globals_1.app.setSettingJSON(ProjectSettings_1.smartTextConfigSetting, config);
                }
            });
        }
        saveTag(tag) {
            // reload the settings to be sure nobody changed it inbetween
            globals_1.restConnection.getProject("setting").done(function (result) {
                globals_1.globalMatrix.ItemConfig.addSettings(result);
                var config = globals_1.globalMatrix.ItemConfig.getSmartText();
                if (!config || !config.replacements || config.replacements.length === 0) {
                    config = { replacements: [tag] };
                }
                else {
                    // check if it is an update or new
                    var found = false;
                    $.each(config.replacements, function (optIdx, opt) {
                        if (opt.what + "" === tag.what + "") {
                            config.replacements[optIdx] = tag;
                            found = true;
                        }
                    });
                    if (!found) {
                        config.replacements.push(tag);
                    }
                }
                globals_1.app.setSettingJSON("rtf", config);
            });
        }
        getReplacement(what) {
            let config = this.getCurrentConfig();
            let hit;
            $.each(config.replacements, function (optIdx, opt) {
                if (opt.what + "" === what + "") { // make sure both are strings
                    hit = opt;
                }
            });
            return hit;
        }
    }
    exports.SmartTextTools = SmartTextTools;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 74 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference types="matrixrequirements-type-declarations" />
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(12), __webpack_require__(17), __webpack_require__(1), __webpack_require__(75), __webpack_require__(76), __webpack_require__(3), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, index_1, index_2, index_3, matrixlib_1, ThemeSelector_1, WidgetPluginsContainer_1, MatrixLibInterfaces_1, globals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.UIToolsEnum = exports.LT = exports.SelectUserOrGroupUI = exports.ProgressUI = exports.BlockingProgressUI = exports.DateTimeUI = void 0;
    class UIToolsEnum {
        constructor() {
            this.tooltip_cache = {};
            this.removeTimer = {};
            this.toolIcons = ["ad", "address-book", "address-card", "adjust", "air-freshener", "align-center", "align-justify", "align-left", "align-right", "allergies", "ambulance", "american-sign-language-interpreting", "anchor", "angle-double-down", "angle-double-left", "angle-double-right", "angle-double-up", "angle-down", "angle-left", "angle-right", "angle-up", "angry", "ankh", "apple-alt", "archive", "archway", "arrow-alt-circle-down", "arrow-alt-circle-left", "arrow-alt-circle-right", "arrow-alt-circle-up", "arrow-circle-down", "arrow-circle-left", "arrow-circle-right", "arrow-circle-up", "arrow-down", "arrow-left", "arrow-right", "arrow-up", "arrows-alt", "arrows-alt-h", "arrows-alt-v", "assistive-listening-systems", "asterisk", "at", "atlas", "atom", "audio-description", "award", "baby", "baby-carriage", "backspace", "backward", "bacon", "balance-scale", "balance-scale-left", "balance-scale-right", "ban", "band-aid", "barcode", "bars", "baseball-ball", "basketball-ball", "bath", "battery-empty", "battery-full", "battery-half", "battery-quarter", "battery-three-quarters", "bed", "beer", "bell", "bell-slash", "bezier-curve", "bible", "bicycle", "biking", "binoculars", "biohazard", "birthday-cake", "blender", "blender-phone", "blind", "blog", "bold", "bolt", "bomb", "bone", "bong", "book", "book-dead", "book-medical", "book-open", "book-reader", "bookmark", "border-all", "border-none", "border-style", "bowling-ball", "box", "box-open", "boxes", "braille", "brain", "bread-slice", "briefcase", "briefcase-medical", "broadcast-tower", "broom", "brush", "bug", "building", "bullhorn", "bullseye", "burn", "bus", "bus-alt", "business-time", "calculator", "calendar", "calendar-alt", "calendar-check", "calendar-day", "calendar-minus", "calendar-plus", "calendar-times", "calendar-week", "camera", "camera-retro", "campground", "candy-cane", "cannabis", "capsules", "car", "car-alt", "car-battery", "car-crash", "car-side", "caret-down", "caret-left", "caret-right", "caret-square-down", "caret-square-left", "caret-square-right", "caret-square-up", "caret-up", "carrot", "cart-arrow-down", "cart-plus", "cash-register", "cat", "certificate", "chair", "chalkboard", "chalkboard-teacher", "charging-station", "chart-area", "chart-bar", "chart-line", "chart-pie", "check", "check-circle", "check-double", "check-square", "cheese", "chess", "chess-bishop", "chess-board", "chess-king", "chess-knight", "chess-pawn", "chess-queen", "chess-rook", "chevron-circle-down", "chevron-circle-left", "chevron-circle-right", "chevron-circle-up", "chevron-down", "chevron-left", "chevron-right", "chevron-up", "child", "church", "circle", "circle-notch", "city", "clinic-medical", "clipboard", "clipboard-check", "clipboard-list", "clock", "clone", "closed-captioning", "cloud", "cloud-download-alt", "cloud-meatball", "cloud-moon", "cloud-moon-rain", "cloud-rain", "cloud-showers-heavy", "cloud-sun", "cloud-sun-rain", "cloud-upload-alt", "cocktail", "code", "code-branch", "coffee", "cog", "cogs", "coins", "columns", "comment", "comment-alt", "comment-dollar", "comment-dots", "comment-medical", "comment-slash", "comments", "comments-dollar", "compact-disc", "compass", "compress", "compress-arrows-alt", "concierge-bell", "cookie", "cookie-bite", "copy", "copyright", "couch", "credit-card", "crop", "crop-alt", "cross", "crosshairs", "crow", "crown", "crutch", "cube", "cubes", "cut", "database", "deaf", "democrat", "desktop", "dharmachakra", "diagnoses", "dice", "dice-d20", "dice-d6", "dice-five", "dice-four", "dice-one", "dice-six", "dice-three", "dice-two", "digital-tachograph", "directions", "divide", "dizzy", "dna", "dog", "dollar-sign", "dolly", "dolly-flatbed", "donate", "door-closed", "door-open", "dot-circle", "dove", "download", "drafting-compass", "dragon", "draw-polygon", "drum", "drum-steelpan", "drumstick-bite", "dumbbell", "dumpster", "dumpster-fire", "dungeon", "edit", "egg", "eject", "ellipsis-h", "ellipsis-v", "envelope", "envelope-open", "envelope-open-text", "envelope-square", "equals", "eraser", "ethernet", "euro-sign", "exchange-alt", "exclamation", "exclamation-circle", "exclamation-triangle", "expand", "expand-arrows-alt", "external-link-alt", "external-link-square-alt", "eye", "eye-dropper", "eye-slash", "fan", "fast-backward", "fast-forward", "fax", "feather", "feather-alt", "female", "fighter-jet", "file", "file-alt", "file-archive", "file-audio", "file-code", "file-contract", "file-csv", "file-download", "file-excel", "file-", "file-image", "file-import", "file-invoice", "file-invoice-dollar", "file-medical", "file-medical-alt", "file-pdf", "file-powerpoint", "file-prescription", "file-signature", "file-upload", "file-video", "file-word", "fill", "fill-drip", "film", "filter", "fingerprint", "fire", "fire-alt", "fire-extinguisher", "first-aid", "fish", "fist-raised", "flag", "flag-checkered", "flag-usa", "flask", "flushed", "folder", "folder-minus", "folder-open", "folder-plus", "font", "football-ball", "forward", "frog", "frown", "frown-open", "funnel-dollar", "futbol", "gamepad", "gas-pump", "gavel", "gem", "genderless", "ghost", "gift", "gifts", "glass-cheers", "glass-martini", "glass-martini-alt", "glass-whiskey", "glasses", "globe", "globe-africa", "globe-americas", "globe-asia", "globe-europe", "golf-ball", "gopuram", "graduation-cap", "greater-than", "greater-than-equal", "grimace", "grin", "grin-alt", "grin-beam", "grin-beam-sweat", "grin-hearts", "grin-squint", "grin-squint-tears", "grin-stars", "grin-tears", "grin-tongue", "grin-tongue-squint", "grin-tongue-wink", "grin-wink", "grip-horizontal", "grip-lines", "grip-lines-vertical", "grip-vertical", "guitar", "h-square", "hamburger", "hammer", "hamsa", "hand-holding", "hand-holding-heart", "hand-holding-usd", "hand-lizard", "hand-middle-finger", "hand-paper", "hand-peace", "hand-point-down", "hand-point-left", "hand-point-right", "hand-point-up", "hand-pointer", "hand-rock", "hand-scissors", "hand-spock", "hands", "hands-helping", "handshake", "hanukiah", "hard-hat", "hashtag", "hat-cowboy", "hat-cowboy-side", "hat-wizard", "haykal", "hdd", "heading", "headphones", "headphones-alt", "headset", "heart", "heart-broken", "heartbeat", "helicopter", "highlighter", "hiking", "hippo", "history", "hockey-puck", "holly-berry", "home", "horse", "horse-head", "hospital", "hospital-alt", "hospital-symbol", "hot-tub", "hotdog", "hotel", "hourglass", "hourglass-end", "hourglass-half", "hourglass-start", "house-damage", "hryvnia", "i-cursor", "ice-cream", "icicles", "icons", "id-badge", "id-card", "id-card-alt", "igloo", "image", "images", "inbox", "indent", "industry", "infinity", "info", "info-circle", "italic", "jedi", "joint", "journal-whills", "kaaba", "key", "keyboard", "khanda", "kiss", "kiss-beam", "kiss-wink-heart", "kiwi-bird", "landmark", "language", "laptop", "laptop-code", "laptop-medical", "laugh", "laugh-beam", "laugh-squint", "laugh-wink", "layer-group", "leaf", "lemon", "less-than", "less-than-equal", "level-down-alt", "level-up-alt", "life-ring", "lightbulb", "link", "lira-sign", "list", "list-alt", "list-ol", "list-ul", "location-arrow", "lock", "lock-open", "long-arrow-alt-down", "long-arrow-alt-left", "long-arrow-alt-right", "long-arrow-alt-up", "low-vision", "luggage-cart", "magic", "magnet", "mail-bulk", "male", "map", "map-marked", "map-marked-alt", "map-marker", "map-marker-alt", "map-pin", "map-signs", "marker", "mars", "mars-double", "mars-stroke", "mars-stroke-h", "mars-stroke-v", "mask", "medal", "medkit", "meh", "meh-blank", "meh-rolling-eyes", "memory", "menorah", "mercury", "meteor", "microchip", "microphone", "microphone-alt", "microphone-alt-slash", "microphone-slash", "microscope", "minus", "minus-circle", "minus-square", "mitten", "mobile", "mobile-alt", "money-bill", "money-bill-alt", "money-bill-wave", "money-bill-wave-alt", "money-check", "money-check-alt", "monument", "moon", "mortar-pestle", "mosque", "motorcycle", "mountain", "mouse", "mouse-pointer", "mug-hot", "music", "network-wired", "neuter", "newspaper", "not-equal", "notes-medical", "object-group", "object-ungroup", "oil-can", "om", "otter", "outdent", "pager", "paint-brush", "paint-roller", "palette", "pallet", "paper-plane", "paperclip", "parachute-box", "paragraph", "parking", "passport", "pastafarianism", "paste", "pause", "pause-circle", "paw", "peace", "pen", "pen-alt", "pen-fancy", "pen-nib", "pen-square", "pencil-alt", "pencil-ruler", "people-carry", "pepper-hot", "percent", "percentage", "person-booth", "phone", "phone-alt", "phone-slash", "phone-square", "phone-square-alt", "phone-volume", "photo-video", "piggy-bank", "pills", "pizza-slice", "place-of-worship", "plane", "plane-arrival", "plane-departure", "play", "play-circle", "plug", "plus", "plus-circle", "plus-square", "podcast", "poll", "poll-h", "poo", "poo-storm", "poop", "portrait", "pound-sign", "power-off", "pray", "praying-hands", "prescription", "prescription-bottle", "prescription-bottle-alt", "print", "procedures", "project-diagram", "puzzle-piece", "qrcode", "question", "question-circle", "quidditch", "quote-left", "quote-right", "quran", "radiation", "radiation-alt", "rainbow", "random", "receipt", "record-vinyl", "recycle", "redo", "redo-alt", "registered", "remove-format", "reply", "reply-all", "republican", "restroom", "retweet", "ribbon", "ring", "road", "robot", "rocket", "route", "rss", "rss-square", "ruble-sign", "ruler", "ruler-combined", "ruler-horizontal", "ruler-vertical", "running", "rupee-sign", "sad-cry", "sad-tear", "satellite", "satellite-dish", "save", "school", "screwdriver", "scroll", "sd-card", "search", "search-dollar", "search-location", "search-minus", "search-plus", "seedling", "server", "shapes", "share", "share-alt", "share-alt-square", "share-square", "shekel-sign", "shield-alt", "ship", "shipping-fast", "shoe-prints", "shopping-bag", "shopping-basket", "shopping-cart", "shower", "shuttle-van", "sign", "sign-in-alt", "sign-language", "sign-out-alt", "signal", "signature", "sim-card", "sitemap", "skating", "skiing", "skiing-nordic", "skull", "skull-crossbones", "slash", "sleigh", "sliders-h", "smile", "smile-beam", "smile-wink", "smog", "smoking", "smoking-ban", "sms", "snowboarding", "snowflake", "snowman", "snowplow", "socks", "solar-panel", "sort", "sort-alpha-down", "sort-alpha-down-alt", "sort-alpha-up", "sort-alpha-up-alt", "sort-amount-down", "sort-amount-down-alt", "sort-amount-up", "sort-amount-up-alt", "sort-down", "sort-numeric-down", "sort-numeric-down-alt", "sort-numeric-up", "sort-numeric-up-alt", "sort-up", "spa", "space-shuttle", "spell-check", "spider", "spinner", "splotch", "spray-can", "square", "square-full", "square-root-alt", "stamp", "star", "star-and-crescent", "star-half", "star-half-alt", "star-of-david", "star-of-life", "step-backward", "step-forward", "stethoscope", "sticky-note", "stop", "stop-circle", "stopwatch", "store", "store-alt", "stream", "street-view", "strikethrough", "stroopwafel", "subscript", "subway", "suitcase", "suitcase-rolling", "sun", "superscript", "surprise", "swatchbook", "swimmer", "swimming-pool", "synagogue", "sync", "sync-alt", "syringe", "table", "table-tennis", "tablet", "tablet-alt", "tablets", "tachometer-alt", "tag", "tags", "tape", "tasks", "taxi", "teeth", "teeth-open", "temperature-high", "temperature-low", "tenge", "terminal", "text-height", "text-width", "th", "th-large", "th-list", "theater-masks", "thermometer", "thermometer-empty", "thermometer-full", "thermometer-half", "thermometer-quarter", "thermometer-three-quarters", "thumbs-down", "thumbs-up", "thumbtack", "ticket-alt", "times", "times-circle", "tint", "tint-slash", "tired", "toggle-off", "toggle-on", "toilet", "toilet-paper", "toolbox", "tools", "tooth", "torah", "torii-gate", "tractor", "trademark", "traffic-light", "train", "tram", "transgender", "transgender-alt", "trash", "trash-alt", "trash-restore", "trash-restore-alt", "tree", "trophy", "truck", "truck-loading", "truck-monster", "truck-moving", "truck-pickup", "tshirt", "tty", "tv", "umbrella", "umbrella-beach", "underline", "undo", "undo-alt", "universal-access", "university", "unlink", "unlock", "unlock-alt", "upload", "user", "user-alt", "user-alt-slash", "user-astronaut", "user-check", "user-circle", "user-clock", "user-cog", "user-edit", "user-friends", "user-graduate", "user-injured", "user-lock", "user-md", "user-minus", "user-ninja", "user-nurse", "user-plus", "user-secret", "user-shield", "user-slash", "user-tag", "user-tie", "user-times", "users", "users-cog", "utensil-spoon", "utensils", "vector-square", "venus", "venus-double", "venus-mars", "vial", "vials", "video", "video-slash", "vihara", "voicemail", "volleyball-ball", "volume-down", "volume-mute", "volume-off", "volume-up", "vote-yea", "vr-cardboard", "walking", "wallet", "warehouse", "water", "wave-square", "weight", "weight-hanging", "wheelchair", "wifi", "wind", "window-close", "window-maximize", "window-minimize", "window-restore", "wine-bottle", "wine-glass", "wine-glass-alt", "won-sign", "wrench", "x-ray", "yen-sign", "yin-yang"];
            //private colorScheme:string[] =  ["#1abc9c", "#2ecc71", "#3498db", "#9b59b6", "#34495e", "#16a085", "#27ae60", "#2980b9", "#8e44ad", "#2c3e50", "#f1c40f", "#e67e22", "#e74c3c", "#95a5a6", "#f39c12", "#d35400", "#c0392b", "#bdc3c7", "#7f8c8d"];
            this.colorScheme = [
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.Black,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BlueDoger,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BlueEastBay,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BlueLagoon,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BlueZiggurat,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BrownCoffeeRoyal,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BrownDiSerria,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.BrownTiaMaria,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.GreenSushi,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.GreenYellow,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.GreyDark,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.OrangeYellow,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.PinkHot,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.RedPersimmon,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.VioletElectric,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.VioletMauve,
                MatrixLibInterfaces_1.UIToolsConstants.CIColors.YellowBrightSun
            ];
            this.widgetPluginsContainer = new WidgetPluginsContainer_1.WidgetPluginsContainer();
            this.DateTime = new DateTimeUI();
            this.BlockingProgress = new BlockingProgressUI();
            this.SelectUserOrGroup = new SelectUserOrGroupUI();
            this.lt = new LT();
            this.Progress = new ProgressUI();
            this.ThemeSelector = new ThemeSelector_1.ThemeSelector();
        }
        fixC3ForCopy(copied) {
            $(".c3-legend-background", copied).remove();
            $("svg path", copied).css("cursor", "unset");
            $("svg text", copied).css("opacity", "1");
            $(".c3-legend-item ", copied).css("cursor", "unset");
            $(".c3-axis path.domain", copied).attr("stroke", "black");
            $(".c3-axis .tick line", copied).attr("stroke", "black");
            $(".c3-axis path.domain", copied).attr("fill", "none");
        }
        // helper to show a drop down / drop up button allowing to click on one of several options
        createDropDownButton(defaultText, options, isUp, isJui, buttonId, disableDefaultButtonClick) {
            var id = buttonId ? ('id="' + buttonId + '"') : "";
            if (options.length === 1) {
                var bootLook = "btn btn-default";
                var juiLook = "ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only juidd";
                // render as simple button
                var button = $('<span ' + id + ' type="button" class="' + (isJui ? juiLook : bootLook) + '">');
                var btnText = $('<span class="ui-button-text">');
                btnText.append($('<span>').html(defaultText));
                button.append(btnText).click(function (event) {
                    if (!button.prop('disabled')) {
                        // do the click and disable button for a while
                        options[0].click();
                        button.prop('disabled', true);
                        button.addClass('disabled');
                        setTimeout(function () {
                            button.prop('disabled', false);
                            button.removeClass('disabled');
                        }, 1000);
                    }
                    if (event.preventDefault)
                        event.preventDefault();
                    return false;
                });
                return $('<div class="btn-group">').append(button);
            }
            var bootLook = "btn btn-default dropdown-toggle";
            var juiLook = "ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only juidd";
            var button = $('<span type="button" class="' + (isJui ? juiLook : bootLook) + '" data-toggle="dropdown" aria-expanded="false">');
            var btnText = $('<span class="ui-button-text">');
            button.append(btnText);
            let ddcaret = $('<span class="caret ddmenubtndrop">');
            btnText.append($('<span ' + id + ' >').html(defaultText).click(function (event) {
                if (disableDefaultButtonClick) {
                    ddcaret.trigger("click");
                }
                else if (!button.prop('disabled')) {
                    // do the click and disable button for a while
                    options[0].click();
                    button.prop('disabled', true);
                    button.addClass('disabled');
                    setTimeout(function () {
                        button.prop('disabled', false);
                        button.removeClass('disabled');
                    }, 1000);
                }
                if (event.preventDefault)
                    event.preventDefault();
                return false;
            }));
            btnText.append(ddcaret);
            var ddOptions = $('<ul class="dropdown-menu" role="menu">');
            $.each(options, function (idx, opt) {
                ddOptions.append($('<li>').append($('<a>').attr('href', 'javascript:void(0)').addClass(opt.class).html(opt.name)).click(function (event) {
                    opt.click();
                    button.closest(".dropdown").removeClass("open");
                    if (event.preventDefault)
                        event.preventDefault();
                    return false;
                }));
            });
            return $('<div class="btn-group ' + (isUp ? 'dropup' : 'dropdown') + '">').append(button).append(ddOptions);
        }
        // get optimal size of a dialog window dependent on available screen
        getNiceDialogSize(minWidth, minHeight) {
            return {
                width: minWidth < 0 ? Math.abs(minWidth) : Math.max(minWidth, globals_1.app.itemForm.width() / 2),
                height: minHeight < 0 ? Math.abs(minHeight) : Math.max(minHeight, globals_1.app.itemForm.height() / 2)
            };
        }
        ;
        // show success message
        // hideAfter =0 or undefined: 2000 ms, -1 do not hide
        showSuccess(messageTitle, hideAfter) {
            matrixlib_1.ml.Logger.log("success", messageTitle);
            $('#message_success').html("<span class='msgHeader'>" + messageTitle + "</span>");
            this.showSlide('#message_success', hideAfter ? (hideAfter < 0 ? 0 : hideAfter) : 2000);
        }
        hideSuccess() {
            this.hideSlide($('#message_success'));
        }
        hideError() {
            this.hideSlide($('#message_error'));
        }
        // show error message
        showError(messageTitle, messageBody, showForMS) {
            matrixlib_1.ml.Logger.log("error", messageTitle + ": " + messageBody);
            $('#message_error').html("<span class='msgHeader'>" + messageTitle + "</span>" +
                "<br/>" +
                "<p class='msgBody'>" + messageBody + "</p>");
            var duration = 5000;
            if (showForMS) {
                duration = showForMS;
            }
            this.showSlide('#message_error', duration);
        }
        ;
        // show acknowledge message
        /**
         * show acknowledge dialog
         * @param ackId: a (unique) value > 0 can be used as unique id to have acknowledge boxes which are shown only one
         * @param messageTitle
         * @param dlgTitle
         */
        showAck(ackId, messageTitle, dlgTitle) {
            if (globals_1.globalMatrix.serverStorage.getItem("ackMessage_" + ackId)) {
                // user clicked on ack -> on this computer
                // or it was manually set
                return;
            }
            matrixlib_1.ml.Logger.log("ack", messageTitle);
            $('#message_ack_title').html(dlgTitle ? dlgTitle : "Acknowledge");
            $('#message_ack_ok').off("click");
            $('#message_ack_ok').one("click", function () {
                if (ackId > 0) {
                    // allow to click away
                    globals_1.globalMatrix.serverStorage.setItem("ackMessage_" + ackId, (new Date()).toString());
                }
            });
            $('#message_ack_content').html(messageTitle);
            $('#message_ack').modal({ backdrop: 'static' });
        }
        // ask for confirmation 
        showConfirm(confId, messageInfo, confFunction, noConfFunction, thirdFunction) {
            let that = this;
            if (globals_1.globalMatrix.serverStorage.getItem("confMessage_" + confId)) {
                // user clicked on conf -> on this computer
                // or it was manually set
                return;
            }
            matrixlib_1.ml.Logger.log("conf", messageInfo.title);
            $('#message_conf_ok').off("click");
            $('#message_conf_nok').off("click");
            $('#message_conf_third').off("click").hide();
            $('#message_conf').off('hidden.bs.modal');
            $('#message_conf_ok').one("click", function () {
                if (confFunction) {
                    $('#message_conf').one('hidden.bs.modal', () => {
                        confFunction();
                    });
                }
            });
            $('#message_conf_nok').one("click", function () {
                if (noConfFunction) {
                    $('#message_conf').one('hidden.bs.modal', () => {
                        noConfFunction();
                    });
                }
            });
            $('#message_conf_third').one("click", function () {
                if (thirdFunction) {
                    $('#message_conf').one('hidden.bs.modal', () => {
                        thirdFunction();
                    });
                }
            });
            $('#message_conf_content').html(messageInfo.title);
            $('#message_conf_ok').html(messageInfo.ok ? messageInfo.ok : "OK");
            $('#message_conf_nok').html(messageInfo.nok ? messageInfo.nok : "Cancel");
            if (messageInfo.third) {
                $('#message_conf_third').html(messageInfo.third);
                $('#message_conf_third').show();
            }
            $('#message_conf').modal({ backdrop: 'static' });
            $("#message_conf_content").closest(".modal").css("z-index", "20000");
        }
        confirmSpinningWait(message) {
            $('#message_conf_content').html("").append(this.getSpinningWait(message));
            this.setEnabled($('#message_conf_ok'), false);
            this.setEnabled($('#message_conf_nok'), false);
            $('#message_conf').modal({ backdrop: 'static' });
        }
        closeConfirmSpinningWait() {
            this.setEnabled($('#message_conf_ok'), true);
            this.setEnabled($('#message_conf_nok'), true);
            $('#message_conf').modal('hide');
        }
        // show item as tool tip
        showTooltip(itemId, target, event, crossProject) {
            let that = this;
            clearTimeout(this.lastTooltipHide);
            clearTimeout(this.lastTooltipRequest);
            this.lastTooltipHide = null;
            this.lastTooltipRequest = window.setTimeout(function () {
                that.showTooltip_Delayed(itemId, target, crossProject);
            }, globals_1.globalMatrix.globalShiftDown ? 10 : 500);
        }
        showTaskAsTooltip(id, title, url, htmlContent, target) {
            let that = this;
            clearTimeout(this.lastTooltipHide);
            clearTimeout(this.lastTooltipRequest);
            this.lastTooltipHide = null;
            this.lastTooltipRequest = window.setTimeout(function () {
                that.showTaskAsTooltip_Delayed(id, title, url, htmlContent, target);
            }, globals_1.globalMatrix.globalShiftDown ? 10 : 500);
        }
        // hide item tool tip
        hideTooltip(now) {
            let that = this;
            clearTimeout(this.lastTooltipHide);
            clearTimeout(this.lastTooltipRequest);
            this.lastTooltipHide = null;
            this.lastTooltipRequest = null;
            if (now) {
                var height = Math.max(300, this.getSlideHeight($("#tooltip_panel"), true));
                $("#tooltip_panel").css('margin-top', '-' + height + 'px');
            }
            else {
                this.lastTooltipHide = window.setTimeout(function () {
                    that.hideCurrentToolTip();
                }, 2000);
            }
        }
        // refresh tool tip (does not yet work...)
        updateTooltip() {
            if (this.hidden_tooltip_itemId) {
                this.showTooltip_Delayed(this.hidden_tooltip_itemId, $("#tooltip_panel"));
            }
        }
        // show message that user name or password has spaces
        spaceMessage(userHasSpaces, passwordHasSpaces) {
            if (userHasSpaces && passwordHasSpaces) {
                return "user name and password cannot have spaces";
            }
            else if (userHasSpaces) {
                return "user name cannot have spaces";
            }
            else if (passwordHasSpaces) {
                return "password cannot have spaces";
            }
            else {
                return "";
            }
        }
        ;
        // return span with spinning wait icon and text
        getSpinningWait(message) {
            var span = $("<span class='spinningWait hideCopy'>");
            span.append($('<span class="fal fa-sync-alt refresh-animate"></span>"'))
                .append($('<span class="waitscreenmessage">' + (message ? message : "please wait....") + '</span>"'));
            return span;
        }
        ;
        setEnabled(button, enabled) {
            if (enabled) {
                button.prop("disabled", false).removeClass("ui-state-disabled");
            }
            else {
                button.prop("disabled", true).addClass("ui-state-disabled");
            }
        }
        getDisplayError(jqxhr, textStatus, error) {
            if (jqxhr && jqxhr.responseJSON && jqxhr.responseJSON.displayError) {
                return jqxhr.responseJSON.displayError;
            }
            if (textStatus == "parsererror")
                return "unknown error";
            return "Status: " + textStatus + "<br/>Error was:" + error;
        }
        showDialog(dlg, title, content, minMaxWidth, minMaxHeight, buttons, // DialogButtonOptions 
        scrolling, autoResize, maximizeButton, close, open, resize, noCloseOnEscape) {
            let that = this;
            let isMax = false;
            // get best size (depending on available screen size, and given max values)
            let niceSize = this.getNiceDialogSize(minMaxWidth, minMaxHeight);
            let nicePos = { top: 0, left: 0 };
            // content
            if (content) {
                dlg.html("");
                dlg.append(content);
            }
            dlg.removeClass("dlg-auto-scroll");
            dlg.removeClass("dlg-no-scroll");
            dlg.removeClass("dlg-v-scroll");
            switch (scrolling) {
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical:
                    dlg.addClass("dlg-v-scroll");
                    break;
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.None:
                    dlg.addClass("dlg-no-scroll");
                    break;
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.Auto:
                    dlg.addClass("dlg-scroll");
                    break;
            }
            dlg.dialog({
                autoOpen: true,
                title: title,
                height: niceSize.height,
                width: niceSize.width,
                modal: true,
                closeOnEscape: !noCloseOnEscape,
                close: function () {
                    // prepare for next opening...
                    $(".maxbutton").remove();
                    dlg.removeClass("dlg-auto-scroll");
                    dlg.removeClass("dlg-no-scroll");
                    dlg.removeClass("dlg-v-scroll");
                    that.popDialog(dlg);
                    if (close)
                        close();
                },
                open: function () {
                    if (maximizeButton) {
                        let maxButton = $('<button title="Maximize" class="maxbutton ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-max" type="button"><span class="ui-icon ui-icon-arrow-4-diag">maximize</span>Maximize</button>');
                        let ui = $(dlg).closest(".ui-dialog");
                        let close = $(".ui-dialog-titlebar-close", ui);
                        let content = $(".ui-dialog-content", ui);
                        close.parent().prepend(maxButton);
                        maxButton.click(function () {
                            if (isMax) {
                                isMax = false;
                                ui.width(niceSize.width);
                                ui.height(niceSize.height);
                                ui.css("left", nicePos.left + "px");
                                ui.css("top", nicePos.top + "px");
                            }
                            else {
                                isMax = true;
                                nicePos = ui.position();
                                niceSize = { width: ui.width(), height: ui.height() };
                                ui.width($(window).width() - 20);
                                ui.height($(window).height() - 20);
                                ui.css("left", "10px");
                                ui.css("top", "10px");
                            }
                            $(content).width(ui.width() - 28);
                            $(content).height(ui.height() - 112);
                            if (autoResize)
                                dlg.resizeDlgContent([content]);
                            if (resize)
                                resize();
                        });
                    }
                    if (open)
                        open();
                    that.pushDialog(dlg);
                },
                resizeStop: function (event, ui) {
                    if (autoResize)
                        dlg.resizeDlgContent([content]);
                    if (resize)
                        resize();
                },
                buttons: buttons
            });
            if (autoResize) {
                dlg.resizeDlgContent([content], false);
            }
        }
        showDialogDes({ 
        // optional parameters with defaults
        maximizeButton = false, noXButton = false, autoResize = false, onClose = null, onOpen = null, onResize = null, noCloseOnEscape = false, minMaxWidth = $(document).width() * 0.9, minMaxHeight = globals_1.app.itemForm.height() * 0.9, scrolling = MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, content = null, 
        // required parameters
        container, title, buttons }) {
            let that = this;
            let isMax = false;
            // get best size (depending on available screen size, and given max values)
            let niceSize = this.getNiceDialogSize(minMaxWidth, minMaxHeight);
            let nicePos = { top: 0, left: 0 };
            // content
            if (content) {
                container.html("");
                container.append(content);
            }
            container.removeClass("dlg-auto-scroll");
            container.removeClass("dlg-no-scroll");
            container.removeClass("dlg-v-scroll");
            switch (scrolling) {
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.Vertical:
                    container.addClass("dlg-v-scroll");
                    break;
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.None:
                    container.addClass("dlg-no-scroll");
                    break;
                case MatrixLibInterfaces_1.UIToolsConstants.Scroll.Auto:
                    container.addClass("dlg-scroll");
                    break;
            }
            container.dialog({
                autoOpen: true,
                title: title,
                height: niceSize.height,
                width: niceSize.width,
                modal: true,
                closeOnEscape: !noCloseOnEscape,
                close: function () {
                    // prepare for next opening...
                    $(".maxbutton").remove();
                    container.removeClass("dlg-auto-scroll");
                    container.removeClass("dlg-no-scroll");
                    container.removeClass("dlg-v-scroll");
                    that.popDialog(container);
                    if (onClose)
                        onClose();
                },
                open: function () {
                    let ui = $(container).closest(".ui-dialog");
                    let close = $(".ui-dialog-titlebar-close", ui);
                    if (maximizeButton) {
                        let maxCss = noXButton ? "maxNoX" : "";
                        let maxButton = $('<button title="Maximize" class="' + maxCss + ' maxbutton ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-max" type="button"><span class="ui-icon ui-icon-arrow-4-diag">maximize</span>Maximize</button>');
                        let content = $(".ui-dialog-content", ui);
                        close.parent().prepend(maxButton);
                        maxButton.click(function () {
                            if (isMax) {
                                isMax = false;
                                ui.width(niceSize.width);
                                ui.height(niceSize.height);
                                ui.css("left", nicePos.left + "px");
                                ui.css("top", nicePos.top + "px");
                            }
                            else {
                                isMax = true;
                                nicePos = ui.position();
                                niceSize = { width: ui.width(), height: ui.height() };
                                ui.width($(window).width() - 20);
                                ui.height($(window).height() - 20);
                                ui.css("left", "10px");
                                ui.css("top", "10px");
                            }
                            $(content).width(ui.width() - 28);
                            $(content).height(ui.height() - 112);
                            if (autoResize)
                                container.resizeDlgContent([content]);
                            if (onResize)
                                onResize();
                        });
                    }
                    if (noXButton) {
                        close.remove();
                    }
                    if (onOpen) {
                        onOpen();
                    }
                    that.pushDialog(container);
                },
                resizeStop: function (event, ui) {
                    if (autoResize) {
                        container.resizeDlgContent([content]);
                    }
                    if (onResize) {
                        onResize();
                    }
                },
                buttons: buttons
            });
            if (autoResize) {
                container.resizeDlgContent([content], false);
            }
        }
        pushDialog(thisDialog) {
            let depth = 0;
            for (var idx = 0; idx < 4; idx++) {
                if (this.countVisibleDialogs(idx)) {
                    depth = idx + 1;
                }
            }
            if (depth === 0) {
                return;
            }
            let dlg = thisDialog.closest(".ui-dialog");
            dlg.removeClass("ui-front");
            dlg.addClass("ui-front" + depth);
            $(".ui-widget-overlay,.ui-widget-overlay1,.ui-widget-overlay2,.ui-widget-overlay3,.ui-widget-overlay4").each(function (idx, over) {
                $(over).removeClass("ui-widget-overlay");
                for (var idx = 1; idx < depth; idx++) {
                    $(over).removeClass("ui-widget-overlay" + idx);
                }
                $(over).addClass("ui-widget-overlay" + depth);
            });
        }
        popDialog(thisDialog) {
            let dlg = thisDialog.closest(".ui-dialog");
            // normalize stack for next time it's displayed
            dlg.addClass("ui-front");
            for (var idx = 0; idx < 4; idx++) {
                dlg.removeClass("ui-front" + (idx + 1));
            }
            $(".ui-widget-overlay1").each(function (idx, over) {
                $(over).removeClass("ui-widget-overlay1");
                $(over).addClass("ui-widget-overlay");
            });
            $(".ui-widget-overlay2").each(function (idx, over) {
                $(over).removeClass("ui-widget-overlay2");
                $(over).addClass("ui-widget-overlay1");
            });
            $(".ui-widget-overlay3").each(function (idx, over) {
                $(over).removeClass("ui-widget-overlay3");
                $(over).addClass("ui-widget-overlay2");
            });
            $(".ui-widget-overlay4").each(function (idx, over) {
                $(over).removeClass("ui-widget-overlay4");
                $(over).addClass("ui-widget-overlay3");
            });
        }
        serverHtmlCleanupBlob(content) {
            let htmlContent = content.html();
            let def = $.Deferred();
            globals_1.restConnection.postProjectJson("htmlCleanupBlob", { htmlToClean: htmlContent })
                .done((result) => {
                def.resolve(result.cleanedHtml);
            });
            return def;
        }
        /*  anchor: where to add a button
            tooltip: to inform user about what is copied
            content: from where to copy
            catchKey: ??
            onProcessCopy: for post processing of copied text
            btnText: // to add some text to copy button
        */
        copyBuffer(anchor, tooltip, content, catchKey, onProcessCopy, btnText, beforeCopy, afterCopy) {
            let that = this;
            $('<i class="fal fa-copy hideCopy" aria-hidden="true" style="padding-left:12px;cursor:pointer" data-original-title="' + tooltip + '"> ' + (btnText ? btnText : "") + '</i>').appendTo(anchor).click(function () {
                if (beforeCopy != undefined) {
                    beforeCopy();
                }
                that.doCopy(content, onProcessCopy);
                if (afterCopy != undefined) {
                    afterCopy();
                }
            }).tooltip({ container: "body", placement: "auto" });
            /*
            if (catchKey) {
                let ctrlDown = false,
                ctrlKey = 17,
                cmdKey = 91,
                vKey = 86,
                cKey = 67;
        
                $(catchKey).keydown(function(e) {
                    if (e.keyCode == ctrlKey || e.keyCode == cmdKey) {
                        ctrlDown = true;
                    }
                    if (ctrlDown &&  e.keyCode == cKey) {
                        that.doCopy( content, onProcessCopy );
                        return false;
                    }
                    return true;
                }).keyup(function(e) {
                    if (e.keyCode == ctrlKey || e.keyCode == cmdKey) {
                        ctrlDown = false;
                    }
                });
            }*/
        }
        getIconOptions() {
            return this.toolIcons.map(function (ti) { return { id: "fal fa-" + ti, label: "fal fa-" + ti }; });
        }
        calculateColorFrom(input) {
            let colorIndex = 0;
            for (var i = 0; i < input.length; i++) {
                colorIndex += input.charCodeAt(i);
            }
            return this.colorScheme[colorIndex % this.colorScheme.length];
        }
        getAvatar(info, size) {
            let avatarDiv = $("<div class='avatar noselect' title='" + info + "'/>");
            var settings = {
                border: {
                    color: MatrixLibInterfaces_1.UIToolsConstants.CIColors.GreyLightAlto.color,
                    width: 3
                },
                colors: this.colorScheme.filter(function (color) { return color.color != MatrixLibInterfaces_1.UIToolsConstants.CIColors.GreyLightAlto.color; }),
                text: MatrixLibInterfaces_1.UIToolsConstants.CIColors.Black.color,
                size: size,
                middlename: true,
                uppercase: true
            };
            var elementText = info;
            var initialLetters = info.length < 2 ? [info[0]] : [info[0], info[1]];
            var initials = initialLetters.join('');
            let color = this.calculateColorFrom(info);
            avatarDiv.text(initials);
            avatarDiv.css({
                'color': color.alternateColor,
                'background-color': color.color,
                'display': 'inline-block',
                'font-family': 'Arial, \'Helvetica Neue\', Helvetica, sans-serif',
                'font-size': settings.size * 0.4,
                'border-radius': settings.size + 'px',
                'width': settings.size + 'px',
                'height': settings.size + 'px',
                'line-height': (settings.size) + 'px',
                'text-align': 'center',
                'text-transform': settings.uppercase ? 'uppercase' : ''
            });
            return avatarDiv;
        }
        doCopy(content, onProcessCopy) {
            let that = this;
            let copyBufferHTML = $("<div class='copyBuffer'>").appendTo("body");
            copyBufferHTML.append(content.clone(true));
            $(".hideCopy", copyBufferHTML).remove();
            $(".hideCopyAlways", copyBufferHTML).remove();
            $(".tooltip", copyBufferHTML).remove();
            $(".tooltip-inner", copyBufferHTML).remove();
            $(".hideScreen", copyBufferHTML).removeClass("hideScreen");
            // copy content of data into html
            $.each($(".replaceCopy", copyBufferHTML), function (ridx, replace) {
                $(replace).html($(replace).data("with"));
            });
            if (onProcessCopy)
                onProcessCopy(copyBufferHTML);
            this.serverHtmlCleanupBlob(copyBufferHTML).done((cleanHtml) => {
                globals_1.globalMatrix.serverStorage.setItem("copyBuffer", cleanHtml);
                copyBufferHTML.remove();
                matrixlib_1.ml.UI.showAck(-3, `To paste the copied information, use the <b>"Paste Dashboard" menu entry </b> in the Matrix menu (for the TinyMCE editor) or the <b>"Paste" menu entry</b> in the paste menu button <br/> (for the legacy editor).<br> <br> Please refer to <a href='https://urlshort.matrixreq.com/d23/faq/pastedashboard' target='_blank'> the FAQ </a>for more details`, "Copy completed");
            });
        }
        countVisibleDialogs(idx) {
            let count = 0;
            let cls = idx ? (".ui-dialog.ui-front" + idx) : ".ui-dialog.ui-front";
            $(cls).each(function (dlgidx, dlg) {
                if ($(dlg).css("display") !== "none") {
                    count++;
                }
            });
            // return count BUT substract 1 from level 0 (the dialog itself which is pushed )
            return idx ? count : count - 1;
        }
        addChevronSection(container, text, help, open) {
            let isOpen = open ? true : false;
            let details = $(`<div class='chevronInner' style='display:${isOpen ? "block" : "none"};'>`);
            let helpLine = $(`<div class='chevronHelp'>${help}</div>`);
            let toggle = $(`<div class='chevronHeading'><span class="fa ${isOpen ? "fa-chevron-down" : "fa-chevron-right"}"></span> <span class='chevronText'>${text}</span></div>`)
                .appendTo(container)
                .click(function () {
                if (isOpen) {
                    isOpen = false;
                    details.hide();
                    $(".fa", toggle).removeClass("fa-chevron-down").addClass("fa-chevron-right");
                }
                else {
                    isOpen = true;
                    details.show();
                    $(".fa", toggle).removeClass("fa-chevron-right").addClass("fa-chevron-down");
                }
            });
            if (help) {
                helpLine.appendTo(container);
            }
            details.appendTo(container);
            return details;
        }
        getSlideHeight(slide, padded) {
            var height = 0;
            slide.children().each(function (idx, child) {
                height += $(child).height();
            });
            var padding = slide.outerHeight() - slide.height(); // padding of outer div + border
            if (height + padding < 50) {
                height = 50 - padding;
            }
            if (height > 300) {
                height = 300;
            }
            let screenHeight = $("#itemDetails").height() ? $("#itemDetails").height() : 400;
            if (!padded) {
                return Math.min(screenHeight, Math.max(height, slide.height()));
            }
            return Math.min(screenHeight, Math.max(height + padding, slide.outerHeight()));
        }
        showSlide(slideId, outAgain) {
            let slide = $(slideId);
            // calc height of box
            slide.height('auto');
            var height = this.getSlideHeight(slide, false);
            var heightPadded = this.getSlideHeight(slide, true);
            // set height of box 
            slide.height(height + "px");
            if (slide.css("margin-top") !== "0px") {
                // slide is not visible
                // move box out of top of screen, so that bottom is just above top of screen
                slide.css("margin-top", '-' + heightPadded + 'px');
            }
            // scroll it in
            slide.clearQueue().animate({ 'margin-top': '0px' });
            // after s sec out again
            if (outAgain) {
                window.clearTimeout(this.removeTimer[slideId]);
                this.removeTimer[slideId] = window.setTimeout(function () {
                    slide.clearQueue().animate({ 'margin-top': '-' + (heightPadded + 4) + 'px' });
                }, outAgain);
            }
        }
        hideSlide(slide) {
            // calc height of box
            let that = this;
            slide.promise().done(function () {
                var heightPadded = that.getSlideHeight(slide, true);
                slide.css("margin-top", '-' + (heightPadded + 4) + 'px');
            });
        }
        getItemHtmlFromCacheOrServerAsync(itemId, crossProject) {
            let that = this;
            let res = $.Deferred();
            let now = new Date();
            this.hidden_tooltip_itemId = null;
            var last_cached = crossProject ? null : this.tooltip_cache[itemId];
            if (crossProject) {
                globals_1.app.getItemProjectAsync(crossProject, itemId, true).done(function (item) {
                    that.renderCrossItem(item, crossProject).always(() => {
                        res.resolve();
                    });
                }).fail(function (error) {
                    res.reject(error);
                });
            }
            else if (last_cached && (now.getTime() - last_cached.date.getTime()) < 10000) {
                that.renderItem(last_cached.item);
                res.resolve();
            }
            else {
                globals_1.app.getItemAsync(itemId, undefined, true).done(function (item) {
                    that.renderItem(item);
                    last_cached = { date: new Date(), item: item };
                    that.tooltip_cache[itemId] = last_cached;
                    res.resolve();
                }).fail(function (error) {
                    if (!error || !error.responseJSON || error.responseJSON.code != "AuthenticationFailed") {
                        globals_1.matrixApplicationUI.renderErrorControl($("#tooltip_panel"), "The item " + itemId + " does not exist.", "And it never did ....", true);
                    }
                    res.resolve();
                });
            }
            return res;
        }
        renderItem(item) {
            let that = this;
            $("#tooltip_panel").html("");
            $("<div class='tooltip_panel_close'>x</div>").appendTo($("#tooltip_panel")).click(function () {
                that.hideCurrentToolTip();
            });
            if (item.title === undefined) {
                globals_1.matrixApplicationUI.renderErrorControl($("#tooltip_panel"), "The item " + item.id + " was deleted", "ou can find it in the deleted item log.", true);
            }
            else if (globals_1.app.canViewItem(item)) {
                var ctrl = new index_3.ItemControl({
                    control: $("#tooltip_panel"),
                    controlState: globals_1.ControlState.Tooltip,
                    item: item,
                    isItem: (typeof item.children === 'undefined')
                });
                let bcs = globals_1.app.getBreadcrumbs(item.id).filter(function (bc) { return bc != item.id; });
                let breadcrumb = bcs.reverse().map(function (bid) { return bid + " " + globals_1.app.getItemTitle(bid); }).join(" > ");
                let title = $("#tooltip_panel .itemTitle").addClass("tooltipItem").removeClass("pull-left").removeClass("itemTitle");
                title.closest(".itemTitleBarNoToolsNoEdit").removeClass("itemTitleBarNoToolsNoEdit");
                $("<hr style='border-top-color: #aaa;margin-top: 10px;width: 100%;margin-bottom: 10px;'/>").insertAfter(title);
                $('<div style="font-size: smaller;">').append($("<span class='inlineHelp'>").html(breadcrumb)).insertAfter(title);
            }
            else {
                globals_1.matrixApplicationUI.renderErrorControl($("#tooltip_panel"), "You have no rights to view " + item.id + "", "Talk to the project administrator.", true);
            }
        }
        renderCrossItem(item, project) {
            let that = this;
            var res = $.Deferred();
            $("#tooltip_panel").html("");
            $("<div class='tooltip_panel_close'>x</div>").appendTo($("#tooltip_panel")).click(function () {
                that.hideCurrentToolTip();
            });
            if (item.isDeleted) {
                $("#tooltip_panel").html(item.id + " in project " + project + " was deleted");
                res.resolve();
                return res;
            }
            let originalIC = matrixlib_1.ml.JSON.clone(globals_1.globalMatrix.ItemConfig);
            let newIC = new index_1.ItemConfiguration(matrixlib_1.ml.Logger, matrixlib_1.ml.JSON);
            globals_1.restConnection.getServer(project + "/cat").done(function (catDetails) {
                newIC.addCategories(catDetails);
                globals_1.restConnection.getServer(project + "/setting").done(function (settings) {
                    newIC.addSettings(settings);
                    globals_1.setIC(newIC);
                    new index_3.ItemControl({
                        control: $("#tooltip_panel"),
                        controlState: globals_1.ControlState.Tooltip,
                        item: item,
                        isItem: (typeof item.children === 'undefined')
                    });
                    let projectInfo = "Project: " + project;
                    let title = $("#tooltip_panel .itemTitle").addClass("tooltipItem").removeClass("pull-left").removeClass("itemTitle");
                    title.closest(".itemTitleBarNoToolsNoEdit").removeClass("itemTitleBarNoToolsNoEdit");
                    $("<hr style='border-top-color: #aaa;margin-top: 10px;width: 100%;margin-bottom: 10px;'/>").insertAfter(title);
                    $('<div style="font-size: smaller;">').append($("<span class='inlineHelp'>").html(projectInfo)).insertAfter(title);
                    globals_1.setIC(originalIC);
                    res.resolve();
                }).fail(function () {
                    globals_1.setIC(originalIC);
                    res.resolve();
                });
            }).fail(function () {
                globals_1.setIC(originalIC);
                res.resolve();
            });
            return res;
        }
        hideCurrentToolTip() {
            this.hidden_tooltip_itemId = null;
            clearTimeout(this.lastTooltipHide);
            this.lastTooltipHide = null;
            var height = Math.max(300, this.getSlideHeight($("#tooltip_panel"), true));
            $("#tooltip_panel").css('margin-top', '-' + (height + 30) + 'px');
        }
        showTaskAsTooltip_Delayed(id, title, url, htmlContent, target) {
            let that = this;
            $("#tooltip_panel").html("");
            $("<div class='tooltip_panel_close'>x</div>").appendTo($("#tooltip_panel")).click(function () {
                that.hideCurrentToolTip();
            });
            if (title === undefined) {
                globals_1.matrixApplicationUI.renderErrorControl($("#tooltip_panel"), "The item " + " was deleted", "", true);
            }
            else {
                $("#tooltip_panel").append(`<div class="tooltipItem"><a href="${url}" target="_blank"><span class="">${id}</span></a><span class="refTitle">${title}</span></div>`);
                $("#tooltip_panel").append(`<hr style="border-top-color: #aaa;margin-top: 10px;width: 100%;margin-bottom: 10px;">`);
                $("#tooltip_panel").append(`<div class="dialog-body">${htmlContent} </div>`);
            }
            that.showSlide("#tooltip_panel");
            $("#tooltip_panel").on('mouseover', function () {
                clearTimeout(that.lastTooltipHide);
                that.lastTooltipHide = null;
            });
            $("#tooltip_panel").on('mouseleave', function () {
                if (!globals_1.globalMatrix.globalShiftDown) {
                    that.hideCurrentToolTip();
                }
            });
        }
        showTooltip_Delayed(itemId, target, crossProject) {
            let that = this;
            if (itemId.indexOf("-") === 0 || globals_1.app.getType(itemId)[0] === "_" || globals_1.app.isFolder(itemId) || globals_1.app.getCurrentItemId() === itemId) {
                this.hideCurrentToolTip();
                return;
            }
            if (index_2.Tasks.isTaskId(itemId)) {
                this.hideCurrentToolTip();
                return;
            }
            this.getItemHtmlFromCacheOrServerAsync(itemId, crossProject).done(function () {
                if (!globals_1.globalMatrix.globalShiftDown || globals_1.app.getCurrentItemId() === itemId) {
                    that.hideCurrentToolTip();
                    return;
                }
                that.showSlide("#tooltip_panel");
                $("#tooltip_panel").on('mouseover', function () {
                    clearTimeout(that.lastTooltipHide);
                    that.lastTooltipHide = null;
                });
                $("#tooltip_panel").on('mouseleave', function () {
                    if (!globals_1.globalMatrix.globalShiftDown) {
                        that.hideCurrentToolTip();
                    }
                });
            });
        }
        // config client helper 
        enableIf(cb, state, ctrls) {
            let that = this;
            $("input", cb).change(function () {
                $.each(ctrls, function (idx, ctrl) {
                    matrixlib_1.ml.UI.setEnabled(ctrl, $("input", cb).is(':checked') == state);
                });
            });
            $.each(ctrls, function (idx, ctrl) {
                matrixlib_1.ml.UI.setEnabled(ctrl, $("input", cb).is(':checked') == state);
            });
        }
        addCheckboxD(ui, text, fieldParams, propertyName, onChange, defaultValue) {
            let that = this;
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let cb = $(`<div data-cy="${dataCY}">`).appendTo(ui).checkBox({
                canEdit: true,
                help: text,
                valueChanged: function () {
                    fieldParams[propertyName] = cb.getController().getValue();
                    if (onChange)
                        onChange();
                },
                parameter: {},
                fieldValue: defaultValue
            });
            fieldParams[propertyName] = cb.getController().getValue();
            return cb;
        }
        addCheckbox(ui, text, fieldParams, propertyName, onChange) {
            return this.addCheckboxD(ui, text, fieldParams, propertyName, onChange, fieldParams[propertyName] ? "1" : "0");
        }
        /** checkbox will only be checked if explicitly be set to true*/
        addCheckboxIsTrue(ui, text, fieldParams, propertyName, onChange) {
            return this.addCheckboxD(ui, text, fieldParams, propertyName, onChange, matrixlib_1.ml.JSON.isTrue(fieldParams[propertyName]) ? "1" : "0");
        }
        /** checkbox will only checked if NOT explicitly be set to false (so unchanged=default=checked) */
        addCheckboxIsFalse(ui, text, fieldParams, propertyName, onChange) {
            return this.addCheckboxD(ui, text, fieldParams, propertyName, onChange, matrixlib_1.ml.JSON.isFalse(fieldParams[propertyName]) ? "0" : "1");
        }
        addPassInput(ui, text, fieldParams, propertyName, onChange, onUnFocus) {
            return this.addTextInput(ui, text, fieldParams, propertyName, onChange, onUnFocus, true);
        }
        addTextInput(ui, text, fieldParams, propertyName, onChange, onFocusOut, isPass, help, readonly, rows = 1, allowResize = false) {
            let that = this;
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let pt = $(`<div data-cy="${dataCY}">`).appendTo(ui).plainText({
                canEdit: true,
                help: text,
                valueChanged: function () {
                    let newValue = pt.getController().getValue();
                    if (fieldParams[propertyName] || newValue) {
                        // avoid creating a empty "" field instead of non existing which would trigger a save
                        if (isPass) {
                            // unescaping the password using TextArea. 
                            newValue = $("<textarea/>").html(newValue).text();
                        }
                        fieldParams[propertyName] = newValue;
                    }
                    if (onChange)
                        onChange();
                },
                parameter: { rows: rows, allowResize: allowResize, password: isPass ? true : false, inlineHelp: help, readonly: readonly },
                fieldValue: fieldParams[propertyName]
            });
            if (isPass) {
                $("input", pt).attr("readonly", "readonly").on("focus", () => {
                    $("input", pt).removeAttr("readonly");
                });
            }
            if (onFocusOut) {
                pt.focusout(function () { onFocusOut(); });
            }
            return pt;
        }
        addRichTextInput(ui, params, text, fieldParams, propertyName, onChange, onFocusOut) {
            let that = this;
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let pt = $(`<div data-cy="${dataCY}">`).appendTo(ui).richText({
                canEdit: true,
                help: text,
                valueChanged: function () {
                    let newValue = pt.getController().getValue();
                    if (fieldParams[propertyName] || newValue) {
                        // avoid creating a empty "" field instead of non existing which would trigger a save 
                        fieldParams[propertyName] = newValue;
                    }
                    if (onChange)
                        onChange();
                },
                parameter: params,
                fieldValue: fieldParams[propertyName]
            });
            if (onFocusOut) {
                pt.focusout(function () { onFocusOut(); });
            }
            return pt;
        }
        addDateSelect(ui, text, fieldParams, propertyName, onChange, help, readonly) {
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let pt = $(`<div data-cy="${dataCY}">`).appendTo(ui).dateselect({
                controlState: globals_1.ControlState.FormEdit,
                canEdit: true,
                help: text,
                fieldValue: fieldParams[propertyName] ? fieldParams[propertyName] : "",
                valueChanged: function () {
                    fieldParams[propertyName] = pt.getController().getValue();
                    onChange();
                },
                parameter: {
                    allowClear: true,
                    inlineHelp: help,
                    readonly: readonly
                }
            });
            return pt;
        }
        addIconInput(ui, text, fieldParams, propertyName, onChange, onFocusOut, isPass) {
            return this.addDropdownToValue(ui, text, fieldParams, propertyName, this.getIconOptions(), true, true, onChange, "");
        }
        addDropdownToArray(ui, text, fieldParams, propertyName, options, grouping, maxItems, create, sort, onChange, placeholder) {
            let that = this;
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let dd = $(`<div data-cy="${dataCY}">`).appendTo(ui).mxDropdown({
                help: text,
                canEdit: true,
                parameter: {
                    placeholder: placeholder ? placeholder : "please select",
                    create: create,
                    options: options,
                    maxItems: maxItems,
                    groups: grouping,
                    sort: sort
                }, valueChanged: function () {
                    if (dd) {
                        let changed = dd.getController().getValue();
                        fieldParams[propertyName] = changed ? changed.split(",") : [];
                        if (onChange)
                            onChange();
                    }
                },
                fieldValue: fieldParams[propertyName] ? fieldParams[propertyName].join(",") : ""
            });
            return dd;
        }
        addDropdownNumber(ui, text, fieldParams, propertyName, first, last, onChange, placeholder, paramsBase) {
            const current = { val: fieldParams[propertyName] ? ("" + fieldParams[propertyName]) : "0" };
            const options = Array.from({ length: 1 + last - first }, (_, n) => { return n + first; }).map((n) => { return { id: "" + n, label: "" + n }; });
            this.addDropdownToValue(ui, text, current, "val", options, false, false, () => {
                fieldParams[propertyName] = Number(current.val);
                if (onChange)
                    onChange();
            }, placeholder, paramsBase);
        }
        addDropdownToValue(ui, text, fieldParams, propertyName, options, create, sort, onChange, placeholder, paramsBase) {
            let defaultParams = paramsBase ? paramsBase : {};
            let params = matrixlib_1.ml.JSON.clone(Object.assign(Object.assign({}, defaultParams), {
                placeholder: placeholder ? placeholder : "please select",
                create: create,
                options: options,
                maxItems: 1,
                sort: sort
            }));
            let dataCY = propertyName !== null && propertyName !== void 0 ? propertyName : text.replace(/\s/g, "-");
            let dd = $(`<div data-cy="${dataCY}">`).appendTo(ui).mxDropdown({
                help: text,
                canEdit: true,
                parameter: params,
                valueChanged: function () {
                    if (dd) {
                        let changed = dd.getController().getValue();
                        fieldParams[propertyName] = changed;
                        if (onChange)
                            onChange();
                    }
                },
                fieldValue: fieldParams[propertyName] ? fieldParams[propertyName] : ""
            });
            return dd;
        }
        getPageTitle(title, getPanel, resize) {
            let that = this;
            let div = $(`<div class="panel-heading itemTitleBar addedTitle">
            <div class="itemTitle pull-left">
                <span data-cy='title' class="refTitle">${title}</span>
            </div>
            
         </div>`);
            let toolBar = $("<div class='pull-right hidden-print tools-pull-right'><div class='btn-group toolbarButtons'></div></div>");
            div.append(toolBar);
            if (getPanel != undefined) {
                let bResize = $("<div  class='btn-group btn-dashboard-fullscreen' ><button title data-original-title='Fullscreen' tabindex='-1' class='btn btn-item btn-fullscreen'> <span class='fal fa-expand-arrows-alt'></span></button></div>").click(function () {
                    let panel = getPanel();
                    let panelParent = panel.parent();
                    let toolbarParent = toolBar.parent();
                    let dlg = $("<div>").appendTo($("body"));
                    matrixlib_1.ml.UI.showDialog(dlg, title, panel, window.innerWidth, window.innerHeight, [{
                            text: 'Ok',
                            class: 'btnDoIt',
                            click: function () {
                                dlg.dialog("close");
                                panelParent.append(panel);
                                toolBar.appendTo(toolbarParent);
                                dlg.remove();
                                resize();
                            }
                        }], MatrixLibInterfaces_1.UIToolsConstants.Scroll.None, false, false, () => {
                        dlg.dialog("close");
                        panelParent.append(panel);
                        toolBar.appendTo(toolbarParent);
                        dlg.remove();
                        resize();
                    }, () => {
                        $(".ui-dialog-titlebar").append(toolBar);
                        resize();
                    }, () => { });
                });
                $(".toolbarButtons", toolBar).append(bResize);
            }
            return div;
        }
        /* ***************************************************
           list of items with up / down / edit delete buttons
           *************************************************** */
        // add a line which can be moved up or down
        createConfigLine(lineId, linePrefix, lineName, lineArray, idProp, onChangedOrder, onEdit, needsEdit, onDelete) {
            let that = this;
            let li = $("<li>");
            $("<span>").html(`<b>${linePrefix}</b>`).appendTo(li);
            $("<span>").html(`<b>${lineName}</b>`).appendTo(li);
            $("<span class='moveUp btn-link' data-original-title='Move up' >").data("lineId", lineId).append('<i style="cursor:pointer" class="taglist fal fa-arrow-up" >').click(function (event) {
                let liToMove = $(event.delegateTarget).data("lineId");
                let liBefore = that.moveUp($(event.delegateTarget));
                let labelToMoveIdx = that.getIndex(lineArray, idProp, liToMove);
                let labelBeforeIdx = that.getIndex(lineArray, idProp, liBefore);
                let toMove = lineArray.splice(labelToMoveIdx, 1);
                lineArray.splice(labelBeforeIdx, 0, toMove[0]);
                onChangedOrder();
            }).appendTo(li);
            $("<span class='moveDown btn-link'>  data-original-title='Move down'").data("lineId", lineId).append('<i style="cursor:pointer" class="taglist fal fa-arrow-down" >').click(function (event) {
                let liToMove = $(event.delegateTarget).data("lineId");
                let liAfter = that.moveDown($(event.delegateTarget));
                let labelToMoveIdx = that.getIndex(lineArray, idProp, liToMove);
                let labelAfterIdx = that.getIndex(lineArray, idProp, liAfter);
                let toMove = lineArray.splice(labelToMoveIdx, 1);
                lineArray.splice(labelAfterIdx + 1, 0, toMove[0]);
                onChangedOrder();
            }).appendTo(li);
            // edit button
            if (onEdit) {
                $(`<span style='${needsEdit ? "color:red" : ""}' class='btn btn-xs btn-link  data-original-title='Edit'>)`).html("<i class='fal fa-pencil'/>")
                    .data("lineId", lineId)
                    .click(function (event) {
                    onEdit($(event.delegateTarget).data("lineId"));
                }).appendTo(li);
            }
            // delete button
            $("<span class='btn btn-xs btn-link'  data-original-title='Delete' >").html("<i class='fal fa-trash-alt'/>").data("lineId", lineId).click(function (event) {
                matrixlib_1.ml.UI.showConfirm(-1, { title: "Delete " + lineId, ok: "Delete", nok: "Cancel" }, () => {
                    let dl = $(event.delegateTarget).data("lineId");
                    onDelete(dl);
                }, () => { });
            }).appendTo(li);
            return li;
        }
        // remove first up / last down icon button
        fixArrows(ul) {
            let count = ul.data("count");
            $.each($("li", ul), function (idx, li) {
                (idx == 0 || count < 2) ? $(".moveUp", li).hide() : $(".moveUp", li).show();
                (idx + 1 == count || count < 2) ? $(".moveDown", li).hide() : $(".moveDown", li).show();
            });
        }
        // line to add a new element
        createConfigAddLine(action, onAdd) {
            let li = $("<li>");
            $("<span class='editLinkButtonLeft'>").html(action).click(function (event) {
                onAdd();
            }).appendTo(li);
            return li;
        }
        /* ***************************************************
          handle < in html to prevent dangerous stuff
          *************************************************** */
        getIndex(lineArray, idProp, lineId) {
            for (var idx = 0; idx < lineArray.length; idx++) {
                if (lineArray[idx][idProp] == lineId) {
                    return idx;
                }
            }
            return -1;
        }
        moveUp(moveBtn) {
            let li1 = moveBtn.closest("li");
            let li2 = li1.prev("li");
            li2.before(li1);
            this.fixArrows(moveBtn.closest("ul"));
            return $(".moveDown", li2).data("lineId");
        }
        moveDown(moveBtn) {
            let li1 = moveBtn.closest("li");
            let li2 = li1.next("li");
            li2.after(li1);
            this.fixArrows(moveBtn.closest("ul"));
            return $(".moveUp", li2).data("lineId");
        }
    }
    exports.UIToolsEnum = UIToolsEnum;
    class DateTimeUI {
        constructor() {
            this.userDateTimeFormat = "yyyy/MM/dd HH:mm:ss";
            this.userDateOnlyFormat = "yyyy/MM/dd";
            this.userTimezone = "UTC";
            this.simpleDateTimeFormat = new SimpleDateFormat(this.userDateTimeFormat);
            this.simpleDateFormat = new SimpleDateFormat(this.userDateOnlyFormat);
            this.dateIso8601FromServer = "";
            this.dateUserFromServer = "";
            this.serverDateTimeFormat = "yyyy/MM/dd HH:mm:ss";
            this.serverDateOnlyFormat = "yyyy/MM/dd";
            this.serverTimezone = "UTC";
            this.simpleCustomerDateTimeFormat = new SimpleDateFormat(this.userDateTimeFormat);
            this.simpleCustomerDateFormat = new SimpleDateFormat(this.userDateOnlyFormat);
        }
        // *******************************************************
        // helper for ui to manage time and date settings
        // *******************************************************
        // gets the current server or user setting from the server and renders 
        // the controls to see and modify the settings
        showControls(controlOptions) {
            let that = this;
            let table = controlOptions.table;
            // shows the time setting controls for the server or a user
            this.initAsync(controlOptions.user).done(function (currentSettings) {
                var tbody = $("tbody", table);
                tbody.append($('<tr><td colspan="2" class="baseControlHelp">' + controlOptions.help + '</td></tr>'));
                var isUserOwnSetting = controlOptions.user && controlOptions.user.toLowerCase() === globals_1.matrixSession.getUser().toLowerCase();
                var isUserSetting = controlOptions.user;
                that.renderDateTimeFormat(tbody, isUserSetting, isUserOwnSetting, currentSettings, "timeformat", "Date Time Formatting");
                that.renderDateTimeFormat(tbody, isUserSetting, isUserOwnSetting, currentSettings, "dateformat", "Date Only Formatting");
                that.renderTimeZone(tbody, isUserSetting, isUserOwnSetting, currentSettings, "timezone", controlOptions.user ? "User Timezone" : "Server Timezone");
            }).fail(function () {
                matrixlib_1.ml.UI.showError("Could not retrieve date time settings from server", "");
            });
        }
        // gets the server or user time/date settings from the server (if specified)
        initAsync(user) {
            // returns the following settings from the server... currently 3 rest calls are needed
            // if no user is passed the global server settings are retrieved
            let result = {
                timeZoneOptions: [],
                settingsSource: user ? ("user/" + user + "/setting") : "all/setting"
            };
            var res = $.Deferred();
            globals_1.restConnection.getServer("all/timezone").done(function (allTimeZones) {
                for (var idx = 0; idx < allTimeZones.length; idx++) {
                    result.timeZoneOptions.push({
                        val: allTimeZones[idx],
                        text: allTimeZones[idx]
                    });
                }
                // check for user overwrites
                if (user) {
                    globals_1.restConnection.getServer("user/" + user).done(function (userInfo) {
                        var settings = userInfo.userSettingsList;
                        for (var idx = 0; idx < settings.length; idx++) {
                            if (settings[idx].key === "timeformat") {
                                result.timeformat = settings[idx].value;
                            }
                            if (settings[idx].key === "dateformat") {
                                result.dateformat = settings[idx].value;
                            }
                            if (settings[idx].key === "timezone") {
                                result.timezone = settings[idx].value;
                            }
                        }
                        res.resolve(result);
                    }).fail(function () {
                        res.reject();
                    });
                }
                else {
                    res.resolve(result);
                }
            }).fail(function () {
                res.reject();
            });
            return res;
        }
        renderDateTimeFormat(tableBody, isUserSetting, isUserOwnSetting, currentSettings, settingName, explanation) {
            let that = this;
            var help = $('<a href="https://urlshort.matrixreq.com/d23/manual/datetime" target="_blank"><span style="top:-4px; margin: 0px 3px;font-size: 12px" class="fal fa-info-circle"></span></a>');
            var timeUpdate;
            var si = $('<input autocomplete="off" type="text" class="form-control admin_utime">').on("keyup", function () {
                clearTimeout(timeUpdate);
                timeUpdate = window.setTimeout(function () {
                    that.showTime(example, si.val());
                    if (example.html() === si.data("last_val") || example.html() === "") {
                        setb.prop('disabled', true);
                        setb.removeClass("btn-success");
                        setb.addClass("btn-default");
                    }
                    else {
                        setb.prop('disabled', false);
                        setb.addClass("btn-success");
                        setb.removeClass("btn-default");
                    }
                }, 300);
            });
            var resetb = $("<button class='btn btn-default' style='margin-right:10px' >Reset</button>").click(function () {
                that.setSetting(isUserOwnSetting, currentSettings.settingsSource, settingName, "").done(function () {
                    si.val(settingName === "timeformat" ? that.serverDateTimeFormat : that.serverDateOnlyFormat);
                    that.showTime(example, si.val());
                    si.data("last_val", example.html());
                    setb.removeClass("btn-success");
                    setb.addClass("btn-default");
                    setb.prop('disabled', true);
                });
            });
            var setb = $("<button class='btn btn-default' style='margin-right:10px' disabled>Use</button>").click(function () {
                that.setSetting(isUserOwnSetting, currentSettings.settingsSource, settingName, si.val()).done(function () {
                    si.data("last_val", example.html());
                    setb.removeClass("btn-success");
                    setb.addClass("btn-default");
                    setb.prop('disabled', true);
                });
            });
            var example = $('<span>');
            var tr = $("<tr>");
            tableBody.append(tr);
            tr.append($("<td class='admin_utdl'>").append($("<label class='control-label'>").html(explanation)).append(help));
            tr.append($("<td>").append(si));
            tr.append($("<td>").append(setb));
            tr.append($("<td>").append(resetb));
            var tre = $("<tr style='vertical-align:top;height:36px'>");
            tableBody.append(tre);
            tre.append($("<td>"));
            tre.append($("<td colspan='3' style='font-size:75%'>").append("<span style='color:darkgrey'>Example: </span>").append(example));
            let cs = currentSettings[settingName];
            si.val(cs ? cs : (settingName === "timeformat" ? this.serverDateTimeFormat : this.serverDateOnlyFormat));
            this.showTime(example, si.val());
            si.data("last_val", example.html());
        }
        showTime(uic, format) {
            var date = new Date(2014, 1, 15, 6, 23, 55);
            var df = new SimpleDateFormat(format);
            uic.html(df.format(date));
        }
        setSetting(isUserOwnSetting, serverOrUserPrefix, key, val) {
            let that = this;
            var res = $.Deferred();
            var postSetSetting = {
                value: val,
                key: key,
                reason: "settings change"
            };
            globals_1.restConnection.postServer(serverOrUserPrefix, postSetSetting).done(function () {
                that.initDateTimeSettings(true).done(function () {
                    res.resolve();
                }).fail(function () {
                    matrixlib_1.ml.UI.showError("Failed to change setting!", "");
                    res.reject();
                });
            }).fail(function () {
                matrixlib_1.ml.UI.showError("Failed to change setting!", "");
                res.reject();
            });
            return res;
        }
        renderTimeZone(tableBody, isUserSetting, isUserOwnSetting, currentSettings, settingName, explanation) {
            let that = this;
            var dd = $('<select class="form-control admin_utime">').change(function () {
                example.html("");
                if (dd.val() === example.data("last_val")) {
                    setb.removeClass("btn-success");
                    setb.addClass("btn-default");
                }
                else {
                    setb.addClass("btn-success");
                    setb.removeClass("btn-default");
                }
            });
            for (var idx = 0; idx < currentSettings.timeZoneOptions.length; idx++) {
                dd.append($("<option value='" + currentSettings.timeZoneOptions[idx].val + "'>" + currentSettings.timeZoneOptions[idx].text + "</option>"));
            }
            var resetb = $("<button class='btn btn-default' style='margin-right:10px'>Reset</button>").click(function () {
                that.setSetting(isUserOwnSetting, currentSettings.settingsSource, settingName, "").done(function () {
                    dd.val(that.serverTimezone);
                    example.html(that.renderTimeZoneWarning(isUserOwnSetting));
                    setb.removeClass("btn-success");
                    setb.addClass("btn-default");
                });
            });
            var setb = $("<button class='btn btn-default' style='margin-right:10px'>Use</button>").click(function () {
                that.setSetting(isUserOwnSetting, currentSettings.settingsSource, settingName, dd.val()).done(function () {
                    example.html(that.renderTimeZoneWarning(isUserOwnSetting));
                    setb.removeClass("btn-success");
                    setb.addClass("btn-default");
                });
            });
            var example = $('<span style="color:red">');
            var tr = $("<tr>");
            tableBody.append(tr);
            tr.append($("<td class='admin_utdl'>").append($("<label class='control-label'>").html(explanation)));
            tr.append($("<td>").append(dd));
            tr.append($("<td>").append(setb));
            tr.append($("<td>").append(resetb));
            var tre = $("<tr>");
            tableBody.append(tre);
            tre.append($("<td>"));
            tre.append($("<td colspan='3'>").append(example));
            let cs = currentSettings[settingName];
            dd.val(cs ? cs : this.serverTimezone);
            example.html(this.renderTimeZoneWarning(isUserOwnSetting)).data("last_val", dd.val());
        }
        renderTimeZoneWarning(isUserOwnSetting) {
            return (isUserOwnSetting && matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) ? "the timezone of your PC seems different!" : "";
        }
        // isValidateDate(new Date("ccccc")) -> false
        isValidDate(d) {
            if (Object.prototype.toString.call(d) === "[object Date]") {
                return !isNaN(d.getTime());
            }
            return false;
        }
        initDateTimeSettings(update) {
            var res = $.Deferred();
            let dateSettings;
            let that = this;
            function updateSettings() {
                that.userDateTimeFormat = dateSettings.timeformat;
                that.userDateOnlyFormat = dateSettings.dateformat;
                that.userTimezone = dateSettings.timeZone;
                that.serverDateOnlyFormat = dateSettings.customerDateformat;
                that.serverDateTimeFormat = dateSettings.customerTimeformat;
                that.serverTimezone = dateSettings.customerTimezone;
                // create formatting strings
                that.simpleCustomerDateTimeFormat = new SimpleDateFormat(that.serverDateTimeFormat);
                that.simpleCustomerDateFormat = new SimpleDateFormat(that.serverDateOnlyFormat);
                // remember the date time settings as the server thinks it should be
                that.dateIso8601FromServer = dateSettings.dateIso8601;
                that.dateUserFromServer = dateSettings.timeUserFormat;
                // create formatting strings
                that.simpleDateTimeFormat = new SimpleDateFormat(that.userDateTimeFormat);
                that.simpleDateFormat = new SimpleDateFormat(that.userDateOnlyFormat);
            }
            if (update) {
                globals_1.restConnection.getServer("all/date").done(function (ds) {
                    dateSettings = ds;
                    updateSettings();
                    res.resolve();
                });
            }
            else {
                dateSettings = globals_1.matrixSession.getDateInfo();
                updateSettings();
                res.resolve();
            }
            return res;
        }
        // render a human date and time in the user's preferred style
        renderHumanDate(date, dateOnly) {
            if (!this.isValidDate(date)) {
                return "";
            }
            if (dateOnly) {
                return this.simpleDateFormat.format(date);
            }
            return this.simpleDateTimeFormat.format(date);
        }
        // render a human date and time in the user's preferred style
        renderCustomerHumanDate(date, dateOnly) {
            if (!this.isValidDate(date)) {
                return "";
            }
            if (dateOnly) {
                return this.simpleCustomerDateFormat.format(date);
            }
            return this.simpleCustomerDateTimeFormat.format(date);
        }
        // render a date 3 letter abbreviation (e.g. for calendars)
        renderHumanMonth(dateObj) {
            var dateFormat = new SimpleDateFormat("MMM");
            return dateFormat.format(dateObj);
        }
        renderDashFormat(dateObj) {
            var dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            return dateFormat.format(dateObj);
        }
        // render user controls to see / change the settings
        renderSettingControls(options) {
            this.showControls(options);
        }
        // shows a pop dialog with control to modify date time settings
        renderSettingDialog(user) {
            globals_1.app.dlgForm.hide();
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            let table = $("<table style='width:100%'><tbody/></table>");
            globals_1.app.dlgForm.append(table);
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: "User Date Time Settings: " + user,
                width: 700,
                height: 430,
                modal: true,
                resizeStop: function () { },
                open: function () {
                    matrixlib_1.ml.UI.DateTime.renderSettingControls({
                        user: user,
                        help: "Settings",
                        table: table
                    });
                },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }
                ]
            });
        }
        // returns an empty string or a warning if the time zone on the PC is different to the server settings
        requiresTimeZoneWarning() {
            var d = new Date(this.dateIso8601FromServer);
            var ds = this.simpleDateTimeFormat.format(d);
            if (ds !== this.dateUserFromServer) {
                return true;
            }
            else {
                return false;
            }
        }
        // return a clickable link button if there are timezone issues
        getTimeZoneCTA() {
            if (!matrixlib_1.ml.UI.DateTime.requiresTimeZoneWarning()) {
                return $("");
            }
            var button = $("<button class='buttonCTA'></button>").text("verify your time zone").click(function () {
                try {
                    if (globals_1.app.dlgForm.dialog("isOpen")) {
                        globals_1.app.dlgForm.dialog("close");
                    }
                }
                catch (exception) {
                    // nothing bad - it just means no dialog was ever opened before
                }
                globals_1.matrixSession.changePassword();
            });
            return button;
        }
        // return the simple date format for controls
        getSimpleDateFormat() {
            return this.userDateOnlyFormat;
        }
        getSimpleDateFormatMoment() {
            return this.toMoment(this.userDateOnlyFormat);
        }
        getSimpleDateTimeFormatMoment() {
            return this.toMoment(this.userDateTimeFormat);
        }
        toMoment(format) {
            // see https://www.angularfaces.net/cheatsheet/
            return format
                .replace("a", "A")
                .replace("DDD", "DDDD")
                .replace("D", "DDD")
                .replace("dd", "DD")
                .replace("d", "D")
                .replace("EEEE", "dddd")
                .replace("EEE", "ddd")
                .replace("EE", "dd")
                .replace("E", "d")
                .replace("u", "E")
                .replace("w", "W")
                .replace("ww", "WW")
                .replace("xxx", "Z")
                .replace("xx", "ZZ")
                .replace("YYYY", "gggg")
                .replace("YY", "gg")
                .replace("yyyy", "YYYY")
                .replace("yyy", "YYY")
                .replace("yy", "YY")
                .replace("y", "Y")
                .replace("Z", "ZZ");
        }
    }
    exports.DateTimeUI = DateTimeUI;
    class BlockingProgressUI {
        closeIfDone() {
            var allDone = true;
            $.each(this.taskList, function (idx, task) {
                if (task.progress < 100) {
                    allDone = false;
                }
            });
            if (allDone) {
                clearTimeout(this.progressLauncher);
                $("#message_progress").hide();
            }
        }
        Init(tasks, animate) {
            let that = this;
            this.taskList = matrixlib_1.ml.JSON.clone(tasks);
            clearTimeout(this.progressLauncher);
            clearTimeout(this.animation);
            var table = $("<table style='width:100%'>");
            var tbody = $("<tbody>");
            table.append(tbody);
            $("#message_progress_text")
                .addClass("alert-success")
                .removeClass("alert-danger")
                .css("width", "600px")
                .html("").append(table);
            $.each(this.taskList, function (idx, task) {
                task.progress = 0;
                var tr = $("<tr>");
                var tdp = $('<div class="progress-bar progress-bar-success progress-bar-striped active progressCtrl2 pci' + idx +
                    '" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width:0%"></div>');
                tdp.data("valuenow", 1).width(1 + "%");
                var name = task.name;
                if (name && name.length > 40) {
                    name = name.substring(0, 37) + "...";
                }
                tbody.append(tr.append($("<td id='progressN" + idx + "' style='text-align:left'>").html(name)).append($("<td style='width:66%;  padding-right: 10px;'>").append(tdp)));
            });
            this.progressLauncher = window.setTimeout(function () {
                $("#message_progress").show();
                if (animate) {
                    $(".pci0", $("#message_progress_text")).width("30px");
                    that.taskList[0].progress = 0;
                    that.animation = window.setInterval(function () { that.tick(); }, 50);
                }
            }, 10);
        }
        SetProgress(taskIdx, percent, newText) {
            clearTimeout(this.animation);
            $(".pci0", $("#message_progress_text")).css("margin-left", "");
            percent = (percent <= 100) ? percent : 100;
            this.taskList[taskIdx].progress = percent;
            $(".pci" + taskIdx, $("#message_progress_text")).data("valuenow", percent).width(percent + "%");
            if (newText) {
                $("#progressN" + taskIdx).html(newText);
            }
            this.closeIfDone();
        }
        SetProgressError(taskIdx, problem) {
            clearTimeout(this.animation);
            this.taskList[taskIdx].progress = 100;
            $(".pci0", $("#message_progress_text")).css("margin-left", "");
            $(".pci" + taskIdx, $("#message_progress_text")).html(problem).css("background-color", "red").width("100%");
            $("#message_progress_text")
                .removeClass("alert-success")
                .addClass("alert-danger");
            this.closeIfDone();
        }
        tick() {
            let percent = this.taskList[0].progress + 1;
            this.taskList[0].progress = percent < 90 ? percent : 0;
            let bar = $(".pci0", $("#message_progress_text"));
            bar.prop("style", "width:30px; margin-left:" + percent + "% !important");
        }
    }
    exports.BlockingProgressUI = BlockingProgressUI;
    class ProgressUI {
        Init(message, warning) {
            $("#progressCtrlContainer").removeClass("hide");
            $("#progressCtrlText").text(message);
            $("#progressCtrl").data("valuenow", 1).width(1 + "%").removeClass("progressWarning");
            if (warning)
                $("#progressCtrl").addClass("progressWarning");
        }
        Update(progress) {
            $("#progressCtrl").data("valuenow", progress).width(progress + "%");
        }
        SuccessHide(message, ms) {
            matrixlib_1.ml.Logger.log('success', message);
            $("#progressCtrlText").text(message);
            $("#progressCtrl").data("valuenow", 100).width(100 + "%");
            clearTimeout(this.ProgressCtrlTimer);
            this.ProgressCtrlTimer = window.setTimeout(function () {
                $("#progressCtrlContainer").addClass("hide");
                $("#progressCtrlText").text("");
                $("#progressCtrl").data("valuenow", 0).width(0 + "%");
            }, ms);
        }
        ErrorHide(message, ms) {
            matrixlib_1.ml.Logger.log('error', message);
            $("#progressCtrlContainer").css("background-color", "red");
            $("#progressCtrlText").text(message);
            $("#progressCtrl").data("valuenow", 0).width(0 + "%");
            clearTimeout(this.ProgressCtrlTimer);
            this.ProgressCtrlTimer = window.setTimeout(function () {
                $("#progressCtrlContainer").addClass("hide");
                $("#progressCtrlContainer").css("background-color", "white");
                $("#progressCtrlText").text("");
                $("#progressCtrl").data("valuenow", 0).width(0 + "%");
            }, ms);
        }
    }
    exports.ProgressUI = ProgressUI;
    class SelectUserOrGroupUI {
        showMultiUserSelect(container, help, selected, title, selectFrom, selectTo, showUsers, showGroups, onSelect, preSelectedUsers) {
            let that = this;
            $('<span class="baseControlHelp">' + help + '</span>').appendTo(container);
            let ctrl = $("<div class='baseControl'>").appendTo(container);
            let input = $("<div class='form-control userSelect'>").appendTo(ctrl);
            input.html(selected ? selected.map(function (userOrGroup) { return that.getGroupDisplayNameFromId(userOrGroup); }).join(", ") : "");
            ctrl.click(function (event) {
                that.showSelectDialog(selected, title, selectFrom, selectTo, showUsers, showGroups, (selection) => {
                    let selectedUI = selection.map(function (userOrGroup) { return that.getGroupDisplayNameFromId(userOrGroup); });
                    input.html(selectedUI.join(", "));
                    onSelect(selection);
                    selected = selection;
                }, preSelectedUsers);
                return false;
            });
        }
        getUsersInSelection(selection) {
            let that = this;
            let users = selection.filter(function (userOrRole) { return !that.isGroup(userOrRole); });
            // add users from groups
            let groups = globals_1.globalMatrix.ItemConfig.getUserGroups();
            if (groups) {
                $.each(groups, function (aclIdx, group) {
                    if (selection.indexOf(that.getGroupId(group)) != -1) {
                        $.each(group.membership, function (mIdx, member) {
                            if (users.indexOf(member.login) == -1) {
                                users.push(member.login);
                            }
                        });
                    }
                });
            }
            return users;
        }
        getGroupId(group) {
            return "g_" + group.groupId + "_g";
        }
        // convert a group id used in mail to italic group name
        getGroupDisplayNameFromId(groupOrUserId) {
            if (!groupOrUserId) {
                groupOrUserId = "";
            }
            if (groupOrUserId.indexOf("g_") != 0 || groupOrUserId.indexOf("_g") != (groupOrUserId.length - 2)) {
                return groupOrUserId; // Not a group let's return the current value.
            }
            let groups = globals_1.globalMatrix.ItemConfig.getUserGroups().sort(function (a, b) { if (a.groupName < b.groupName)
                return -1;
            else
                return 1; });
            for (var idx = 0; idx < groups.length; idx++) {
                if (this.getGroupId(groups[idx]) == groupOrUserId) {
                    return "<span class='groupFlag'>group&nbsp;</span>" + groups[idx].groupName;
                }
            }
            if (!globals_1.globalMatrix.ItemConfig.hasGroupInfo(groupOrUserId)) {
                return `<span class='groupFlag'>group&nbsp;</span><s>${groupOrUserId}</s>`;
            }
            return groupOrUserId;
        }
        // return if the id is a group
        isGroup(groupOrUserId) {
            let groups = globals_1.globalMatrix.ItemConfig.getUserGroups();
            for (var idx = 0; idx < groups.length; idx++) {
                if (this.getGroupId(groups[idx]) == groupOrUserId) {
                    return true;
                }
            }
            return false;
        }
        exists(groupOrUserId) {
            if (this.isGroup(groupOrUserId))
                return true;
            if (globals_1.globalMatrix.ItemConfig.getUserIds().indexOf(groupOrUserId) != -1)
                return true;
            return false;
        }
        showSelectDialog(selected, title, selectFrom, selectTo, showUsers, showGroups, onSelect, preSelectedUsers) {
            let that = this;
            that.dlg = $(`<div data-cy='${title.replace(/\s/g, "-")}'>`).appendTo("body");
            let select = $("<select multiple>").appendTo(that.dlg);
            selected = selected ? selected : [];
            select.append("<option style='display:none' value='' data-search=''>");
            let users = preSelectedUsers ? preSelectedUsers : globals_1.globalMatrix.ItemConfig.getUserNames();
            let groups = globals_1.globalMatrix.ItemConfig.getUserGroups().sort(function (a, b) { if (a.groupName < b.groupName)
                return -1;
            else
                return 1; });
            let userSelect = select;
            let groupSelect = select;
            if (showGroups && showUsers) {
                userSelect = $("<optgroup label='Users'>").appendTo(select);
                groupSelect = $("<optgroup label='User Groups'>").appendTo(select);
            }
            if (showUsers) {
                // sort users alphabetically
                users = users.sort(function (a, b) { if (a.login < b.login)
                    return -1;
                else
                    return 1; });
                // add to user select
                $.each(users, function (userIdx, user) {
                    let name = that.combinedName(user);
                    let email = (user.email ? user.email : "");
                    let searchVal = email + " " + name;
                    let sel = (selected.indexOf(user.login) != -1) ? " selected" : "";
                    userSelect.append($(`
                    <option data-search='${searchVal.toLowerCase()}' data-cy='${user.login}' data-user='${user.login}' 
                        title='${email}' value='${user.login}' ${sel}>
                        ${name}
                    </option>`));
                });
            }
            if (showGroups) {
                $.each(groups, function (groupIdx, group) {
                    let groupName = group.groupName;
                    let groupId = that.getGroupId(group);
                    let sel = (selected.indexOf(groupId) != -1) ? " selected" : "";
                    let tooltip = "Press shift to select individual users instead of groups: " +
                        group.membership.map(function (member) { return member.login; }).join(", ");
                    if (group.membership.length == 0) {
                        tooltip = "group has no members";
                    }
                    groupSelect.append($(`<option title='${tooltip}'  data-group='group' data-search='group ${groupName.toLowerCase()}' value='${groupId}' ${sel} >${groupName}</option>`));
                });
            }
            that.dlg.dialog({
                autoOpen: true,
                title: title ? title : "Select",
                width: 716,
                height: 580,
                resizeStop: function () { that.resize(); },
                modal: true,
                open: function () {
                    matrixlib_1.ml.UI.pushDialog(that.dlg);
                    select.multiSelect({
                        selectableHeader: "<div class='custom-header'>" + selectFrom + "</div><input type='text' class='form-control ms-search' autocomplete='off' placeholder='filter'>",
                        selectionHeader: "<div class='custom-header'>" + selectTo + "</div><input type='text' class='form-control ms-search' autocomplete='off' placeholder='filter'>",
                        afterInit: function () {
                            let that = this, $selectableSearch = that.$selectableUl.prev(), $selectionSearch = that.$selectionUl.prev(), selectableSearchString = '#' + that.$container.attr('id') + ' .ms-elem-selectable:not(.ms-selected)', selectionSearchString = '#' + that.$container.attr('id') + ' .ms-elem-selection.ms-selected';
                            $("li", that.dlg).each(function (idx, opt) {
                                if ($(opt).data("group"))
                                    $(opt).prepend("<span class='groupFlag'>group</span>");
                                if ($(opt).data("user"))
                                    $(opt).prepend(that.UI.getAvatar($(opt).data("user"), 25));
                            });
                            $selectableSearch.on('keyup', function (e) {
                                if (e.which === 40) {
                                    that.$selectableUl.focus();
                                    return false;
                                }
                                else {
                                    let searchExpr = $selectableSearch.val().toLowerCase();
                                    $.each($(selectableSearchString), function (lidx, li) {
                                        (!searchExpr || $(li).data("search").indexOf(searchExpr) != -1) ? $(li).show() : $(li).hide();
                                    });
                                    return true;
                                }
                            }).focus();
                            $selectionSearch.on('keyup', function (e) {
                                if (e.which == 40) {
                                    that.$selectionUl.focus();
                                    return false;
                                }
                                else {
                                    let searchExpr = $selectionSearch.val().toLowerCase();
                                    $.each($(selectionSearchString), function (lidx, li) {
                                        (!searchExpr || $(li).data("search").indexOf(searchExpr) != -1) ? $(li).show() : $(li).hide();
                                    });
                                    return true;
                                }
                            });
                        },
                        afterSelect: function (sel) {
                            let groupAddedAsUsers = false;
                            if (globals_1.globalMatrix.globalShiftDown && showGroups) {
                                $.each(groups, function (groupIdx, group) {
                                    let groupId = that.getGroupId(group);
                                    if (groupId == sel[0]) {
                                        groupAddedAsUsers = true;
                                        let newMembers = group.membership.map(function (member) { return member.login; }).filter(function (login) { return selected.indexOf(login) == -1; });
                                        // update UI
                                        $.each(newMembers, function (nmIdx, newMember) {
                                            select.multiSelect('select', [newMember]);
                                        });
                                        // update internal selection
                                        // selected = selected.concat( newMembers );
                                    }
                                });
                            }
                            if (!groupAddedAsUsers) {
                                selected.push(sel[0]);
                            }
                        },
                        afterDeselect: function (sel) {
                            selected = selected.filter(function (s) { return s != sel[0]; });
                        }
                    });
                    that.resize();
                },
                close: function () { matrixlib_1.ml.UI.popDialog(that.dlg); that.dlg.remove(); },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            onSelect(selected);
                            that.dlg.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.dlg.dialog("close");
                        }
                    }]
            });
        }
        getUserDropDownOptions(showUsers, showGroups, preSelectedUsers, possiblyDeletedUserGroupNames) {
            let that = this;
            let options = [];
            let users = preSelectedUsers ? preSelectedUsers : globals_1.globalMatrix.ItemConfig.getUserNames();
            let groups = globals_1.globalMatrix.ItemConfig.getUserGroups().sort(function (a, b) { if (a.groupName < b.groupName)
                return -1;
            else
                return 1; });
            // if {possiblyDeletedUsernames} are not found in {users}, we want to add them.
            const isGroup = /g_([0-9])+_g/;
            let names = possiblyDeletedUserGroupNames ? possiblyDeletedUserGroupNames.split(',') : [];
            names.forEach(name => {
                if (!globals_1.globalMatrix.ItemConfig.hasUserInfo(name)) {
                    if (!isGroup.test(name)) {
                        users.push({
                            id: 0,
                            login: name,
                            email: "unknown",
                            permission: 0,
                            firstName: "",
                            lastName: "",
                            deleted: true
                        });
                    }
                    else if (!globals_1.globalMatrix.ItemConfig.hasGroupInfo(name)) {
                        // We know match found a group because isGroup.test(name) returned true.
                        const groupId = parseInt(name.match(isGroup)[1]);
                        groups.push({
                            groupName: name,
                            permission: 0,
                            groupId: groupId,
                            membership: [],
                            deleted: true
                        });
                    }
                }
            });
            if (showGroups && showUsers) {
            }
            if (showUsers) {
                // sort users alphabetically
                users = users.sort(function (a, b) { if (a.login < b.login)
                    return -1;
                else
                    return 1; });
                // add to user select
                $.each(users, function (userIdx, user) {
                    // Deleted users have strikethrough text, and are disabled from selection.
                    // We only display their login, not their full name.
                    const deletedUser = user.deleted === true;
                    const labelText = deletedUser ? user.login : that.combinedName(user);
                    options.push({
                        id: user.login, label: labelText, class: "users",
                        disabled: deletedUser,
                        strikethrough: deletedUser
                    });
                });
            }
            if (showGroups) {
                $.each(groups, function (groupIdx, group) {
                    const deletedGroup = group.deleted === true;
                    let groupName = group.groupName;
                    let groupId = deletedGroup ? groupName : that.getGroupId(group);
                    options.push({
                        id: groupId, label: groupName, class: "groups",
                        disabled: deletedGroup,
                        strikethrough: deletedGroup
                    });
                });
            }
            return options;
        }
        showSingleSelect(control, showUsers, showGroups, onSelect, preSelectedUsers, possiblyDeletedUsername) {
            let that = this;
            let options = this.getUserDropDownOptions(showUsers, showGroups, preSelectedUsers, possiblyDeletedUsername);
            control.selectize({
                persist: false,
                maxItems: 1,
                valueField: 'id',
                labelField: 'label',
                searchField: ['label'],
                options: options,
                onChange: function (args) {
                    onSelect(args);
                },
                render: {
                    option: function (item, escape) {
                        // This is to avoid escaped strings showing in the UI
                        let labelText = item.label;
                        if (item.strikethrough) {
                            labelText = `<s>${labelText}</s>`;
                        }
                        return `<div class='option'>${labelText}</div>`;
                    },
                    item: function (item, escape) {
                        let labelText = item.label;
                        if (item.strikethrough) {
                            labelText = `<s>${labelText}</s>`;
                        }
                        return `<div class='item'>${labelText}</div>`;
                    }
                }
            });
        }
        // store all the current groups and users in page
        getAllUsersAndGroups() {
            let that = this;
            let res = $.Deferred();
            let dropdownOptions = [];
            globals_1.restConnection.getServer("user").done(function (allUsersResult) {
                let users = allUsersResult.user.filter(function (user) {
                    return user.userStatus != "deleted" && user.userStatus != "blocked" && !user.superAdmin;
                }).sort(function (a, b) { if (a.login < b.login)
                    return -1;
                else
                    return 1; });
                // add to user select
                $.each(users, function (userIdx, user) {
                    let name = (user.firstName ? user.firstName : "") + " " + (user.lastName ? user.lastName : "");
                    name = user.login + (name == " " ? "" : (" - ") + name);
                    let opt = { id: user.login, label: name, class: "users" };
                    dropdownOptions.push(opt);
                });
                globals_1.restConnection.getServer("group").done(function (allGroupsResult) {
                    let groups = allGroupsResult.groups.sort(function (a, b) { if (a.groupName < b.groupName)
                        return -1;
                    else
                        return 1; });
                    // add groups
                    $.each(groups, function (groupIdx, group) {
                        let groupName = group.groupName;
                        let groupId = that.getGroupId(group);
                        let opt = { id: groupId, label: groupName, class: "groups" };
                        dropdownOptions.push(opt);
                    });
                    res.resolve(dropdownOptions);
                });
            });
            return res;
        }
        combinedName(user) {
            let name = (user.firstName ? user.firstName : "") + " " + (user.lastName ? user.lastName : "");
            return user.login + (name == " " ? "" : (" - ") + name);
        }
        showSingleSelectDialog(selected, title, help, showUsers, showGroups, onSelect, preSelectedUsers) {
            let that = this;
            that.dlg = $("<div>").appendTo("body");
            $('<span class="baseControlHelp">' + help + '</span>').appendTo(that.dlg);
            let ctrl = $("<div class='baseControl'>").appendTo(that.dlg);
            let input = $("<div class='form-control'>").appendTo(ctrl);
            this.showSingleSelect(input, showUsers, showGroups, (newSelection) => {
                selected = newSelection;
            }, preSelectedUsers, selected);
            that.dlg.dialog({
                autoOpen: true,
                title: title ? title : "Select",
                width: 716,
                height: 380,
                resizeStop: function () { that.resize(); },
                modal: true,
                open: function () {
                    matrixlib_1.ml.UI.pushDialog(that.dlg);
                },
                close: function () { matrixlib_1.ml.UI.popDialog(that.dlg); that.dlg.remove(); },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            onSelect(selected);
                            that.dlg.dialog("close");
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            that.dlg.dialog("close");
                        }
                    }]
            });
        }
        resize() {
            let height = this.dlg.height();
            let top = $(".ms-list", this.dlg).position().top;
            $(".ms-list", this.dlg).height(height - top);
        }
    }
    exports.SelectUserOrGroupUI = SelectUserOrGroupUI;
    // TODO(modules): I don't think LT needs to be implemented in this file, it's a lower-level library.
    /** helper to escape < into non-dangerous &lt; */
    class LT {
        /** prepares the text for storage in db and readonly display
         * @param code is the text
         * @param fieldId (or 0/null) is the field which can have this turned off
        */
        forDB(code, fieldId) {
            let config = globals_1.globalMatrix.ItemConfig ? globals_1.globalMatrix.ItemConfig.getFieldConfig(fieldId) : null;
            if (config && config.unsafeHtml)
                return code;
            return (code && !globals_1.matrixSession.isConfigClient()) ? code.replace(/&/g, "&amp;").replace(/</g, "&lt;") : code;
        }
        /** prepares the text for editing in UI
         * @param code is the text
         * @param fieldId (or 0/null) is the field which can have this turned off
        */
        forUI(code, fieldId) {
            let config = (fieldId && globals_1.globalMatrix.ItemConfig) ? globals_1.globalMatrix.ItemConfig.getFieldConfig(fieldId) : null;
            if (config && config.unsafeHtml) {
                return code;
            }
            if (code && !globals_1.matrixSession.isConfigClient()) {
                return code.replace(/&lt;/g, "<").replace(/&amp;/g, "&").replace(/&gt;/g, ">");
            }
            else {
                return code;
            }
        }
    }
    exports.LT = LT;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 75 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ThemeSelector = void 0;
    class ThemeSelector {
        constructor() {
            this.currentCSS = "";
            this.themes = {
                dark: `
            .navbar-inverse{
                background:black !important;
            }
            #idProject
            {
                color:white!important;
            }
            #projectNameTitleContainer:hover
            {
                color:lightgrey!important;
            }
           
            .navbar-inverse .btn-success:hover
            {
                box-shadow: 2px 2px 2px 1px #ffffff80;

            }
                      `,
                light: ``,
            };
            let that = this;
            this.currentCSS = "";
            if (localStorage.getItem("currentCSS") == undefined) {
                localStorage.setItem("currentCSS", "light");
            }
            let inter = setInterval(() => {
                if (!that.themeSelectorAdded) {
                    that.themeSelectorAdded = true;
                    this.currentCSS = localStorage.getItem("currentCSS");
                    that.loadTheme(this.currentCSS);
                }
                else {
                    if (this.themeSelectorAdded) {
                        clearInterval(inter);
                    }
                }
            }, 200);
        }
        injectCSS(cssFile) {
            var t = $("#themeCSS");
            let that = this;
            if (cssFile != "") {
                console.log("Injecting the CSS ");
                //Load external file
                that.loadTheme(cssFile);
            }
            else {
                t.remove();
            }
            that.currentCSS = cssFile;
            localStorage.setItem("currentCSS", cssFile);
        }
        reloadCurrentCSS() {
            this.injectCSS(this.currentCSS);
        }
        loadTheme(themeName) {
            $("#extraTheme").remove();
            let theme = $("<style id='extraTheme'>");
            theme.html(this.themes[themeName]);
            $('body').append(theme);
        }
        init() {
        }
        renderThemeSelectorControl(help, table) {
            //This is saved in localstorage.
            let tableBody = $("tbody", table);
            tableBody.append($('<tr class="theme showInAdmin" ><td colspan="2" class="baseControlHelp">Colors</td></tr'));
            var tr = $("<tr  class='theme showInAdmin' >");
            tableBody.append(tr);
            tr.append($("<td class='admin_utdl'>").append($("<label class='control-label'>").html("Theme")));
            let that = this;
            /*$(document).keydown(function(key){ if (key.ctrlKey && key.altKey && key.key == 'q' )
            {
                that.reloadCurrentCSS();
            }})*/
            tr.append($("<td>").append(`<select  style="width: 100%;height: 34px;" class="form-control" id="themeSelectorCombo">   
                <option value="light">Light</option>
                <option value="dark">Dark</option> 
           </select>`));
            $("#themeSelectorCombo").change((o) => {
                var value = $("#themeSelectorCombo option:selected").val();
                this.injectCSS(value);
            });
            $("#themeSelectorCombo").val(this.currentCSS);
            tr.append($("<td>").append(""));
        }
    }
    exports.ThemeSelector = ThemeSelector;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 76 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(77), __webpack_require__(1), __webpack_require__(81), __webpack_require__(6), __webpack_require__(82), __webpack_require__(83)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, gridstack_1, matrixlib_1, ILineEditor_1, globals_1, WidgetPluginManager_1, WidgetSettingsManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.WidgetPluginsConstants = exports.WidgetPluginsContainer = void 0;
    class WidgetPluginsConstants {
    }
    exports.WidgetPluginsConstants = WidgetPluginsConstants;
    WidgetPluginsConstants.defaultDashboardId = "default";
    WidgetPluginsConstants.defaultDashboard = { displayString: "home" };
    class WidgetPluginsContainer {
        constructor() {
            this.currentDashboard = WidgetPluginsConstants.defaultDashboardId;
        }
        toggle() {
            if (!this.visible) {
                this.render(this.currentDashboard);
            }
            else {
                this.exit(this.previousUrl);
            }
        }
        addNewWidget() {
            var _a;
            let that = this;
            let editor = new ILineEditor_1.LineEditorExt();
            let lst = [];
            for (let key in WidgetPluginManager_1.widgetPluginManager.pluginList) {
                let widget = WidgetPluginManager_1.widgetPluginManager.pluginList[key];
                if (widget.defaultParameters().canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.superAdmin && !globals_1.matrixSession.isSuperAdmin()) {
                    continue;
                }
                if (widget.defaultParameters().canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.admin && !globals_1.matrixSession.isAdmin()) {
                    continue;
                }
                let display = ((_a = widget.help) !== null && _a !== void 0 ? _a : "") + "   [" + key + "]";
                lst.push({ id: key, label: display });
            }
            let defaultVal = lst.length > 0 ? lst[0].id : "";
            let lines = [
                { help: 'Type', type: 'select', required: true, value: defaultVal, options: lst },
            ];
            let editorTitle = "Add a widget";
            if (globals_1.matrixSession.isAdmin() && globals_1.globalMatrix.globalShiftDown) {
                editorTitle = "Add a widget for specific users";
                lines.push({ help: 'Add for other user?', type: 'boolean', required: false, value: "false" });
            }
            let selectedPlugin;
            let newWidget;
            editor.showDialog(editorTitle, 400, lines, (updated) => {
                selectedPlugin = Object.create(window[updated[0].value].prototype);
                selectedPlugin.constructor.apply();
                let params = selectedPlugin.defaultParameters();
                let selectedPluginIndex = updated[0].options.findIndex((i) => { return i.id == updated[0].value; });
                ;
                params.options.title = updated[0].options[selectedPluginIndex].label;
                params.position.w = 2;
                params.position.h = 2;
                params.position.dashboard = this.currentDashboard;
                newWidget = { id: `widget_${updated[0].value}_${new Date().getTime().toString()}`, pluginName: updated[0].value, parameters: params, createdBy: globals_1.matrixSession.getUser() };
                if (updated.length == 2 && updated[1].value != undefined && updated[1].value != "") {
                    newWidget.parameters.users = ["*"];
                    newWidget.parameters.options.canBeHidden = updated[1].value.toString() == "true";
                }
                WidgetSettingsManager_1.WidgetSettingsManager.setSettings(newWidget);
                let widget = that.grid.addWidget({ w: Math.max(params.position.w, 1), h: Math.max(params.position.h, 1), });
                selectedPlugin.render($(".grid-stack-item-content", widget), newWidget, WidgetPluginManager_1.renderMode.placeholder);
                WidgetPluginManager_1.widgetPluginManager.addLoadedWidget(newWidget.id, selectedPlugin);
                return true;
            }).done(() => {
                selectedPlugin.showWidgetSettingEditor(newWidget);
            });
        }
        render(dashboardId = WidgetPluginsConstants.defaultDashboardId) {
            let conf = globals_1.matrixSession.getDashboardConfig();
            if (conf.dashboards[dashboardId] == null) {
                matrixlib_1.ml.UI.showError("Dashboard not found", "");
            }
            let dashboard = conf.dashboards[dashboardId];
            WidgetPluginManager_1.widgetPluginManager.unLoadAllWidgets();
            $("#widgetDashboard").remove();
            $("#addWidget").remove();
            $(".dashboardTitle").remove();
            $("#showHiddenWidgetButton").remove();
            this.previousUrl = window.location.href;
            history.pushState(null, null, globals_1.globalMatrix.matrixBaseUrl + "/?dashboard=" + dashboardId);
            this.currentDashboard = dashboardId;
            this.visible = true;
            let that = this;
            $('#highlightContext').hide();
            $("#contextframe").hide();
            $("#contextframesizer").hide();
            $("body").append(`<div id='addWidget'><span class="fa-stack ">
                            <i class="fal fa-sticky-note fa-stack-2x"></i>
                            <i class="fa fa-plus fa-stack" style=""></i>
                        </span> </div> `);
            this._root = $("<div id='widgetDashboard'> <div class='grid-stack'> </div></div>");
            this._root.insertAfter("header");
            $("#widgetDashboard").prepend(matrixlib_1.ml.UI.getPageTitle(dashboard.displayString));
            var bClose = $("<div  class='btn-group btn-dashboard-close' ><button title data-original-title='Close' style='margin-right: -12px;' class='btn btn-item btn-fullscreen'> <span class='fal fa-times-circle'></span></button></div>").click(function () {
                that.exit(that.previousUrl);
            });
            $("#widgetDashboard .toolbarButtons").append(bClose);
            WidgetPluginManager_1.widgetPluginManager.unLoadAllWidgets();
            this.grid = gridstack_1.GridStack.init();
            let layout = 'none';
            let width = document.body.clientWidth;
            if (width < 800) {
                that.grid.column(1, layout);
            }
            else {
                that.grid.column(12, layout);
            }
            let i = 0;
            globals_1.matrixSession.serverConfig.currentUserSettings.forEach((userSetting) => {
                if (userSetting.key.indexOf("widget_") == 0) {
                    let w = JSON.parse(userSetting.value);
                    let plugin = WidgetPluginManager_1.widgetPluginManager.pluginList[w.pluginName];
                    if (plugin && w.parameters.position.dashboard == this.currentDashboard) {
                        let clonedPlugin = Object.create(window[w.pluginName].prototype);
                        clonedPlugin.constructor.apply();
                        w.parameters = plugin.mergeOptions(w.parameters);
                        WidgetPluginManager_1.widgetPluginManager.addLoadedWidget(userSetting.key, clonedPlugin);
                        let gridWidget = this.grid.addWidget({ w: w.parameters.position.w, h: w.parameters.position.h, x: w.parameters.position.x, y: w.parameters.position.y });
                        clonedPlugin.render($(".grid-stack-item-content", gridWidget), w, WidgetPluginManager_1.renderMode.placeholder);
                    }
                    else {
                        console.log("Unknown plugin");
                    }
                }
            });
            that.loadServerSettingWidgets();
            let hiddenWidget = WidgetSettingsManager_1.WidgetSettingsManager.getHiddenWidgets();
            hiddenWidget.forEach((w) => {
                let p = WidgetPluginManager_1.widgetPluginManager.loadedWidgets[w];
                if (p != undefined) {
                    p.hide(false);
                }
            });
            $("#addWidget").click(() => {
                that.addNewWidget();
            });
            $("#addWidget").hover(() => {
                $("#addWidget").tooltip({
                    title: globals_1.matrixSession.isAdmin() ? "Add a widget (use shift to add it for somebody else)" : "Add a widget",
                    placement: "auto",
                    container: "body"
                });
            });
            this.showUpdateShowHiddenButton();
            this.grid.on('change', function (event, items) {
                setTimeout(() => {
                    if (window.innerWidth > 700) {
                        items.forEach(function (item) {
                            let id = $(".mWidget", item.el).prop("id");
                            let widget = WidgetPluginManager_1.widgetPluginManager.loadedWidgets[id];
                            if (widget != undefined) {
                                widget.updatePosition(item.w, item.h, item.x, item.y);
                            }
                        });
                    }
                }, 100);
            });
            this._root.prop("style", "");
        }
        loadServerSettingWidgets(loadAllUser = false) {
            globals_1.matrixSession.serverConfig.customerSettings.forEach((setting) => {
                if (setting.key.indexOf("widget_") == 0 && WidgetPluginManager_1.widgetPluginManager.loadedWidgets[setting.key] == undefined) {
                    let w = JSON.parse(setting.value);
                    let plugin = WidgetPluginManager_1.widgetPluginManager.pluginList[w.pluginName];
                    if (plugin && w.parameters.users != undefined &&
                        ((w.parameters.users.indexOf("*") != -1 || w.parameters.users.indexOf(globals_1.matrixSession.getUser()) != -1)
                            || (loadAllUser && globals_1.matrixSession.isAdmin()))) {
                        // Check for position override
                        let pos = localStorage.getItem(w.id);
                        if (pos != undefined && pos != "") {
                            let position = JSON.parse(pos);
                            w.parameters.position = position;
                        }
                        let clonedPlugin = Object.create(window[w.pluginName].prototype);
                        clonedPlugin.constructor.apply();
                        w.parameters = plugin.mergeOptions(w.parameters);
                        if (w.parameters.position.dashboard == this.currentDashboard) {
                            WidgetPluginManager_1.widgetPluginManager.addLoadedWidget(setting.key, clonedPlugin);
                            let gridWidget = this.grid.addWidget({ w: w.parameters.position.w, h: w.parameters.position.h, x: w.parameters.position.x, y: w.parameters.position.y, noMove: !globals_1.matrixSession.isAdmin(), noResize: !globals_1.matrixSession.isAdmin() });
                            clonedPlugin.render($(".grid-stack-item-content", gridWidget), w, WidgetPluginManager_1.renderMode.placeholder);
                            if (globals_1.matrixSession.isAdmin() && w.parameters.users && (w.parameters.users.indexOf("*") == -1 && w.parameters.users.indexOf(globals_1.matrixSession.getUser()) == -1)) {
                                $(".grid-stack-item-content", gridWidget).css("opacity", 0.4);
                            }
                            $(".grid-stack-item-content", gridWidget).addClass("widgetAddedByAdmin");
                        }
                    }
                    else {
                        console.log("Unknown plugin");
                    }
                }
            });
        }
        exit(destination) {
            this.visible = false;
            if (destination == null || destination.indexOf(globals_1.globalMatrix.matrixBaseUrl + "/?dashboard=") == 0) {
                if (localStorage.getItem("SessionLastProject") != null)
                    window.location.href = globals_1.globalMatrix.matrixBaseUrl + localStorage.getItem("SessionLastProject");
                else
                    window.location.href = globals_1.globalMatrix.matrixBaseUrl;
            }
            else {
                history.pushState(null, null, destination);
                $('#highlightContext').show();
                $("#contextframe").show();
                $("#contextframesizer").show();
                WidgetPluginManager_1.widgetPluginManager.unLoadAllWidgets();
                $("#widgetDashboard").remove();
                $("#addWidget").remove();
                $("#showHiddenWidgetButton").remove();
                $(".dashboardTitle").remove();
            }
        }
        hideWidget(id) {
            $(".grid-stack-item:has(#" + id + ")").hide();
            this.showUpdateShowHiddenButton();
        }
        unhide(id) {
            $(".grid-stack-item:has(#" + id + ")").show();
            this.showUpdateShowHiddenButton();
        }
        deleteWidget(displayedWidget) {
            WidgetSettingsManager_1.WidgetSettingsManager.unhide(displayedWidget);
            $(".grid-stack-item:has(#" + displayedWidget.id + ")").remove();
            this.showUpdateShowHiddenButton();
        }
        showUpdateShowHiddenButton() {
            let that = this;
            if (WidgetSettingsManager_1.WidgetSettingsManager.getHiddenWidgets().length > 0) {
                if ($('#showHiddenWidgetButton').length == 0) {
                    $("body").append(`<div id='showHiddenWidgetButton'><span class="fa-stack ">
                <i class="fal fa-eye-slash fa-stack-2x"></i>
                <i class="fal fa-toggle-on" style=""></i>
                    </span> </div> `);
                    $("#showHiddenWidgetButton").hover(() => {
                        $("#showHiddenWidgetButton").tooltip({
                            title: "Toggle hidden widget",
                            placement: "top",
                            container: "body"
                        });
                    });
                    $("#showHiddenWidgetButton").click(() => {
                        if (globals_1.globalMatrix.globalShiftDown) {
                            that.loadServerSettingWidgets(true);
                        }
                        WidgetSettingsManager_1.WidgetSettingsManager.getHiddenWidgets().forEach((widget) => {
                            $(".grid-stack-item:has(#" + widget + ")").toggle();
                        });
                    });
                }
            }
            else {
                $('#showHiddenWidgetButton').remove();
            }
        }
    }
    exports.WidgetPluginsContainer = WidgetPluginsContainer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// gridstack.ts 3.2.0 @preserve
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * https://gridstackjs.com/
 * (c) 2014-2020 Alain Dumesny, Dylan Weiss, Pavel Reznikov
 * gridstack.js may be freely distributed under the MIT license.
*/
const gridstack_engine_1 = __webpack_require__(78);
const utils_1 = __webpack_require__(79);
const gridstack_ddi_1 = __webpack_require__(80);
__export(__webpack_require__(79));
__export(__webpack_require__(78));
__export(__webpack_require__(80));
// default values for grid options - used during init and when saving out
const GridDefaults = {
    column: 12,
    minRow: 0,
    maxRow: 0,
    itemClass: 'grid-stack-item',
    placeholderClass: 'grid-stack-placeholder',
    placeholderText: '',
    handle: '.grid-stack-item-content',
    handleClass: null,
    styleInHead: false,
    cellHeight: 'auto',
    margin: 10,
    auto: true,
    minWidth: 768,
    float: false,
    staticGrid: false,
    animate: true,
    alwaysShowResizeHandle: false,
    resizable: {
        autoHide: true,
        handles: 'se'
    },
    draggable: {
        handle: '.grid-stack-item-content',
        scroll: false,
        appendTo: 'body'
    },
    dragIn: undefined,
    dragInOptions: {
        revert: 'invalid',
        handle: '.grid-stack-item-content',
        scroll: false,
        appendTo: 'body'
    },
    disableDrag: false,
    disableResize: false,
    rtl: 'auto',
    removable: false,
    removableOptions: {
        accept: '.grid-stack-item'
    },
    removeTimeout: 2000,
    marginUnit: 'px',
    cellHeightUnit: 'px',
    disableOneColumnMode: false,
    oneColumnModeDomSort: false
};
/**
 * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.
 * Note: your grid elements MUST have the following classes for the CSS layout to work:
 * @example
 * <div class="grid-stack">
 *   <div class="grid-stack-item">
 *     <div class="grid-stack-item-content">Item 1</div>
 *   </div>
 * </div>
 */
class GridStack {
    /**
     * Construct a grid item from the given element and options
     * @param el
     * @param opts
     */
    constructor(el, opts = {}) {
        /** @internal */
        this._gsEventHandler = {};
        this.el = el; // exposed HTML element to the user
        opts = opts || {}; // handles null/undefined/0
        utils_1.obsoleteOpts(opts, 'verticalMargin', 'margin', 'v2.0');
        utils_1.obsoleteAttr(this.el, 'data-gs-current-height', 'gs-current-row', 'v1.0.0');
        // if row property exists, replace minRow and maxRow instead
        if (opts.row) {
            opts.minRow = opts.maxRow = opts.row;
            delete opts.row;
        }
        let rowAttr = utils_1.Utils.toNumber(el.getAttribute('gs-row'));
        // elements attributes override any passed options (like CSS style) - merge the two together
        let defaults = Object.assign(Object.assign({}, GridDefaults), { column: utils_1.Utils.toNumber(el.getAttribute('gs-column')) || 12, minRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute('gs-min-row')) || 0, maxRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute('gs-max-row')) || 0, staticGrid: utils_1.Utils.toBool(el.getAttribute('gs-static')) || false, _styleSheetClass: 'grid-stack-instance-' + (Math.random() * 10000).toFixed(0), alwaysShowResizeHandle: opts.alwaysShowResizeHandle || false, resizable: {
                autoHide: !(opts.alwaysShowResizeHandle || false),
                handles: 'se'
            }, draggable: {
                handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || '.grid-stack-item-content',
                scroll: false,
                appendTo: 'body'
            }, removableOptions: {
                accept: '.' + (opts.itemClass || 'grid-stack-item')
            } });
        if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead
            defaults.animate = utils_1.Utils.toBool(el.getAttribute('gs-animate'));
        }
        this.opts = utils_1.Utils.defaults(opts, defaults);
        opts = null; // make sure we use this.opts instead
        this.initMargin();
        if (this.opts.rtl === 'auto') {
            this.opts.rtl = el.style.direction === 'rtl';
        }
        if (this.opts.rtl) {
            this.el.classList.add('grid-stack-rtl');
        }
        // check if we're been nested, and if so update our style and keep pointer around (used during save)
        let parentGridItemEl = utils_1.Utils.closestByClass(this.el, GridDefaults.itemClass);
        if (parentGridItemEl && parentGridItemEl.gridstackNode) {
            this.opts._isNested = parentGridItemEl.gridstackNode;
            this.opts._isNested.subGrid = this;
            this.el.classList.add('grid-stack-nested');
        }
        this._isAutoCellHeight = (this.opts.cellHeight === 'auto');
        if (this._isAutoCellHeight) {
            // make the cell content square initially (will use resize event to keep it square)
            let marginDiff = -this.opts.marginRight - this.opts.marginLeft
                + this.opts.marginTop + this.opts.marginBottom;
            this.cellHeight(this.cellWidth() + marginDiff, false);
        }
        else {
            this.cellHeight(this.opts.cellHeight, false);
        }
        this.el.classList.add(this.opts._styleSheetClass);
        this._setStaticClass();
        this.engine = new gridstack_engine_1.GridStackEngine({
            column: this.opts.column,
            float: this.opts.float,
            maxRow: this.opts.maxRow,
            onChange: (cbNodes, removeDOM = true) => {
                let maxH = 0;
                this.engine.nodes.forEach(n => { maxH = Math.max(maxH, n.y + n.h); });
                cbNodes.forEach(n => {
                    let el = n.el;
                    if (removeDOM && n._id === null) {
                        if (el && el.parentNode) {
                            el.parentNode.removeChild(el);
                        }
                    }
                    else {
                        this._writePosAttr(el, n.x, n.y, n.w, n.h);
                    }
                });
                this._updateStyles(false, maxH); // false = don't recreate, just append if need be
            }
        });
        if (this.opts.auto) {
            this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...
            let elements = [];
            this.getGridItems().forEach(el => {
                let x = parseInt(el.getAttribute('gs-x'));
                let y = parseInt(el.getAttribute('gs-y'));
                elements.push({
                    el,
                    // if x,y are missing (autoPosition) add them to end of list - but keep their respective DOM order
                    i: (Number.isNaN(x) ? 1000 : x) + (Number.isNaN(y) ? 1000 : y) * this.opts.column
                });
            });
            elements.sort(e => e.i).forEach(e => this._prepareElement(e.el));
            this.commit();
        }
        this.engine.saveInitial(); // initial start of items
        this.setAnimation(this.opts.animate);
        this._updateStyles();
        if (this.opts.column != 12) {
            this.el.classList.add('grid-stack-' + this.opts.column);
        }
        this._setupDragIn();
        this._setupRemoveDrop();
        this._setupAcceptWidget();
        this._updateWindowResizeEvent(); // finally this may size us down to 1 column
    }
    /**
     * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will
     * simply return the existing instance (ignore any passed options). There is also an initAll() version that support
     * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.
     * @param options grid options (optional)
     * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)
     *
     * @example
     * let grid = GridStack.init();
     *
     * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later
     * let grid = document.querySelector('.grid-stack').gridstack;
     */
    static init(options = {}, elOrString = '.grid-stack') {
        let el = GridStack.getGridElement(elOrString);
        if (!el) {
            if (typeof elOrString === 'string') {
                console.error('GridStack.initAll() no grid was found with selector "' + elOrString + '" - element missing or wrong selector ?' +
                    '\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
            }
            else {
                console.error('GridStack.init() no grid element was passed.');
            }
            return null;
        }
        if (!el.gridstack) {
            el.gridstack = new GridStack(el, Object.assign({}, options));
        }
        return el.gridstack;
    }
    /**
     * Will initialize a list of elements (given a selector) and return an array of grids.
     * @param options grid options (optional)
     * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)
     *
     * @example
     * let grids = GridStack.initAll();
     * grids.forEach(...)
     */
    static initAll(options = {}, selector = '.grid-stack') {
        let grids = [];
        GridStack.getGridElements(selector).forEach(el => {
            if (!el.gridstack) {
                el.gridstack = new GridStack(el, Object.assign({}, options));
            }
            grids.push(el.gridstack);
        });
        if (grids.length === 0) {
            console.error('GridStack.initAll() no grid was found with selector "' + selector + '" - element missing or wrong selector ?' +
                '\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
        }
        return grids;
    }
    /**
     * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then
     * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from
     * JSON serialized data, including options.
     * @param parent HTML element parent to the grid
     * @param opt grids options used to initialize the grid, and list of children
     */
    static addGrid(parent, opt = {}) {
        if (!parent)
            return null;
        // create the grid element
        let doc = document.implementation.createHTMLDocument();
        doc.body.innerHTML = `<div class="grid-stack ${opt.class || ''}"></div>`;
        let el = doc.body.children[0];
        parent.append(el);
        // create grid class and load any children
        let grid = GridStack.init(opt, el);
        if (opt.children) {
            grid.load(opt.children);
        }
        return grid;
    }
    /** @internal create placeholder DIV as needed */
    get placeholder() {
        if (!this._placeholder) {
            let placeholderChild = document.createElement('div'); // child so padding match item-content
            placeholderChild.className = 'placeholder-content';
            if (this.opts.placeholderText) {
                placeholderChild.innerHTML = this.opts.placeholderText;
            }
            this._placeholder = document.createElement('div');
            this._placeholder.classList.add(this.opts.placeholderClass, GridDefaults.itemClass, this.opts.itemClass);
            this.placeholder.appendChild(placeholderChild);
        }
        return this._placeholder;
    }
    /**
     * add a new widget and returns it.
     *
     * Widget will be always placed even if result height is more than actual grid height.
     * You need to use `willItFit()` before calling addWidget for additional check.
     * See also `makeWidget()`.
     *
     * @example
     * let grid = GridStack.init();
     * grid.addWidget({w: 3, content: 'hello'});
     * grid.addWidget('<div class="grid-stack-item"><div class="grid-stack-item-content">hello</div></div>', {w: 3});
     *
     * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add
     * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget
     */
    addWidget(els, options) {
        // support legacy call for now ?
        if (arguments.length > 2) {
            console.warn('gridstack.ts: `addWidget(el, x, y, width...)` is deprecated. Use `addWidget({x, y, w, content, ...})`. It will be removed soon');
            // eslint-disable-next-line prefer-rest-params
            let a = arguments, i = 1, opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++],
                minW: a[i++], maxW: a[i++], minH: a[i++], maxH: a[i++], id: a[i++] };
            return this.addWidget(els, opt);
        }
        function isGridStackWidget(w) {
            return w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;
        }
        let el;
        if (typeof els === 'string') {
            let doc = document.implementation.createHTMLDocument();
            doc.body.innerHTML = els;
            el = doc.body.children[0];
        }
        else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {
            let content = els ? els.content || '' : '';
            options = els;
            let doc = document.implementation.createHTMLDocument();
            doc.body.innerHTML = `<div class="grid-stack-item ${this.opts.itemClass || ''}"><div class="grid-stack-item-content">${content}</div></div>`;
            el = doc.body.children[0];
        }
        else {
            el = els;
        }
        // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos
        // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz) before adding the node.
        // So make sure we load any DOM attributes that are not specified in passed in options (which override)
        let domAttr = this._readAttr(el);
        options = Object.assign({}, (options || {})); // make a copy before we modify in case caller re-uses it
        utils_1.Utils.defaults(options, domAttr);
        this.engine.prepareNode(options);
        this._writeAttr(el, options);
        if (this._insertNotAppend) {
            this.el.prepend(el);
        }
        else {
            this.el.appendChild(el);
        }
        // similar to makeWidget() that doesn't read attr again and worse re-create a new node and loose any _id
        this._prepareElement(el, true, options);
        this._updateContainerHeight();
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return el;
    }
    /**
     * saves the current layout returning a list of widgets for serialization (with default to save content), which might include any nested grids.
     * Optionally you can also save the grid with options itself, so you can call the new GridStack.addGrid()
     * to recreate everything from scratch. GridStackOptions.children would then contain the widget list.
     */
    save(saveContent = true, saveGridOpt = false) {
        // return copied nodes we can modify at will...
        let list = this.engine.save(saveContent);
        // check for HTML content as well
        if (saveContent) {
            list.forEach(n => {
                if (n.el && !n.subGrid) { // sub-grid are saved differently, not plain content
                    let sub = n.el.querySelector('.grid-stack-item-content');
                    n.content = sub ? sub.innerHTML : undefined;
                    if (!n.content)
                        delete n.content;
                    delete n.el;
                }
            });
        }
        // check if save entire grid options (needed for recursive) + children...
        if (saveGridOpt) {
            // check for nested grid
            list.forEach(n => {
                if (n.subGrid) {
                    n.subGrid = n.subGrid.save(saveContent, saveGridOpt);
                }
            });
            let o = Object.assign({}, this.opts);
            // delete default values that will be recreated on launch
            if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {
                o.margin = o.marginTop;
                delete o.marginTop;
                delete o.marginRight;
                delete o.marginBottom;
                delete o.marginLeft;
            }
            if (o.rtl === (this.el.style.direction === 'rtl')) {
                o.rtl = 'auto';
            }
            if (this._isAutoCellHeight) {
                o.cellHeight = 'auto';
            }
            utils_1.Utils.removeInternalAndSame(o, GridDefaults);
            o.children = list;
            return o;
        }
        return list;
    }
    /**
     * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.
     *
     * @param layout list of widgets definition to update/create
     * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving
     * the user control of insertion.
     *
     * @example
     * see http://gridstackjs.com/demo/serialization.html
     **/
    load(layout, addAndRemove = true) {
        let items = GridStack.Utils.sort(layout, -1, this._prevColumn || this.opts.column);
        this._insertNotAppend = true; // since create in reverse order...
        // if we're loading a layout into 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save
        // the original wanted layout so we can scale back up correctly #1471
        if (this._prevColumn && this._prevColumn !== this.opts.column && items.some(n => (n.x + n.w) > this.opts.column)) {
            this._ignoreLayoutsNodeChange = true; // skip layout update
            this.engine.cacheLayout(items, this._prevColumn, true);
        }
        let removed = [];
        this.batchUpdate();
        // see if any items are missing from new layout and need to be removed first
        if (addAndRemove) {
            let copyNodes = [...this.engine.nodes]; // don't loop through array you modify
            copyNodes.forEach(n => {
                let item = items.find(w => n.id === w.id);
                if (!item) {
                    if (typeof (addAndRemove) === 'function') {
                        addAndRemove(this, n, false);
                    }
                    else {
                        removed.push(n); // batch keep track
                        this.removeWidget(n.el, true, false);
                    }
                }
            });
        }
        // now add/update the widgets
        items.forEach(w => {
            let item = (w.id || w.id === 0) ? this.engine.nodes.find(n => n.id === w.id) : undefined;
            if (item) {
                this.update(item.el, w);
                if (w.subGrid && w.subGrid.children) { // update any sub grid as well
                    let sub = item.el.querySelector('.grid-stack');
                    if (sub && sub.gridstack) {
                        sub.gridstack.load(w.subGrid.children); // TODO: support updating grid options ?
                        this._insertNotAppend = true; // got reset by above call
                    }
                }
            }
            else if (addAndRemove) {
                if (typeof (addAndRemove) === 'function') {
                    w = addAndRemove(this, w, true).gridstackNode;
                }
                else {
                    w = this.addWidget(w).gridstackNode;
                }
                if (w.subGrid) { // see if there is a sub-grid to create too
                    let content = w.el.querySelector('.grid-stack-item-content');
                    w.subGrid = GridStack.addGrid(content, w.subGrid);
                }
            }
        });
        this.engine.removedNodes = removed;
        this.commit();
        // after commit, clear that flag
        delete this._ignoreLayoutsNodeChange;
        delete this._insertNotAppend;
        return this;
    }
    /**
     * Initializes batch updates. You will see no changes until `commit()` method is called.
     */
    batchUpdate() {
        this.engine.batchUpdate();
        return this;
    }
    /**
     * Gets current cell height.
     */
    getCellHeight(forcePixel = false) {
        if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&
            (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {
            return this.opts.cellHeight;
        }
        // else get first cell height
        // or do entire grid and # of rows ? (this.el.getBoundingClientRect().height) / parseInt(this.el.getAttribute('gs-current-row'))
        let el = this.el.querySelector('.' + this.opts.itemClass);
        let height = utils_1.Utils.toNumber(el.getAttribute('gs-h'));
        return Math.round(el.offsetHeight / height);
    }
    /**
     * Update current cell height - see `GridStackOptions.cellHeight` for format.
     * This method rebuilds an internal CSS style sheet.
     * Note: You can expect performance issues if call this method too often.
     *
     * @param val the cell height
     * @param update (Optional) if false, styles will not be updated
     *
     * @example
     * grid.cellHeight(grid.cellWidth() * 1.2);
     */
    cellHeight(val, update = true) {
        let data = utils_1.Utils.parseHeight(val);
        if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {
            return this;
        }
        this.opts.cellHeightUnit = data.unit;
        this.opts.cellHeight = data.h;
        if (update) {
            this._updateStyles(true, this.getRow()); // true = force re-create, for that # of rows
        }
        this._resizeNestedGrids(this.el);
        return this;
    }
    /**
     * Gets current cell width.
     */
    cellWidth() {
        // use parent width if we're 0 (no size yet)
        return (this.el.offsetWidth || this.el.parentElement.offsetWidth || window.innerWidth) / this.opts.column;
    }
    /**
     * Finishes batch updates. Updates DOM nodes. You must call it after batchUpdate.
     */
    commit() {
        this.engine.commit();
        this._triggerRemoveEvent();
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return this;
    }
    /** re-layout grid items to reclaim any empty space */
    compact() {
        this.engine.compact();
        this._triggerChangeEvent();
        return this;
    }
    /**
     * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,
     * as well as cache the original layout so you can revert back to previous positions without loss.
     * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],
     * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)
     * @param column - Integer > 0 (default 12).
     * @param layout specify the type of re-layout that will happen (position, size, etc...).
     * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column
     */
    column(column, layout = 'moveScale') {
        if (this.opts.column === column)
            return this;
        let oldColumn = this.opts.column;
        // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)
        // then remember the original columns so we can restore.
        if (column === 1) {
            this._prevColumn = oldColumn;
        }
        else {
            delete this._prevColumn;
        }
        this.el.classList.remove('grid-stack-' + oldColumn);
        this.el.classList.add('grid-stack-' + column);
        this.opts.column = this.engine.column = column;
        // update the items now - see if the dom order nodes should be passed instead (else default to current list)
        let domNodes;
        if (column === 1 && this.opts.oneColumnModeDomSort) {
            domNodes = [];
            this.getGridItems().forEach(el => {
                if (el.gridstackNode) {
                    domNodes.push(el.gridstackNode);
                }
            });
            if (!domNodes.length) {
                domNodes = undefined;
            }
        }
        this.engine.updateNodeWidths(oldColumn, column, domNodes, layout);
        // and trigger our event last...
        this._ignoreLayoutsNodeChange = true; // skip layout update
        this._triggerChangeEvent();
        delete this._ignoreLayoutsNodeChange;
        return this;
    }
    /**
     * get the number of columns in the grid (default 12)
     */
    getColumn() {
        return this.opts.column;
    }
    /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children */
    getGridItems() {
        return Array.from(this.el.children)
            .filter((el) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));
    }
    /**
     * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.
     * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).
     */
    destroy(removeDOM = true) {
        if (!this.el)
            return; // prevent multiple calls
        this._updateWindowResizeEvent(true);
        this.setStatic(true); // permanently removes DD
        if (!removeDOM) {
            this.removeAll(removeDOM);
            this.el.classList.remove(this.opts._styleSheetClass);
        }
        else {
            this.el.parentNode.removeChild(this.el);
        }
        this._removeStylesheet();
        delete this.opts._isNested;
        delete this.opts;
        delete this._placeholder;
        delete this.engine;
        delete this.el.gridstack; // remove circular dependency that would prevent a freeing
        delete this.el;
        return this;
    }
    /**
     * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)
     */
    float(val) {
        this.engine.float = val;
        this._triggerChangeEvent();
        return this;
    }
    /**
     * get the current float mode
     */
    getFloat() {
        return this.engine.float;
    }
    /**
     * Get the position of the cell under a pixel on screen.
     * @param position the position of the pixel to resolve in
     * absolute coordinates, as an object with top and left properties
     * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).
     * Useful when grid is within `position: relative` element
     *
     * Returns an object with properties `x` and `y` i.e. the column and row in the grid.
     */
    getCellFromPixel(position, useDocRelative = false) {
        let box = this.el.getBoundingClientRect();
        // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)
        let containerPos;
        if (useDocRelative) {
            containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };
            // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)
        }
        else {
            containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft };
            // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)
        }
        let relativeLeft = position.left - containerPos.left;
        let relativeTop = position.top - containerPos.top;
        let columnWidth = (box.width / this.opts.column);
        let rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));
        return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };
    }
    /** returns the current number of rows, which will be at least `minRow` if set */
    getRow() {
        return Math.max(this.engine.getRow(), this.opts.minRow);
    }
    /**
     * Checks if specified area is empty.
     * @param x the position x.
     * @param y the position y.
     * @param w the width of to check
     * @param h the height of to check
     */
    isAreaEmpty(x, y, w, h) {
        return this.engine.isAreaEmpty(x, y, w, h);
    }
    /**
     * If you add elements to your grid by hand, you have to tell gridstack afterwards to make them widgets.
     * If you want gridstack to add the elements for you, use `addWidget()` instead.
     * Makes the given element a widget and returns it.
     * @param els widget or single selector to convert.
     *
     * @example
     * let grid = GridStack.init();
     * grid.el.appendChild('<div id="gsi-1" gs-w="3"></div>');
     * grid.makeWidget('#gsi-1');
     */
    makeWidget(els) {
        let el = GridStack.getElement(els);
        this._prepareElement(el, true);
        this._updateContainerHeight();
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return el;
    }
    /**
     * Event handler that extracts our CustomEvent data out automatically for receiving custom
     * notifications (see doc for supported events)
     * @param name of the event (see possible values) or list of names space separated
     * @param callback function called with event and optional second/third param
     * (see README documentation for each signature).
     *
     * @example
     * grid.on('added', function(e, items) { log('added ', items)} );
     * or
     * grid.on('added removed change', function(e, items) { log(e.type, items)} );
     *
     * Note: in some cases it is the same as calling native handler and parsing the event.
     * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );
     *
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(name, callback) {
        // check for array of names being passed instead
        if (name.indexOf(' ') !== -1) {
            let names = name.split(' ');
            names.forEach(name => this.on(name, callback));
            return this;
        }
        if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {
            // native CustomEvent handlers - cash the generic handlers so we can easily remove
            let noData = (name === 'enable' || name === 'disable');
            if (noData) {
                this._gsEventHandler[name] = (event) => callback(event);
            }
            else {
                this._gsEventHandler[name] = (event) => callback(event, event.detail);
            }
            this.el.addEventListener(name, this._gsEventHandler[name]);
        }
        else if (name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resizestop' || name === 'dropped') {
            // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.
            // do same for start event to make it easier...
            this._gsEventHandler[name] = callback;
        }
        else {
            console.log('GridStack.on(' + name + ') event not supported, but you can still use $(".grid-stack").on(...) while jquery-ui is still used internally.');
        }
        return this;
    }
    /**
     * unsubscribe from the 'on' event below
     * @param name of the event (see possible values)
     */
    off(name) {
        // check for array of names being passed instead
        if (name.indexOf(' ') !== -1) {
            let names = name.split(' ');
            names.forEach(name => this.off(name));
            return this;
        }
        if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {
            // remove native CustomEvent handlers
            if (this._gsEventHandler[name]) {
                this.el.removeEventListener(name, this._gsEventHandler[name]);
            }
        }
        delete this._gsEventHandler[name];
        return this;
    }
    /**
     * Removes widget from the grid.
     * @param el  widget or selector to modify
     * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).
     * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).
     */
    removeWidget(els, removeDOM = true, triggerEvent = true) {
        GridStack.getElements(els).forEach(el => {
            if (el.parentElement !== this.el)
                return; // not our child!
            let node = el.gridstackNode;
            // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272
            if (!node) {
                node = this.engine.nodes.find(n => el === n.el);
            }
            if (!node)
                return;
            // remove our DOM data (circular link) and drag&drop permanently
            delete el.gridstackNode;
            gridstack_ddi_1.GridStackDDI.get().remove(el);
            this.engine.removeNode(node, removeDOM, triggerEvent);
            if (removeDOM && el.parentElement) {
                el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM
            }
        });
        if (triggerEvent) {
            this._triggerRemoveEvent();
            this._triggerChangeEvent();
        }
        return this;
    }
    /**
     * Removes all widgets from the grid.
     * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).
     */
    removeAll(removeDOM = true) {
        // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently
        this.engine.nodes.forEach(n => {
            delete n.el.gridstackNode;
            gridstack_ddi_1.GridStackDDI.get().remove(n.el);
        });
        this.engine.removeAll(removeDOM);
        this._triggerRemoveEvent();
        return this;
    }
    /**
     * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.
     * @param doAnimate if true the grid will animate.
     */
    setAnimation(doAnimate) {
        if (doAnimate) {
            this.el.classList.add('grid-stack-animate');
        }
        else {
            this.el.classList.remove('grid-stack-animate');
        }
        return this;
    }
    /**
     * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.
     * Also toggle the grid-stack-static class.
     * @param val if true the grid become static.
     */
    setStatic(val) {
        if (this.opts.staticGrid === val)
            return this;
        this.opts.staticGrid = val;
        this.engine.nodes.forEach(n => this._prepareDragDropByNode(n)); // either delete Drag&drop or initialize it
        this._setStaticClass();
        return this;
    }
    /**
     * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.
     * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)
     * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.
     */
    update(els, opt) {
        // support legacy call for now ?
        if (arguments.length > 2) {
            console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update({x, w, content, ...})`. It will be removed soon');
            // eslint-disable-next-line prefer-rest-params
            let a = arguments, i = 1;
            opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++] };
            return this.update(els, opt);
        }
        GridStack.getElements(els).forEach(el => {
            if (!el || !el.gridstackNode)
                return;
            let n = el.gridstackNode;
            let w = Object.assign({}, opt); // make a copy we can modify in case they re-use it or multiple items
            delete w.autoPosition;
            // move/resize widget if anything changed
            let keys = ['x', 'y', 'w', 'h'];
            let m;
            if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {
                m = {};
                keys.forEach(k => {
                    m[k] = (w[k] !== undefined) ? w[k] : n[k];
                    delete w[k];
                });
            }
            // for a move as well IFF there is any min/max fields set
            if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {
                m = {}; // will use node position but validate values
            }
            // check for content changing
            if (w.content) {
                let sub = el.querySelector('.grid-stack-item-content');
                if (sub && sub.innerHTML !== w.content) {
                    sub.innerHTML = w.content;
                }
                delete w.content;
            }
            // any remaining fields are assigned, but check for dragging changes, resize constrain
            let changed = false;
            let ddChanged = false;
            for (const key in w) {
                if (key[0] !== '_' && n[key] !== w[key]) {
                    n[key] = w[key];
                    changed = true;
                    ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));
                }
            }
            // finally move the widget
            if (m) {
                this.engine.cleanNodes();
                this.engine.beginUpdate(n);
                this.engine.moveNode(n, m.x, m.y, m.w, m.h);
                this._updateContainerHeight();
                this._triggerChangeEvent();
                this.engine.endUpdate();
            }
            if (changed) { // move will only update x,y,w,h so update the rest too
                this._writeAttr(el, n);
            }
            if (ddChanged) {
                this._prepareDragDropByNode(n);
            }
        });
        return this;
    }
    /**
     * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).
     * @param value margin value
     */
    margin(value) {
        let isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);
        // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)
        if (!isMultiValue) {
            let data = utils_1.Utils.parseHeight(value);
            if (this.opts.marginUnit === data.unit && this.opts.margin === data.h)
                return;
        }
        // re-use existing margin handling
        this.opts.margin = value;
        this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;
        this.initMargin();
        this._updateStyles(true); // true = force re-create
        return this;
    }
    /** returns current margin number value (undefined if 4 sides don't match) */
    getMargin() { return this.opts.margin; }
    /**
     * Returns true if the height of the grid will be less than the vertical
     * constraint. Always returns true if grid doesn't have height constraint.
     * @param node contains x,y,w,h,auto-position options
     *
     * @example
     * if (grid.willItFit(newWidget)) {
     *   grid.addWidget(newWidget);
     * } else {
     *   alert('Not enough free space to place the widget');
     * }
     */
    willItFit(node) {
        // support legacy call for now
        if (arguments.length > 1) {
            console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');
            // eslint-disable-next-line prefer-rest-params
            let a = arguments, i = 0, w = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };
            return this.willItFit(w);
        }
        return this.engine.willItFit(node);
    }
    /** @internal */
    _triggerChangeEvent() {
        if (this.engine.batchMode)
            return this;
        let elements = this.engine.getDirtyNodes(true); // verify they really changed
        if (elements && elements.length) {
            if (!this._ignoreLayoutsNodeChange) {
                this.engine.layoutsNodesChange(elements);
            }
            this._triggerEvent('change', elements);
        }
        this.engine.saveInitial(); // we called, now reset initial values & dirty flags
        return this;
    }
    /** @internal */
    _triggerAddEvent() {
        if (this.engine.batchMode)
            return this;
        if (this.engine.addedNodes && this.engine.addedNodes.length > 0) {
            if (!this._ignoreLayoutsNodeChange) {
                this.engine.layoutsNodesChange(this.engine.addedNodes);
            }
            // prevent added nodes from also triggering 'change' event (which is called next)
            this.engine.addedNodes.forEach(n => { delete n._dirty; });
            this._triggerEvent('added', this.engine.addedNodes);
            this.engine.addedNodes = [];
        }
        return this;
    }
    /** @internal */
    _triggerRemoveEvent() {
        if (this.engine.batchMode)
            return this;
        if (this.engine.removedNodes && this.engine.removedNodes.length > 0) {
            this._triggerEvent('removed', this.engine.removedNodes);
            this.engine.removedNodes = [];
        }
        return this;
    }
    /** @internal */
    _triggerEvent(name, data) {
        let event = data ? new CustomEvent(name, { bubbles: false, detail: data }) : new Event(name);
        this.el.dispatchEvent(event);
        return this;
    }
    /** @internal called to delete the current dynamic style sheet used for our layout */
    _removeStylesheet() {
        if (this._styles) {
            utils_1.Utils.removeStylesheet(this._styles._id);
            delete this._styles;
        }
        return this;
    }
    /** @internal updated/create the CSS styles for row based layout and initial margin setting */
    _updateStyles(forceUpdate = false, maxH) {
        // call to delete existing one if we change cellHeight / margin
        if (forceUpdate) {
            this._removeStylesheet();
        }
        this._updateContainerHeight();
        // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??
        if (this.opts.cellHeight === 0) {
            return this;
        }
        let cellHeight = this.opts.cellHeight;
        let cellHeightUnit = this.opts.cellHeightUnit;
        let prefix = `.${this.opts._styleSheetClass} > .${this.opts.itemClass}`;
        // create one as needed
        if (!this._styles) {
            let id = 'gridstack-style-' + (Math.random() * 100000).toFixed();
            // insert style to parent (instead of 'head' by default) to support WebComponent
            let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;
            this._styles = utils_1.Utils.createStylesheet(id, styleLocation);
            if (!this._styles)
                return this;
            this._styles._id = id;
            this._styles._max = 0;
            // these are done once only
            utils_1.Utils.addCSSRule(this._styles, prefix, `min-height: ${cellHeight}${cellHeightUnit}`);
            // content margins
            let top = this.opts.marginTop + this.opts.marginUnit;
            let bottom = this.opts.marginBottom + this.opts.marginUnit;
            let right = this.opts.marginRight + this.opts.marginUnit;
            let left = this.opts.marginLeft + this.opts.marginUnit;
            let content = `${prefix} > .grid-stack-item-content`;
            let placeholder = `.${this.opts._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;
            utils_1.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
            utils_1.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
            // resize handles offset (to match margin)
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);
        }
        // now update the height specific fields
        maxH = maxH || this._styles._max;
        if (maxH > this._styles._max) {
            let getHeight = (rows) => (cellHeight * rows) + cellHeightUnit;
            for (let i = this._styles._max + 1; i <= maxH; i++) { // start at 1
                let h = getHeight(i);
                utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-y="${i - 1}"]`, `top: ${getHeight(i - 1)}`); // start at 0
                utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-h="${i}"]`, `height: ${h}`);
                utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-min-h="${i}"]`, `min-height: ${h}`);
                utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-max-h="${i}"]`, `max-height: ${h}`);
            }
            this._styles._max = maxH;
        }
        return this;
    }
    /** @internal */
    _updateContainerHeight() {
        if (!this.engine || this.engine.batchMode)
            return this;
        let row = this.getRow(); // checks for minRow already
        // check for css min height
        let cssMinHeight = parseInt(getComputedStyle(this.el)['min-height']);
        if (cssMinHeight > 0) {
            let minRow = Math.round(cssMinHeight / this.getCellHeight(true));
            if (row < minRow) {
                row = minRow;
            }
        }
        this.el.setAttribute('gs-current-row', String(row));
        if (row === 0) {
            this.el.style.removeProperty('height');
            return this;
        }
        let cellHeight = this.opts.cellHeight;
        let unit = this.opts.cellHeightUnit;
        if (!cellHeight)
            return this;
        this.el.style.height = row * cellHeight + unit;
        return this;
    }
    /** called to resize children nested grids when we/item resizes */
    _resizeNestedGrids(target) {
        target.querySelectorAll('.grid-stack').forEach((el) => {
            if (el.gridstack) {
                el.gridstack.onParentResize();
            }
        });
        return this;
    }
    /** @internal */
    _prepareElement(el, triggerAddEvent = false, node) {
        if (!node) {
            el.classList.add(this.opts.itemClass);
            node = this._readAttr(el);
        }
        el.gridstackNode = node;
        node.el = el;
        node.grid = this;
        let copy = Object.assign({}, node);
        node = this.engine.addNode(node, triggerAddEvent);
        // write node attr back in case there was collision or we have to fix bad values during addNode()
        if (!utils_1.Utils.same(node, copy)) {
            this._writeAttr(el, node);
        }
        this._prepareDragDropByNode(node);
        return this;
    }
    /** @internal call to write x,y,w,h attributes back to element */
    _writePosAttr(el, x, y, w, h) {
        if (x !== undefined && x !== null) {
            el.setAttribute('gs-x', String(x));
        }
        if (y !== undefined && y !== null) {
            el.setAttribute('gs-y', String(y));
        }
        if (w) {
            el.setAttribute('gs-w', String(w));
        }
        if (h) {
            el.setAttribute('gs-h', String(h));
        }
        return this;
    }
    /** @internal call to write any default attributes back to element */
    _writeAttr(el, node) {
        if (!node)
            return this;
        this._writePosAttr(el, node.x, node.y, node.w, node.h);
        let attrs /*: GridStackWidget but strings */ = {
            autoPosition: 'gs-auto-position',
            minW: 'gs-min-w',
            minH: 'gs-min-h',
            maxW: 'gs-max-w',
            maxH: 'gs-max-h',
            noResize: 'gs-no-resize',
            noMove: 'gs-no-move',
            locked: 'gs-locked',
            id: 'gs-id',
            resizeHandles: 'gs-resize-handles'
        };
        for (const key in attrs) {
            if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway
                el.setAttribute(attrs[key], String(node[key]));
            }
            else {
                el.removeAttribute(attrs[key]);
            }
        }
        return this;
    }
    /** @internal call to read any default attributes from element */
    _readAttr(el) {
        let node = {};
        node.x = utils_1.Utils.toNumber(el.getAttribute('gs-x'));
        node.y = utils_1.Utils.toNumber(el.getAttribute('gs-y'));
        node.w = utils_1.Utils.toNumber(el.getAttribute('gs-w'));
        node.h = utils_1.Utils.toNumber(el.getAttribute('gs-h'));
        node.maxW = utils_1.Utils.toNumber(el.getAttribute('gs-max-w'));
        node.minW = utils_1.Utils.toNumber(el.getAttribute('gs-min-w'));
        node.maxH = utils_1.Utils.toNumber(el.getAttribute('gs-max-h'));
        node.minH = utils_1.Utils.toNumber(el.getAttribute('gs-min-h'));
        node.autoPosition = utils_1.Utils.toBool(el.getAttribute('gs-auto-position'));
        node.noResize = utils_1.Utils.toBool(el.getAttribute('gs-no-resize'));
        node.noMove = utils_1.Utils.toBool(el.getAttribute('gs-no-move'));
        node.locked = utils_1.Utils.toBool(el.getAttribute('gs-locked'));
        node.resizeHandles = el.getAttribute('gs-resize-handles');
        node.id = el.getAttribute('gs-id');
        // remove any key not found (null or false which is default)
        for (const key in node) {
            if (!node.hasOwnProperty(key))
                return;
            if (!node[key] && node[key] !== 0) { // 0 can be valid value (x,y only really)
                delete node[key];
            }
        }
        return node;
    }
    /** @internal */
    _setStaticClass() {
        let classes = ['grid-stack-static'];
        if (this.opts.staticGrid) {
            this.el.classList.add(...classes);
            this.el.setAttribute('gs-static', 'true');
        }
        else {
            this.el.classList.remove(...classes);
            this.el.removeAttribute('gs-static');
        }
        return this;
    }
    /**
     * called when we are being resized by the window - check if the one Column Mode needs to be turned on/off
     * and remember the prev columns we used, as well as check for auto cell height (square)
     */
    onParentResize() {
        if (!this.el || !this.el.clientWidth)
            return; // return if we're gone or no size yet (will get called again)
        // make the cells content (minus margin) square again
        if (this._isAutoCellHeight) {
            utils_1.Utils.throttle(() => {
                let marginDiff = -this.opts.marginRight - this.opts.marginLeft
                    + this.opts.marginTop + this.opts.marginBottom;
                this.cellHeight(this.cellWidth() + marginDiff);
            }, 100);
        }
        if (!this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.minWidth) {
            if (this._oneColumnMode)
                return this;
            this._oneColumnMode = true;
            this.column(1);
            this._resizeNestedGrids(this.el);
        }
        else {
            if (!this._oneColumnMode)
                return this;
            delete this._oneColumnMode;
            this.column(this._prevColumn);
            this._resizeNestedGrids(this.el);
        }
        return this;
    }
    /** add or remove the window size event handler */
    _updateWindowResizeEvent(forceRemove = false) {
        const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode);
        // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)
        if (workTodo && !forceRemove && !this.opts._isNested && !this._windowResizeBind) {
            this._windowResizeBind = this.onParentResize.bind(this); // so we can properly remove later
            window.addEventListener('resize', this._windowResizeBind);
            this.onParentResize(); // initially call it once...
        }
        else if ((forceRemove || !workTodo) && this._windowResizeBind) {
            window.removeEventListener('resize', this._windowResizeBind);
            delete this._windowResizeBind; // remove link to us so we can free
        }
        return this;
    }
    /** @internal convert a potential selector into actual element */
    static getElement(els = '.grid-stack-item') { return utils_1.Utils.getElement(els); }
    /** @internal */
    static getElements(els = '.grid-stack-item') { return utils_1.Utils.getElements(els); }
    /** @internal */
    static getGridElement(els) { return GridStack.getElement(els); }
    /** @internal */
    static getGridElements(els) { return utils_1.Utils.getElements(els); }
    /** @internal initialize margin top/bottom/left/right and units */
    initMargin() {
        let data;
        let margin = 0;
        // support passing multiple values like CSS (ex: '5px 10px 0 20px')
        let margins = [];
        if (typeof this.opts.margin === 'string') {
            margins = this.opts.margin.split(' ');
        }
        if (margins.length === 2) { // top/bot, left/right like CSS
            this.opts.marginTop = this.opts.marginBottom = margins[0];
            this.opts.marginLeft = this.opts.marginRight = margins[1];
        }
        else if (margins.length === 4) { // Clockwise like CSS
            this.opts.marginTop = margins[0];
            this.opts.marginRight = margins[1];
            this.opts.marginBottom = margins[2];
            this.opts.marginLeft = margins[3];
        }
        else {
            data = utils_1.Utils.parseHeight(this.opts.margin);
            this.opts.marginUnit = data.unit;
            margin = this.opts.margin = data.h;
        }
        // see if top/bottom/left/right need to be set as well
        if (this.opts.marginTop === undefined) {
            this.opts.marginTop = margin;
        }
        else {
            data = utils_1.Utils.parseHeight(this.opts.marginTop);
            this.opts.marginTop = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginBottom === undefined) {
            this.opts.marginBottom = margin;
        }
        else {
            data = utils_1.Utils.parseHeight(this.opts.marginBottom);
            this.opts.marginBottom = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginRight === undefined) {
            this.opts.marginRight = margin;
        }
        else {
            data = utils_1.Utils.parseHeight(this.opts.marginRight);
            this.opts.marginRight = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginLeft === undefined) {
            this.opts.marginLeft = margin;
        }
        else {
            data = utils_1.Utils.parseHeight(this.opts.marginLeft);
            this.opts.marginLeft = data.h;
            delete this.opts.margin;
        }
        this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...
        if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {
            this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()
        }
        return this;
    }
    /*
     * drag&drop empty stubs that will be implemented in gridstack-dd.ts for non static grid
     * so we don't incur the load unless needed.
     * NOTE: had to make those methods public in order to define them else as
     *   GridStack.prototype._setupAcceptWidget = function()
     * maybe there is a better way ????
     */
    /* eslint-disable @typescript-eslint/no-unused-vars */
    /**
     * Enables/Disables moving. No-op for static grids.
     * @param els widget or selector to modify.
     * @param val if true widget will be draggable.
     */
    movable(els, val) { return this; }
    /**
     * Enables/Disables resizing. No-op for static grids.
     * @param els  widget or selector to modify
     * @param val  if true widget will be resizable.
     */
    resizable(els, val) { return this; }
    /**
     * Temporarily disables widgets moving/resizing.
     * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.
     * Note: no-op for static grid
     * This is a shortcut for:
     * @example
     *  grid.enableMove(false);
     *  grid.enableResize(false);
     */
    disable() { return this; }
    /**
     * Re-enables widgets moving/resizing - see disable().
     * Note: no-op for static grid.
     * This is a shortcut for:
     * @example
     *  grid.enableMove(true);
     *  grid.enableResize(true);
     */
    enable() { return this; }
    /**
     * Enables/disables widget moving. No-op for static grids.
     *
     * @param doEnable
     * @param includeNewWidgets will force new widgets to be draggable as per
     * doEnable`s value by changing the disableDrag grid option (default: true).
     */
    enableMove(doEnable, includeNewWidgets = true) { return this; }
    /**
     * Enables/disables widget resizing. No-op for static grids.
     * @param doEnable
     * @param includeNewWidgets will force new widgets to be draggable as per
     * doEnable`s value by changing the disableResize grid option (default: true).
     */
    enableResize(doEnable, includeNewWidgets = true) { return this; }
    /** @internal called to add drag over support to support widgets */
    _setupAcceptWidget() { return this; }
    /** @internal called to setup a trash drop zone if the user specifies it */
    _setupRemoveDrop() { return this; }
    /** @internal */
    _setupRemovingTimeout(el) { return this; }
    /** @internal */
    _clearRemovingTimeout(el) { return this; }
    /** @internal call to setup dragging in from the outside (say toolbar), with options */
    _setupDragIn() { return this; }
    /** @internal prepares the element for drag&drop **/
    _prepareDragDropByNode(node) { return this; }
    // 2.x API that just calls the new and better update() - keep those around for backward compat only...
    /** @internal */
    locked(els, locked) { return this.update(els, { locked }); }
    /** @internal */
    maxWidth(els, maxW) { return this.update(els, { maxW }); }
    /** @internal */
    minWidth(els, minW) { return this.update(els, { minW }); }
    /** @internal */
    maxHeight(els, maxH) { return this.update(els, { maxH }); }
    /** @internal */
    minHeight(els, minH) { return this.update(els, { minH }); }
    /** @internal */
    move(els, x, y) { return this.update(els, { x, y }); }
    /** @internal */
    resize(els, w, h) { return this.update(els, { w, h }); }
}
exports.GridStack = GridStack;
/** scoping so users can call GridStack.Utils.sort() for example */
GridStack.Utils = utils_1.Utils;
/** scoping so users can call new GridStack.Engine(12) for example */
GridStack.Engine = gridstack_engine_1.GridStackEngine;
//# sourceMappingURL=gridstack.js.map

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// gridstack-engine.ts 3.2.0 @preserve
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * https://gridstackjs.com/
 * (c) 2014-2020 Alain Dumesny, Dylan Weiss, Pavel Reznikov
 * gridstack.js may be freely distributed under the MIT license.
*/
const utils_1 = __webpack_require__(79);
/**
 * Defines the GridStack engine that does most no DOM grid manipulation.
 * See GridStack methods and vars for descriptions.
 *
 * NOTE: values should not be modified directly - call the main GridStack API instead
 */
class GridStackEngine {
    constructor(opts = {}) {
        this.addedNodes = [];
        this.removedNodes = [];
        /** @internal legacy method renames */
        this.getGridHeight = utils_1.obsolete(this, GridStackEngine.prototype.getRow, 'getGridHeight', 'getRow', 'v1.0.0');
        this.column = opts.column || 12;
        this.onChange = opts.onChange;
        this._float = opts.float;
        this.maxRow = opts.maxRow;
        this.nodes = opts.nodes || [];
    }
    batchUpdate() {
        if (this.batchMode)
            return this;
        this.batchMode = true;
        this._prevFloat = this._float;
        this._float = true; // let things go anywhere for now... commit() will restore and possibly reposition
        return this;
    }
    commit() {
        if (!this.batchMode)
            return this;
        this.batchMode = false;
        this._float = this._prevFloat;
        delete this._prevFloat;
        this._packNodes();
        this._notify();
        return this;
    }
    /** @internal */
    _fixCollisions(node) {
        this._sortNodes(-1);
        let nn = node;
        let hasLocked = Boolean(this.nodes.find(n => n.locked));
        if (!this.float && !hasLocked) {
            nn = { x: 0, y: node.y, w: this.column, h: node.h };
        }
        while (true) {
            let collisionNode = this.collide(node, nn);
            if (!collisionNode)
                return this;
            let moved;
            if (collisionNode.locked) {
                // if colliding with a locked item, move ourself instead
                moved = this.moveNode(node, node.x, collisionNode.y + collisionNode.h, node.w, node.h, true);
            }
            else {
                moved = this.moveNode(collisionNode, collisionNode.x, node.y + node.h, collisionNode.w, collisionNode.h, true);
            }
            if (!moved)
                return this; // break inf loop if we couldn't move after all (ex: maxRow, fixed)
        }
    }
    /** return any intercepted node with the given area, skipping the passed in node (usually self) */
    collide(node, area = node) {
        return this.nodes.find(n => n !== node && utils_1.Utils.isIntercepted(n, area));
    }
    isAreaEmpty(x, y, w, h) {
        let nn = { x: x || 0, y: y || 0, w: w || 1, h: h || 1 };
        return !this.collide(nn);
    }
    /** re-layout grid items to reclaim any empty space */
    compact() {
        if (this.nodes.length === 0)
            return this;
        this.batchUpdate();
        this._sortNodes();
        let copyNodes = this.nodes;
        this.nodes = []; // pretend we have no nodes to conflict layout to start with...
        copyNodes.forEach(node => {
            if (!node.noMove && !node.locked) {
                node.autoPosition = true;
            }
            this.addNode(node, false); // 'false' for add event trigger
            node._dirty = true; // force attr update
        });
        this.commit();
        return this;
    }
    /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */
    set float(val) {
        if (this._float === val)
            return;
        this._float = val || false;
        if (!val) {
            this._packNodes();
            this._notify();
        }
    }
    /** float getter method */
    get float() { return this._float || false; }
    /** @internal */
    _sortNodes(dir) {
        this.nodes = utils_1.Utils.sort(this.nodes, dir, this.column);
        return this;
    }
    /** @internal */
    _packNodes() {
        this._sortNodes();
        if (this.float) {
            this.nodes.forEach((n, i) => {
                if (n._updating || n._packY === undefined || n.y === n._packY) {
                    return this;
                }
                let newY = n.y;
                while (newY >= n._packY) {
                    let box = { x: n.x, y: newY, w: n.w, h: n.h };
                    let collisionNode = this.nodes.slice(0, i).find(bn => utils_1.Utils.isIntercepted(box, bn));
                    if (!collisionNode) {
                        n._dirty = true;
                        n.y = newY;
                    }
                    --newY;
                }
            });
        }
        else {
            this.nodes.forEach((n, i) => {
                if (n.locked)
                    return this;
                while (n.y > 0) {
                    let newY = n.y - 1;
                    let canBeMoved = i === 0;
                    let box = { x: n.x, y: newY, w: n.w, h: n.h };
                    if (i > 0) {
                        let collisionNode = this.nodes.slice(0, i).find(bn => utils_1.Utils.isIntercepted(box, bn));
                        canBeMoved = !collisionNode;
                    }
                    if (!canBeMoved) {
                        break;
                    }
                    // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions
                    // and move items back. The user 'change' CB should detect changes from the original
                    // starting position instead.
                    n._dirty = (n.y !== newY);
                    n.y = newY;
                }
            });
        }
        return this;
    }
    /**
     * given a random node, makes sure it's coordinates/values are valid in the current grid
     * @param node to adjust
     * @param resizing if out of bound, resize down or move into the grid to fit ?
     */
    prepareNode(node, resizing) {
        node = node || {};
        node._id = node._id || GridStackEngine._idSeq++;
        // if we're missing position, have the grid position us automatically (before we set them to 0,0)
        if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {
            node.autoPosition = true;
        }
        // assign defaults for missing required fields
        let defaults = { x: 0, y: 0, w: 1, h: 1 };
        utils_1.Utils.defaults(node, defaults);
        if (!node.autoPosition) {
            delete node.autoPosition;
        }
        if (!node.noResize) {
            delete node.noResize;
        }
        if (!node.noMove) {
            delete node.noMove;
        }
        // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)
        if (typeof node.x == 'string') {
            node.x = Number(node.x);
        }
        if (typeof node.y == 'string') {
            node.y = Number(node.y);
        }
        if (typeof node.w == 'string') {
            node.w = Number(node.w);
        }
        if (typeof node.h == 'string') {
            node.h = Number(node.h);
        }
        if (isNaN(node.x)) {
            node.x = defaults.x;
            node.autoPosition = true;
        }
        if (isNaN(node.y)) {
            node.y = defaults.y;
            node.autoPosition = true;
        }
        if (isNaN(node.w)) {
            node.w = defaults.w;
        }
        if (isNaN(node.h)) {
            node.h = defaults.h;
        }
        if (node.maxW) {
            node.w = Math.min(node.w, node.maxW);
        }
        if (node.maxH) {
            node.h = Math.min(node.h, node.maxH);
        }
        if (node.minW) {
            node.w = Math.max(node.w, node.minW);
        }
        if (node.minH) {
            node.h = Math.max(node.h, node.minH);
        }
        if (node.w > this.column) {
            node.w = this.column;
        }
        else if (node.w < 1) {
            node.w = 1;
        }
        if (this.maxRow && node.h > this.maxRow) {
            node.h = this.maxRow;
        }
        else if (node.h < 1) {
            node.h = 1;
        }
        if (node.x < 0) {
            node.x = 0;
        }
        if (node.y < 0) {
            node.y = 0;
        }
        if (node.x + node.w > this.column) {
            if (resizing) {
                node.w = this.column - node.x;
            }
            else {
                node.x = this.column - node.w;
            }
        }
        if (this.maxRow && node.y + node.h > this.maxRow) {
            if (resizing) {
                node.h = this.maxRow - node.y;
            }
            else {
                node.y = this.maxRow - node.h;
            }
        }
        return node;
    }
    getDirtyNodes(verify) {
        // compare original X,Y,W,H (or entire node?) instead as _dirty can be a temporary state
        if (verify) {
            let dirtNodes = [];
            this.nodes.forEach(n => {
                if (n._dirty) {
                    if (n.y === n._origY && n.x === n._origX && n.w === n._origW && n.h === n._origH) {
                        delete n._dirty;
                    }
                    else {
                        dirtNodes.push(n);
                    }
                }
            });
            return dirtNodes;
        }
        return this.nodes.filter(n => n._dirty);
    }
    /** @internal */
    _notify(nodes, removeDOM = true) {
        if (this.batchMode)
            return this;
        nodes = (nodes === undefined ? [] : (Array.isArray(nodes) ? nodes : [nodes]));
        let dirtyNodes = nodes.concat(this.getDirtyNodes());
        if (this.onChange) {
            this.onChange(dirtyNodes, removeDOM);
        }
        return this;
    }
    cleanNodes() {
        if (this.batchMode)
            return this;
        this.nodes.forEach(n => { delete n._dirty; });
        return this;
    }
    addNode(node, triggerAddEvent = false) {
        node = this.prepareNode(node);
        if (node.autoPosition) {
            this._sortNodes();
            for (let i = 0;; ++i) {
                let x = i % this.column;
                let y = Math.floor(i / this.column);
                if (x + node.w > this.column) {
                    continue;
                }
                let box = { x, y, w: node.w, h: node.h };
                if (!this.nodes.find(n => utils_1.Utils.isIntercepted(box, n))) {
                    node.x = x;
                    node.y = y;
                    delete node.autoPosition; // found our slot
                    break;
                }
            }
        }
        this.nodes.push(node);
        if (triggerAddEvent) {
            this.addedNodes.push(node);
        }
        this._fixCollisions(node);
        this._packNodes();
        this._notify();
        return node;
    }
    removeNode(node, removeDOM = true, triggerEvent = false) {
        if (triggerEvent) { // we wait until final drop to manually track removed items (rather than during drag)
            this.removedNodes.push(node);
        }
        node._id = null; // hint that node is being removed
        // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.
        this.nodes = this.nodes.filter(n => n !== node);
        if (!this.float) {
            this._packNodes();
        }
        this._notify(node, removeDOM);
        return this;
    }
    removeAll(removeDOM = true) {
        delete this._layouts;
        if (this.nodes.length === 0)
            return this;
        if (removeDOM) {
            this.nodes.forEach(n => { n._id = null; }); // hint that node is being removed
        }
        this.removedNodes = this.nodes;
        this.nodes = [];
        this._notify(this.removedNodes, removeDOM);
        return this;
    }
    canMoveNode(node, x, y, w, h) {
        if (!this.isNodeChangedPosition(node, x, y, w, h)) {
            return false;
        }
        let hasLocked = this.nodes.some(n => n.locked);
        if (!this.maxRow && !hasLocked) {
            return true;
        }
        let clonedNode;
        let clone = new GridStackEngine({
            column: this.column,
            float: this.float,
            nodes: this.nodes.map(n => {
                if (n === node) {
                    clonedNode = Object.assign({}, n);
                    return clonedNode;
                }
                return Object.assign({}, n);
            })
        });
        if (!clonedNode)
            return true;
        clone.moveNode(clonedNode, x, y, w, h);
        let canMove = true;
        if (hasLocked) {
            canMove = !clone.nodes.some(n => n.locked && n._dirty && n !== clonedNode);
        }
        if (this.maxRow && canMove) {
            canMove = (clone.getRow() <= this.maxRow);
        }
        return canMove;
    }
    /** return true if can fit in grid height constrain only (always true if no maxRow) */
    willItFit(node) {
        if (!this.maxRow)
            return true;
        let clone = new GridStackEngine({
            column: this.column,
            float: this.float,
            nodes: this.nodes.map(n => { return Object.assign({}, n); })
        });
        clone.addNode(node);
        return clone.getRow() <= this.maxRow;
    }
    /** return true if the passed in node (x,y) is being dragged outside of the grid, and not added to bottom */
    isOutside(x, y, node) {
        // simple outside boundaries
        if (x < 0 || x >= this.column || y < 0)
            return true;
        if (this.maxRow)
            return (y >= this.maxRow);
        else if (this.float)
            return false; // infinite grow with no maxRow
        // see if dragging PAST bottom (row+1)
        let row = this.getRow();
        if (y < row || y === 0)
            return false;
        if (y > row)
            return true;
        // else check to see if we can add that item to the bottom... (y == row)
        if (!node._temporaryRemoved) {
            let clone = new GridStackEngine({
                column: this.column,
                float: this.float,
                nodes: this.nodes.filter(n => n !== node).map(n => { return Object.assign({}, n); })
            });
            let nn = Object.assign(Object.assign({}, node), { x, y });
            clone.addNode(nn);
            return nn.y === node.y && nn.x === node.x; // didn't actually move, so last row was a drag out and not a new place...
        }
        return node._temporaryRemoved; // if still outside so we don't flicker back & forth
    }
    isNodeChangedPosition(node, x, y, w, h) {
        if (typeof x !== 'number') {
            x = node.x;
        }
        if (typeof y !== 'number') {
            y = node.y;
        }
        if (typeof w !== 'number') {
            w = node.w;
        }
        if (typeof h !== 'number') {
            h = node.h;
        }
        if (node.maxW) {
            w = Math.min(w, node.maxW);
        }
        if (node.maxH) {
            h = Math.min(h, node.maxH);
        }
        if (node.minW) {
            w = Math.max(w, node.minW);
        }
        if (node.minH) {
            h = Math.max(h, node.minH);
        }
        if (node.x === x && node.y === y && node.w === w && node.h === h) {
            return false;
        }
        return true;
    }
    moveNode(node, x, y, w, h, noPack) {
        if (node.locked)
            return null;
        if (typeof x !== 'number') {
            x = node.x;
        }
        if (typeof y !== 'number') {
            y = node.y;
        }
        if (typeof w !== 'number') {
            w = node.w;
        }
        if (typeof h !== 'number') {
            h = node.h;
        }
        // constrain the passed in values and check if we're still changing our node
        let resizing = (node.w !== w || node.h !== h);
        let nn = { x, y, w, h, maxW: node.maxW, maxH: node.maxH, minW: node.minW, minH: node.minH };
        nn = this.prepareNode(nn, resizing);
        if (node.x === nn.x && node.y === nn.y && node.w === nn.w && node.h === nn.h) {
            return null;
        }
        node._dirty = true;
        node.x = node._lastTriedX = nn.x;
        node.y = node._lastTriedY = nn.y;
        node.w = node._lastTriedW = nn.w;
        node.h = node._lastTriedH = nn.h;
        this._fixCollisions(node);
        if (!noPack) {
            this._packNodes();
            this._notify();
        }
        return node;
    }
    getRow() {
        return this.nodes.reduce((memo, n) => Math.max(memo, n.y + n.h), 0);
    }
    beginUpdate(node) {
        if (node._updating)
            return this;
        node._updating = true;
        this.nodes.forEach(n => { n._packY = n.y; });
        return this;
    }
    endUpdate() {
        let n = this.nodes.find(n => n._updating);
        if (n) {
            delete n._updating;
            this.nodes.forEach(n => { delete n._packY; });
        }
        return this;
    }
    /** saves the current layout returning a list of widgets for serialization */
    save(saveElement = true) {
        let widgets = [];
        utils_1.Utils.sort(this.nodes);
        this.nodes.forEach(n => {
            let w = {};
            for (let key in n) {
                if (key[0] !== '_' && n[key] !== null && n[key] !== undefined)
                    w[key] = n[key];
            }
            // delete other internals
            if (!saveElement)
                delete w.el;
            delete w.grid;
            // delete default values (will be re-created on read)
            if (!w.autoPosition)
                delete w.autoPosition;
            if (!w.noResize)
                delete w.noResize;
            if (!w.noMove)
                delete w.noMove;
            if (!w.locked)
                delete w.locked;
            widgets.push(w);
        });
        return widgets;
    }
    /** @internal called whenever a node is added or moved - updates the cached layouts */
    layoutsNodesChange(nodes) {
        if (!this._layouts || this._ignoreLayoutsNodeChange)
            return this;
        // remove smaller layouts - we will re-generate those on the fly... larger ones need to update
        this._layouts.forEach((layout, column) => {
            if (!layout || column === this.column)
                return this;
            if (column < this.column) {
                this._layouts[column] = undefined;
            }
            else {
                // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.
                // Note: we don't need to check against out of bound scaling/moving as that will be done when using those cache values.
                nodes.forEach(node => {
                    let n = layout.find(l => l._id === node._id);
                    if (!n)
                        return this; // no cache for new nodes. Will use those values.
                    let ratio = column / this.column;
                    // Y changed, push down same amount
                    // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)
                    if (node.y !== node._origY) {
                        n.y += (node.y - node._origY);
                    }
                    // X changed, scale from new position
                    if (node.x !== node._origX) {
                        n.x = Math.round(node.x * ratio);
                    }
                    // width changed, scale from new width
                    if (node.w !== node._origW) {
                        n.w = Math.round(node.w * ratio);
                    }
                    // ...height always carries over from cache
                });
            }
        });
        return this;
    }
    /**
     * @internal Called to scale the widget width & position up/down based on the column change.
     * Note we store previous layouts (especially original ones) to make it possible to go
     * from say 12 -> 1 -> 12 and get back to where we were.
     *
     * @param oldColumn previous number of columns
     * @param column  new column number
     * @param nodes different sorted list (ex: DOM order) instead of current list
     * @param layout specify the type of re-layout that will happen (position, size, etc...).
     * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column
     */
    updateNodeWidths(oldColumn, column, nodes, layout = 'moveScale') {
        if (!this.nodes.length || oldColumn === column)
            return this;
        // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data
        this.cacheLayout(this.nodes, oldColumn);
        // if we're going to 1 column and using DOM order rather than default sorting, then generate that layout
        if (column === 1 && nodes && nodes.length) {
            let top = 0;
            nodes.forEach(n => {
                n.x = 0;
                n.w = 1;
                n.y = Math.max(n.y, top);
                top = n.y + n.h;
            });
        }
        else {
            nodes = utils_1.Utils.sort(this.nodes, -1, oldColumn); // current column reverse sorting so we can insert last to front (limit collision)
        }
        // see if we have cached previous layout.
        let cacheNodes = this._layouts[column] || [];
        // if not AND we are going up in size start with the largest layout as down-scaling is more accurate
        let lastIndex = this._layouts.length - 1;
        if (cacheNodes.length === 0 && column > oldColumn && column < lastIndex) {
            cacheNodes = this._layouts[lastIndex] || [];
            if (cacheNodes.length) {
                // pretend we came from that larger column by assigning those values as starting point
                oldColumn = lastIndex;
                cacheNodes.forEach(cacheNode => {
                    let j = nodes.findIndex(n => n._id === cacheNode._id);
                    if (j !== -1) {
                        // still current, use cache info positions
                        nodes[j].x = cacheNode.x;
                        nodes[j].y = cacheNode.y;
                        nodes[j].w = cacheNode.w;
                    }
                });
                cacheNodes = []; // we still don't have new column cached data... will generate from larger one.
            }
        }
        // if we found cache re-use those nodes that are still current
        let newNodes = [];
        cacheNodes.forEach(cacheNode => {
            let j = nodes.findIndex(n => n._id === cacheNode._id);
            if (j !== -1) {
                // still current, use cache info positions
                nodes[j].x = cacheNode.x;
                nodes[j].y = cacheNode.y;
                nodes[j].w = cacheNode.w;
                newNodes.push(nodes[j]);
                nodes.splice(j, 1);
            }
        });
        // ...and add any extra non-cached ones
        if (nodes.length) {
            if (typeof layout === 'function') {
                layout(column, oldColumn, newNodes, nodes);
            }
            else {
                let ratio = column / oldColumn;
                let move = (layout === 'move' || layout === 'moveScale');
                let scale = (layout === 'scale' || layout === 'moveScale');
                nodes.forEach(node => {
                    node.x = (column === 1 ? 0 : (move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1)));
                    node.w = ((column === 1 || oldColumn === 1) ? 1 :
                        scale ? (Math.round(node.w * ratio) || 1) : (Math.min(node.w, column)));
                    newNodes.push(node);
                });
                nodes = [];
            }
        }
        // finally re-layout them in reverse order (to get correct placement)
        newNodes = utils_1.Utils.sort(newNodes, -1, column);
        this._ignoreLayoutsNodeChange = true;
        this.batchUpdate();
        this.nodes = []; // pretend we have no nodes to start with (we use same structures) to simplify layout
        newNodes.forEach(node => {
            this.addNode(node, false); // 'false' for add event trigger
            node._dirty = true; // force attr update
        }, this);
        this.commit();
        delete this._ignoreLayoutsNodeChange;
        return this;
    }
    /** @internal called to save initial position/size */
    saveInitial() {
        this.nodes.forEach(n => {
            n._origX = n.x;
            n._origY = n.y;
            n._origW = n.w;
            n._origH = n.h;
            delete n._dirty;
        });
        return this;
    }
    /**
     * call to cache the given layout internally to the given location so we can restore back when column changes size
     * @param nodes list of nodes
     * @param column corresponding column index to save it under
     * @param clear if true, will force other caches to be removed (default false)
     */
    cacheLayout(nodes, column, clear = false) {
        let copy = [];
        nodes.forEach((n, i) => {
            n._id = n._id || GridStackEngine._idSeq++; // make sure we have an id in case this is new layout, else re-use id already set
            copy[i] = { x: n.x, y: n.y, w: n.w, _id: n._id }; // only thing we change is x,y,w and id to find it back
        });
        this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick
        this._layouts[column] = copy;
        return this;
    }
    /** called to remove all internal values */
    cleanupNode(node) {
        for (let prop in node) {
            if (prop[0] === '_')
                delete node[prop];
        }
        return this;
    }
}
exports.GridStackEngine = GridStackEngine;
/** @internal */
GridStackEngine._idSeq = 1;
//# sourceMappingURL=gridstack-engine.js.map

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// utils.ts 3.2.0 @preserve
Object.defineProperty(exports, "__esModule", ({ value: true }));
/** checks for obsolete method names */
// eslint-disable-next-line
function obsolete(self, f, oldName, newName, rev) {
    let wrapper = (...args) => {
        console.warn('gridstack.js: Function `' + oldName + '` is deprecated in ' + rev + ' and has been replaced ' +
            'with `' + newName + '`. It will be **completely** removed in v1.0');
        return f.apply(self, args);
    };
    wrapper.prototype = f.prototype;
    return wrapper;
}
exports.obsolete = obsolete;
/** checks for obsolete grid options (can be used for any fields, but msg is about options) */
function obsoleteOpts(opts, oldName, newName, rev) {
    if (opts[oldName] !== undefined) {
        opts[newName] = opts[oldName];
        console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + ' and has been replaced with `' +
            newName + '`. It will be **completely** removed in v1.0');
    }
}
exports.obsoleteOpts = obsoleteOpts;
/** checks for obsolete grid options which are gone */
function obsoleteOptsDel(opts, oldName, rev, info) {
    if (opts[oldName] !== undefined) {
        console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + info);
    }
}
exports.obsoleteOptsDel = obsoleteOptsDel;
/** checks for obsolete Jquery element attributes */
function obsoleteAttr(el, oldName, newName, rev) {
    let oldAttr = el.getAttribute(oldName);
    if (oldAttr !== null) {
        el.setAttribute(newName, oldAttr);
        console.warn('gridstack.js: attribute `' + oldName + '`=' + oldAttr + ' is deprecated on this object in ' + rev + ' and has been replaced with `' +
            newName + '`. It will be **completely** removed in v1.0');
    }
}
exports.obsoleteAttr = obsoleteAttr;
/**
 * Utility methods
 */
class Utils {
    /** convert a potential selector into actual list of html elements */
    static getElements(els) {
        if (typeof els === 'string') {
            let list = document.querySelectorAll(els);
            if (!list.length && els[0] !== '.' && els[0] !== '#') {
                list = document.querySelectorAll('.' + els);
                if (!list.length) {
                    list = document.querySelectorAll('#' + els);
                }
            }
            return Array.from(list);
        }
        return [els];
    }
    /** convert a potential selector into actual single element */
    static getElement(els) {
        if (typeof els === 'string') {
            if (!els.length)
                return null;
            if (els[0] === '#') {
                return document.getElementById(els.substring(1));
            }
            if (els[0] === '.' || els[0] === '[') {
                return document.querySelector(els);
            }
            // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS
            if (!isNaN(+els[0])) { // start with digit
                return document.getElementById(els);
            }
            // finally try string, then id then class
            let el = document.querySelector(els);
            if (!el) {
                el = document.getElementById(els);
            }
            if (!el) {
                el = document.querySelector('.' + els);
            }
            return el;
        }
        return els;
    }
    /** returns true if a and b overlap */
    static isIntercepted(a, b) {
        return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }
    /**
     * Sorts array of nodes
     * @param nodes array to sort
     * @param dir 1 for asc, -1 for desc (optional)
     * @param width width of the grid. If undefined the width will be calculated automatically (optional).
     **/
    static sort(nodes, dir, column) {
        if (!column) {
            let widths = nodes.map(n => n.x + n.w);
            column = Math.max(...widths);
        }
        if (dir === -1)
            return nodes.sort((a, b) => (b.x + b.y * column) - (a.x + a.y * column));
        else
            return nodes.sort((b, a) => (b.x + b.y * column) - (a.x + a.y * column));
    }
    /**
     * creates a style sheet with style id under given parent
     * @param id will set the 'gs-style-id' attribute to that id
     * @param parent to insert the stylesheet as first child,
     * if none supplied it will be appended to the document head instead.
     */
    static createStylesheet(id, parent) {
        let style = document.createElement('style');
        style.setAttribute('type', 'text/css');
        style.setAttribute('gs-style-id', id);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (style.styleSheet) { // TODO: only CSSImportRule have that and different beast ??
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            style.styleSheet.cssText = '';
        }
        else {
            style.appendChild(document.createTextNode('')); // WebKit hack
        }
        if (!parent) {
            // default to head
            parent = document.getElementsByTagName('head')[0];
            parent.appendChild(style);
        }
        else {
            parent.insertBefore(style, parent.firstChild);
        }
        return style.sheet;
    }
    /** removed the given stylesheet id */
    static removeStylesheet(id) {
        let el = document.querySelector('STYLE[gs-style-id=' + id + ']');
        if (el && el.parentNode)
            el.remove();
    }
    /** inserts a CSS rule */
    static addCSSRule(sheet, selector, rules) {
        if (typeof sheet.addRule === 'function') {
            sheet.addRule(selector, rules);
        }
        else if (typeof sheet.insertRule === 'function') {
            sheet.insertRule(`${selector}{${rules}}`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static toBool(v) {
        if (typeof v === 'boolean') {
            return v;
        }
        if (typeof v === 'string') {
            v = v.toLowerCase();
            return !(v === '' || v === 'no' || v === 'false' || v === '0');
        }
        return Boolean(v);
    }
    static toNumber(value) {
        return (value === null || value.length === 0) ? undefined : Number(value);
    }
    static parseHeight(val) {
        let h;
        let unit = 'px';
        if (typeof val === 'string') {
            let match = val.match(/^(-[0-9]+\.[0-9]+|[0-9]*\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);
            if (!match) {
                throw new Error('Invalid height');
            }
            unit = match[2] || 'px';
            h = parseFloat(match[1]);
        }
        else {
            h = val;
        }
        return { h, unit };
    }
    /** copies unset fields in target to use the given default sources values */
    // eslint-disable-next-line
    static defaults(target, ...sources) {
        sources.forEach(source => {
            for (const key in source) {
                if (!source.hasOwnProperty(key))
                    return;
                if (target[key] === null || target[key] === undefined) {
                    target[key] = source[key];
                }
                else if (typeof source[key] === 'object' && typeof target[key] === 'object') {
                    // property is an object, recursively add it's field over... #1373
                    this.defaults(target[key], source[key]);
                }
            }
        });
        return target;
    }
    /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */
    static same(a, b) {
        if (typeof a !== 'object')
            return a == b;
        if (typeof a !== typeof b)
            return false;
        // else we have object, check just 1 level deep for being same things...
        if (Object.keys(a).length !== Object.keys(b).length)
            return false;
        for (const key in a) {
            if (a[key] !== b[key])
                return false;
        }
        return true;
    }
    /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */
    static removeInternalAndSame(a, b) {
        if (typeof a !== 'object' || typeof b !== 'object')
            return;
        for (let key in a) {
            let val = a[key];
            if (val && typeof val === 'object') {
                for (let i in val) {
                    if (val[i] === b[key][i] || i[0] === '_') {
                        delete val[i];
                    }
                }
                if (!Object.keys(val).length) {
                    delete a[key];
                }
            }
            else if (val === b[key] || key[0] === '_') {
                delete a[key];
            }
        }
    }
    /** return the closest parent matching the given class */
    static closestByClass(el, name) {
        while (el = el.parentElement) {
            if (el.classList.contains(name))
                return el;
        }
        return null;
    }
    /** delay calling the given function by certain amount of time */
    static throttle(callback, delay) {
        let isWaiting = false;
        return (...args) => {
            if (!isWaiting) {
                callback.apply(this, args);
                isWaiting = true;
                setTimeout(() => isWaiting = false, delay);
            }
        };
    }
    static removePositioningStyles(el) {
        let style = el.style;
        if (style.position) {
            style.removeProperty('position');
        }
        if (style.left) {
            style.removeProperty('left');
        }
        if (style.top) {
            style.removeProperty('top');
        }
        if (style.width) {
            style.removeProperty('width');
        }
        if (style.height) {
            style.removeProperty('height');
        }
    }
    /** @internal */
    static getScrollParent(el) {
        if (el === null)
            return document.documentElement;
        const style = getComputedStyle(el);
        const overflowRegex = /(auto|scroll)/;
        if (overflowRegex.test(style.overflow + style.overflowY)) {
            return el;
        }
        else {
            return this.getScrollParent(el.parentElement);
        }
    }
    /** @internal */
    static updateScrollPosition(el, position, distance) {
        // is widget in view?
        let rect = el.getBoundingClientRect();
        let innerHeightOrClientHeight = (window.innerHeight || document.documentElement.clientHeight);
        if (rect.top < 0 ||
            rect.bottom > innerHeightOrClientHeight) {
            // set scrollTop of first parent that scrolls
            // if parent is larger than el, set as low as possible
            // to get entire widget on screen
            let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;
            let offsetDiffUp = rect.top;
            let scrollEl = this.getScrollParent(el);
            if (scrollEl !== null) {
                let prevScroll = scrollEl.scrollTop;
                if (rect.top < 0 && distance < 0) {
                    // moving up
                    if (el.offsetHeight > innerHeightOrClientHeight) {
                        scrollEl.scrollTop += distance;
                    }
                    else {
                        scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;
                    }
                }
                else if (distance > 0) {
                    // moving down
                    if (el.offsetHeight > innerHeightOrClientHeight) {
                        scrollEl.scrollTop += distance;
                    }
                    else {
                        scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;
                    }
                }
                // move widget y by amount scrolled
                position.top += scrollEl.scrollTop - prevScroll;
            }
        }
    }
    /**
     * @internal Function used to scroll the page.
     *
     * @param event `MouseEvent` that triggers the resize
     * @param el `HTMLElement` that's being resized
     * @param distance Distance from the V edges to start scrolling
     */
    static updateScrollResize(event, el, distance) {
        const scrollEl = this.getScrollParent(el);
        const height = scrollEl.clientHeight;
        const top = event.clientY < distance;
        const bottom = event.clientY > height - distance;
        if (top) {
            // This also can be done with a timeout to keep scrolling while the mouse is
            // in the scrolling zone. (will have smoother behavior)
            scrollEl.scrollBy({ behavior: 'smooth', top: event.clientY - distance });
        }
        else if (bottom) {
            scrollEl.scrollBy({ behavior: 'smooth', top: distance - (height - event.clientY) });
        }
    }
}
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// gridstack-ddi.ts 3.2.0 @preserve
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Abstract Partial Interface API for drag'n'drop plugin - look at GridStackDD and HTML5 / Jquery implementation versions
 */
class GridStackDDI {
    /** call this method to register your plugin instead of the default no-op one */
    static registerPlugin(pluginClass) {
        GridStackDDI.ddi = new pluginClass();
        return GridStackDDI.ddi;
    }
    /** get the current registered plugin to use */
    static get() {
        return GridStackDDI.ddi || GridStackDDI.registerPlugin(GridStackDDI);
    }
    /** removes any drag&drop present (called during destroy) */
    remove(el) {
        return this; // no-op for static grids
    }
}
exports.GridStackDDI = GridStackDDI;
//# sourceMappingURL=gridstack-ddi.js.map

/***/ }),
/* 81 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.LineEditorExt = void 0;
    //This class will allow to use the lineEditor outside the config app.
    class LineEditorExt {
        constructor() {
            // super();
        }
        ;
        showDialog(title, height, input, onOk, width, showUserAndGroupsSelectWithDialog) {
            let that = this;
            let ok;
            let d = $.Deferred();
            globals_1.app.dlgForm.html("");
            globals_1.app.dlgForm.addClass("dlg-v-scroll");
            globals_1.app.dlgForm.removeClass("dlg-no-scroll");
            let ctrls = [];
            globals_1.app.dlgForm.dialog({
                autoOpen: true,
                title: title,
                height: height,
                width: width ? width : 720,
                modal: true,
                close: function () { },
                open: function () {
                    $.each(input, function (idx, inp) {
                        var _a;
                        let canEdit = !inp.readonly;
                        let inlineHelp = inp.explanation ? inp.explanation : "";
                        let dataCy = (_a = inp.id) !== null && _a !== void 0 ? _a : inp.help.replace(/\s/g, "_");
                        let ctrl = $(`<div data-cy='${dataCy}'>`).appendTo(globals_1.app.dlgForm);
                        if (inp.type == "textline" || inp.type == "id" || inp.type == "id_" || inp.type == "uppercase" || inp.type == "number") {
                            ctrl.plainText({
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: { rows: inp.multiple ? 5 : 1, allowResize: false, inlineHelp: inlineHelp },
                                fieldValue: inp.value,
                            });
                        }
                        else if (inp.type == "json") {
                            ctrl.plainText({
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: {
                                    code: 'json',
                                    height: 200,
                                    autoFormat: true,
                                    showJSONFormat: true,
                                    hideFullscreen: true,
                                    rows: inp.multiple ? 5 : 1, allowResize: false, inlineHelp: inlineHelp
                                },
                                fieldValue: inp.value,
                            });
                        }
                        else if (inp.type == "color") {
                            ctrl.colorPicker({
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: { allowResize: false, inlineHelp: inlineHelp },
                                fieldValue: inp.value,
                            });
                        }
                        else if (inp.type == "richtext") {
                            ctrl.richText({
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: { height: 200, requiresContent: inp.required, tiny: true },
                                fieldValue: inp.value,
                            });
                        }
                        else if (inp.type == "readonly") {
                            ctrl.plainText({
                                canEdit: false,
                                help: inp.help,
                                valueChanged: function () { },
                                parameter: { rows: 1, allowResize: false, inlineHelp: inlineHelp },
                                fieldValue: inp.value
                            });
                        }
                        else if (inp.type == "boolean") {
                            ctrl.checkBox({
                                canEdit: canEdit,
                                help: inp.help,
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                fieldValue: inp.value,
                                parameter: { inlineHelp: inlineHelp }
                            });
                        }
                        else if (inp.type == "table") {
                            ctrl.tableCtrl({
                                canEdit: canEdit,
                                help: inp.help,
                                valueChanged: function () { },
                                fieldValue: inp.value,
                                parameter: {
                                    canBeModified: inp.noEdit ? false : true,
                                    create: inp.noEdit ? false : true,
                                    showLineNumbers: false,
                                    readonly_allowfocus: false,
                                    columns: inp.columns,
                                    inlineHelp: inlineHelp
                                }
                            });
                        }
                        else if (inp.type == "select") {
                            ctrl.mxDropdown({
                                controlState: globals_1.ControlState.FormEdit,
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                fieldValue: inp.value,
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: {
                                    placeholder: 'select',
                                    maxItems: inp.multiple ? 100 : 1,
                                    options: inp.options,
                                    groups: inp.groups ? inp.groups : [],
                                    create: inp.noEdit ? false : true,
                                    sort: false,
                                    inlineHelp: inlineHelp
                                },
                            });
                        }
                        else if (inp.type == "folderselect") {
                            let showOnly = [], showNot = [];
                            if (inp.extraOptions) {
                                if (inp.extraOptions.showOnly && inp.extraOptions.showOnly.length > 0) {
                                    showOnly = inp.extraOptions.showOnly;
                                }
                                if (inp.extraOptions.showNot && inp.extraOptions.showNot.length > 0) {
                                    showNot = inp.extraOptions.showNot;
                                }
                            }
                            // This a hack to make sure that we will parse the ref to create link.
                            addHighlightLink("", globals_1.globalMatrix.matrixBaseUrl + "/");
                            ctrl.itemSelection({
                                controlState: globals_1.ControlState.FormEdit,
                                canEdit: canEdit,
                                help: inp.help + (inp.required ? "<sup>*</sup>" : ""),
                                fieldValue: inp.value,
                                valueChanged: function () { that.setEnabled(ok, ctrls, input); },
                                parameter: {
                                    crossProject: true,
                                    crossProjectAsList: false,
                                    prefix: "Selected folder : ",
                                    buttonName: "Select folder",
                                    singleFolderOnly: true,
                                    showOnly: showOnly,
                                    showNot: showNot,
                                },
                            });
                        }
                        else if (inp.type == "multiselect") {
                            ctrl.multiSelect({
                                afterSelect: function (values) {
                                    var _a;
                                    let selection = (_a = ctrl.data("selected")) !== null && _a !== void 0 ? _a : [];
                                    values.forEach((value) => {
                                        if (!selection.includes(value))
                                            selection.push(value);
                                    });
                                    ctrl.data("selected", selection);
                                    that.setEnabled(ok, ctrls, input);
                                },
                                afterDeselect: function (values) {
                                    var _a;
                                    let selection = (_a = ctrl.data("selected")) !== null && _a !== void 0 ? _a : [];
                                    values.forEach((value) => {
                                        let i = selection.indexOf(value);
                                        selection = selection.splice(i, 1);
                                    });
                                    ctrl.data("selected", selection);
                                }
                            });
                            if (inp.options) {
                                inp.options.forEach((opt) => {
                                    ctrl.multiSelect('addOption', { value: opt.id, text: opt.label });
                                });
                                let selection = inp.value ? inp.value.split(",") : [];
                                ctrl.multiSelect("select", selection);
                            }
                            $("<div class='baseControlHelp' style='margin-top:10px'>" + inp.help + (inp.required ? "<sup>*</sup>" : "") + "</div>").insertBefore(ctrl);
                        }
                        else if (inp.type == "userAndGroupSelect") {
                            ctrl.data("selected", inp.value ? inp.value.split(",") : []);
                            if (showUserAndGroupsSelectWithDialog) {
                                showUserAndGroupsSelectWithDialog(ctrl, true, true, inp.help + (inp.required ? "<sup>*</sup>" : ""), "select users or groups", inp.value ? inp.value.split(",") : [], inp.help, (selected) => {
                                    ctrl.data("selected", selected);
                                    that.setEnabled(ok, ctrls, input);
                                });
                            }
                        }
                        ctrls.push(ctrl);
                        if (inp.hide) {
                            ctrl.hide();
                        }
                    });
                },
                resizeStop: function (event, ui) { },
                buttons: [{
                        text: 'Ok',
                        class: 'btnDoIt',
                        click: function () {
                            let updates = that.getValue(ctrls, input);
                            let issues = [];
                            $.each(updates, function (idx, update) {
                                if (update.type == "id" && !update.value.match(/^[a-z0-9]+$/i)) {
                                    issues.push(input[idx].help + " is an identifier. It cannot contain anything but letters and digits");
                                }
                                if (update.type == "id_" && !update.value.match(/^[a-z0-9_\-]+$/i)) {
                                    issues.push(input[idx].help + " is an identifier. It cannot contain anything but letters, digits, dash and underscore");
                                }
                                if (update.type == "id_" && !update.value.substr(0, 1).match(/^[a-z]+$/i)) {
                                    issues.push(input[idx].help + " is an identifier. It must start with a letter");
                                }
                                if (update.type == "number" && !update.value.match(/^[0-9]+$/)) {
                                    issues.push(input[idx].help + " is a number. It cannot contain anything but digits");
                                }
                                if (update.type == "uppercase" && !update.value.match(/^[A-Z]+$/)) {
                                    issues.push(input[idx].help + " is a short id. It cannot contain nothing but uppercase letters");
                                }
                            });
                            if (issues.length) {
                                alert(issues.join("\n"));
                            }
                            else if (onOk(updates)) {
                                globals_1.app.dlgForm.dialog("close");
                                d.resolve();
                            }
                        }
                    }, {
                        text: 'Cancel',
                        class: 'btnCancelIt',
                        click: function () {
                            d.reject();
                            globals_1.app.dlgForm.dialog("close");
                        }
                    }]
            });
            // get Ok button
            ok = $(".btnDoIt", globals_1.app.dlgForm.parent());
            // check if at least one shown input is required
            let showsRequired = false;
            $.each(input, function (idx, inp) {
                if (inp.required && !inp.hide) {
                    showsRequired = true;
                }
            });
            if (showsRequired) {
                ok.parent().prepend("* required ");
            }
            this.setEnabled(ok, ctrls, input);
            return d;
        }
        static mapToKeys(results) {
            let update = [];
            $.each(results, function (idx, uwk) {
                update[uwk.key] = uwk;
            });
            return update;
        }
        setEnabled(btn, ctrls, input) {
            if (btn) {
                matrixlib_1.ml.UI.setEnabled(btn, this.isEnabled(this.getValue(ctrls, input)));
            }
        }
        getValue(ctrls, input) {
            let updates = matrixlib_1.ml.JSON.clone(input);
            $.each(ctrls, function (idx, ctrl) {
                if (ctrl.getController) {
                    updates[idx].value = ctrl.getController().getValue();
                }
                else {
                    updates[idx].value = ctrl.data("selected") ? ctrl.data("selected").join(",") : "";
                }
            });
            return updates;
        }
        isEnabled(status) {
            let hasRequired = false;
            let hasAllRequired = true;
            $.each(status, function (idx, input) {
                if (input.required && !input.hide) {
                    hasRequired = true;
                    if (!input.value) {
                        hasAllRequired = false;
                    }
                }
            });
            return !hasRequired || hasAllRequired;
        }
    }
    exports.LineEditorExt = LineEditorExt;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 82 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.widgetPluginManager = exports.WidgetPluginManager = exports.renderMode = exports.widgetRenderEvent = exports.IWidgetScope = void 0;
    ;
    var widgetRenderEvent;
    (function (widgetRenderEvent) {
        widgetRenderEvent[widgetRenderEvent["load"] = 0] = "load";
        widgetRenderEvent[widgetRenderEvent["scroll"] = 1] = "scroll";
        widgetRenderEvent[widgetRenderEvent["click"] = 2] = "click";
    })(widgetRenderEvent || (widgetRenderEvent = {}));
    exports.widgetRenderEvent = widgetRenderEvent;
    var renderMode;
    (function (renderMode) {
        renderMode[renderMode["placeholder"] = 0] = "placeholder";
        renderMode[renderMode["minimized"] = 1] = "minimized";
        renderMode[renderMode["maximized"] = 2] = "maximized";
    })(renderMode || (renderMode = {}));
    exports.renderMode = renderMode;
    var IWidgetScope;
    (function (IWidgetScope) {
        IWidgetScope[IWidgetScope["admin"] = 0] = "admin";
        IWidgetScope[IWidgetScope["user"] = 1] = "user";
        IWidgetScope[IWidgetScope["superAdmin"] = 2] = "superAdmin";
    })(IWidgetScope || (IWidgetScope = {}));
    exports.IWidgetScope = IWidgetScope;
    class WidgetPluginManager {
        constructor() {
            this.pluginList = {};
            this.loadedWidgets = {};
        }
        registerPlugin(plugin) {
            this.pluginList[plugin.pluginName()] = (plugin);
        }
        addLoadedWidget(key, widget) {
            let id = key;
            this.loadedWidgets[id] = widget;
        }
        unLoadAllWidgets() {
            for (let key in this.loadedWidgets) {
                if (this.loadedWidgets[key].unload)
                    this.loadedWidgets[key].unload();
            }
            this.loadedWidgets = {};
        }
        removeLoadedWidget(displayedWidget) {
            let foundWidget = this.loadedWidgets[displayedWidget.id];
            if (foundWidget) {
                if (foundWidget.unload) {
                    foundWidget.unload();
                }
                delete this.loadedWidgets[displayedWidget.id];
            }
        }
    }
    exports.WidgetPluginManager = WidgetPluginManager;
    var widgetPluginManager = new WidgetPluginManager(); // plugin manager 
    exports.widgetPluginManager = widgetPluginManager;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 83 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(82)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, WidgetPluginManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.WidgetSettingsManager = void 0;
    class WidgetSettingsManager {
        static getHiddenWidgets() {
            let list = [];
            let index = globals_1.matrixSession.serverConfig.currentUserSettings.findIndex(o => { return o.key == "hiddenWidget"; });
            if (index >= 0) {
                try {
                    let templist = JSON.parse(globals_1.matrixSession.serverConfig.currentUserSettings[index].value);
                    list = templist.filter(function (item, pos) {
                        return templist.indexOf(item) == pos;
                    });
                }
                catch (error) {
                }
            }
            return list;
        }
        static hide(widget) {
            let d = $.Deferred();
            let list = [];
            let index = globals_1.matrixSession.serverConfig.currentUserSettings.findIndex(o => { return o.key == "hiddenWidget"; });
            if (index >= 0) {
                let templist = JSON.parse(globals_1.matrixSession.serverConfig.currentUserSettings[index].value);
                templist.push(widget.id);
                //Remove duplicates
                list = templist.filter(function (item, pos) {
                    return templist.indexOf(item) == pos;
                });
                globals_1.matrixSession.serverConfig.currentUserSettings[index].value = JSON.stringify(list);
            }
            else {
                list.push(widget.id);
                globals_1.matrixSession.serverConfig.currentUserSettings.push({
                    key: "hiddenWidget",
                    value: JSON.stringify(list), secret: false
                });
            }
            let data = {
                key: "hiddenWidget",
                value: JSON.stringify(list),
                reason: "adding widget Setting"
            };
            return globals_1.restConnection.postServer("user/" + globals_1.matrixSession.getUser() + "/setting", data);
        }
        static unhide(displayedWidget) {
            let index = globals_1.matrixSession.serverConfig.currentUserSettings.findIndex(o => { return o.key == "hiddenWidget"; });
            let list = WidgetSettingsManager.getHiddenWidgets().filter((w => { return w != displayedWidget.id; }));
            if (index >= 0)
                globals_1.matrixSession.serverConfig.currentUserSettings[index].value = JSON.stringify(list);
            let data = {
                key: "hiddenWidget",
                value: JSON.stringify(list),
                reason: "adding widget Setting"
            };
            return globals_1.restConnection.postServer("user/" + globals_1.matrixSession.getUser() + "/setting", data);
        }
        static updatePosition(widget) {
            let d = $.Deferred();
            if (widget.parameters.users != undefined && widget.parameters.users.length > 0 && widget.createdBy != globals_1.matrixSession.getUser()) {
                // Save new position to localstorage
                localStorage.setItem(widget.id, JSON.stringify(widget.parameters.position));
                d.resolve();
                return d;
            }
            else {
                return WidgetSettingsManager.setSettings(widget);
            }
        }
        static setSettings(widget) {
            let d = $.Deferred();
            if (widget.parameters.users != undefined && widget.parameters.users.length > 0) {
                if (globals_1.matrixSession.isAdmin()) {
                    let index = globals_1.matrixSession.serverConfig.customerSettings.findIndex(o => { return o.key == widget.id; });
                    if (index >= 0)
                        globals_1.matrixSession.serverConfig.customerSettings[index].value = JSON.stringify(widget);
                    else
                        globals_1.matrixSession.serverConfig.customerSettings.push({ key: widget.id, value: JSON.stringify(widget), secret: false });
                    return globals_1.app.setSettingCustomerJSON(widget.id, widget);
                }
            }
            else {
                let index = globals_1.matrixSession.serverConfig.currentUserSettings.findIndex(o => { return o.key == widget.id; });
                if (index >= 0)
                    globals_1.matrixSession.serverConfig.currentUserSettings[index].value = JSON.stringify(widget);
                else
                    globals_1.matrixSession.serverConfig.currentUserSettings.push({ key: widget.id, value: JSON.stringify(widget), secret: false });
                if (widget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.user) {
                    let data = {
                        key: widget.id,
                        value: JSON.stringify(widget),
                        reason: "adding widget Setting"
                    };
                    return globals_1.restConnection.postServer("user/" + globals_1.matrixSession.getUser() + "/setting", data);
                }
            }
            d.fail();
            return d;
        }
        static deleteDeleteWidgetSettings(widget) {
            let d = $.Deferred();
            if (widget.parameters.users != undefined && widget.parameters.users.length > 0) {
                if (globals_1.matrixSession.isAdmin()) {
                    globals_1.matrixSession.serverConfig.customerSettings = globals_1.matrixSession.serverConfig.customerSettings.filter((value, index, arr) => { return value.key != widget.id; });
                    return globals_1.app.setSettingCustomerJSON(widget.id, "");
                }
            }
            else {
                if (widget.parameters.canBeAddedOrDeletedBy == undefined || widget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.user) {
                    globals_1.matrixSession.serverConfig.currentUserSettings = globals_1.matrixSession.serverConfig.currentUserSettings.filter((value, index, arr) => { return value.key != widget.id; });
                    let data = {
                        key: widget.id,
                        value: "",
                        reason: "removing widget Setting"
                    };
                    return globals_1.restConnection.postServer("user/" + globals_1.matrixSession.getUser() + "/setting", data);
                }
            }
            d.fail();
            return d;
        }
        static canBeEdited(displayedWidget, configurator) {
            if (displayedWidget.parameters.users != undefined && displayedWidget.parameters.users.length > 0) {
                if (globals_1.matrixSession.isAdmin())
                    return true;
                else
                    return false;
            }
            return (displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.user
                || (displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.admin && globals_1.matrixSession.isAdmin())
                || (displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.superAdmin && globals_1.matrixSession.isSuperAdmin()))
                && (configurator != undefined && configurator.length > 0);
        }
        static canBeDeleted(displayedWidget) {
            if (displayedWidget.parameters.users != undefined && displayedWidget.parameters.users.length > 0) {
                if (globals_1.matrixSession.isAdmin())
                    return true;
                else
                    return false;
            }
            return (displayedWidget.parameters.canBeAddedOrDeletedBy == undefined || displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.user
                || (displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.admin && globals_1.matrixSession.isAdmin())
                || (displayedWidget.parameters.canBeAddedOrDeletedBy == WidgetPluginManager_1.IWidgetScope.superAdmin && globals_1.matrixSession.isSuperAdmin()));
        }
    }
    exports.WidgetSettingsManager = WidgetSettingsManager;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 84 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(6), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, globals_1, matrixlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.URLTools = void 0;
    class URLTools {
        getParameterByName(url, name) {
            var match = RegExp('[?&]' + name + '=([^&]*)').exec(url);
            return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
        }
        parseUrl(url) {
            let result = {
                project: "",
                item: "",
                params: {}
            };
            // remove https://server.matrixreq.com/
            let noserver = url.replace(globals_1.globalMatrix.matrixBaseUrl + "/", "").replace(globals_1.globalMatrix.matrixBaseUrl, "").split("?");
            if (noserver[0]) {
                let pi = noserver[0].split("/");
                result.project = pi[0];
                result.item = pi.length > 1 ? pi[1] : "";
            }
            if (noserver.length > 1) {
                let params = noserver[1].split("&");
                $.each(params, function (pidx, param) {
                    let firstE = param.indexOf("=");
                    if (firstE == -1) {
                        matrixlib_1.ml.Logger.log("warning", "invalid url parameter '" + param + "'");
                        return;
                    }
                    result.params[param.substr(0, firstE)] = decodeURIComponent(param.substr(firstE + 1).replace(/\+/g, ' '));
                });
            }
            return result;
        }
    }
    exports.URLTools = URLTools;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 85 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.XPathTools = void 0;
    class XPathTools {
        constructor() {
        }
        get(node) {
            var comp, comps = [];
            var xpath = '';
            var getPos = function (element) {
                var position = 1, curNode;
                if (element.nodeType == Node.ATTRIBUTE_NODE) {
                    return null;
                }
                for (curNode = element.previousSibling; curNode; curNode = curNode.previousSibling) {
                    if (curNode.nodeName == element.nodeName) {
                        ++position;
                    }
                }
                return position;
            };
            var element = node[0];
            if (element instanceof Document) {
                return '/';
            }
            for (; element && !(element instanceof Document); element = element.nodeType == Node.ATTRIBUTE_NODE ? element.ownerElement : element.parentNode) {
                comp = comps[comps.length] = {};
                switch (element.nodeType) {
                    case Node.TEXT_NODE:
                        comp.name = 'text()';
                        break;
                    case Node.ATTRIBUTE_NODE:
                        comp.name = '@' + element.nodeName;
                        break;
                    case Node.PROCESSING_INSTRUCTION_NODE:
                        comp.name = 'processing-instruction()';
                        break;
                    case Node.COMMENT_NODE:
                        comp.name = 'comment()';
                        break;
                    case Node.ELEMENT_NODE:
                        comp.name = element.nodeName;
                        break;
                }
                comp.position = getPos(element);
            }
            for (var i = comps.length - 1; i >= 0; i--) {
                comp = comps[i];
                xpath += '/' + comp.name.toLowerCase();
                if (comp.position !== null) {
                    xpath += '[' + comp.position + ']';
                }
            }
            return xpath;
        }
        ;
        hardCopy(element) {
            // note this is used only by selenium top copy the attributes of a doc
            $.each(element.find("select"), function (idx, select) {
                var selected = $(select).val();
                $(select).find('option').prop('selected', false);
                $(select).find('option').removeAttr('selected');
                $(select).find("option[value='" + selected + "']").prop('selected', true);
                $(select).find("option[value='" + selected + "']").attr('selected', 'selected');
            });
            $.each(element.find("input[type='checkbox']"), function (idx, cb) {
                $(cb).is(":checked") ? $(cb).attr("checked", "checked") : $(cb).removeAttr("checked");
            });
            return element.html();
        }
    }
    exports.XPathTools = XPathTools;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(185), __webpack_require__(12), __webpack_require__(187), __webpack_require__(1), __webpack_require__(1), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, isomorphic_fetch_1, businesslogic_1, rest_api_1, matrixlib_1, matrixlib_2, SimpleItemTools_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.CreateConsoleAPI = exports.StandaloneMatrixAPI = void 0;
    isomorphic_fetch_1 = __importDefault(isomorphic_fetch_1);
    function CreateConsoleAPI(config, baseRestUrl, baseMatrixUrl) {
        let session = new class {
            getCsrfCookie() { return ""; }
            setComment(comment) { this.comment = comment; }
            getComment() { return this.comment; }
            setProject(project) { this.project = project; }
            getProject() { return this.project; }
        };
        const logger = new matrixlib_1.LoggerTools();
        const json = new matrixlib_2.JSONTools(logger);
        const itemTools = new SimpleItemTools_1.SimpleItemTools();
        const itemConfig = new businesslogic_1.ItemConfiguration(logger, json);
        return new StandaloneMatrixAPI(config, session, itemConfig, baseRestUrl, baseMatrixUrl, logger, json, itemTools);
    }
    exports.CreateConsoleAPI = CreateConsoleAPI;
    class StandaloneMatrixAPI {
        constructor(config, session, initialItemConfig, baseRestUrl, matrixBaseUrl, logger, json, simpleItemTools) {
            this.config = config;
            this.session = session;
            this.baseRestUrl = baseRestUrl;
            this.matrixBaseUrl = matrixBaseUrl;
            this.logger = logger;
            this.json = json;
            this.simpleItemTools = simpleItemTools;
            this.debug = false;
            this.instance = new rest_api_1.DefaultApi(this.config, this.baseRestUrl, isomorphic_fetch_1.default);
            this.setItemConfig(initialItemConfig);
        }
        createNewItemConfig() {
            return new businesslogic_1.ItemConfiguration(this.logger, this.json);
        }
        getItemConfig() {
            return this.ItemConfig;
        }
        setItemConfig(newItemConfig) {
            this.ItemConfig = newItemConfig;
        }
        getHeadersForPost() {
            let headers = {};
            headers['x-csrf'] = this.session.getCsrfCookie();
            return headers;
        }
        // Called by setProject on project change.
        async initializeProject() {
            const p = await this.instance.projectGet(this.getProject(), 1);
        }
        log(arg) {
            if (this.debug) {
                this.logger.info(arg);
            }
        }
        setComment(comment) {
            this.session.setComment(comment);
        }
        getComment() { return this.session.getComment(); }
        async setProject(project) {
            this.session.setProject(project);
            if (project) {
                await this.initializeProject();
            }
        }
        getProject() { return this.session.getProject(); }
        async getProjects() {
            let p = this.instance.rootGet(0);
            return p.then((result) => {
                let projects = [];
                if (result.project) {
                    result.project.forEach((a) => {
                        projects.push(a.shortLabel);
                    });
                }
                return projects;
            });
        }
        parseRef(itemId) {
            return this.simpleItemTools.parseRef(itemId, this.getProject(), this.matrixBaseUrl);
        }
        getType(itemId) {
            var ir = this.parseRef(itemId);
            if (ir.type !== "") {
                return ir.type;
            }
            // no idea... 
            return "";
        }
        /**
         * get an item from the database as json object.
         *
         * Use: await api.getItem("F-DOC-1")
         *
         * @param itemId the id of the item like "REQ-1" or a specific version like "REQ-1-v1"
         * @throws error in case the itemId is bad.
         * @returns Promise to json object with all fields, links and labels
         */
        async getItem(itemId) {
            this.log(`get item "${itemId}`);
            let type = this.parseRef(itemId).type;
            if (!type || this.getItemConfig().getCategories(true).indexOf(type) == -1) {
                const msg = `This is not possibly an item in this project: "${itemId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            return this.appGetItemAsync(itemId);
        }
        /**
         * get the initial tree structure from a project. Project must be set first.
         */
        async getTree() {
            let p = this.instance.projectTreeGet(this.getProject(), "yes");
            return p.then((folders) => {
                let result = [];
                folders.forEach((v) => {
                    const hasChildren = v.children && v.children.length > 0;
                    result.push({ isFolder: hasChildren, title: v.title, id: v.id });
                });
                return result;
            });
        }
        /**
         * get a folder from the database, filling in it's children.
         * @param folderId  the id of the folder like "F-<type>-<id>"
         * @throws error if folderId is invalid
         * @returns Prommise to json object
         */
        async getFolderChildren(folderId) {
            this.log(`get folder "${folderId}`);
            const ref = this.parseRef(folderId);
            if (!ref.isFolder) {
                const msg = `This is not a folder: "${folderId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            let type = ref.type;
            if (!type || this.getItemConfig().getCategories(true).indexOf(type) == -1) {
                const msg = `This is not possibly a folder in this project: "${folderId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            const p = this.instance.projectItemFolderGet(this.getProject(), folderId, 0, "", "yes");
            return p.then((value) => {
                let result = [];
                // Harvest the children's IDs.
                if (value.itemList) {
                    value.itemList.forEach((v) => {
                        result.push({ isFolder: v.isFolder > 0, title: v.title, id: v.itemRef });
                    });
                }
                return result;
            });
        }
        parseItemJSON(itemId, result) {
            var item = {
                id: itemId,
                title: result.title,
                type: this.getType(itemId),
                downLinks: [],
                upLinks: [],
                modDate: result.modDate,
                isUnselected: result.isUnselected,
                labels: result.labels ? result.labels : [],
                maxVersion: result.maxVersion
            };
            if (result.isFolder != undefined) {
                item.isFolder = result.isFolder == 1;
                item.children = [];
            }
            else {
                item.isFolder = false;
            }
            if (result.docHasPackage) {
                item.docHasPackage = result.docHasPackage;
            }
            if (!result.maxVersion) {
                item.isDeleted = true;
            }
            if (result.fieldValList) {
                for (var fieldVal in result.fieldValList.fieldVal) {
                    item[result.fieldValList.fieldVal[fieldVal].id.toString()] = result.fieldValList.fieldVal[fieldVal].value;
                }
            }
            for (var idx = 0; result.downLinkList && idx < result.downLinkList.length; idx++) {
                var tol = result.downLinkList[idx].itemRef;
                item.downLinks.push({ to: this.parseRef(tol).id, title: result.downLinkList[idx].title, modDate: result.downLinkList[idx].modDate });
            }
            for (var idx = 0; result.upLinkList && idx < result.upLinkList.length; idx++) {
                var tol = result.upLinkList[idx].itemRef;
                item.upLinks.push({ to: this.parseRef(tol).id, title: result.upLinkList[idx].title, modDate: result.upLinkList[idx].modDate });
            }
            // copy original up list
            item.upLinkList = result.upLinkList;
            if (result.availableFormats) {
                item["availableFormats"] = result.availableFormats;
            }
            if (result.selectSubTree) {
                item["selectSubTree"] = result.selectSubTree;
            }
            if (result.requireSubTree) {
                item["requireSubTree"] = result.requireSubTree;
            }
            var hoi = [];
            for (var idx = 0; result.itemHistoryList && idx < result.itemHistoryList.itemHistory.length; idx++) {
                var theAction = result.itemHistoryList.itemHistory[idx];
                var historyInfo = {
                    id: itemId,
                    user: theAction.createdByUserLogin,
                    action: theAction.auditAction,
                    version: theAction.version,
                    date: theAction.createdAt,
                    dateUserFormat: theAction.createdAtUserFormat,
                    title: theAction.title,
                    comment: theAction.reason
                };
                // now use the information that undeleted items have been deleted just before
                if (theAction.auditAction === "undelete") {
                    if (result.itemHistoryList.itemHistory.length > idx + 1) {
                        var theDelete = result.itemHistoryList.itemHistory[idx + 1];
                        if (theDelete.auditAction !== "delete") {
                            historyInfo["deletedate"] = theDelete.deletedAtUserFormat;
                        }
                    }
                }
                hoi.push(historyInfo);
            }
            item['history'] = hoi;
            return item;
        }
        async appGetItemAsync(itemId) {
            const p = this.instance.projectItemItemGet(this.getProject(), itemId, 1);
            return p.then((value) => {
                if (value.isFolder) {
                    value["children"] = [];
                }
                const item = this.parseItemJSON(itemId, value);
                return item;
            });
        }
        async getDownlinks(itemId) {
            this.log(`get downlinks of item "${itemId}`);
            const itemPromise = this.getItem(itemId);
            return itemPromise.then((value) => {
                return value.downLinks ? value.downLinks : [];
            });
        }
        async getDownlinkIds(itemId) {
            this.log(`get downlink ids of item "${itemId}`);
            const links = this.getDownlinks(itemId);
            return links.then((value) => {
                return value.map(d => d.to);
            });
        }
        async getUplinks(itemId) {
            this.log(`get Uplinks of item "${itemId}`);
            const itemPromise = this.getItem(itemId);
            return itemPromise.then((value) => {
                return value.upLinks ? value.upLinks : [];
            });
        }
        async getUplinkIds(itemId) {
            this.log(`get uplink ids of item "${itemId}`);
            const links = this.getUplinks(itemId);
            return links.then((value) => {
                return value.map(d => d.to);
            });
        }
        /**
         * search items
         *
         * @param term search expression, e.g. mrql:category=REQ
         * @param includeFields true to include fields
         * @param includeLinks true to include links
         * @param includeLabels true to include labels
         * @returns
         */
        async search(term, includeFields, includeLinks, includeLabels, filter) {
            this.log(`Search for "${term}"`);
            return this.appSearchAsync(term, filter !== null && filter !== void 0 ? filter : null, true, includeFields ? "*" : null, null, includeLabels !== null && includeLabels !== void 0 ? includeLabels : false, includeLinks !== null && includeLinks !== void 0 ? includeLinks : false, includeLinks !== null && includeLinks !== void 0 ? includeLinks : false);
        }
        async uploadProjectFile(url) {
            const options = { headers: this.getHeadersForPost() };
            let result = await this.instance.projectFilePost(this.getProject(), url, options);
            return result;
        }
        async execute(payload) {
            const options = { headers: this.getHeadersForPost() };
            let items = await this.instance.projectExecutePost(this.getProject(), payload, options);
            return items;
        }
        parseSearchResult(needle, fieldList) {
            let fullitem = this.parseRef(needle.itemOrFolderRef);
            const that = this;
            let sr = {
                itemId: fullitem.id, version: fullitem.version, title: needle.title, downlinks: [], uplinks: [], labels: []
            };
            if (fieldList && fieldList.length > 0) {
                sr.fieldVal = needle.fieldVal;
            }
            if (needle.downLinkList) {
                for (let link of needle.downLinkList) {
                    sr.downlinks.push(that.parseRef(link.itemRef).id);
                }
            }
            if (needle.upLinkList) {
                for (let link of needle.upLinkList) {
                    sr.uplinks.push(that.parseRef(link.itemRef).id);
                }
            }
            if (needle.labels) {
                let labels = needle.labels.split(",");
                for (let label of labels) {
                    sr.labels.push(label.substr(1, label.length - 2));
                }
            }
            return sr;
        }
        // TODO: crossProject is not handled (it is a server query, not a project query).
        async appSearchAsync(term, filter, ignoreFilters, fieldList, crossProject, labels, down, up, treeOrder) {
            let linksReq = "";
            if (down && up) {
                linksReq = "up,down";
            }
            else if (down) {
                linksReq = "down";
            }
            else if (up) {
                linksReq = "up";
            }
            const p = this.instance.projectNeedleGet(this.getProject(), term, "", filter, fieldList, labels ? 1 : 0, treeOrder ? 1 : 0, linksReq);
            return p.then((result) => {
                var hoi = [];
                for (var idx = 0; idx < result.needles.length; idx++) {
                    hoi.push(this.parseSearchResult(result.needles[idx], fieldList));
                }
                return hoi;
            });
        }
        async getItemIdsInCategory(category) {
            this.log(`get items of type "${category}"`);
            let items = await this.search("mrql:category=" + category);
            return items.map(item => item.itemId);
        }
        /**
         * gets the value of a field of an item from the database
         *
         * Use: await getField( "REQ-1", "description")
         *
         * @param itemId the id of the item like "REQ-1" or a specific version like "REQ-1-v1"
         * @param fieldName name of the field
         * @throws Error in case of invalid item or field
         * @returns Promise to the value of the field
         */
        async getField(itemId, fieldName) {
            this.log(`get field "${fieldName} of item "${itemId}" `);
            let type = this.parseRef(itemId).type;
            if (!type || this.getItemConfig().getCategories(true).indexOf(type) == -1) {
                const msg = `This is not possibly an item in this project: "${itemId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            let fieldId = this.getItemConfig().getFieldId(type, fieldName);
            if (!fieldId) {
                const msg = `"${fieldName}" is not a field of this item "${itemId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            let itemPromise = this.appGetItemAsync(itemId);
            return itemPromise.then((value) => {
                return value[fieldId];
            });
        }
        /**
         * set a field of an item in the database
         *
         * Use: await api.setField("PROC-83", "plain english", "x");
         *
         * @param itemId itemId the id of the item like "REQ-1"
         * @param fieldName name of the field
         * @param value value of the field
         * @throws Error in case of invalid itemId or fieldName
         * @returns Promise to the updated item
         */
        async setField(itemId, fieldName, value) {
            this.log(`set field "${fieldName} of item "${itemId}" `);
            return this.setFields(itemId, [{ fieldName: fieldName, value: value }]);
        }
        async setTitle(itemId, value) {
            this.log(`set title of item "${itemId}" `);
            let update = {
                id: itemId,
                onlyThoseFields: 1,
                onlyThoseLabels: 1,
                title: value
            };
            let type = this.parseRef(itemId).type;
            if (!type) {
                const msg = `This is not possibly an item in this project: "${itemId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            return this.appUpdateItemInDBAsync(update, "edit");
        }
        appUpdateItemInDBAsync(itemJson, auditAction) {
            const comment = this.getComment();
            let putIt = { reason: comment };
            if (typeof itemJson.title !== "undefined") {
                putIt.title = itemJson.title;
            }
            if (auditAction) {
                putIt["auditAction"] = auditAction;
            }
            const regex = /fx[0-9]+/;
            let fxFields = {};
            for (var par in itemJson) {
                if (!itemJson.hasOwnProperty(par))
                    continue;
                if (putIt.hasOwnProperty(par))
                    continue;
                if (par === "type")
                    continue;
                if (par === "category")
                    continue;
                if (par === "links")
                    continue;
                if (par === "title")
                    continue;
                if (par === "id")
                    continue;
                if (isNaN(par)) {
                    // it's attribute other than a field
                    putIt[par] = itemJson[par];
                }
                else {
                    // it's a number so we assume it's a field
                    fxFields["fx" + par] = itemJson[par];
                }
                // If itemJson already has "fx" fields, we need to put those in the fxFields bucket.
                if (regex.test(par)) {
                    fxFields[par] = itemJson[par];
                }
            }
            const options = { query: fxFields, headers: this.getHeadersForPost() };
            const p = this.instance.projectItemItemPut(this.getProject(), itemJson.id, putIt.reason, putIt.title, undefined, undefined, putIt["auditAction"], undefined, undefined, undefined, undefined, undefined, undefined, itemJson.onlyThoseFields, itemJson.onlyThoseLabels, undefined, options);
            return p.then((result) => {
                var item = this.parseItemJSON(itemJson.id, result);
                return item;
            });
        }
        /**
         * sets multiple fields in the database
         *
         * Use: await api.setFields("PROC-83", [{fieldName:"plain english",value:"x"}]  )
         *
         * @param itemId itemId itemId the id of the item like "REQ-1"
         * @param data array of fieldName and value tupels
         * @throws Error in case of invalid id or fields
         * @returns the updated item
         */
        async setFields(itemId, data) {
            this.log(`set fields "${JSON.stringify(data)} of item "${itemId}" `);
            let update = {
                id: itemId,
                onlyThoseFields: 1,
                onlyThoseLabels: 1
            };
            let type = this.parseRef(itemId).type;
            if (!type) {
                const msg = `This is not possibly an item in this project: "${itemId}"!`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            for (let s of data) {
                let fieldId = this.getItemConfig().getFieldId(type, s.fieldName);
                if (!fieldId) {
                    const msg = `"${s.fieldName}" is not a field of this item "${itemId}"!`;
                    this.logger.error(msg);
                    throw new Error(msg);
                }
                update["fx" + fieldId] = s.value;
            }
            return this.appUpdateItemInDBAsync(update, "edit");
        }
        async addDownLink(fromId, toId) {
            this.log(`Add downlink from "${fromId} to "${toId}"`);
            const options = { headers: this.getHeadersForPost() };
            return this.instance.projectItemlinkUpitemDownitemPost(this.getProject(), fromId, toId, this.getComment(), options);
        }
        async deleteItem(itemId, force) {
            this.log(`Delete Item "${itemId}"`);
            if (force == undefined) {
                force = false;
            }
            return this.appDeleteItem(itemId, force);
        }
        async appDeleteItem(itemId, force) {
            return this.appGetItemAsync(itemId).then((itemJson) => {
                const comment = this.getComment();
                let confirm = "no";
                if (itemJson.isFolder && itemJson.children && force) {
                    confirm = "yes";
                }
                if (!force && itemJson.children.length > 0) {
                    throw new Error(`Item "${itemId}" not deleted because it has children`);
                }
                return this.instance.projectItemItemDelete(this.getProject(), itemId, confirm, comment);
            });
        }
        async deleteDownLink(fromId, toId) {
            this.log(`Delete downlink from "${fromId} to "${toId}"`);
            return this.instance.projectItemlinkUpitemDownitemDelete(this.getProject(), fromId, toId, this.getComment());
        }
        async deleteDownLinks(fromId) {
            this.log(`Delete all downlinks from "${fromId}"`);
            let dls = await this.getDownlinkIds(fromId);
            let results = [];
            for (let dl of dls) {
                results.push(await this.deleteDownLink(fromId, dl));
            }
            return results;
        }
        async deleteUpLinks(fromId) {
            this.log(`Delete all uplinks from "${fromId}"`);
            let uls = await this.getUplinkIds(fromId);
            let results = [];
            for (let ul of uls) {
                results.push(await this.deleteDownLink(ul, fromId));
            }
            return results;
        }
        /**
         * create a new item in the database
         *
         * Use: createItem( "F-REQ-1", "my item", [{fieldName:"description",value:"x"}], ["labelx"], downlinks:["SPEC-1"], uplinks:[] )
         *
         * @param folder where to store the item
         * @param title name of the item
         * @param data array with fieldNames and values
         * @param labels list of labels to set
         * @param downlinks list of downlinks to create
         * @param uplinks list of uplinks to create
         * @returns the created item id
         */
        async createItem(folder, title, data, labels, downlinks, uplinks) {
            this.log(`Create item "${title} in folder "${folder}" with labels:"
            ${labels ? labels.join(",") : ""}" downlinks:"${downlinks ? downlinks.join(",") : ""}" and uplinks:"${uplinks ? uplinks.join(",") : ""}" `);
            let that = this;
            let category = this.parseRef(folder).type;
            let update = { title: title, type: category };
            if (data) {
                for (let s of data) {
                    let fieldId = this.getItemConfig().getFieldId(category, s.fieldName);
                    if (!fieldId) {
                        const msg = `"${s.fieldName}" is not a field of this category "${category}"!`;
                        this.logger.error(msg);
                        throw new Error(msg);
                    }
                    update[fieldId] = s.value;
                }
            }
            if (labels && labels.length)
                update.labels = labels.join(",");
            const result = this.appCreateItemOfTypeAsync(category, update, "add", folder);
            return result.then(async (newItemId) => {
                let itemId = that.parseRef(newItemId).id;
                if (downlinks) {
                    for (let link of downlinks) {
                        await that.addDownLink(itemId, link);
                    }
                }
                if (uplinks) {
                    for (let link of uplinks) {
                        await that.addDownLink(link, itemId);
                    }
                }
                return newItemId;
            });
        }
        // Returns a promise with the id of the created item.
        async appCreateItemOfTypeAsync(category, itemJson, actions, parentId) {
            var _a, _b;
            const comment = this.getComment();
            if (itemJson.children) {
                let postItFolder = {
                    label: itemJson.title,
                    parent: parentId,
                    reason: comment
                };
                let fxFields = {};
                for (var par in itemJson) {
                    if (!itemJson.hasOwnProperty(par))
                        continue;
                    if (postItFolder.hasOwnProperty(par))
                        continue;
                    if (par === "type" || par === "children" ||
                        par === "title" || par === "labels" ||
                        par === "linksUp" || par === "linksDown") {
                        continue;
                    }
                    if (!isNaN(par)) {
                        fxFields["fx" + par] = itemJson[par];
                    }
                }
                const options = { query: fxFields, headers: this.getHeadersForPost() };
                let ack = this.instance.projectFolderPost(this.getProject(), parentId, itemJson.title, comment, undefined, options);
                return ack.then((result) => {
                    itemJson.id = "F-" + itemJson.type + "-" + result.serial;
                    return itemJson.id;
                });
            }
            let fxFields = {};
            for (var par in itemJson) {
                if (!itemJson.hasOwnProperty(par))
                    continue;
                if (par === "type" || par === "labels" ||
                    par === "linksUp" || par === "linksDown") {
                    continue;
                }
                if (!isNaN(par)) {
                    // it's a number so we assume it's a field
                    fxFields["fx" + par] = itemJson[par];
                }
            }
            let linksUp = (_a = itemJson.linksUp) !== null && _a !== void 0 ? _a : [];
            let linksDown = (_b = itemJson.linksDown) !== null && _b !== void 0 ? _b : [];
            const options = { query: fxFields, headers: this.getHeadersForPost() };
            let ack = this.instance.projectItemPost(this.getProject(), itemJson.title, parentId, comment, linksUp, linksDown, undefined, itemJson.labels, undefined, 1, options);
            return ack.then((result) => {
                itemJson.id = itemJson.type + "-" + result.serial;
                return itemJson.id;
            });
        }
        /**
         * Creates a folder
         *
         * @param parent where to store the folder
         * @param title name of the folder
         * @param data array with fieldNames and values
         * @throws error in case of input error (bad fields, etc)
         * @returns Promise to the item id of folder
         */
        async createFolder(parent, title, data) {
            this.log(`Create folder "${title} in folder "${parent}" `);
            let type = this.parseRef(parent).type;
            let update = { title: title, children: [], type: type };
            if (data) {
                for (let s of data) {
                    let fieldId = this.getItemConfig().getFieldId("FOLDER", s.fieldName);
                    if (!fieldId) {
                        const msg = `"${s.fieldName}" is not a field of a FOLDER"!`;
                        this.logger.error(msg);
                        throw new Error(msg);
                    }
                    update[fieldId] = s.value;
                }
            }
            // TODO: is XTC really correct here?
            return this.appCreateItemOfTypeAsync("XTC", update, "add", parent);
        }
        async getItemIdByTitle(category, title) {
            this.log(`get item by title "${title}" in category "${category}"`);
            let that = this;
            let itemsPromise = this.search("mrql:category=" + category);
            return itemsPromise.then((items) => {
                if (!items || items.length == 0) {
                    that.log(`Warning there's no item with title '${title}' in category '${category}'`);
                    return null;
                }
                const itemsFilteredByName = items.filter(item => item.title == title);
                if (itemsFilteredByName.length == 0) {
                    that.log(`Warning there's no item with title '${title}' in category '${category}'`);
                    return null;
                }
                if (itemsFilteredByName.length > 1) {
                    that.log(`Warning there's more than one match. Returning first item with title '${title}' in category '${category}'`);
                }
                that.log(`get item by title "${title}" in category "${category}" => ${itemsFilteredByName[0].itemId}`);
                return itemsFilteredByName[0].itemId;
            });
        }
        async copyItem(fromProject, fromItem, toProject, toFolder, copyLabels) {
            this.log(`Copy Item "${fromProject}/${fromItem}" to  "${toProject}/${toFolder}"`);
            return this.instance.projectCopyItemOrFolderPost(fromProject, fromItem, toFolder, this.getComment(), toProject, copyLabels ? 1 : 0);
        }
    }
    exports.StandaloneMatrixAPI = StandaloneMatrixAPI;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 185 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(186);
module.exports = self.fetch.bind(self);


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOMException": () => (/* binding */ DOMException),
/* harmony export */   "Headers": () => (/* binding */ Headers),
/* harmony export */   "Request": () => (/* binding */ Request),
/* harmony export */   "Response": () => (/* binding */ Response),
/* harmony export */   "fetch": () => (/* binding */ fetch)
/* harmony export */ });
var global =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  (typeof global !== 'undefined' && global)

var support = {
  searchParams: 'URLSearchParams' in global,
  iterable: 'Symbol' in global && 'iterator' in Symbol,
  blob:
    'FileReader' in global &&
    'Blob' in global &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in global,
  arrayBuffer: 'ArrayBuffer' in global
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this)
        if (isConsumed) {
          return isConsumed
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = global.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && global.location.href ? global.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer &&
        request.headers.get('Content-Type') &&
        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!global.fetch) {
  global.fetch = fetch
  global.Headers = Headers
  global.Request = Request
  global.Response = Response
}


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(189), __webpack_require__(185)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, url, isomorphic_fetch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiFetchParamCreator = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
    url = __importStar(url);
    isomorphic_fetch_1 = __importDefault(isomorphic_fetch_1);
    const btoa = __webpack_require__(188);
    const BASE_PATH = "https://demo23.matrixreq.com/rest/1".replace(/\/+$/, "");
    /**
     *
     * @export
     */
    exports.COLLECTION_FORMATS = {
        csv: ",",
        ssv: " ",
        tsv: "\t",
        pipes: "|",
    };
    /**
     *
     * @export
     * @class BaseAPI
     */
    class BaseAPI {
        constructor(configuration, basePath = BASE_PATH, fetch = isomorphic_fetch_1.default) {
            this.basePath = basePath;
            this.fetch = fetch;
            if (configuration) {
                this.configuration = configuration;
                this.basePath = configuration.basePath || this.basePath;
            }
        }
    }
    exports.BaseAPI = BaseAPI;
    ;
    /**
     *
     * @export
     * @class RequiredError
     * @extends {Error}
     */
    class RequiredError extends Error {
        constructor(field, msg) {
            super(msg);
            this.field = field;
        }
    }
    exports.RequiredError = RequiredError;
    /**
     * DefaultApi - fetch parameter creator
     * @export
     */
    exports.DefaultApiFetchParamCreator = function (configuration) {
        return {
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Asks for the difference between A and B html exerpts, and produce the B html with annotations
             * @param {string} [arg] json object with the arguments
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allCompareHtmlPost(arg, options = {}) {
                const localVarPath = `/all/compareHtml`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (arg !== undefined) {
                    localVarQueryParameter['arg'] = arg;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Returns all info about a date
             * @param {string} [date] (optional) an input date formatted as iso8601. If not present, current date/time is used
             * @param {string} [dateformat] (optional) a date formatter. If not present, current date format is used
             * @param {string} [timeformat] (optional) a date-time formatter. If not present, current date/time format is used
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allDateGet(date, dateformat, timeformat, options = {}) {
                const localVarPath = `/all/date`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (date !== undefined) {
                    localVarQueryParameter['date'] = date;
                }
                if (dateformat !== undefined) {
                    localVarQueryParameter['dateformat'] = dateformat;
                }
                if (timeformat !== undefined) {
                    localVarQueryParameter['timeformat'] = timeformat;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one customer file. The fileno is a simple fileId. This request returns the actual file
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileFilenoGet(fileno, key, disposition, options = {}) {
                // verify required parameter 'fileno' is not null or undefined
                if (fileno === null || fileno === undefined) {
                    throw new RequiredError('fileno', 'Required parameter fileno was null or undefined when calling allFileFilenoGet.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling allFileFilenoGet.');
                }
                const localVarPath = `/all/file/{fileno}`
                    .replace(`{${"fileno"}}`, encodeURIComponent(String(fileno)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (disposition !== undefined) {
                    localVarQueryParameter['disposition'] = disposition;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieve list of all customer-wide files
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileGet(options = {}) {
                const localVarPath = `/all/file`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a new customer-wide file - the file should be uploaded as payload. Its mime type should be sent through the HTTP protocol.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFilePost(options = {}) {
                const localVarPath = `/all/file`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Retrieve license status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLicenseGet(options = {}) {
                const localVarPath = `/all/license`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Adds a log entry (server side).
             * @param {string} message Message to log
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLogPost(message, options = {}) {
                // verify required parameter 'message' is not null or undefined
                if (message === null || message === undefined) {
                    throw new RequiredError('message', 'Required parameter message was null or undefined when calling allLogPost.');
                }
                const localVarPath = `/all/log`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (message !== undefined) {
                    localVarQueryParameter['message'] = message;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Monitoring object
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allMonitorGet(options = {}) {
                const localVarPath = `/all/monitor`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in all projects
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleGet(search, id, filter, fieldsOut, labels, links, options = {}) {
                // verify required parameter 'search' is not null or undefined
                if (search === null || search === undefined) {
                    throw new RequiredError('search', 'Required parameter search was null or undefined when calling allNeedleGet.');
                }
                // verify required parameter 'id' is not null or undefined
                if (id === null || id === undefined) {
                    throw new RequiredError('id', 'Required parameter id was null or undefined when calling allNeedleGet.');
                }
                const localVarPath = `/all/needle`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (search !== undefined) {
                    localVarQueryParameter['search'] = search;
                }
                if (id !== undefined) {
                    localVarQueryParameter['id'] = id;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (fieldsOut !== undefined) {
                    localVarQueryParameter['fieldsOut'] = fieldsOut;
                }
                if (labels !== undefined) {
                    localVarQueryParameter['labels'] = labels;
                }
                if (links !== undefined) {
                    localVarQueryParameter['links'] = links;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in all projects
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleminimalGet(search, filter, options = {}) {
                // verify required parameter 'search' is not null or undefined
                if (search === null || search === undefined) {
                    throw new RequiredError('search', 'Required parameter search was null or undefined when calling allNeedleminimalGet.');
                }
                const localVarPath = `/all/needleminimal`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (search !== undefined) {
                    localVarQueryParameter['search'] = search;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.2
             * @summary The OpenAPI 3.0 definition of our REST API
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allOpenapiGet(options = {}) {
                const localVarPath = `/all/openapi`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Lists all reports
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allReportsGet(options = {}) {
                const localVarPath = `/all/reports`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Sends an email. Non-optional parameters are sent as a POST JSON payload.
             * @param {SendmailParam} [body] Necessary information to send a mail
             * @param {number} [system] (optional) if set to 1 makes it a system email (not sent by the actual user)
             * @param {number} [noreply] (optional) if set to 1 makes it a no-reply email (not sent by the actual user)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSendmailPost(body, system, noreply, options = {}) {
                const localVarPath = `/all/sendmail`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (system !== undefined) {
                    localVarQueryParameter['system'] = system;
                }
                if (noreply !== undefined) {
                    localVarQueryParameter['noreply'] = noreply;
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a service desk issue. The parameters are sent as a POST JSON payload.
             * @param {ServiceDeskParam} [body] Necessary information to send a mail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allServicedeskPost(body, options = {}) {
                const localVarPath = `/all/servicedesk`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a customer
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingGet(options = {}) {
                const localVarPath = `/all/setting`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a customer setting. If the value is empty, the setting will be deleted.
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingPost(key, value, options = {}) {
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling allSettingPost.');
                }
                // verify required parameter 'value' is not null or undefined
                if (value === null || value === undefined) {
                    throw new RequiredError('value', 'Required parameter value was null or undefined when calling allSettingPost.');
                }
                const localVarPath = `/all/setting`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get instance status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allStatusGet(options = {}) {
                const localVarPath = `/all/status`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Returns all accepted time zones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTimezoneGet(options = {}) {
                const localVarPath = `/all/timezone`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for all projects
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTodoGet(includeDone, includeFuture, options = {}) {
                const localVarPath = `/all/todo`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (includeDone !== undefined) {
                    localVarQueryParameter['includeDone'] = includeDone;
                }
                if (includeFuture !== undefined) {
                    localVarQueryParameter['includeFuture'] = includeFuture;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary WebHook
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allWebhookPost(options = {}) {
                const localVarPath = `/all/webhook`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Retrieves the group list
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGet(details, options = {}) {
                const localVarPath = `/group`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (details !== undefined) {
                    localVarQueryParameter['details'] = details;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a group
             * @param {string} groupId group Id
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdDelete(groupId, confirm, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdDelete.');
                }
                // verify required parameter 'confirm' is not null or undefined
                if (confirm === null || confirm === undefined) {
                    throw new RequiredError('confirm', 'Required parameter confirm was null or undefined when calling groupGroupIdDelete.');
                }
                const localVarPath = `/group/{groupId}`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (confirm !== undefined) {
                    localVarQueryParameter['confirm'] = confirm;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.2
             * @summary Retrieves details of a group
             * @param {string} groupId group Id
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdGet(groupId, details, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdGet.');
                }
                const localVarPath = `/group/{groupId}`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (details !== undefined) {
                    localVarQueryParameter['details'] = details;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Adds a group to a project (or removes it)
             * @param {string} groupId group Id
             * @param {string} project Project short label
             * @param {number} [permission] Specify the (new) permission for that group in that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdProjectProjectPost(groupId, project, permission, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdProjectProjectPost.');
                }
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling groupGroupIdProjectProjectPost.');
                }
                const localVarPath = `/group/{groupId}/project/{project}`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (permission !== undefined) {
                    localVarQueryParameter['permission'] = permission;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a group
             * @param {string} groupId group Id
             * @param {string} newName The new group name. Cannot be one of the existing. Must start with &#x27;group.&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdRenamePut(groupId, newName, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdRenamePut.');
                }
                // verify required parameter 'newName' is not null or undefined
                if (newName === null || newName === undefined) {
                    throw new RequiredError('newName', 'Required parameter newName was null or undefined when calling groupGroupIdRenamePut.');
                }
                const localVarPath = `/group/{groupId}/rename`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (newName !== undefined) {
                    localVarQueryParameter['newName'] = newName;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.2
             * @summary Adds a user to a group
             * @param {string} groupId group Id
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserUserPut(groupId, user, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdUserUserPut.');
                }
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling groupGroupIdUserUserPut.');
                }
                const localVarPath = `/group/{groupId}/user/{user}`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Sets all users of a group (replacing potential former content)
             * @param {string} groupId group Id
             * @param {string} users List of all users members of that group, commas-separated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserlistPut(groupId, users, options = {}) {
                // verify required parameter 'groupId' is not null or undefined
                if (groupId === null || groupId === undefined) {
                    throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling groupGroupIdUserlistPut.');
                }
                // verify required parameter 'users' is not null or undefined
                if (users === null || users === undefined) {
                    throw new RequiredError('users', 'Required parameter users was null or undefined when calling groupGroupIdUserlistPut.');
                }
                const localVarPath = `/group/{groupId}/userlist`
                    .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (users !== undefined) {
                    localVarQueryParameter['users'] = users;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Creates a new group
             * @param {string} groupName group name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNamePost(groupName, options = {}) {
                // verify required parameter 'groupName' is not null or undefined
                if (groupName === null || groupName === undefined) {
                    throw new RequiredError('groupName', 'Required parameter groupName was null or undefined when calling groupGroupNamePost.');
                }
                const localVarPath = `/group/{groupName}`
                    .replace(`{${"groupName"}}`, encodeURIComponent(String(groupName)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a user from a group
             * @param {string} groupName group name
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNameUserUserDelete(groupName, user, options = {}) {
                // verify required parameter 'groupName' is not null or undefined
                if (groupName === null || groupName === undefined) {
                    throw new RequiredError('groupName', 'Required parameter groupName was null or undefined when calling groupGroupNameUserUserDelete.');
                }
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling groupGroupNameUserUserDelete.');
                }
                const localVarPath = `/group/{groupName}/user/{user}`
                    .replace(`{${"groupName"}}`, encodeURIComponent(String(groupName)))
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.3
             * @summary Merge branch into mainline. First project is the mainline, second is the branch. The payload must contain a json object with a list of actions to perform.
             * @param {string} mainproject mainproject
             * @param {string} branchproject branchproject
             * @param {string} reason The reason why the user is doing this
             * @param {MergeParam} [body] Actions to perform
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options = {}) {
                // verify required parameter 'mainproject' is not null or undefined
                if (mainproject === null || mainproject === undefined) {
                    throw new RequiredError('mainproject', 'Required parameter mainproject was null or undefined when calling mainprojectMergeBranchprojectPost.');
                }
                // verify required parameter 'branchproject' is not null or undefined
                if (branchproject === null || branchproject === undefined) {
                    throw new RequiredError('branchproject', 'Required parameter branchproject was null or undefined when calling mainprojectMergeBranchprojectPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling mainprojectMergeBranchprojectPost.');
                }
                const localVarPath = `/{mainproject}/merge/{branchproject}`
                    .replace(`{${"mainproject"}}`, encodeURIComponent(String(mainproject)))
                    .replace(`{${"branchproject"}}`, encodeURIComponent(String(branchproject)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.2
             * @summary Retrieves all accesses in a project (list of groups and users who have access)
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAccessGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectAccessGet.');
                }
                const localVarPath = `/{project}/access`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieves all changes in a project
             * @param {string} project Project short label
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {string} [deleteOnly] (optional) if set to yes, only returns actions of type delete
             * @param {string} [tech] (optional) if set to yes, returns the underneath changes
             * @param {number} [auditIdMin] (optional) sets a minimum ID for audits, as returned by GET calendar
             * @param {number} [auditIdMax] (optional) sets a maximum ID for audits
             * @param {number} [noReport] (optional) set to 1 to avoid having reports
             * @param {number} [noImport] (optional) set to 1 to avoid having imports
             * @param {string} [include] (optional) set to a list of actions to include (delete,undelete,add,edit,...)
             * @param {number} [resolveRef] (optional) set to 1 to resolve item IDs into refs
             * @param {string} [itemRef] (optional) restrict the audit to only those mentionning this item
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectAuditGet.');
                }
                const localVarPath = `/{project}/audit`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (startAt !== undefined) {
                    localVarQueryParameter['startAt'] = startAt;
                }
                if (maxResults !== undefined) {
                    localVarQueryParameter['maxResults'] = maxResults;
                }
                if (deleteOnly !== undefined) {
                    localVarQueryParameter['deleteOnly'] = deleteOnly;
                }
                if (tech !== undefined) {
                    localVarQueryParameter['tech'] = tech;
                }
                if (auditIdMin !== undefined) {
                    localVarQueryParameter['auditIdMin'] = auditIdMin;
                }
                if (auditIdMax !== undefined) {
                    localVarQueryParameter['auditIdMax'] = auditIdMax;
                }
                if (noReport !== undefined) {
                    localVarQueryParameter['noReport'] = noReport;
                }
                if (noImport !== undefined) {
                    localVarQueryParameter['noImport'] = noImport;
                }
                if (include !== undefined) {
                    localVarQueryParameter['include'] = include;
                }
                if (resolveRef !== undefined) {
                    localVarQueryParameter['resolveRef'] = resolveRef;
                }
                if (itemRef !== undefined) {
                    localVarQueryParameter['itemRef'] = itemRef;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Launches a server-side branch or clone - needs the 'merge' module if actual branching
             * @param {string} project Project short label
             * @param {string} label Branch project label
             * @param {string} shortLabel Branch project short label
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after branching)
             * @param {number} keepContent 1 or 0. Defaults to 1. 0 only works without branch and without history
             * @param {number} [branch] (optional) Set to 1 to branch (default), 0 to just copy/clone
             * @param {number} [history] (optional) Set to 1 to branch or copy with history, defaults to 0
             * @param {string} [tagToCreate] (optional) specify a tag (by default auto-generated)
             * @param {string} [branchInThePastTag] (optional) specify a tag to branch in the past (needs history&#x3D;1)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectBranchPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectBranchPost.');
                }
                // verify required parameter 'shortLabel' is not null or undefined
                if (shortLabel === null || shortLabel === undefined) {
                    throw new RequiredError('shortLabel', 'Required parameter shortLabel was null or undefined when calling projectBranchPost.');
                }
                // verify required parameter 'keepPermissions' is not null or undefined
                if (keepPermissions === null || keepPermissions === undefined) {
                    throw new RequiredError('keepPermissions', 'Required parameter keepPermissions was null or undefined when calling projectBranchPost.');
                }
                // verify required parameter 'keepContent' is not null or undefined
                if (keepContent === null || keepContent === undefined) {
                    throw new RequiredError('keepContent', 'Required parameter keepContent was null or undefined when calling projectBranchPost.');
                }
                const localVarPath = `/{project}/branch`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (shortLabel !== undefined) {
                    localVarQueryParameter['shortLabel'] = shortLabel;
                }
                if (branch !== undefined) {
                    localVarQueryParameter['branch'] = branch;
                }
                if (history !== undefined) {
                    localVarQueryParameter['history'] = history;
                }
                if (tagToCreate !== undefined) {
                    localVarQueryParameter['tagToCreate'] = tagToCreate;
                }
                if (branchInThePastTag !== undefined) {
                    localVarQueryParameter['branchInThePastTag'] = branchInThePastTag;
                }
                if (keepPermissions !== undefined) {
                    localVarQueryParameter['keepPermissions'] = keepPermissions;
                }
                if (keepContent !== undefined) {
                    localVarQueryParameter['keepContent'] = keepContent;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all dates at which a project has been modified
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCalendarGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCalendarGet.');
                }
                const localVarPath = `/{project}/calendar`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a category. Will fail on REPORT and FOLDER categories
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryDelete(project, category, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatCategoryDelete.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatCategoryDelete.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectCatCategoryDelete.');
                }
                const localVarPath = `/{project}/cat/{category}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} [filter] (optional) specify a filter
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryGet(project, category, filter, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatCategoryGet.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatCategoryGet.');
                }
                const localVarPath = `/{project}/cat/{category}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a categorie's labels, and fix the project's settings to reflect that change, OR modifies a category's order.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} order The new order (for reordering)
             * @param {string} shortLabel The new short label for that category (for renaming)
             * @param {string} label The new long label for that category (for renaming)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryPut(project, category, order, shortLabel, label, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatCategoryPut.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatCategoryPut.');
                }
                // verify required parameter 'order' is not null or undefined
                if (order === null || order === undefined) {
                    throw new RequiredError('order', 'Required parameter order was null or undefined when calling projectCatCategoryPut.');
                }
                // verify required parameter 'shortLabel' is not null or undefined
                if (shortLabel === null || shortLabel === undefined) {
                    throw new RequiredError('shortLabel', 'Required parameter shortLabel was null or undefined when calling projectCatCategoryPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectCatCategoryPut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectCatCategoryPut.');
                }
                const localVarPath = `/{project}/cat/{category}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (order !== undefined) {
                    localVarQueryParameter['order'] = order;
                }
                if (shortLabel !== undefined) {
                    localVarQueryParameter['shortLabel'] = shortLabel;
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingGet(project, category, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatCategorySettingGet.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatCategorySettingGet.');
                }
                const localVarPath = `/{project}/cat/{category}/setting`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a category setting. If the value is empty, the setting will be deleted
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingPost(project, category, key, value, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatCategorySettingPost.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatCategorySettingPost.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling projectCatCategorySettingPost.');
                }
                // verify required parameter 'value' is not null or undefined
                if (value === null || value === undefined) {
                    throw new RequiredError('value', 'Required parameter value was null or undefined when calling projectCatCategorySettingPost.');
                }
                const localVarPath = `/{project}/cat/{category}/setting`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all categories of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatGet.');
                }
                const localVarPath = `/{project}/cat`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a fields in a category
             * @param {string} project Project short label
             * @param {string} label Field label
             * @param {string} category Category short label
             * @param {string} fieldType Type of field
             * @param {string} fieldParam Parameter for the field
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatPost(project, label, category, fieldType, fieldParam, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCatPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectCatPost.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectCatPost.');
                }
                // verify required parameter 'fieldType' is not null or undefined
                if (fieldType === null || fieldType === undefined) {
                    throw new RequiredError('fieldType', 'Required parameter fieldType was null or undefined when calling projectCatPost.');
                }
                // verify required parameter 'fieldParam' is not null or undefined
                if (fieldParam === null || fieldParam === undefined) {
                    throw new RequiredError('fieldParam', 'Required parameter fieldParam was null or undefined when calling projectCatPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectCatPost.');
                }
                const localVarPath = `/{project}/cat`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (category !== undefined) {
                    localVarQueryParameter['category'] = category;
                }
                if (fieldType !== undefined) {
                    localVarQueryParameter['fieldType'] = fieldType;
                }
                if (fieldParam !== undefined) {
                    localVarQueryParameter['fieldParam'] = fieldParam;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Clones a project
             * @param {string} project Project short label
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {number} keepHistory 1 or 0. Defaults to 0
             * @param {number} keepContent 1 or 0. Defaults to 0 (only the REPORT part is kept, make sense only if keepHistory is 0)
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after cloning)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectClonePost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectClonePost.');
                }
                // verify required parameter 'shortLabel' is not null or undefined
                if (shortLabel === null || shortLabel === undefined) {
                    throw new RequiredError('shortLabel', 'Required parameter shortLabel was null or undefined when calling projectClonePost.');
                }
                // verify required parameter 'keepHistory' is not null or undefined
                if (keepHistory === null || keepHistory === undefined) {
                    throw new RequiredError('keepHistory', 'Required parameter keepHistory was null or undefined when calling projectClonePost.');
                }
                // verify required parameter 'keepContent' is not null or undefined
                if (keepContent === null || keepContent === undefined) {
                    throw new RequiredError('keepContent', 'Required parameter keepContent was null or undefined when calling projectClonePost.');
                }
                // verify required parameter 'keepPermissions' is not null or undefined
                if (keepPermissions === null || keepPermissions === undefined) {
                    throw new RequiredError('keepPermissions', 'Required parameter keepPermissions was null or undefined when calling projectClonePost.');
                }
                const localVarPath = `/{project}/clone`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (shortLabel !== undefined) {
                    localVarQueryParameter['shortLabel'] = shortLabel;
                }
                if (keepHistory !== undefined) {
                    localVarQueryParameter['keepHistory'] = keepHistory;
                }
                if (keepContent !== undefined) {
                    localVarQueryParameter['keepContent'] = keepContent;
                }
                if (keepPermissions !== undefined) {
                    localVarQueryParameter['keepPermissions'] = keepPermissions;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for the difference between 2 signed documents, as a Word document. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} signitem1 SIGN-xx for the first SIGN document to compare
             * @param {string} signitem2 SIGN-xx for the 2nd SIGN document to compare
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCompareSignitem1Signitem2Post.');
                }
                // verify required parameter 'signitem1' is not null or undefined
                if (signitem1 === null || signitem1 === undefined) {
                    throw new RequiredError('signitem1', 'Required parameter signitem1 was null or undefined when calling projectCompareSignitem1Signitem2Post.');
                }
                // verify required parameter 'signitem2' is not null or undefined
                if (signitem2 === null || signitem2 === undefined) {
                    throw new RequiredError('signitem2', 'Required parameter signitem2 was null or undefined when calling projectCompareSignitem1Signitem2Post.');
                }
                const localVarPath = `/{project}/compare/{signitem1}/{signitem2}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"signitem1"}}`, encodeURIComponent(String(signitem1)))
                    .replace(`{${"signitem2"}}`, encodeURIComponent(String(signitem2)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectConfigcheckGet(excludeCategories, options = {}) {
                const localVarPath = `/project/configcheck`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (excludeCategories !== undefined) {
                    localVarQueryParameter['excludeCategories'] = excludeCategories;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.2
             * @summary Copy items from a folder to another one
             * @param {string} project Project short label
             * @param {string} itemOrFolder Item reference (XXX-nn) or folder (F-XXX-nn)
             * @param {string} targetFolder Reference of the target folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [targetProject] (optional) project to copy into (by default, same project)
             * @param {number} [copyLabels] (optional) 0 or 1. Defaults to 0
             * @param {string} [map] (optional) mapN&#x3D;M -  map field N in source to field M in target
             * @param {string} [ignoreLabels] (optional) can contain a comma-delimited list of labels NOT to copy
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectCopyItemOrFolderPost.');
                }
                // verify required parameter 'itemOrFolder' is not null or undefined
                if (itemOrFolder === null || itemOrFolder === undefined) {
                    throw new RequiredError('itemOrFolder', 'Required parameter itemOrFolder was null or undefined when calling projectCopyItemOrFolderPost.');
                }
                // verify required parameter 'targetFolder' is not null or undefined
                if (targetFolder === null || targetFolder === undefined) {
                    throw new RequiredError('targetFolder', 'Required parameter targetFolder was null or undefined when calling projectCopyItemOrFolderPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectCopyItemOrFolderPost.');
                }
                const localVarPath = `/{project}/copy/{itemOrFolder}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"itemOrFolder"}}`, encodeURIComponent(String(itemOrFolder)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (targetFolder !== undefined) {
                    localVarQueryParameter['targetFolder'] = targetFolder;
                }
                if (targetProject !== undefined) {
                    localVarQueryParameter['targetProject'] = targetProject;
                }
                if (copyLabels !== undefined) {
                    localVarQueryParameter['copyLabels'] = copyLabels;
                }
                if (map !== undefined) {
                    localVarQueryParameter['map'] = map;
                }
                if (ignoreLabels !== undefined) {
                    localVarQueryParameter['ignoreLabels'] = ignoreLabels;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a project (only used for unit testing). This is an actual DELETE in the database.
             * @param {string} project Project short label
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectDelete(project, confirm, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectDelete.');
                }
                // verify required parameter 'confirm' is not null or undefined
                if (confirm === null || confirm === undefined) {
                    throw new RequiredError('confirm', 'Required parameter confirm was null or undefined when calling projectDelete.');
                }
                const localVarPath = `/{project}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (confirm !== undefined) {
                    localVarQueryParameter['confirm'] = confirm;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Converts an excel file (xls, xlsx) into a XML version that we send straight back as an XML payload.
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExcelxmlPost(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectExcelxmlPost.');
                }
                const localVarPath = `/{project}/excelxml`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Executes UC or TC into XTC items
             * @param {string} project Project short label
             * @param {ExecuteParam} [body] There must be a JSON as a payload. It includes all parameters AND the reason
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExecutePost(project, body, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectExecutePost.');
                }
                const localVarPath = `/{project}/execute`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for an export of some items. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} itemList Mandatory list of items to export.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExportGet(project, itemList, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectExportGet.');
                }
                // verify required parameter 'itemList' is not null or undefined
                if (itemList === null || itemList === undefined) {
                    throw new RequiredError('itemList', 'Required parameter itemList was null or undefined when calling projectExportGet.');
                }
                const localVarPath = `/{project}/export`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (itemList !== undefined) {
                    localVarQueryParameter['itemList'] = itemList;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a field.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldCategoryDelete(project, category, field, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFieldCategoryDelete.');
                }
                // verify required parameter 'category' is not null or undefined
                if (category === null || category === undefined) {
                    throw new RequiredError('category', 'Required parameter category was null or undefined when calling projectFieldCategoryDelete.');
                }
                // verify required parameter 'field' is not null or undefined
                if (field === null || field === undefined) {
                    throw new RequiredError('field', 'Required parameter field was null or undefined when calling projectFieldCategoryDelete.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectFieldCategoryDelete.');
                }
                const localVarPath = `/{project}/field/{category}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"category"}}`, encodeURIComponent(String(category)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (field !== undefined) {
                    localVarQueryParameter['field'] = field;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get 1 field of an item. {item} has the form CATEG-number.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} field Mandatory. Field number (faster) OR field label
             * @param {string} [format] Optional. Format for the return. Can be text, json, html, xml or xslt. Defaults to html
             * @param {number} [download] Optional. 1 to have in download, 0 as direct result. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldItemGet(project, item, field, format, download, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFieldItemGet.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectFieldItemGet.');
                }
                // verify required parameter 'field' is not null or undefined
                if (field === null || field === undefined) {
                    throw new RequiredError('field', 'Required parameter field was null or undefined when calling projectFieldItemGet.');
                }
                const localVarPath = `/{project}/field/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (field !== undefined) {
                    localVarQueryParameter['field'] = field;
                }
                if (format !== undefined) {
                    localVarQueryParameter['format'] = format;
                }
                if (download !== undefined) {
                    localVarQueryParameter['download'] = download;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a field's label and parameter OR modifies a field's order.
             * @param {string} project Project short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} label The new label (for renaming)
             * @param {string} fieldParam The new parameter (for renaming)
             * @param {number} order The new order (for reordering)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldPut(project, field, label, fieldParam, order, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFieldPut.');
                }
                // verify required parameter 'field' is not null or undefined
                if (field === null || field === undefined) {
                    throw new RequiredError('field', 'Required parameter field was null or undefined when calling projectFieldPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectFieldPut.');
                }
                // verify required parameter 'fieldParam' is not null or undefined
                if (fieldParam === null || fieldParam === undefined) {
                    throw new RequiredError('fieldParam', 'Required parameter fieldParam was null or undefined when calling projectFieldPut.');
                }
                // verify required parameter 'order' is not null or undefined
                if (order === null || order === undefined) {
                    throw new RequiredError('order', 'Required parameter order was null or undefined when calling projectFieldPut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectFieldPut.');
                }
                const localVarPath = `/{project}/field`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (field !== undefined) {
                    localVarQueryParameter['field'] = field;
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (fieldParam !== undefined) {
                    localVarQueryParameter['fieldParam'] = fieldParam;
                }
                if (order !== undefined) {
                    localVarQueryParameter['order'] = order;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one project file. The fileno is a simple fileId. This request returns the actual file
             * @param {string} project Project short label
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileFilenoGet(project, fileno, key, disposition, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFileFilenoGet.');
                }
                // verify required parameter 'fileno' is not null or undefined
                if (fileno === null || fileno === undefined) {
                    throw new RequiredError('fileno', 'Required parameter fileno was null or undefined when calling projectFileFilenoGet.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling projectFileFilenoGet.');
                }
                const localVarPath = `/{project}/file/{fileno}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"fileno"}}`, encodeURIComponent(String(fileno)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (disposition !== undefined) {
                    localVarQueryParameter['disposition'] = disposition;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all files owned by a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFileGet.');
                }
                const localVarPath = `/{project}/file`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Creates a new file - the file should be uploaded as payload (or through the url argument as an alternative). It's mime type should be sent through the HTTP protocol.
             * @param {string} project Project short label
             * @param {string} [input_url] Optional argument -  the file could also come from an external URL. In this case there will be an error if we can&#x27;t retrieve it on the server
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFilePost(project, input_url, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFilePost.');
                }
                const localVarPath = `/{project}/file`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (input_url !== undefined) {
                    localVarQueryParameter['url'] = input_url;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Creates a new folder
             * @param {string} project Project short label
             * @param {string} parent Reference of the parent folder in the form F-CATEG-serial (example -  F-SPEC-17)
             * @param {string} label folder label
             * @param {string} reason The reason why the user is doing this
             * @param {string} [fxField] (optional) Add one of each of these to set folder&#x27;s fields. fx is followed by the field ID (a number)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFolderPost(project, parent, label, reason, fxField, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectFolderPost.');
                }
                // verify required parameter 'parent' is not null or undefined
                if (parent === null || parent === undefined) {
                    throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling projectFolderPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectFolderPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectFolderPost.');
                }
                const localVarPath = `/{project}/folder`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (parent !== undefined) {
                    localVarQueryParameter['parent'] = parent;
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (fxField !== undefined) {
                    localVarQueryParameter['fxField'] = fxField;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get list of project info -  users, settings, categories
             * @param {string} project Project short label
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have this project data even if you are not assigned to, as an admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectGet(project, adminUI, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectGet.');
                }
                const localVarPath = `/{project}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (adminUI !== undefined) {
                    localVarQueryParameter['adminUI'] = adminUI;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Hides a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHidePut(project, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectHidePut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectHidePut.');
                }
                const localVarPath = `/{project}/hide`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Launches a server-side hook
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} hook name of the hook
             * @param {string} [body] Payload for the hook, treated as a string.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHookItemPost(project, item, hook, body, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectHookItemPost.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectHookItemPost.');
                }
                // verify required parameter 'hook' is not null or undefined
                if (hook === null || hook === undefined) {
                    throw new RequiredError('hook', 'Required parameter hook was null or undefined when calling projectHookItemPost.');
                }
                const localVarPath = `/{project}/hook/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (hook !== undefined) {
                    localVarQueryParameter['hook'] = hook;
                }
                localVarHeaderParameter['Content-Type'] = 'text/plain';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( false) || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Cleans up an input html blob according to the current html cleanup rules. The blob is passed in the POST payload. The payload must be a json object with {\"htmlToClean\" - \"x\"}
             * @param {string} project Project short label
             * @param {GetHmlBlobInput} [body] Payload
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupBlobPost(project, body, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectHtmlCleanupBlobPost.');
                }
                const localVarPath = `/{project}/htmlCleanupBlob`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the list of items that would be changed if we applied html cleanup. You can pass a cleanup setting in the payload of the POST. If it's not there we take the customer (global) setting and force the cleanup to true
             * @param {string} project Project short label
             * @param {CleanupSetting} [body] Cleanup setting (optional)
             * @param {string} [categories] (optional) list of comma-delimited categories to go through, all by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupTestPost(project, body, categories, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectHtmlCleanupTestPost.');
                }
                const localVarPath = `/{project}/htmlCleanupTest`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (categories !== undefined) {
                    localVarQueryParameter['categories'] = categories;
                }
                localVarHeaderParameter['Content-Type'] = 'application/json';
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                const needsSerialization = ( true) || 0;
                localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Imports some items into a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectImportPost(project, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectImportPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectImportPost.');
                }
                const localVarPath = `/{project}/import`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a folder. {folder} has the form F-CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [children] (optional) set to yes if you need the children as well (recursively).
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemFolderGet.');
                }
                // verify required parameter 'folder' is not null or undefined
                if (folder === null || folder === undefined) {
                    throw new RequiredError('folder', 'Required parameter folder was null or undefined when calling projectItemFolderGet.');
                }
                const localVarPath = `/{project}/item/{folder}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (history !== undefined) {
                    localVarQueryParameter['history'] = history;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (children !== undefined) {
                    localVarQueryParameter['children'] = children;
                }
                if (atDate !== undefined) {
                    localVarQueryParameter['atDate'] = atDate;
                }
                if (fields !== undefined) {
                    localVarQueryParameter['fields'] = fields;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Removes (inactivate) an item (or a folder). Item has the form (F-)CATEG-number. Will fail on non-empty folders
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} confirm Needs to be yes for the method to be executed IF it is a non-empty folder
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemDelete(project, item, confirm, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemItemDelete.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectItemItemDelete.');
                }
                // verify required parameter 'confirm' is not null or undefined
                if (confirm === null || confirm === undefined) {
                    throw new RequiredError('confirm', 'Required parameter confirm was null or undefined when calling projectItemItemDelete.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemItemDelete.');
                }
                const localVarPath = `/{project}/item/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (confirm !== undefined) {
                    localVarQueryParameter['confirm'] = confirm;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of an item. {item} has the form CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [withTree] (optional) retrieves the context tree if set to 1, in the field contextTree. Exclusive to filter and atDate
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemItemGet.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectItemItemGet.');
                }
                const localVarPath = `/{project}/item/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (history !== undefined) {
                    localVarQueryParameter['history'] = history;
                }
                if (fields !== undefined) {
                    localVarQueryParameter['fields'] = fields;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (atDate !== undefined) {
                    localVarQueryParameter['atDate'] = atDate;
                }
                if (withTree !== undefined) {
                    localVarQueryParameter['withTree'] = withTree;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Restores an item. Item has the form CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [at] (optional) If set, specifies that the item should be restored as it was in that version
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPost(project, item, reason, at, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemItemPost.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectItemItemPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemItemPost.');
                }
                const localVarPath = `/{project}/item/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (at !== undefined) {
                    localVarQueryParameter['at'] = at;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Modifies an item or a folder. Item has the form CATEG-number, folders -  F-CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [title] Specify new title for the item -- if not there, keep the old title
             * @param {string} [fxid_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [auditAction] (optional) Specify a new verb for the audit action. Defaults to edit
             * @param {string} [newFolder] (optional) Name of a new folder to move the item into (exclusive from title and fx arguments)
             * @param {number} [newPosition] (optional) Indicates a new position within the newfolder. If newFolder is not specified, only changes the position. Exclusive of title and fx arguments. Position is an integer starting at 1
             * @param {string} [filter] (optional) A filter
             * @param {string} [linksUp] (optional) Comma-delimited (%2C)list of references to up items
             * @param {string} [linksDown] (optional) Comma-delimited (%2C)list of references to down items
             * @param {number} [currentVersion] (optional) will not make the change if the current version is not that one
             * @param {number} [onlyThoseFields] (optional) when set to 1 says that the only fields to change are those passed
             * @param {number} [onlyThoseLabels] (optional) when set to 1 says that the only labels to change are those passed. To remove a label in this case, prefix it with minus
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemItemPut.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectItemItemPut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemItemPut.');
                }
                const localVarPath = `/{project}/item/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (title !== undefined) {
                    localVarQueryParameter['title'] = title;
                }
                if (fxid_ !== undefined) {
                    localVarQueryParameter['fx{id} ...'] = fxid_;
                }
                if (labels !== undefined) {
                    localVarQueryParameter['labels'] = labels;
                }
                if (auditAction !== undefined) {
                    localVarQueryParameter['auditAction'] = auditAction;
                }
                if (newFolder !== undefined) {
                    localVarQueryParameter['newFolder'] = newFolder;
                }
                if (newPosition !== undefined) {
                    localVarQueryParameter['newPosition'] = newPosition;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (linksUp !== undefined) {
                    localVarQueryParameter['linksUp'] = linksUp;
                }
                if (linksDown !== undefined) {
                    localVarQueryParameter['linksDown'] = linksDown;
                }
                if (currentVersion !== undefined) {
                    localVarQueryParameter['currentVersion'] = currentVersion;
                }
                if (onlyThoseFields !== undefined) {
                    localVarQueryParameter['onlyThoseFields'] = onlyThoseFields;
                }
                if (onlyThoseLabels !== undefined) {
                    localVarQueryParameter['onlyThoseLabels'] = onlyThoseLabels;
                }
                if (failOnCleanup !== undefined) {
                    localVarQueryParameter['failOnCleanup'] = failOnCleanup;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Adds an item in a folder
             * @param {string} project Project short label
             * @param {string} title Item title
             * @param {string} folder Reference of the folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} linksUp Comma-delimited (%2C)list of references to up items
             * @param {string} linksDown Comma-delimited (%2C)list of references to down items
             * @param {string} [fxID_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [author] The author (login name) - only works when superadmin is issuing this
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemPost.');
                }
                // verify required parameter 'title' is not null or undefined
                if (title === null || title === undefined) {
                    throw new RequiredError('title', 'Required parameter title was null or undefined when calling projectItemPost.');
                }
                // verify required parameter 'folder' is not null or undefined
                if (folder === null || folder === undefined) {
                    throw new RequiredError('folder', 'Required parameter folder was null or undefined when calling projectItemPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemPost.');
                }
                // verify required parameter 'linksUp' is not null or undefined
                if (linksUp === null || linksUp === undefined) {
                    throw new RequiredError('linksUp', 'Required parameter linksUp was null or undefined when calling projectItemPost.');
                }
                // verify required parameter 'linksDown' is not null or undefined
                if (linksDown === null || linksDown === undefined) {
                    throw new RequiredError('linksDown', 'Required parameter linksDown was null or undefined when calling projectItemPost.');
                }
                const localVarPath = `/{project}/item`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (title !== undefined) {
                    localVarQueryParameter['title'] = title;
                }
                if (folder !== undefined) {
                    localVarQueryParameter['folder'] = folder;
                }
                if (fxID_ !== undefined) {
                    localVarQueryParameter['fx{ID} ...'] = fxID_;
                }
                if (labels !== undefined) {
                    localVarQueryParameter['labels'] = labels;
                }
                if (author !== undefined) {
                    localVarQueryParameter['author'] = author;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (linksUp !== undefined) {
                    localVarQueryParameter['linksUp'] = linksUp;
                }
                if (linksDown !== undefined) {
                    localVarQueryParameter['linksDown'] = linksDown;
                }
                if (failOnCleanup !== undefined) {
                    localVarQueryParameter['failOnCleanup'] = failOnCleanup;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - ?. Valid from version 2.1
             * @summary Removes (inactivate) a link between 2 items. Items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemlinkUpitemDownitemDelete.');
                }
                // verify required parameter 'upitem' is not null or undefined
                if (upitem === null || upitem === undefined) {
                    throw new RequiredError('upitem', 'Required parameter upitem was null or undefined when calling projectItemlinkUpitemDownitemDelete.');
                }
                // verify required parameter 'downitem' is not null or undefined
                if (downitem === null || downitem === undefined) {
                    throw new RequiredError('downitem', 'Required parameter downitem was null or undefined when calling projectItemlinkUpitemDownitemDelete.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemlinkUpitemDownitemDelete.');
                }
                const localVarPath = `/{project}/itemlink/{upitem}/{downitem}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"upitem"}}`, encodeURIComponent(String(upitem)))
                    .replace(`{${"downitem"}}`, encodeURIComponent(String(downitem)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a link between 2 items. Both items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemlinkUpitemDownitemPost.');
                }
                // verify required parameter 'upitem' is not null or undefined
                if (upitem === null || upitem === undefined) {
                    throw new RequiredError('upitem', 'Required parameter upitem was null or undefined when calling projectItemlinkUpitemDownitemPost.');
                }
                // verify required parameter 'downitem' is not null or undefined
                if (downitem === null || downitem === undefined) {
                    throw new RequiredError('downitem', 'Required parameter downitem was null or undefined when calling projectItemlinkUpitemDownitemPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectItemlinkUpitemDownitemPost.');
                }
                const localVarPath = `/{project}/itemlink/{upitem}/{downitem}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"upitem"}}`, encodeURIComponent(String(upitem)))
                    .replace(`{${"downitem"}}`, encodeURIComponent(String(downitem)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get the list of items that are detailed in a DOC/SIGN item.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [detailed] Optional. When set to 1 adds a secondaryItems list in the answer. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlistItemGet(project, item, detailed, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectItemlistItemGet.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectItemlistItemGet.');
                }
                const localVarPath = `/{project}/itemlist/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (detailed !== undefined) {
                    localVarQueryParameter['detailed'] = detailed;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all jobs in a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectJobGet.');
                }
                const localVarPath = `/{project}/job`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Aborts a job.
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobDelete(project, job, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectJobJobDelete.');
                }
                // verify required parameter 'job' is not null or undefined
                if (job === null || job === undefined) {
                    throw new RequiredError('job', 'Required parameter job was null or undefined when calling projectJobJobDelete.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectJobJobDelete.');
                }
                const localVarPath = `/{project}/job/{job}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"job"}}`, encodeURIComponent(String(job)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job file. The job part is the jobID (a number) and the file is the fileID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} fileno file number
             * @param {string} [mode] (optional) set to mode&#x3D;direct to get the output in the response output instead of as a download file. This assumes the file is HTML
             * @param {string} [format] (optional) set to format&#x3D;json to get a json output instead of XML
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectJobJobFilenoGet.');
                }
                // verify required parameter 'job' is not null or undefined
                if (job === null || job === undefined) {
                    throw new RequiredError('job', 'Required parameter job was null or undefined when calling projectJobJobFilenoGet.');
                }
                // verify required parameter 'fileno' is not null or undefined
                if (fileno === null || fileno === undefined) {
                    throw new RequiredError('fileno', 'Required parameter fileno was null or undefined when calling projectJobJobFilenoGet.');
                }
                const localVarPath = `/{project}/job/{job}/{fileno}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"job"}}`, encodeURIComponent(String(job)))
                    .replace(`{${"fileno"}}`, encodeURIComponent(String(fileno)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (mode !== undefined) {
                    localVarQueryParameter['mode'] = mode;
                }
                if (format !== undefined) {
                    localVarQueryParameter['format'] = format;
                }
                if (disposition !== undefined) {
                    localVarQueryParameter['disposition'] = disposition;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job status, including generated files. The variable part is the jobID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobGet(project, job, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectJobJobGet.');
                }
                // verify required parameter 'job' is not null or undefined
                if (job === null || job === undefined) {
                    throw new RequiredError('job', 'Required parameter job was null or undefined when calling projectJobJobGet.');
                }
                const localVarPath = `/{project}/job/{job}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"job"}}`, encodeURIComponent(String(job)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Sets the progress of a job
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} progress progress (0 to 100, 200 for error)
             * @param {string} [status] (optional( status text
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobPost(project, job, progress, status, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectJobJobPost.');
                }
                // verify required parameter 'job' is not null or undefined
                if (job === null || job === undefined) {
                    throw new RequiredError('job', 'Required parameter job was null or undefined when calling projectJobJobPost.');
                }
                // verify required parameter 'progress' is not null or undefined
                if (progress === null || progress === undefined) {
                    throw new RequiredError('progress', 'Required parameter progress was null or undefined when calling projectJobJobPost.');
                }
                const localVarPath = `/{project}/job/{job}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"job"}}`, encodeURIComponent(String(job)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (progress !== undefined) {
                    localVarQueryParameter['progress'] = progress;
                }
                if (status !== undefined) {
                    localVarQueryParameter['status'] = status;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the label history of a project -  list of all label changes for all items
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) ask for just one item (the return structure is still an array in that case)
             * @param {string} [from] (optional) date from
             * @param {string} [to] (optional) date to - works only if you only specified a from
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectLabelhistoryGet(project, itemRef, from, to, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectLabelhistoryGet.');
                }
                const localVarPath = `/{project}/labelhistory`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (itemRef !== undefined) {
                    localVarQueryParameter['itemRef'] = itemRef;
                }
                if (from !== undefined) {
                    localVarQueryParameter['from'] = from;
                }
                if (to !== undefined) {
                    localVarQueryParameter['to'] = to;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge history of a project - needs the 'merge' module
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergehistoryGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectMergehistoryGet.');
                }
                const localVarPath = `/{project}/mergehistory`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge information - needs the 'merge' module
             * @param {string} project Project short label
             * @param {string} [excludeCategories] (optional) comma-delimited list of categories to exclude
             * @param {string} [fromDate] (optional) date from which we consider the merges. ISO8601 format -- this parameter was introduced in v 2.3.4
             * @param {number} [push] (optional) set to 1 if you inquire about a push, not a merge -- this parameter was introduced in v 2.3.4
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergeinfoGet(project, excludeCategories, fromDate, push, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectMergeinfoGet.');
                }
                const localVarPath = `/{project}/mergeinfo`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (excludeCategories !== undefined) {
                    localVarQueryParameter['excludeCategories'] = excludeCategories;
                }
                if (fromDate !== undefined) {
                    localVarQueryParameter['fromDate'] = fromDate;
                }
                if (push !== undefined) {
                    localVarQueryParameter['push'] = push;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Move items into this folder
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [items] List of items to move in
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMoveinFolderPost(project, folder, reason, items, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectMoveinFolderPost.');
                }
                // verify required parameter 'folder' is not null or undefined
                if (folder === null || folder === undefined) {
                    throw new RequiredError('folder', 'Required parameter folder was null or undefined when calling projectMoveinFolderPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectMoveinFolderPost.');
                }
                const localVarPath = `/{project}/movein/{folder}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (items !== undefined) {
                    localVarQueryParameter['items'] = items;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {number} [treeOrder] (optional) set to 1 to return items in tree order (otherwise it&#x27;s project,category,serial)
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectNeedleGet.');
                }
                // verify required parameter 'search' is not null or undefined
                if (search === null || search === undefined) {
                    throw new RequiredError('search', 'Required parameter search was null or undefined when calling projectNeedleGet.');
                }
                // verify required parameter 'id' is not null or undefined
                if (id === null || id === undefined) {
                    throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectNeedleGet.');
                }
                const localVarPath = `/{project}/needle`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (search !== undefined) {
                    localVarQueryParameter['search'] = search;
                }
                if (id !== undefined) {
                    localVarQueryParameter['id'] = id;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (fieldsOut !== undefined) {
                    localVarQueryParameter['fieldsOut'] = fieldsOut;
                }
                if (labels !== undefined) {
                    localVarQueryParameter['labels'] = labels;
                }
                if (treeOrder !== undefined) {
                    localVarQueryParameter['treeOrder'] = treeOrder;
                }
                if (links !== undefined) {
                    localVarQueryParameter['links'] = links;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleminimalGet(project, search, filter, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectNeedleminimalGet.');
                }
                // verify required parameter 'search' is not null or undefined
                if (search === null || search === undefined) {
                    throw new RequiredError('search', 'Required parameter search was null or undefined when calling projectNeedleminimalGet.');
                }
                const localVarPath = `/{project}/needleminimal`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (search !== undefined) {
                    localVarQueryParameter['search'] = search;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a category to a project
             * @param {string} project Project short label
             * @param {string} label Category label
             * @param {string} shortLabel Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPost(project, label, shortLabel, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectPost.');
                }
                // verify required parameter 'shortLabel' is not null or undefined
                if (shortLabel === null || shortLabel === undefined) {
                    throw new RequiredError('shortLabel', 'Required parameter shortLabel was null or undefined when calling projectPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectPost.');
                }
                const localVarPath = `/{project}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (shortLabel !== undefined) {
                    localVarQueryParameter['shortLabel'] = shortLabel;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Publishes an item. Item has the form PUB-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason reason for the publication
             * @param {string} [trainingFor] (optional) list of items for which we need to add training. If list is not there, all trainings will be generated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPublishItemPost(project, item, reason, trainingFor, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectPublishItemPost.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectPublishItemPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectPublishItemPost.');
                }
                const localVarPath = `/{project}/publish/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (trainingFor !== undefined) {
                    localVarQueryParameter['trainingFor'] = trainingFor;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.3
             * @summary Find a string in the QMS published items
             * @param {string} project Project short label
             * @param {string} [search] (optional) search term. Return an empty array on PUB &lt; 2.3.1 and et the list of all pub if not specified.
             * @param {string} [pubItem] (optional) PUB-x item if you want to search in another than the last one for that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectQmsfindGet(project, search, pubItem, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectQmsfindGet.');
                }
                const localVarPath = `/{project}/qmsfind`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (search !== undefined) {
                    localVarQueryParameter['search'] = search;
                }
                if (pubItem !== undefined) {
                    localVarQueryParameter['pubItem'] = pubItem;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) for the reports, read/write for the signed reports. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer. {report} can be REPORT-n, DOC-n, SIGN-n or a report name.To follow the progress of the job, the GET /{project}/job/{jobid} can be called
             * @param {string} project Project short label
             * @param {string} report name of the report
             * @param {string} isSignedReport If set to true, means the report needs to generate a signed record
             * @param {string} includeSignatures List of comma separated users who need to sign
             * @param {string} newTitle New title for the SIGN- item that is generated (only valid for isSignedReport)
             * @param {string} copyFields List of from-to fields (123,456),(124,457) that we can use to generate the fields in the SIGN record (only valid for isSignedReport)
             * @param {string} [itemList] (optional) list of items to use in the report. By default all categories are used
             * @param {string} [input_url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx, zippdf or package (from 2.2), or mf (since 2.3)
             * @param {string} [filter] (optional) specify a comma-delimited filter list. Can be negative filters (with minus before)
             * @param {number} [useOld] (optional) ask to use the old report engine (pre 1.11) if set to 1.
             * @param {string} [atDate] (optional) generates the report at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, input_url, resturl, format, filter, useOld, atDate, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectReportReportPost.');
                }
                // verify required parameter 'report' is not null or undefined
                if (report === null || report === undefined) {
                    throw new RequiredError('report', 'Required parameter report was null or undefined when calling projectReportReportPost.');
                }
                // verify required parameter 'isSignedReport' is not null or undefined
                if (isSignedReport === null || isSignedReport === undefined) {
                    throw new RequiredError('isSignedReport', 'Required parameter isSignedReport was null or undefined when calling projectReportReportPost.');
                }
                // verify required parameter 'includeSignatures' is not null or undefined
                if (includeSignatures === null || includeSignatures === undefined) {
                    throw new RequiredError('includeSignatures', 'Required parameter includeSignatures was null or undefined when calling projectReportReportPost.');
                }
                // verify required parameter 'newTitle' is not null or undefined
                if (newTitle === null || newTitle === undefined) {
                    throw new RequiredError('newTitle', 'Required parameter newTitle was null or undefined when calling projectReportReportPost.');
                }
                // verify required parameter 'copyFields' is not null or undefined
                if (copyFields === null || copyFields === undefined) {
                    throw new RequiredError('copyFields', 'Required parameter copyFields was null or undefined when calling projectReportReportPost.');
                }
                const localVarPath = `/{project}/report/{report}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"report"}}`, encodeURIComponent(String(report)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (itemList !== undefined) {
                    localVarQueryParameter['itemList'] = itemList;
                }
                if (input_url !== undefined) {
                    localVarQueryParameter['url'] = input_url;
                }
                if (resturl !== undefined) {
                    localVarQueryParameter['resturl'] = resturl;
                }
                if (format !== undefined) {
                    localVarQueryParameter['format'] = format;
                }
                if (isSignedReport !== undefined) {
                    localVarQueryParameter['isSignedReport'] = isSignedReport;
                }
                if (includeSignatures !== undefined) {
                    localVarQueryParameter['includeSignatures'] = includeSignatures;
                }
                if (newTitle !== undefined) {
                    localVarQueryParameter['newTitle'] = newTitle;
                }
                if (copyFields !== undefined) {
                    localVarQueryParameter['copyFields'] = copyFields;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (useOld !== undefined) {
                    localVarQueryParameter['useOld'] = useOld;
                }
                if (atDate !== undefined) {
                    localVarQueryParameter['atDate'] = atDate;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} project Project short label
             * @param {number} [simple] (optional) set to simple&#x3D;1 to have a simpler output (no fields, round shape)
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSchemaGet(project, simple, excludeCategories, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSchemaGet.');
                }
                const localVarPath = `/{project}/schema`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (simple !== undefined) {
                    localVarQueryParameter['simple'] = simple;
                }
                if (excludeCategories !== undefined) {
                    localVarQueryParameter['excludeCategories'] = excludeCategories;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all settings of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSettingGet.');
                }
                const localVarPath = `/{project}/setting`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds or changes a project setting. If the value is empty, the setting will be deleted.
             * @param {string} project Project short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingPost(project, key, value, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSettingPost.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling projectSettingPost.');
                }
                // verify required parameter 'value' is not null or undefined
                if (value === null || value === undefined) {
                    throw new RequiredError('value', 'Required parameter value was null or undefined when calling projectSettingPost.');
                }
                const localVarPath = `/{project}/setting`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Signs an item. Item has the form SIGN-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} password signature password - the user who is signing is the one who is logged in
             * @param {string} [acceptComments] (optional) adds an acceptance comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPost(project, item, password, acceptComments, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSignItemPost.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectSignItemPost.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling projectSignItemPost.');
                }
                const localVarPath = `/{project}/sign/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                if (acceptComments !== undefined) {
                    localVarQueryParameter['acceptComments'] = acceptComments;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Edit the signature parts
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} rejectSign The reason why the user is rejecting the signature
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPut(project, item, rejectSign, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSignItemPut.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectSignItemPut.');
                }
                // verify required parameter 'rejectSign' is not null or undefined
                if (rejectSign === null || rejectSign === undefined) {
                    throw new RequiredError('rejectSign', 'Required parameter rejectSign was null or undefined when calling projectSignItemPut.');
                }
                const localVarPath = `/{project}/sign/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (rejectSign !== undefined) {
                    localVarQueryParameter['rejectSign'] = rejectSign;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} [input_url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx or zippdf
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignedreportSIGNNPost(project, input_url, resturl, format, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectSignedreportSIGNNPost.');
                }
                const localVarPath = `/{project}/signedreport/SIGN-n`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (input_url !== undefined) {
                    localVarQueryParameter['url'] = input_url;
                }
                if (resturl !== undefined) {
                    localVarQueryParameter['resturl'] = resturl;
                }
                if (format !== undefined) {
                    localVarQueryParameter['format'] = format;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all tags of a project. Works on any project if user is admin
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagGet(project, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTagGet.');
                }
                const localVarPath = `/{project}/tag`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a tag to a project
             * @param {string} project Project short label
             * @param {string} label Tag label. Must be unique within a project
             * @param {number} auditId Id of the audit this tag is based on
             * @param {string} type Type of tag (default -  tag)
             * @param {string} comments Free optional comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagPost(project, label, auditId, type, comments, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTagPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling projectTagPost.');
                }
                // verify required parameter 'auditId' is not null or undefined
                if (auditId === null || auditId === undefined) {
                    throw new RequiredError('auditId', 'Required parameter auditId was null or undefined when calling projectTagPost.');
                }
                // verify required parameter 'type' is not null or undefined
                if (type === null || type === undefined) {
                    throw new RequiredError('type', 'Required parameter type was null or undefined when calling projectTagPost.');
                }
                // verify required parameter 'comments' is not null or undefined
                if (comments === null || comments === undefined) {
                    throw new RequiredError('comments', 'Required parameter comments was null or undefined when calling projectTagPost.');
                }
                const localVarPath = `/{project}/tag`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (auditId !== undefined) {
                    localVarQueryParameter['auditId'] = auditId;
                }
                if (type !== undefined) {
                    localVarQueryParameter['type'] = type;
                }
                if (comments !== undefined) {
                    localVarQueryParameter['comments'] = comments;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for oneproject
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) set to an item to have all todos linked to an item, regardless of the user
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeAllUsers] (optional) set to 1 to include all todos for all users
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTodoGet.');
                }
                const localVarPath = `/{project}/todo`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (itemRef !== undefined) {
                    localVarQueryParameter['itemRef'] = itemRef;
                }
                if (includeDone !== undefined) {
                    localVarQueryParameter['includeDone'] = includeDone;
                }
                if (includeAllUsers !== undefined) {
                    localVarQueryParameter['includeAllUsers'] = includeAllUsers;
                }
                if (includeFuture !== undefined) {
                    localVarQueryParameter['includeFuture'] = includeFuture;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Creates a todo on an item (note that you only need read access for this POST method) for you or others
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} text The todo reason
             * @param {number} [fieldId] (optional) If set, specifies that the todo is related to that field (review, ...)
             * @param {string} [logins] (optional) If set, a list of user logins or groups to which these todo apply
             * @param {string} [todoType] (optional) The todo type -  &#x27;user&#x27; by default
             * @param {string} [atDate] (optional) a date in the future for reminders
             * @param {number} [auto] (optional) set to 1 to create an auto-notification (0 by default)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTodoItemPost.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectTodoItemPost.');
                }
                // verify required parameter 'text' is not null or undefined
                if (text === null || text === undefined) {
                    throw new RequiredError('text', 'Required parameter text was null or undefined when calling projectTodoItemPost.');
                }
                const localVarPath = `/{project}/todo/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (fieldId !== undefined) {
                    localVarQueryParameter['fieldId'] = fieldId;
                }
                if (logins !== undefined) {
                    localVarQueryParameter['logins'] = logins;
                }
                if (text !== undefined) {
                    localVarQueryParameter['text'] = text;
                }
                if (todoType !== undefined) {
                    localVarQueryParameter['todoType'] = todoType;
                }
                if (atDate !== undefined) {
                    localVarQueryParameter['atDate'] = atDate;
                }
                if (auto !== undefined) {
                    localVarQueryParameter['auto'] = auto;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Removes (mark as done) a todo.
             * @param {string} project Project short label
             * @param {string} todoid todoid
             * @param {string} hardDelete Set to yes to actually remove the record
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoTodoidDelete(project, todoid, hardDelete, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTodoTodoidDelete.');
                }
                // verify required parameter 'todoid' is not null or undefined
                if (todoid === null || todoid === undefined) {
                    throw new RequiredError('todoid', 'Required parameter todoid was null or undefined when calling projectTodoTodoidDelete.');
                }
                // verify required parameter 'hardDelete' is not null or undefined
                if (hardDelete === null || hardDelete === undefined) {
                    throw new RequiredError('hardDelete', 'Required parameter hardDelete was null or undefined when calling projectTodoTodoidDelete.');
                }
                const localVarPath = `/{project}/todo/{todoid}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"todoid"}}`, encodeURIComponent(String(todoid)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (hardDelete !== undefined) {
                    localVarQueryParameter['hardDelete'] = hardDelete;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Touches (set to same date) an item or folder
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [nbLayers] (optional) Number of layers -- 1 by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTouchItemPut(project, item, reason, nbLayers, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTouchItemPut.');
                }
                // verify required parameter 'item' is not null or undefined
                if (item === null || item === undefined) {
                    throw new RequiredError('item', 'Required parameter item was null or undefined when calling projectTouchItemPut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectTouchItemPut.');
                }
                const localVarPath = `/{project}/touch/{item}`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                    .replace(`{${"item"}}`, encodeURIComponent(String(item)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (nbLayers !== undefined) {
                    localVarQueryParameter['nbLayers'] = nbLayers;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get full tree
             * @param {string} project Project short label
             * @param {string} [fancy] (optional) returns a fancy tree
             * @param {string} [filter] (optional) applies a filter
             * @param {string} [atDate] (optional) generates the tree at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTreeGet(project, fancy, filter, atDate, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectTreeGet.');
                }
                const localVarPath = `/{project}/tree`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (fancy !== undefined) {
                    localVarQueryParameter['fancy'] = fancy;
                }
                if (filter !== undefined) {
                    localVarQueryParameter['filter'] = filter;
                }
                if (atDate !== undefined) {
                    localVarQueryParameter['atDate'] = atDate;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Unhides a project.
             * @param {string} project Project short label
             * @param {string} newShort The new project short name to use
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectUnhidePut(project, newShort, reason, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectUnhidePut.');
                }
                // verify required parameter 'newShort' is not null or undefined
                if (newShort === null || newShort === undefined) {
                    throw new RequiredError('newShort', 'Required parameter newShort was null or undefined when calling projectUnhidePut.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectUnhidePut.');
                }
                const localVarPath = `/{project}/unhide`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (newShort !== undefined) {
                    localVarQueryParameter['newShort'] = newShort;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Converts a word document to an HTML, with images pointing to uploaded files on the server
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {number} [fileNo] If specified, means that the conversion is from an already uploaded file. Otherwise the file must be uploaded as body of this call
             * @param {string} [targetDocumentFolder] target document folder (in this case creates a document)
             * @param {number} [useAsField] set to 1 to have this docx used as a field. In this case the return value is the html equivalent, with some meta
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options = {}) {
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling projectWordconvertPost.');
                }
                // verify required parameter 'reason' is not null or undefined
                if (reason === null || reason === undefined) {
                    throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling projectWordconvertPost.');
                }
                const localVarPath = `/{project}/wordconvert`
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (fileNo !== undefined) {
                    localVarQueryParameter['fileNo'] = fileNo;
                }
                if (targetDocumentFolder !== undefined) {
                    localVarQueryParameter['targetDocumentFolder'] = targetDocumentFolder;
                }
                if (useAsField !== undefined) {
                    localVarQueryParameter['useAsField'] = useAsField;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get list of all projects, all settings and current user, all todos and JIRA meta create object
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have all projects even the ones you are not assigned to, as an admin
             * @param {string} [output] (optional) comma-delimited list of requested output fields. Returns all fields if parameter is not present
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootGet(adminUI, output, options = {}) {
                const localVarPath = `/`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (adminUI !== undefined) {
                    localVarQueryParameter['adminUI'] = adminUI;
                }
                if (output !== undefined) {
                    localVarQueryParameter['output'] = output;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new project. Either the full project is sent as XML payload, or the label and shortLabel are given. If uploading data for a whole project, label and shortLabel are optional but overwrite the XML content if present. Branching can be done with an audit report as payload, and branch* must be defined in that case
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {string} [overwrite] Must be set to yes if you&#x27;re overwriting an existing project
             * @param {string} [importUsers] Must be set to yes if you want to import users. false by default
             * @param {string} [branchLabel] Must be set to branch (optional)
             * @param {string} [branchTag] Must be set to branch, and match a tag in the audit export (optional)
             * @param {string} [branchComment] Comment for the branch (optional)
             * @param {string} [branchBaseProjectLabel] Label of the base Project (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options = {}) {
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new RequiredError('label', 'Required parameter label was null or undefined when calling rootPost.');
                }
                // verify required parameter 'shortLabel' is not null or undefined
                if (shortLabel === null || shortLabel === undefined) {
                    throw new RequiredError('shortLabel', 'Required parameter shortLabel was null or undefined when calling rootPost.');
                }
                const localVarPath = `/`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (label !== undefined) {
                    localVarQueryParameter['label'] = label;
                }
                if (shortLabel !== undefined) {
                    localVarQueryParameter['shortLabel'] = shortLabel;
                }
                if (overwrite !== undefined) {
                    localVarQueryParameter['overwrite'] = overwrite;
                }
                if (importUsers !== undefined) {
                    localVarQueryParameter['importUsers'] = importUsers;
                }
                if (branchLabel !== undefined) {
                    localVarQueryParameter['branchLabel'] = branchLabel;
                }
                if (branchTag !== undefined) {
                    localVarQueryParameter['branchTag'] = branchTag;
                }
                if (branchComment !== undefined) {
                    localVarQueryParameter['branchComment'] = branchComment;
                }
                if (branchBaseProjectLabel !== undefined) {
                    localVarQueryParameter['branchBaseProjectLabel'] = branchBaseProjectLabel;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Retrieves the user list
             * @param {string} details (optional) -  if set to 1 returns all details
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userGet(details, options = {}) {
                // verify required parameter 'details' is not null or undefined
                if (details === null || details === undefined) {
                    throw new RequiredError('details', 'Required parameter details was null or undefined when calling userGet.');
                }
                const localVarPath = `/user`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (details !== undefined) {
                    localVarQueryParameter['details'] = details;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new user. Arguments are either a set of arguments or json
             * @param {string} login User login name
             * @param {string} email User email
             * @param {string} password User password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userPost(login, email, password, json, first, last, options = {}) {
                // verify required parameter 'login' is not null or undefined
                if (login === null || login === undefined) {
                    throw new RequiredError('login', 'Required parameter login was null or undefined when calling userPost.');
                }
                // verify required parameter 'email' is not null or undefined
                if (email === null || email === undefined) {
                    throw new RequiredError('email', 'Required parameter email was null or undefined when calling userPost.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userPost.');
                }
                // verify required parameter 'json' is not null or undefined
                if (json === null || json === undefined) {
                    throw new RequiredError('json', 'Required parameter json was null or undefined when calling userPost.');
                }
                const localVarPath = `/user`;
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (login !== undefined) {
                    localVarQueryParameter['login'] = login;
                }
                if (email !== undefined) {
                    localVarQueryParameter['email'] = email;
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                if (first !== undefined) {
                    localVarQueryParameter['first'] = first;
                }
                if (last !== undefined) {
                    localVarQueryParameter['last'] = last;
                }
                if (json !== undefined) {
                    localVarQueryParameter['json'] = json;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all actions of a user
             * @param {string} user user login name
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserAuditGet(user, startAt, maxResults, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserAuditGet.');
                }
                const localVarPath = `/user/{user}/audit`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (startAt !== undefined) {
                    localVarQueryParameter['startAt'] = startAt;
                }
                if (maxResults !== undefined) {
                    localVarQueryParameter['maxResults'] = maxResults;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckGet(user, password, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserCheckGet.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userUserCheckGet.');
                }
                const localVarPath = `/user/{user}/check`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckPost(user, password, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserCheckPost.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userUserCheckPost.');
                }
                const localVarPath = `/user/{user}/check`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a user (only used for unit testing)
             * @param {string} user user login name
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserDelete(user, confirm, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserDelete.');
                }
                // verify required parameter 'confirm' is not null or undefined
                if (confirm === null || confirm === undefined) {
                    throw new RequiredError('confirm', 'Required parameter confirm was null or undefined when calling userUserDelete.');
                }
                const localVarPath = `/user/{user}`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (confirm !== undefined) {
                    localVarQueryParameter['confirm'] = confirm;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves full details of a user
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserGet(user, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserGet.');
                }
                const localVarPath = `/user/{user}`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Login
             * @param {string} user user login name
             * @param {string} password password in clear
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLoginPost(user, password, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserLoginPost.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userUserLoginPost.');
                }
                const localVarPath = `/user/{user}/login`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Logout
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLogoutPost(user, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserLogoutPost.');
                }
                const localVarPath = `/user/{user}/logout`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Sets a new password for an account that has a password_reset token in place (the {user} in the URL doesn't matter)
             * @param {string} user user login name
             * @param {string} token password_reset token
             * @param {string} password New password to use from now on
             * @param {string} [signaturePassword] (optional) New password to use from now on for signatures
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPasswordResetPost(user, token, password, signaturePassword, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserPasswordResetPost.');
                }
                // verify required parameter 'token' is not null or undefined
                if (token === null || token === undefined) {
                    throw new RequiredError('token', 'Required parameter token was null or undefined when calling userUserPasswordResetPost.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userUserPasswordResetPost.');
                }
                const localVarPath = `/user/{user}/password_reset`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (token !== undefined) {
                    localVarQueryParameter['token'] = token;
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                if (signaturePassword !== undefined) {
                    localVarQueryParameter['signature_password'] = signaturePassword;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a user to a project
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin, 4 for visitor
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPost(user, project, permission, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserProjectPost.');
                }
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling userUserProjectPost.');
                }
                // verify required parameter 'permission' is not null or undefined
                if (permission === null || permission === undefined) {
                    throw new RequiredError('permission', 'Required parameter permission was null or undefined when calling userUserProjectPost.');
                }
                const localVarPath = `/user/{user}/{project}`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (permission !== undefined) {
                    localVarQueryParameter['permission'] = permission;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Edits the user permissions in a project. If permission is 0, it means the user has no longer access (but we retain its records for audit purposes)
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPut(user, project, permission, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserProjectPut.');
                }
                // verify required parameter 'project' is not null or undefined
                if (project === null || project === undefined) {
                    throw new RequiredError('project', 'Required parameter project was null or undefined when calling userUserProjectPut.');
                }
                // verify required parameter 'permission' is not null or undefined
                if (permission === null || permission === undefined) {
                    throw new RequiredError('permission', 'Required parameter permission was null or undefined when calling userUserProjectPut.');
                }
                const localVarPath = `/user/{user}/{project}`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                    .replace(`{${"project"}}`, encodeURIComponent(String(project)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (permission !== undefined) {
                    localVarQueryParameter['permission'] = permission;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all projects a user has access to
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectsGet(user, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserProjectsGet.');
                }
                const localVarPath = `/user/{user}/projects`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Edits the user details. Arguments are all separated or a single json argument. Regular users can only change their signature and passwords.
             * @param {string} user user login name
             * @param {string} email User new email
             * @param {string} password User new password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPut(user, email, password, json, first, last, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserPut.');
                }
                // verify required parameter 'email' is not null or undefined
                if (email === null || email === undefined) {
                    throw new RequiredError('email', 'Required parameter email was null or undefined when calling userUserPut.');
                }
                // verify required parameter 'password' is not null or undefined
                if (password === null || password === undefined) {
                    throw new RequiredError('password', 'Required parameter password was null or undefined when calling userUserPut.');
                }
                // verify required parameter 'json' is not null or undefined
                if (json === null || json === undefined) {
                    throw new RequiredError('json', 'Required parameter json was null or undefined when calling userUserPut.');
                }
                const localVarPath = `/user/{user}`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (email !== undefined) {
                    localVarQueryParameter['email'] = email;
                }
                if (password !== undefined) {
                    localVarQueryParameter['password'] = password;
                }
                if (first !== undefined) {
                    localVarQueryParameter['first'] = first;
                }
                if (last !== undefined) {
                    localVarQueryParameter['last'] = last;
                }
                if (json !== undefined) {
                    localVarQueryParameter['json'] = json;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a user login
             * @param {string} user user login name
             * @param {string} newLogin The new login name. Cannot be one of the existing
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserRenamePut(user, newLogin, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserRenamePut.');
                }
                // verify required parameter 'newLogin' is not null or undefined
                if (newLogin === null || newLogin === undefined) {
                    throw new RequiredError('newLogin', 'Required parameter newLogin was null or undefined when calling userUserRenamePut.');
                }
                const localVarPath = `/user/{user}/rename`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (newLogin !== undefined) {
                    localVarQueryParameter['newLogin'] = newLogin;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds or deletes a user setting.
             * @param {string} user user login name
             * @param {string} key Name of the setting
             * @param {string} value Value of the setting. If empty, deletes the setting.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserSettingPost(user, key, value, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserSettingPost.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new RequiredError('key', 'Required parameter key was null or undefined when calling userUserSettingPost.');
                }
                // verify required parameter 'value' is not null or undefined
                if (value === null || value === undefined) {
                    throw new RequiredError('value', 'Required parameter value was null or undefined when calling userUserSettingPost.');
                }
                const localVarPath = `/user/{user}/setting`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (key !== undefined) {
                    localVarQueryParameter['key'] = key;
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Sets the new status of the user. Can be normal,blocked or deleted
             * @param {string} user user login name
             * @param {string} status Can be normal,blocked or deleted
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserStatusPut(user, status, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserStatusPut.');
                }
                // verify required parameter 'status' is not null or undefined
                if (status === null || status === undefined) {
                    throw new RequiredError('status', 'Required parameter status was null or undefined when calling userUserStatusPut.');
                }
                const localVarPath = `/user/{user}/status`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (status !== undefined) {
                    localVarQueryParameter['status'] = status;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Removes a user token
             * @param {string} user user login name
             * @param {string} value The token to be removed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenDelete(user, value, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserTokenDelete.');
                }
                // verify required parameter 'value' is not null or undefined
                if (value === null || value === undefined) {
                    throw new RequiredError('value', 'Required parameter value was null or undefined when calling userUserTokenDelete.');
                }
                const localVarPath = `/user/{user}/token`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds a token for a user
             * @param {string} user user login name
             * @param {string} purpose Purpose of the token. Not checked. Should contain either \&quot;password_reset\&quot; or \&quot;oauth\&quot;
             * @param {string} [value] Value of the token - by default generated by this call
             * @param {string} [reason] Free text explain where the token will be used (URL or others). Should be set for oauth, not needed for others
             * @param {number} [validity] Validity of the token in hours - if not set, doesn&#x27;t expire
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenPost(user, purpose, value, reason, validity, options = {}) {
                // verify required parameter 'user' is not null or undefined
                if (user === null || user === undefined) {
                    throw new RequiredError('user', 'Required parameter user was null or undefined when calling userUserTokenPost.');
                }
                // verify required parameter 'purpose' is not null or undefined
                if (purpose === null || purpose === undefined) {
                    throw new RequiredError('purpose', 'Required parameter purpose was null or undefined when calling userUserTokenPost.');
                }
                const localVarPath = `/user/{user}/token`
                    .replace(`{${"user"}}`, encodeURIComponent(String(user)));
                const localVarUrlObj = url.parse(localVarPath, true);
                const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
                const localVarHeaderParameter = {};
                const localVarQueryParameter = {};
                // authentication ApiKeyAuth required
                if (configuration && configuration.apiKey) {
                    const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                        ? configuration.apiKey("Authorization")
                        : configuration.apiKey;
                    localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
                }
                // authentication BasicAuth required
                // http basic authentication required
                if (configuration && (configuration.username || configuration.password)) {
                    localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
                }
                if (value !== undefined) {
                    localVarQueryParameter['value'] = value;
                }
                if (purpose !== undefined) {
                    localVarQueryParameter['purpose'] = purpose;
                }
                if (reason !== undefined) {
                    localVarQueryParameter['reason'] = reason;
                }
                if (validity !== undefined) {
                    localVarQueryParameter['validity'] = validity;
                }
                localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
                // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                delete localVarUrlObj.search;
                localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
                return {
                    url: url.format(localVarUrlObj),
                    options: localVarRequestOptions,
                };
            },
        };
    };
    /**
     * DefaultApi - functional programming interface
     * @export
     */
    exports.DefaultApiFp = function (configuration) {
        return {
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Asks for the difference between A and B html exerpts, and produce the B html with annotations
             * @param {string} [arg] json object with the arguments
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allCompareHtmlPost(arg, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allCompareHtmlPost(arg, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Returns all info about a date
             * @param {string} [date] (optional) an input date formatted as iso8601. If not present, current date/time is used
             * @param {string} [dateformat] (optional) a date formatter. If not present, current date format is used
             * @param {string} [timeformat] (optional) a date-time formatter. If not present, current date/time format is used
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allDateGet(date, dateformat, timeformat, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allDateGet(date, dateformat, timeformat, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one customer file. The fileno is a simple fileId. This request returns the actual file
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileFilenoGet(fileno, key, disposition, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allFileFilenoGet(fileno, key, disposition, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieve list of all customer-wide files
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allFileGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a new customer-wide file - the file should be uploaded as payload. Its mime type should be sent through the HTTP protocol.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFilePost(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allFilePost(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Retrieve license status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLicenseGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allLicenseGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Adds a log entry (server side).
             * @param {string} message Message to log
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLogPost(message, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allLogPost(message, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Monitoring object
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allMonitorGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allMonitorGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in all projects
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleGet(search, id, filter, fieldsOut, labels, links, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allNeedleGet(search, id, filter, fieldsOut, labels, links, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in all projects
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleminimalGet(search, filter, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allNeedleminimalGet(search, filter, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.2
             * @summary The OpenAPI 3.0 definition of our REST API
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allOpenapiGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allOpenapiGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Lists all reports
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allReportsGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allReportsGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Sends an email. Non-optional parameters are sent as a POST JSON payload.
             * @param {SendmailParam} [body] Necessary information to send a mail
             * @param {number} [system] (optional) if set to 1 makes it a system email (not sent by the actual user)
             * @param {number} [noreply] (optional) if set to 1 makes it a no-reply email (not sent by the actual user)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSendmailPost(body, system, noreply, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allSendmailPost(body, system, noreply, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a service desk issue. The parameters are sent as a POST JSON payload.
             * @param {ServiceDeskParam} [body] Necessary information to send a mail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allServicedeskPost(body, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allServicedeskPost(body, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a customer
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allSettingGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a customer setting. If the value is empty, the setting will be deleted.
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingPost(key, value, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allSettingPost(key, value, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get instance status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allStatusGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allStatusGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Returns all accepted time zones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTimezoneGet(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allTimezoneGet(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for all projects
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTodoGet(includeDone, includeFuture, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allTodoGet(includeDone, includeFuture, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary WebHook
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allWebhookPost(options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).allWebhookPost(options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Retrieves the group list
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGet(details, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGet(details, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a group
             * @param {string} groupId group Id
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdDelete(groupId, confirm, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdDelete(groupId, confirm, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.2
             * @summary Retrieves details of a group
             * @param {string} groupId group Id
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdGet(groupId, details, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdGet(groupId, details, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Adds a group to a project (or removes it)
             * @param {string} groupId group Id
             * @param {string} project Project short label
             * @param {number} [permission] Specify the (new) permission for that group in that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdProjectProjectPost(groupId, project, permission, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdProjectProjectPost(groupId, project, permission, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a group
             * @param {string} groupId group Id
             * @param {string} newName The new group name. Cannot be one of the existing. Must start with &#x27;group.&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdRenamePut(groupId, newName, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdRenamePut(groupId, newName, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.2
             * @summary Adds a user to a group
             * @param {string} groupId group Id
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserUserPut(groupId, user, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdUserUserPut(groupId, user, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Sets all users of a group (replacing potential former content)
             * @param {string} groupId group Id
             * @param {string} users List of all users members of that group, commas-separated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserlistPut(groupId, users, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupIdUserlistPut(groupId, users, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Creates a new group
             * @param {string} groupName group name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNamePost(groupName, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupNamePost(groupName, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a user from a group
             * @param {string} groupName group name
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNameUserUserDelete(groupName, user, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).groupGroupNameUserUserDelete(groupName, user, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.3
             * @summary Merge branch into mainline. First project is the mainline, second is the branch. The payload must contain a json object with a list of actions to perform.
             * @param {string} mainproject mainproject
             * @param {string} branchproject branchproject
             * @param {string} reason The reason why the user is doing this
             * @param {MergeParam} [body] Actions to perform
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.2
             * @summary Retrieves all accesses in a project (list of groups and users who have access)
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAccessGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectAccessGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieves all changes in a project
             * @param {string} project Project short label
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {string} [deleteOnly] (optional) if set to yes, only returns actions of type delete
             * @param {string} [tech] (optional) if set to yes, returns the underneath changes
             * @param {number} [auditIdMin] (optional) sets a minimum ID for audits, as returned by GET calendar
             * @param {number} [auditIdMax] (optional) sets a maximum ID for audits
             * @param {number} [noReport] (optional) set to 1 to avoid having reports
             * @param {number} [noImport] (optional) set to 1 to avoid having imports
             * @param {string} [include] (optional) set to a list of actions to include (delete,undelete,add,edit,...)
             * @param {number} [resolveRef] (optional) set to 1 to resolve item IDs into refs
             * @param {string} [itemRef] (optional) restrict the audit to only those mentionning this item
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Launches a server-side branch or clone - needs the 'merge' module if actual branching
             * @param {string} project Project short label
             * @param {string} label Branch project label
             * @param {string} shortLabel Branch project short label
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after branching)
             * @param {number} keepContent 1 or 0. Defaults to 1. 0 only works without branch and without history
             * @param {number} [branch] (optional) Set to 1 to branch (default), 0 to just copy/clone
             * @param {number} [history] (optional) Set to 1 to branch or copy with history, defaults to 0
             * @param {string} [tagToCreate] (optional) specify a tag (by default auto-generated)
             * @param {string} [branchInThePastTag] (optional) specify a tag to branch in the past (needs history&#x3D;1)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all dates at which a project has been modified
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCalendarGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCalendarGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a category. Will fail on REPORT and FOLDER categories
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryDelete(project, category, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatCategoryDelete(project, category, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} [filter] (optional) specify a filter
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryGet(project, category, filter, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatCategoryGet(project, category, filter, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a categorie's labels, and fix the project's settings to reflect that change, OR modifies a category's order.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} order The new order (for reordering)
             * @param {string} shortLabel The new short label for that category (for renaming)
             * @param {string} label The new long label for that category (for renaming)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryPut(project, category, order, shortLabel, label, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatCategoryPut(project, category, order, shortLabel, label, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingGet(project, category, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatCategorySettingGet(project, category, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a category setting. If the value is empty, the setting will be deleted
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingPost(project, category, key, value, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatCategorySettingPost(project, category, key, value, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all categories of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a fields in a category
             * @param {string} project Project short label
             * @param {string} label Field label
             * @param {string} category Category short label
             * @param {string} fieldType Type of field
             * @param {string} fieldParam Parameter for the field
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatPost(project, label, category, fieldType, fieldParam, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCatPost(project, label, category, fieldType, fieldParam, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Clones a project
             * @param {string} project Project short label
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {number} keepHistory 1 or 0. Defaults to 0
             * @param {number} keepContent 1 or 0. Defaults to 0 (only the REPORT part is kept, make sense only if keepHistory is 0)
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after cloning)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for the difference between 2 signed documents, as a Word document. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} signitem1 SIGN-xx for the first SIGN document to compare
             * @param {string} signitem2 SIGN-xx for the 2nd SIGN document to compare
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectConfigcheckGet(excludeCategories, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectConfigcheckGet(excludeCategories, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.2
             * @summary Copy items from a folder to another one
             * @param {string} project Project short label
             * @param {string} itemOrFolder Item reference (XXX-nn) or folder (F-XXX-nn)
             * @param {string} targetFolder Reference of the target folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [targetProject] (optional) project to copy into (by default, same project)
             * @param {number} [copyLabels] (optional) 0 or 1. Defaults to 0
             * @param {string} [map] (optional) mapN&#x3D;M -  map field N in source to field M in target
             * @param {string} [ignoreLabels] (optional) can contain a comma-delimited list of labels NOT to copy
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a project (only used for unit testing). This is an actual DELETE in the database.
             * @param {string} project Project short label
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectDelete(project, confirm, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectDelete(project, confirm, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Converts an excel file (xls, xlsx) into a XML version that we send straight back as an XML payload.
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExcelxmlPost(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectExcelxmlPost(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Executes UC or TC into XTC items
             * @param {string} project Project short label
             * @param {ExecuteParam} [body] There must be a JSON as a payload. It includes all parameters AND the reason
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExecutePost(project, body, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectExecutePost(project, body, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for an export of some items. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} itemList Mandatory list of items to export.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExportGet(project, itemList, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectExportGet(project, itemList, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a field.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldCategoryDelete(project, category, field, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFieldCategoryDelete(project, category, field, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get 1 field of an item. {item} has the form CATEG-number.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} field Mandatory. Field number (faster) OR field label
             * @param {string} [format] Optional. Format for the return. Can be text, json, html, xml or xslt. Defaults to html
             * @param {number} [download] Optional. 1 to have in download, 0 as direct result. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldItemGet(project, item, field, format, download, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFieldItemGet(project, item, field, format, download, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a field's label and parameter OR modifies a field's order.
             * @param {string} project Project short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} label The new label (for renaming)
             * @param {string} fieldParam The new parameter (for renaming)
             * @param {number} order The new order (for reordering)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldPut(project, field, label, fieldParam, order, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFieldPut(project, field, label, fieldParam, order, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one project file. The fileno is a simple fileId. This request returns the actual file
             * @param {string} project Project short label
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileFilenoGet(project, fileno, key, disposition, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFileFilenoGet(project, fileno, key, disposition, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all files owned by a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFileGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Creates a new file - the file should be uploaded as payload (or through the url argument as an alternative). It's mime type should be sent through the HTTP protocol.
             * @param {string} project Project short label
             * @param {string} [url] Optional argument -  the file could also come from an external URL. In this case there will be an error if we can&#x27;t retrieve it on the server
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFilePost(project, url, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFilePost(project, url, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Creates a new folder
             * @param {string} project Project short label
             * @param {string} parent Reference of the parent folder in the form F-CATEG-serial (example -  F-SPEC-17)
             * @param {string} label folder label
             * @param {string} reason The reason why the user is doing this
             * @param {string} [fxField] (optional) Add one of each of these to set folder&#x27;s fields. fx is followed by the field ID (a number)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFolderPost(project, parent, label, reason, fxField, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectFolderPost(project, parent, label, reason, fxField, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get list of project info -  users, settings, categories
             * @param {string} project Project short label
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have this project data even if you are not assigned to, as an admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectGet(project, adminUI, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectGet(project, adminUI, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Hides a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHidePut(project, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectHidePut(project, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Launches a server-side hook
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} hook name of the hook
             * @param {string} [body] Payload for the hook, treated as a string.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHookItemPost(project, item, hook, body, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectHookItemPost(project, item, hook, body, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Cleans up an input html blob according to the current html cleanup rules. The blob is passed in the POST payload. The payload must be a json object with {\"htmlToClean\" - \"x\"}
             * @param {string} project Project short label
             * @param {GetHmlBlobInput} [body] Payload
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupBlobPost(project, body, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectHtmlCleanupBlobPost(project, body, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the list of items that would be changed if we applied html cleanup. You can pass a cleanup setting in the payload of the POST. If it's not there we take the customer (global) setting and force the cleanup to true
             * @param {string} project Project short label
             * @param {CleanupSetting} [body] Cleanup setting (optional)
             * @param {string} [categories] (optional) list of comma-delimited categories to go through, all by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupTestPost(project, body, categories, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectHtmlCleanupTestPost(project, body, categories, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Imports some items into a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectImportPost(project, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectImportPost(project, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a folder. {folder} has the form F-CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [children] (optional) set to yes if you need the children as well (recursively).
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Removes (inactivate) an item (or a folder). Item has the form (F-)CATEG-number. Will fail on non-empty folders
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} confirm Needs to be yes for the method to be executed IF it is a non-empty folder
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemDelete(project, item, confirm, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemItemDelete(project, item, confirm, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of an item. {item} has the form CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [withTree] (optional) retrieves the context tree if set to 1, in the field contextTree. Exclusive to filter and atDate
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Restores an item. Item has the form CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [at] (optional) If set, specifies that the item should be restored as it was in that version
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPost(project, item, reason, at, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemItemPost(project, item, reason, at, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Modifies an item or a folder. Item has the form CATEG-number, folders -  F-CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [title] Specify new title for the item -- if not there, keep the old title
             * @param {string} [fxid_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [auditAction] (optional) Specify a new verb for the audit action. Defaults to edit
             * @param {string} [newFolder] (optional) Name of a new folder to move the item into (exclusive from title and fx arguments)
             * @param {number} [newPosition] (optional) Indicates a new position within the newfolder. If newFolder is not specified, only changes the position. Exclusive of title and fx arguments. Position is an integer starting at 1
             * @param {string} [filter] (optional) A filter
             * @param {string} [linksUp] (optional) Comma-delimited (%2C)list of references to up items
             * @param {string} [linksDown] (optional) Comma-delimited (%2C)list of references to down items
             * @param {number} [currentVersion] (optional) will not make the change if the current version is not that one
             * @param {number} [onlyThoseFields] (optional) when set to 1 says that the only fields to change are those passed
             * @param {number} [onlyThoseLabels] (optional) when set to 1 says that the only labels to change are those passed. To remove a label in this case, prefix it with minus
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Adds an item in a folder
             * @param {string} project Project short label
             * @param {string} title Item title
             * @param {string} folder Reference of the folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} linksUp Comma-delimited (%2C)list of references to up items
             * @param {string} linksDown Comma-delimited (%2C)list of references to down items
             * @param {string} [fxID_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [author] The author (login name) - only works when superadmin is issuing this
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - ?. Valid from version 2.1
             * @summary Removes (inactivate) a link between 2 items. Items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a link between 2 items. Both items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get the list of items that are detailed in a DOC/SIGN item.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [detailed] Optional. When set to 1 adds a secondaryItems list in the answer. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlistItemGet(project, item, detailed, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectItemlistItemGet(project, item, detailed, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all jobs in a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectJobGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Aborts a job.
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobDelete(project, job, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectJobJobDelete(project, job, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job file. The job part is the jobID (a number) and the file is the fileID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} fileno file number
             * @param {string} [mode] (optional) set to mode&#x3D;direct to get the output in the response output instead of as a download file. This assumes the file is HTML
             * @param {string} [format] (optional) set to format&#x3D;json to get a json output instead of XML
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job status, including generated files. The variable part is the jobID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobGet(project, job, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectJobJobGet(project, job, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Sets the progress of a job
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} progress progress (0 to 100, 200 for error)
             * @param {string} [status] (optional( status text
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobPost(project, job, progress, status, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectJobJobPost(project, job, progress, status, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the label history of a project -  list of all label changes for all items
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) ask for just one item (the return structure is still an array in that case)
             * @param {string} [from] (optional) date from
             * @param {string} [to] (optional) date to - works only if you only specified a from
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectLabelhistoryGet(project, itemRef, from, to, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectLabelhistoryGet(project, itemRef, from, to, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge history of a project - needs the 'merge' module
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergehistoryGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectMergehistoryGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge information - needs the 'merge' module
             * @param {string} project Project short label
             * @param {string} [excludeCategories] (optional) comma-delimited list of categories to exclude
             * @param {string} [fromDate] (optional) date from which we consider the merges. ISO8601 format -- this parameter was introduced in v 2.3.4
             * @param {number} [push] (optional) set to 1 if you inquire about a push, not a merge -- this parameter was introduced in v 2.3.4
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergeinfoGet(project, excludeCategories, fromDate, push, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectMergeinfoGet(project, excludeCategories, fromDate, push, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Move items into this folder
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [items] List of items to move in
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMoveinFolderPost(project, folder, reason, items, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectMoveinFolderPost(project, folder, reason, items, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {number} [treeOrder] (optional) set to 1 to return items in tree order (otherwise it&#x27;s project,category,serial)
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleminimalGet(project, search, filter, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectNeedleminimalGet(project, search, filter, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a category to a project
             * @param {string} project Project short label
             * @param {string} label Category label
             * @param {string} shortLabel Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPost(project, label, shortLabel, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectPost(project, label, shortLabel, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Publishes an item. Item has the form PUB-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason reason for the publication
             * @param {string} [trainingFor] (optional) list of items for which we need to add training. If list is not there, all trainings will be generated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPublishItemPost(project, item, reason, trainingFor, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectPublishItemPost(project, item, reason, trainingFor, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.3
             * @summary Find a string in the QMS published items
             * @param {string} project Project short label
             * @param {string} [search] (optional) search term. Return an empty array on PUB &lt; 2.3.1 and et the list of all pub if not specified.
             * @param {string} [pubItem] (optional) PUB-x item if you want to search in another than the last one for that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectQmsfindGet(project, search, pubItem, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectQmsfindGet(project, search, pubItem, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) for the reports, read/write for the signed reports. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer. {report} can be REPORT-n, DOC-n, SIGN-n or a report name.To follow the progress of the job, the GET /{project}/job/{jobid} can be called
             * @param {string} project Project short label
             * @param {string} report name of the report
             * @param {string} isSignedReport If set to true, means the report needs to generate a signed record
             * @param {string} includeSignatures List of comma separated users who need to sign
             * @param {string} newTitle New title for the SIGN- item that is generated (only valid for isSignedReport)
             * @param {string} copyFields List of from-to fields (123,456),(124,457) that we can use to generate the fields in the SIGN record (only valid for isSignedReport)
             * @param {string} [itemList] (optional) list of items to use in the report. By default all categories are used
             * @param {string} [url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx, zippdf or package (from 2.2), or mf (since 2.3)
             * @param {string} [filter] (optional) specify a comma-delimited filter list. Can be negative filters (with minus before)
             * @param {number} [useOld] (optional) ask to use the old report engine (pre 1.11) if set to 1.
             * @param {string} [atDate] (optional) generates the report at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} project Project short label
             * @param {number} [simple] (optional) set to simple&#x3D;1 to have a simpler output (no fields, round shape)
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSchemaGet(project, simple, excludeCategories, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSchemaGet(project, simple, excludeCategories, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all settings of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSettingGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds or changes a project setting. If the value is empty, the setting will be deleted.
             * @param {string} project Project short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingPost(project, key, value, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSettingPost(project, key, value, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Signs an item. Item has the form SIGN-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} password signature password - the user who is signing is the one who is logged in
             * @param {string} [acceptComments] (optional) adds an acceptance comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPost(project, item, password, acceptComments, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSignItemPost(project, item, password, acceptComments, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Edit the signature parts
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} rejectSign The reason why the user is rejecting the signature
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPut(project, item, rejectSign, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSignItemPut(project, item, rejectSign, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} [url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx or zippdf
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignedreportSIGNNPost(project, url, resturl, format, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectSignedreportSIGNNPost(project, url, resturl, format, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all tags of a project. Works on any project if user is admin
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagGet(project, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTagGet(project, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a tag to a project
             * @param {string} project Project short label
             * @param {string} label Tag label. Must be unique within a project
             * @param {number} auditId Id of the audit this tag is based on
             * @param {string} type Type of tag (default -  tag)
             * @param {string} comments Free optional comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagPost(project, label, auditId, type, comments, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTagPost(project, label, auditId, type, comments, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for oneproject
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) set to an item to have all todos linked to an item, regardless of the user
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeAllUsers] (optional) set to 1 to include all todos for all users
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Creates a todo on an item (note that you only need read access for this POST method) for you or others
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} text The todo reason
             * @param {number} [fieldId] (optional) If set, specifies that the todo is related to that field (review, ...)
             * @param {string} [logins] (optional) If set, a list of user logins or groups to which these todo apply
             * @param {string} [todoType] (optional) The todo type -  &#x27;user&#x27; by default
             * @param {string} [atDate] (optional) a date in the future for reminders
             * @param {number} [auto] (optional) set to 1 to create an auto-notification (0 by default)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Removes (mark as done) a todo.
             * @param {string} project Project short label
             * @param {string} todoid todoid
             * @param {string} hardDelete Set to yes to actually remove the record
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoTodoidDelete(project, todoid, hardDelete, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTodoTodoidDelete(project, todoid, hardDelete, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Touches (set to same date) an item or folder
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [nbLayers] (optional) Number of layers -- 1 by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTouchItemPut(project, item, reason, nbLayers, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTouchItemPut(project, item, reason, nbLayers, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get full tree
             * @param {string} project Project short label
             * @param {string} [fancy] (optional) returns a fancy tree
             * @param {string} [filter] (optional) applies a filter
             * @param {string} [atDate] (optional) generates the tree at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTreeGet(project, fancy, filter, atDate, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectTreeGet(project, fancy, filter, atDate, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Unhides a project.
             * @param {string} project Project short label
             * @param {string} newShort The new project short name to use
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectUnhidePut(project, newShort, reason, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectUnhidePut(project, newShort, reason, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Converts a word document to an HTML, with images pointing to uploaded files on the server
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {number} [fileNo] If specified, means that the conversion is from an already uploaded file. Otherwise the file must be uploaded as body of this call
             * @param {string} [targetDocumentFolder] target document folder (in this case creates a document)
             * @param {number} [useAsField] set to 1 to have this docx used as a field. In this case the return value is the html equivalent, with some meta
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get list of all projects, all settings and current user, all todos and JIRA meta create object
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have all projects even the ones you are not assigned to, as an admin
             * @param {string} [output] (optional) comma-delimited list of requested output fields. Returns all fields if parameter is not present
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootGet(adminUI, output, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).rootGet(adminUI, output, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new project. Either the full project is sent as XML payload, or the label and shortLabel are given. If uploading data for a whole project, label and shortLabel are optional but overwrite the XML content if present. Branching can be done with an audit report as payload, and branch* must be defined in that case
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {string} [overwrite] Must be set to yes if you&#x27;re overwriting an existing project
             * @param {string} [importUsers] Must be set to yes if you want to import users. false by default
             * @param {string} [branchLabel] Must be set to branch (optional)
             * @param {string} [branchTag] Must be set to branch, and match a tag in the audit export (optional)
             * @param {string} [branchComment] Comment for the branch (optional)
             * @param {string} [branchBaseProjectLabel] Label of the base Project (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Retrieves the user list
             * @param {string} details (optional) -  if set to 1 returns all details
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userGet(details, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userGet(details, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new user. Arguments are either a set of arguments or json
             * @param {string} login User login name
             * @param {string} email User email
             * @param {string} password User password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userPost(login, email, password, json, first, last, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userPost(login, email, password, json, first, last, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all actions of a user
             * @param {string} user user login name
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserAuditGet(user, startAt, maxResults, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserAuditGet(user, startAt, maxResults, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckGet(user, password, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserCheckGet(user, password, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckPost(user, password, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserCheckPost(user, password, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a user (only used for unit testing)
             * @param {string} user user login name
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserDelete(user, confirm, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserDelete(user, confirm, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves full details of a user
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserGet(user, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserGet(user, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Login
             * @param {string} user user login name
             * @param {string} password password in clear
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLoginPost(user, password, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserLoginPost(user, password, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Logout
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLogoutPost(user, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserLogoutPost(user, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Sets a new password for an account that has a password_reset token in place (the {user} in the URL doesn't matter)
             * @param {string} user user login name
             * @param {string} token password_reset token
             * @param {string} password New password to use from now on
             * @param {string} [signaturePassword] (optional) New password to use from now on for signatures
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPasswordResetPost(user, token, password, signaturePassword, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserPasswordResetPost(user, token, password, signaturePassword, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a user to a project
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin, 4 for visitor
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPost(user, project, permission, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserProjectPost(user, project, permission, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Edits the user permissions in a project. If permission is 0, it means the user has no longer access (but we retain its records for audit purposes)
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPut(user, project, permission, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserProjectPut(user, project, permission, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all projects a user has access to
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectsGet(user, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserProjectsGet(user, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Edits the user details. Arguments are all separated or a single json argument. Regular users can only change their signature and passwords.
             * @param {string} user user login name
             * @param {string} email User new email
             * @param {string} password User new password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPut(user, email, password, json, first, last, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserPut(user, email, password, json, first, last, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a user login
             * @param {string} user user login name
             * @param {string} newLogin The new login name. Cannot be one of the existing
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserRenamePut(user, newLogin, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserRenamePut(user, newLogin, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds or deletes a user setting.
             * @param {string} user user login name
             * @param {string} key Name of the setting
             * @param {string} value Value of the setting. If empty, deletes the setting.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserSettingPost(user, key, value, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserSettingPost(user, key, value, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Sets the new status of the user. Can be normal,blocked or deleted
             * @param {string} user user login name
             * @param {string} status Can be normal,blocked or deleted
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserStatusPut(user, status, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserStatusPut(user, status, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Removes a user token
             * @param {string} user user login name
             * @param {string} value The token to be removed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenDelete(user, value, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserTokenDelete(user, value, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds a token for a user
             * @param {string} user user login name
             * @param {string} purpose Purpose of the token. Not checked. Should contain either \&quot;password_reset\&quot; or \&quot;oauth\&quot;
             * @param {string} [value] Value of the token - by default generated by this call
             * @param {string} [reason] Free text explain where the token will be used (URL or others). Should be set for oauth, not needed for others
             * @param {number} [validity] Validity of the token in hours - if not set, doesn&#x27;t expire
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenPost(user, purpose, value, reason, validity, options) {
                const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).userUserTokenPost(user, purpose, value, reason, validity, options);
                return (fetch = isomorphic_fetch_1.default, basePath = BASE_PATH) => {
                    return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        }
                        else {
                            throw response;
                        }
                    });
                };
            },
        };
    };
    /**
     * DefaultApi - factory interface
     * @export
     */
    exports.DefaultApiFactory = function (configuration, fetch, basePath) {
        return {
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Asks for the difference between A and B html exerpts, and produce the B html with annotations
             * @param {string} [arg] json object with the arguments
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allCompareHtmlPost(arg, options) {
                return exports.DefaultApiFp(configuration).allCompareHtmlPost(arg, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Returns all info about a date
             * @param {string} [date] (optional) an input date formatted as iso8601. If not present, current date/time is used
             * @param {string} [dateformat] (optional) a date formatter. If not present, current date format is used
             * @param {string} [timeformat] (optional) a date-time formatter. If not present, current date/time format is used
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allDateGet(date, dateformat, timeformat, options) {
                return exports.DefaultApiFp(configuration).allDateGet(date, dateformat, timeformat, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one customer file. The fileno is a simple fileId. This request returns the actual file
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileFilenoGet(fileno, key, disposition, options) {
                return exports.DefaultApiFp(configuration).allFileFilenoGet(fileno, key, disposition, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieve list of all customer-wide files
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFileGet(options) {
                return exports.DefaultApiFp(configuration).allFileGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a new customer-wide file - the file should be uploaded as payload. Its mime type should be sent through the HTTP protocol.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allFilePost(options) {
                return exports.DefaultApiFp(configuration).allFilePost(options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Retrieve license status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLicenseGet(options) {
                return exports.DefaultApiFp(configuration).allLicenseGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Adds a log entry (server side).
             * @param {string} message Message to log
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allLogPost(message, options) {
                return exports.DefaultApiFp(configuration).allLogPost(message, options)(fetch, basePath);
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Monitoring object
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allMonitorGet(options) {
                return exports.DefaultApiFp(configuration).allMonitorGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in all projects
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleGet(search, id, filter, fieldsOut, labels, links, options) {
                return exports.DefaultApiFp(configuration).allNeedleGet(search, id, filter, fieldsOut, labels, links, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in all projects
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allNeedleminimalGet(search, filter, options) {
                return exports.DefaultApiFp(configuration).allNeedleminimalGet(search, filter, options)(fetch, basePath);
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.2
             * @summary The OpenAPI 3.0 definition of our REST API
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allOpenapiGet(options) {
                return exports.DefaultApiFp(configuration).allOpenapiGet(options)(fetch, basePath);
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Lists all reports
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allReportsGet(options) {
                return exports.DefaultApiFp(configuration).allReportsGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Sends an email. Non-optional parameters are sent as a POST JSON payload.
             * @param {SendmailParam} [body] Necessary information to send a mail
             * @param {number} [system] (optional) if set to 1 makes it a system email (not sent by the actual user)
             * @param {number} [noreply] (optional) if set to 1 makes it a no-reply email (not sent by the actual user)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSendmailPost(body, system, noreply, options) {
                return exports.DefaultApiFp(configuration).allSendmailPost(body, system, noreply, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Creates a service desk issue. The parameters are sent as a POST JSON payload.
             * @param {ServiceDeskParam} [body] Necessary information to send a mail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allServicedeskPost(body, options) {
                return exports.DefaultApiFp(configuration).allServicedeskPost(body, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a customer
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingGet(options) {
                return exports.DefaultApiFp(configuration).allSettingGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a customer setting. If the value is empty, the setting will be deleted.
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allSettingPost(key, value, options) {
                return exports.DefaultApiFp(configuration).allSettingPost(key, value, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get instance status
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allStatusGet(options) {
                return exports.DefaultApiFp(configuration).allStatusGet(options)(fetch, basePath);
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Returns all accepted time zones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTimezoneGet(options) {
                return exports.DefaultApiFp(configuration).allTimezoneGet(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for all projects
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allTodoGet(includeDone, includeFuture, options) {
                return exports.DefaultApiFp(configuration).allTodoGet(includeDone, includeFuture, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary WebHook
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            allWebhookPost(options) {
                return exports.DefaultApiFp(configuration).allWebhookPost(options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Retrieves the group list
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGet(details, options) {
                return exports.DefaultApiFp(configuration).groupGet(details, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a group
             * @param {string} groupId group Id
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdDelete(groupId, confirm, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdDelete(groupId, confirm, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.2
             * @summary Retrieves details of a group
             * @param {string} groupId group Id
             * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdGet(groupId, details, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdGet(groupId, details, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Adds a group to a project (or removes it)
             * @param {string} groupId group Id
             * @param {string} project Project short label
             * @param {number} [permission] Specify the (new) permission for that group in that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdProjectProjectPost(groupId, project, permission, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdProjectProjectPost(groupId, project, permission, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a group
             * @param {string} groupId group Id
             * @param {string} newName The new group name. Cannot be one of the existing. Must start with &#x27;group.&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdRenamePut(groupId, newName, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdRenamePut(groupId, newName, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.2
             * @summary Adds a user to a group
             * @param {string} groupId group Id
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserUserPut(groupId, user, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdUserUserPut(groupId, user, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Sets all users of a group (replacing potential former content)
             * @param {string} groupId group Id
             * @param {string} users List of all users members of that group, commas-separated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupIdUserlistPut(groupId, users, options) {
                return exports.DefaultApiFp(configuration).groupGroupIdUserlistPut(groupId, users, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Creates a new group
             * @param {string} groupName group name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNamePost(groupName, options) {
                return exports.DefaultApiFp(configuration).groupGroupNamePost(groupName, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Removes a user from a group
             * @param {string} groupName group name
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            groupGroupNameUserUserDelete(groupName, user, options) {
                return exports.DefaultApiFp(configuration).groupGroupNameUserUserDelete(groupName, user, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.3
             * @summary Merge branch into mainline. First project is the mainline, second is the branch. The payload must contain a json object with a list of actions to perform.
             * @param {string} mainproject mainproject
             * @param {string} branchproject branchproject
             * @param {string} reason The reason why the user is doing this
             * @param {MergeParam} [body] Actions to perform
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options) {
                return exports.DefaultApiFp(configuration).mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.2
             * @summary Retrieves all accesses in a project (list of groups and users who have access)
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAccessGet(project, options) {
                return exports.DefaultApiFp(configuration).projectAccessGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Retrieves all changes in a project
             * @param {string} project Project short label
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {string} [deleteOnly] (optional) if set to yes, only returns actions of type delete
             * @param {string} [tech] (optional) if set to yes, returns the underneath changes
             * @param {number} [auditIdMin] (optional) sets a minimum ID for audits, as returned by GET calendar
             * @param {number} [auditIdMax] (optional) sets a maximum ID for audits
             * @param {number} [noReport] (optional) set to 1 to avoid having reports
             * @param {number} [noImport] (optional) set to 1 to avoid having imports
             * @param {string} [include] (optional) set to a list of actions to include (delete,undelete,add,edit,...)
             * @param {number} [resolveRef] (optional) set to 1 to resolve item IDs into refs
             * @param {string} [itemRef] (optional) restrict the audit to only those mentionning this item
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options) {
                return exports.DefaultApiFp(configuration).projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Launches a server-side branch or clone - needs the 'merge' module if actual branching
             * @param {string} project Project short label
             * @param {string} label Branch project label
             * @param {string} shortLabel Branch project short label
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after branching)
             * @param {number} keepContent 1 or 0. Defaults to 1. 0 only works without branch and without history
             * @param {number} [branch] (optional) Set to 1 to branch (default), 0 to just copy/clone
             * @param {number} [history] (optional) Set to 1 to branch or copy with history, defaults to 0
             * @param {string} [tagToCreate] (optional) specify a tag (by default auto-generated)
             * @param {string} [branchInThePastTag] (optional) specify a tag to branch in the past (needs history&#x3D;1)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options) {
                return exports.DefaultApiFp(configuration).projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all dates at which a project has been modified
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCalendarGet(project, options) {
                return exports.DefaultApiFp(configuration).projectCalendarGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a category. Will fail on REPORT and FOLDER categories
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryDelete(project, category, reason, options) {
                return exports.DefaultApiFp(configuration).projectCatCategoryDelete(project, category, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} [filter] (optional) specify a filter
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryGet(project, category, filter, options) {
                return exports.DefaultApiFp(configuration).projectCatCategoryGet(project, category, filter, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a categorie's labels, and fix the project's settings to reflect that change, OR modifies a category's order.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} order The new order (for reordering)
             * @param {string} shortLabel The new short label for that category (for renaming)
             * @param {string} label The new long label for that category (for renaming)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategoryPut(project, category, order, shortLabel, label, reason, options) {
                return exports.DefaultApiFp(configuration).projectCatCategoryPut(project, category, order, shortLabel, label, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all settings of a category
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingGet(project, category, options) {
                return exports.DefaultApiFp(configuration).projectCatCategorySettingGet(project, category, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds or changes a category setting. If the value is empty, the setting will be deleted
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatCategorySettingPost(project, category, key, value, options) {
                return exports.DefaultApiFp(configuration).projectCatCategorySettingPost(project, category, key, value, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get all categories of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatGet(project, options) {
                return exports.DefaultApiFp(configuration).projectCatGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a fields in a category
             * @param {string} project Project short label
             * @param {string} label Field label
             * @param {string} category Category short label
             * @param {string} fieldType Type of field
             * @param {string} fieldParam Parameter for the field
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCatPost(project, label, category, fieldType, fieldParam, reason, options) {
                return exports.DefaultApiFp(configuration).projectCatPost(project, label, category, fieldType, fieldParam, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Clones a project
             * @param {string} project Project short label
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {number} keepHistory 1 or 0. Defaults to 0
             * @param {number} keepContent 1 or 0. Defaults to 0 (only the REPORT part is kept, make sense only if keepHistory is 0)
             * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after cloning)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options) {
                return exports.DefaultApiFp(configuration).projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for the difference between 2 signed documents, as a Word document. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} signitem1 SIGN-xx for the first SIGN document to compare
             * @param {string} signitem2 SIGN-xx for the 2nd SIGN document to compare
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options) {
                return exports.DefaultApiFp(configuration).projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectConfigcheckGet(excludeCategories, options) {
                return exports.DefaultApiFp(configuration).projectConfigcheckGet(excludeCategories, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.2
             * @summary Copy items from a folder to another one
             * @param {string} project Project short label
             * @param {string} itemOrFolder Item reference (XXX-nn) or folder (F-XXX-nn)
             * @param {string} targetFolder Reference of the target folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [targetProject] (optional) project to copy into (by default, same project)
             * @param {number} [copyLabels] (optional) 0 or 1. Defaults to 0
             * @param {string} [map] (optional) mapN&#x3D;M -  map field N in source to field M in target
             * @param {string} [ignoreLabels] (optional) can contain a comma-delimited list of labels NOT to copy
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options) {
                return exports.DefaultApiFp(configuration).projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options)(fetch, basePath);
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a project (only used for unit testing). This is an actual DELETE in the database.
             * @param {string} project Project short label
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectDelete(project, confirm, options) {
                return exports.DefaultApiFp(configuration).projectDelete(project, confirm, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Converts an excel file (xls, xlsx) into a XML version that we send straight back as an XML payload.
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExcelxmlPost(project, options) {
                return exports.DefaultApiFp(configuration).projectExcelxmlPost(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Executes UC or TC into XTC items
             * @param {string} project Project short label
             * @param {ExecuteParam} [body] There must be a JSON as a payload. It includes all parameters AND the reason
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExecutePost(project, body, options) {
                return exports.DefaultApiFp(configuration).projectExecutePost(project, body, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for an export of some items. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} itemList Mandatory list of items to export.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectExportGet(project, itemList, options) {
                return exports.DefaultApiFp(configuration).projectExportGet(project, itemList, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Removes (inactivate) a field.
             * @param {string} project Project short label
             * @param {string} category Category short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldCategoryDelete(project, category, field, reason, options) {
                return exports.DefaultApiFp(configuration).projectFieldCategoryDelete(project, category, field, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get 1 field of an item. {item} has the form CATEG-number.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} field Mandatory. Field number (faster) OR field label
             * @param {string} [format] Optional. Format for the return. Can be text, json, html, xml or xslt. Defaults to html
             * @param {number} [download] Optional. 1 to have in download, 0 as direct result. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldItemGet(project, item, field, format, download, options) {
                return exports.DefaultApiFp(configuration).projectFieldItemGet(project, item, field, format, download, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Modifies a field's label and parameter OR modifies a field's order.
             * @param {string} project Project short label
             * @param {number} field The field number (like field&#x3D;502)
             * @param {string} label The new label (for renaming)
             * @param {string} fieldParam The new parameter (for renaming)
             * @param {number} order The new order (for reordering)
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFieldPut(project, field, label, fieldParam, order, reason, options) {
                return exports.DefaultApiFp(configuration).projectFieldPut(project, field, label, fieldParam, order, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have the right key to download the file. Valid from version 2.1
             * @summary Retrieve one project file. The fileno is a simple fileId. This request returns the actual file
             * @param {string} project Project short label
             * @param {number} fileno file number
             * @param {string} key The key of the file
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileFilenoGet(project, fileno, key, disposition, options) {
                return exports.DefaultApiFp(configuration).projectFileFilenoGet(project, fileno, key, disposition, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all files owned by a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFileGet(project, options) {
                return exports.DefaultApiFp(configuration).projectFileGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Creates a new file - the file should be uploaded as payload (or through the url argument as an alternative). It's mime type should be sent through the HTTP protocol.
             * @param {string} project Project short label
             * @param {string} [url] Optional argument -  the file could also come from an external URL. In this case there will be an error if we can&#x27;t retrieve it on the server
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFilePost(project, url, options) {
                return exports.DefaultApiFp(configuration).projectFilePost(project, url, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Creates a new folder
             * @param {string} project Project short label
             * @param {string} parent Reference of the parent folder in the form F-CATEG-serial (example -  F-SPEC-17)
             * @param {string} label folder label
             * @param {string} reason The reason why the user is doing this
             * @param {string} [fxField] (optional) Add one of each of these to set folder&#x27;s fields. fx is followed by the field ID (a number)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectFolderPost(project, parent, label, reason, fxField, options) {
                return exports.DefaultApiFp(configuration).projectFolderPost(project, parent, label, reason, fxField, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get list of project info -  users, settings, categories
             * @param {string} project Project short label
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have this project data even if you are not assigned to, as an admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectGet(project, adminUI, options) {
                return exports.DefaultApiFp(configuration).projectGet(project, adminUI, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Hides a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHidePut(project, reason, options) {
                return exports.DefaultApiFp(configuration).projectHidePut(project, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Launches a server-side hook
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} hook name of the hook
             * @param {string} [body] Payload for the hook, treated as a string.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHookItemPost(project, item, hook, body, options) {
                return exports.DefaultApiFp(configuration).projectHookItemPost(project, item, hook, body, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Cleans up an input html blob according to the current html cleanup rules. The blob is passed in the POST payload. The payload must be a json object with {\"htmlToClean\" - \"x\"}
             * @param {string} project Project short label
             * @param {GetHmlBlobInput} [body] Payload
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupBlobPost(project, body, options) {
                return exports.DefaultApiFp(configuration).projectHtmlCleanupBlobPost(project, body, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the list of items that would be changed if we applied html cleanup. You can pass a cleanup setting in the payload of the POST. If it's not there we take the customer (global) setting and force the cleanup to true
             * @param {string} project Project short label
             * @param {CleanupSetting} [body] Cleanup setting (optional)
             * @param {string} [categories] (optional) list of comma-delimited categories to go through, all by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectHtmlCleanupTestPost(project, body, categories, options) {
                return exports.DefaultApiFp(configuration).projectHtmlCleanupTestPost(project, body, categories, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Imports some items into a project
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectImportPost(project, reason, options) {
                return exports.DefaultApiFp(configuration).projectImportPost(project, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of a folder. {folder} has the form F-CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [children] (optional) set to yes if you need the children as well (recursively).
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options) {
                return exports.DefaultApiFp(configuration).projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Removes (inactivate) an item (or a folder). Item has the form (F-)CATEG-number. Will fail on non-empty folders
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} confirm Needs to be yes for the method to be executed IF it is a non-empty folder
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemDelete(project, item, confirm, reason, options) {
                return exports.DefaultApiFp(configuration).projectItemItemDelete(project, item, confirm, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get details of an item. {item} has the form CATEG-number[-vN].
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
             * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
             * @param {string} [filter] (optional) specify a filter
             * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
             * @param {number} [withTree] (optional) retrieves the context tree if set to 1, in the field contextTree. Exclusive to filter and atDate
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options) {
                return exports.DefaultApiFp(configuration).projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Restores an item. Item has the form CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [at] (optional) If set, specifies that the item should be restored as it was in that version
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPost(project, item, reason, at, options) {
                return exports.DefaultApiFp(configuration).projectItemItemPost(project, item, reason, at, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Modifies an item or a folder. Item has the form CATEG-number, folders -  F-CATEG-number
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [title] Specify new title for the item -- if not there, keep the old title
             * @param {string} [fxid_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [auditAction] (optional) Specify a new verb for the audit action. Defaults to edit
             * @param {string} [newFolder] (optional) Name of a new folder to move the item into (exclusive from title and fx arguments)
             * @param {number} [newPosition] (optional) Indicates a new position within the newfolder. If newFolder is not specified, only changes the position. Exclusive of title and fx arguments. Position is an integer starting at 1
             * @param {string} [filter] (optional) A filter
             * @param {string} [linksUp] (optional) Comma-delimited (%2C)list of references to up items
             * @param {string} [linksDown] (optional) Comma-delimited (%2C)list of references to down items
             * @param {number} [currentVersion] (optional) will not make the change if the current version is not that one
             * @param {number} [onlyThoseFields] (optional) when set to 1 says that the only fields to change are those passed
             * @param {number} [onlyThoseLabels] (optional) when set to 1 says that the only labels to change are those passed. To remove a label in this case, prefix it with minus
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options) {
                return exports.DefaultApiFp(configuration).projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
             * @summary Adds an item in a folder
             * @param {string} project Project short label
             * @param {string} title Item title
             * @param {string} folder Reference of the folder (F-categ-serial)
             * @param {string} reason The reason why the user is doing this
             * @param {string} linksUp Comma-delimited (%2C)list of references to up items
             * @param {string} linksDown Comma-delimited (%2C)list of references to down items
             * @param {string} [fxID_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
             * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
             * @param {string} [author] The author (login name) - only works when superadmin is issuing this
             * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options) {
                return exports.DefaultApiFp(configuration).projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options)(fetch, basePath);
            },
            /**
             * Permissions - ?. Valid from version 2.1
             * @summary Removes (inactivate) a link between 2 items. Items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options) {
                return exports.DefaultApiFp(configuration).projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a link between 2 items. Both items are in the form CATEG-number
             * @param {string} project Project short label
             * @param {string} upitem Item reference (XXX-nn) for the UP item
             * @param {string} downitem Item reference (XXX-nn) for the DOWN item
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options) {
                return exports.DefaultApiFp(configuration).projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get the list of items that are detailed in a DOC/SIGN item.
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {number} [detailed] Optional. When set to 1 adds a secondaryItems list in the answer. Defaults to 0.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectItemlistItemGet(project, item, detailed, options) {
                return exports.DefaultApiFp(configuration).projectItemlistItemGet(project, item, detailed, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Retrieve list of all jobs in a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobGet(project, options) {
                return exports.DefaultApiFp(configuration).projectJobGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.3
             * @summary Aborts a job.
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobDelete(project, job, reason, options) {
                return exports.DefaultApiFp(configuration).projectJobJobDelete(project, job, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job file. The job part is the jobID (a number) and the file is the fileID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} fileno file number
             * @param {string} [mode] (optional) set to mode&#x3D;direct to get the output in the response output instead of as a download file. This assumes the file is HTML
             * @param {string} [format] (optional) set to format&#x3D;json to get a json output instead of XML
             * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options) {
                return exports.DefaultApiFp(configuration).projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a job status, including generated files. The variable part is the jobID (a number)
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobGet(project, job, options) {
                return exports.DefaultApiFp(configuration).projectJobJobGet(project, job, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.2
             * @summary Sets the progress of a job
             * @param {string} project Project short label
             * @param {number} job job number
             * @param {number} progress progress (0 to 100, 200 for error)
             * @param {string} [status] (optional( status text
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectJobJobPost(project, job, progress, status, options) {
                return exports.DefaultApiFp(configuration).projectJobJobPost(project, job, progress, status, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the label history of a project -  list of all label changes for all items
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) ask for just one item (the return structure is still an array in that case)
             * @param {string} [from] (optional) date from
             * @param {string} [to] (optional) date to - works only if you only specified a from
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectLabelhistoryGet(project, itemRef, from, to, options) {
                return exports.DefaultApiFp(configuration).projectLabelhistoryGet(project, itemRef, from, to, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge history of a project - needs the 'merge' module
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergehistoryGet(project, options) {
                return exports.DefaultApiFp(configuration).projectMergehistoryGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
             * @summary Get the merge information - needs the 'merge' module
             * @param {string} project Project short label
             * @param {string} [excludeCategories] (optional) comma-delimited list of categories to exclude
             * @param {string} [fromDate] (optional) date from which we consider the merges. ISO8601 format -- this parameter was introduced in v 2.3.4
             * @param {number} [push] (optional) set to 1 if you inquire about a push, not a merge -- this parameter was introduced in v 2.3.4
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMergeinfoGet(project, excludeCategories, fromDate, push, options) {
                return exports.DefaultApiFp(configuration).projectMergeinfoGet(project, excludeCategories, fromDate, push, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Move items into this folder
             * @param {string} project Project short label
             * @param {string} folder Folder reference (F-XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {string} [items] List of items to move in
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectMoveinFolderPost(project, folder, reason, items, options) {
                return exports.DefaultApiFp(configuration).projectMoveinFolderPost(project, folder, reason, items, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find items based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
             * @param {number} [labels] (optional) set to 1 to return labels in the output
             * @param {number} [treeOrder] (optional) set to 1 to return items in tree order (otherwise it&#x27;s project,category,serial)
             * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options) {
                return exports.DefaultApiFp(configuration).projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Find item ids based on a search string in one project
             * @param {string} project Project short label
             * @param {string} search search term
             * @param {string} [filter] (optional) applies a filter, can be negative
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectNeedleminimalGet(project, search, filter, options) {
                return exports.DefaultApiFp(configuration).projectNeedleminimalGet(project, search, filter, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a category to a project
             * @param {string} project Project short label
             * @param {string} label Category label
             * @param {string} shortLabel Category short label
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPost(project, label, shortLabel, reason, options) {
                return exports.DefaultApiFp(configuration).projectPost(project, label, shortLabel, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Publishes an item. Item has the form PUB-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason reason for the publication
             * @param {string} [trainingFor] (optional) list of items for which we need to add training. If list is not there, all trainings will be generated
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectPublishItemPost(project, item, reason, trainingFor, options) {
                return exports.DefaultApiFp(configuration).projectPublishItemPost(project, item, reason, trainingFor, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.3
             * @summary Find a string in the QMS published items
             * @param {string} project Project short label
             * @param {string} [search] (optional) search term. Return an empty array on PUB &lt; 2.3.1 and et the list of all pub if not specified.
             * @param {string} [pubItem] (optional) PUB-x item if you want to search in another than the last one for that project
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectQmsfindGet(project, search, pubItem, options) {
                return exports.DefaultApiFp(configuration).projectQmsfindGet(project, search, pubItem, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) for the reports, read/write for the signed reports. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer. {report} can be REPORT-n, DOC-n, SIGN-n or a report name.To follow the progress of the job, the GET /{project}/job/{jobid} can be called
             * @param {string} project Project short label
             * @param {string} report name of the report
             * @param {string} isSignedReport If set to true, means the report needs to generate a signed record
             * @param {string} includeSignatures List of comma separated users who need to sign
             * @param {string} newTitle New title for the SIGN- item that is generated (only valid for isSignedReport)
             * @param {string} copyFields List of from-to fields (123,456),(124,457) that we can use to generate the fields in the SIGN record (only valid for isSignedReport)
             * @param {string} [itemList] (optional) list of items to use in the report. By default all categories are used
             * @param {string} [url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx, zippdf or package (from 2.2), or mf (since 2.3)
             * @param {string} [filter] (optional) specify a comma-delimited filter list. Can be negative filters (with minus before)
             * @param {number} [useOld] (optional) ask to use the old report engine (pre 1.11) if set to 1.
             * @param {string} [atDate] (optional) generates the report at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options) {
                return exports.DefaultApiFp(configuration).projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get a project's schema
             * @param {string} project Project short label
             * @param {number} [simple] (optional) set to simple&#x3D;1 to have a simpler output (no fields, round shape)
             * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSchemaGet(project, simple, excludeCategories, options) {
                return exports.DefaultApiFp(configuration).projectSchemaGet(project, simple, excludeCategories, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all settings of a project
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingGet(project, options) {
                return exports.DefaultApiFp(configuration).projectSettingGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds or changes a project setting. If the value is empty, the setting will be deleted.
             * @param {string} project Project short label
             * @param {string} key setting key
             * @param {string} value value
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSettingPost(project, key, value, options) {
                return exports.DefaultApiFp(configuration).projectSettingPost(project, key, value, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Signs an item. Item has the form SIGN-nnn
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} password signature password - the user who is signing is the one who is logged in
             * @param {string} [acceptComments] (optional) adds an acceptance comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPost(project, item, password, acceptComments, options) {
                return exports.DefaultApiFp(configuration).projectSignItemPost(project, item, password, acceptComments, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Edit the signature parts
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} rejectSign The reason why the user is rejecting the signature
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignItemPut(project, item, rejectSign, options) {
                return exports.DefaultApiFp(configuration).projectSignItemPut(project, item, rejectSign, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Asks for a new report. The job ID is returned as answer
             * @param {string} project Project short label
             * @param {string} [url] (optional) url to generate in the filter
             * @param {string} [resturl] (optional) REST url to generate in the filter
             * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx or zippdf
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectSignedreportSIGNNPost(project, url, resturl, format, options) {
                return exports.DefaultApiFp(configuration).projectSignedreportSIGNNPost(project, url, resturl, format, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get all tags of a project. Works on any project if user is admin
             * @param {string} project Project short label
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagGet(project, options) {
                return exports.DefaultApiFp(configuration).projectTagGet(project, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Adds a tag to a project
             * @param {string} project Project short label
             * @param {string} label Tag label. Must be unique within a project
             * @param {number} auditId Id of the audit this tag is based on
             * @param {string} type Type of tag (default -  tag)
             * @param {string} comments Free optional comment
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTagPost(project, label, auditId, type, comments, options) {
                return exports.DefaultApiFp(configuration).projectTagPost(project, label, auditId, type, comments, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Get all todos for the current user, for oneproject
             * @param {string} project Project short label
             * @param {string} [itemRef] (optional) set to an item to have all todos linked to an item, regardless of the user
             * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
             * @param {number} [includeAllUsers] (optional) set to 1 to include all todos for all users
             * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options) {
                return exports.DefaultApiFp(configuration).projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
             * @summary Creates a todo on an item (note that you only need read access for this POST method) for you or others
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} text The todo reason
             * @param {number} [fieldId] (optional) If set, specifies that the todo is related to that field (review, ...)
             * @param {string} [logins] (optional) If set, a list of user logins or groups to which these todo apply
             * @param {string} [todoType] (optional) The todo type -  &#x27;user&#x27; by default
             * @param {string} [atDate] (optional) a date in the future for reminders
             * @param {number} [auto] (optional) set to 1 to create an auto-notification (0 by default)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options) {
                return exports.DefaultApiFp(configuration).projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.2
             * @summary Removes (mark as done) a todo.
             * @param {string} project Project short label
             * @param {string} todoid todoid
             * @param {string} hardDelete Set to yes to actually remove the record
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTodoTodoidDelete(project, todoid, hardDelete, options) {
                return exports.DefaultApiFp(configuration).projectTodoTodoidDelete(project, todoid, hardDelete, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Touches (set to same date) an item or folder
             * @param {string} project Project short label
             * @param {string} item Item reference (XXX-nn)
             * @param {string} reason The reason why the user is doing this
             * @param {number} [nbLayers] (optional) Number of layers -- 1 by default
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTouchItemPut(project, item, reason, nbLayers, options) {
                return exports.DefaultApiFp(configuration).projectTouchItemPut(project, item, reason, nbLayers, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
             * @summary Get full tree
             * @param {string} project Project short label
             * @param {string} [fancy] (optional) returns a fancy tree
             * @param {string} [filter] (optional) applies a filter
             * @param {string} [atDate] (optional) generates the tree at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectTreeGet(project, fancy, filter, atDate, options) {
                return exports.DefaultApiFp(configuration).projectTreeGet(project, fancy, filter, atDate, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Unhides a project.
             * @param {string} project Project short label
             * @param {string} newShort The new project short name to use
             * @param {string} reason The reason why the user is doing this
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectUnhidePut(project, newShort, reason, options) {
                return exports.DefaultApiFp(configuration).projectUnhidePut(project, newShort, reason, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have read/write access to the project. Valid from version 2.1
             * @summary Converts a word document to an HTML, with images pointing to uploaded files on the server
             * @param {string} project Project short label
             * @param {string} reason The reason why the user is doing this
             * @param {number} [fileNo] If specified, means that the conversion is from an already uploaded file. Otherwise the file must be uploaded as body of this call
             * @param {string} [targetDocumentFolder] target document folder (in this case creates a document)
             * @param {number} [useAsField] set to 1 to have this docx used as a field. In this case the return value is the html equivalent, with some meta
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options) {
                return exports.DefaultApiFp(configuration).projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Get list of all projects, all settings and current user, all todos and JIRA meta create object
             * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have all projects even the ones you are not assigned to, as an admin
             * @param {string} [output] (optional) comma-delimited list of requested output fields. Returns all fields if parameter is not present
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootGet(adminUI, output, options) {
                return exports.DefaultApiFp(configuration).rootGet(adminUI, output, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new project. Either the full project is sent as XML payload, or the label and shortLabel are given. If uploading data for a whole project, label and shortLabel are optional but overwrite the XML content if present. Branching can be done with an audit report as payload, and branch* must be defined in that case
             * @param {string} label Project label
             * @param {string} shortLabel Project short label
             * @param {string} [overwrite] Must be set to yes if you&#x27;re overwriting an existing project
             * @param {string} [importUsers] Must be set to yes if you want to import users. false by default
             * @param {string} [branchLabel] Must be set to branch (optional)
             * @param {string} [branchTag] Must be set to branch, and match a tag in the audit export (optional)
             * @param {string} [branchComment] Comment for the branch (optional)
             * @param {string} [branchBaseProjectLabel] Label of the base Project (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options) {
                return exports.DefaultApiFp(configuration).rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Retrieves the user list
             * @param {string} details (optional) -  if set to 1 returns all details
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userGet(details, options) {
                return exports.DefaultApiFp(configuration).userGet(details, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Creates a new user. Arguments are either a set of arguments or json
             * @param {string} login User login name
             * @param {string} email User email
             * @param {string} password User password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userPost(login, email, password, json, first, last, options) {
                return exports.DefaultApiFp(configuration).userPost(login, email, password, json, first, last, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all actions of a user
             * @param {string} user user login name
             * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
             * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserAuditGet(user, startAt, maxResults, options) {
                return exports.DefaultApiFp(configuration).userUserAuditGet(user, startAt, maxResults, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckGet(user, password, options) {
                return exports.DefaultApiFp(configuration).userUserCheckGet(user, password, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Check a user's password
             * @param {string} user user login name
             * @param {string} password Asks for a check of the password1
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserCheckPost(user, password, options) {
                return exports.DefaultApiFp(configuration).userUserCheckPost(user, password, options)(fetch, basePath);
            },
            /**
             * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
             * @summary Removes completely a user (only used for unit testing)
             * @param {string} user user login name
             * @param {string} confirm Needs to be yes for the method to be executed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserDelete(user, confirm, options) {
                return exports.DefaultApiFp(configuration).userUserDelete(user, confirm, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves full details of a user
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserGet(user, options) {
                return exports.DefaultApiFp(configuration).userUserGet(user, options)(fetch, basePath);
            },
            /**
             * Permissions - No permissions needed. Valid from version 2.1
             * @summary Login
             * @param {string} user user login name
             * @param {string} password password in clear
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLoginPost(user, password, options) {
                return exports.DefaultApiFp(configuration).userUserLoginPost(user, password, options)(fetch, basePath);
            },
            /**
             * Permissions - Must have a valid authentication. Valid from version 2.1
             * @summary Logout
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserLogoutPost(user, options) {
                return exports.DefaultApiFp(configuration).userUserLogoutPost(user, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Sets a new password for an account that has a password_reset token in place (the {user} in the URL doesn't matter)
             * @param {string} user user login name
             * @param {string} token password_reset token
             * @param {string} password New password to use from now on
             * @param {string} [signaturePassword] (optional) New password to use from now on for signatures
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPasswordResetPost(user, token, password, signaturePassword, options) {
                return exports.DefaultApiFp(configuration).userUserPasswordResetPost(user, token, password, signaturePassword, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Adds a user to a project
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin, 4 for visitor
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPost(user, project, permission, options) {
                return exports.DefaultApiFp(configuration).userUserProjectPost(user, project, permission, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Edits the user permissions in a project. If permission is 0, it means the user has no longer access (but we retain its records for audit purposes)
             * @param {string} user user login name
             * @param {string} project Project short label
             * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectPut(user, project, permission, options) {
                return exports.DefaultApiFp(configuration).userUserProjectPut(user, project, permission, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
             * @summary Retrieves all projects a user has access to
             * @param {string} user user login name
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserProjectsGet(user, options) {
                return exports.DefaultApiFp(configuration).userUserProjectsGet(user, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Edits the user details. Arguments are all separated or a single json argument. Regular users can only change their signature and passwords.
             * @param {string} user user login name
             * @param {string} email User new email
             * @param {string} password User new password in clear
             * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
             * @param {string} [first] User first name (optional)
             * @param {string} [last] User last name (optional)
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserPut(user, email, password, json, first, last, options) {
                return exports.DefaultApiFp(configuration).userUserPut(user, email, password, json, first, last, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.2
             * @summary Renames a user login
             * @param {string} user user login name
             * @param {string} newLogin The new login name. Cannot be one of the existing
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserRenamePut(user, newLogin, options) {
                return exports.DefaultApiFp(configuration).userUserRenamePut(user, newLogin, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds or deletes a user setting.
             * @param {string} user user login name
             * @param {string} key Name of the setting
             * @param {string} value Value of the setting. If empty, deletes the setting.
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserSettingPost(user, key, value, options) {
                return exports.DefaultApiFp(configuration).userUserSettingPost(user, key, value, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin. Valid from version 2.1
             * @summary Sets the new status of the user. Can be normal,blocked or deleted
             * @param {string} user user login name
             * @param {string} status Can be normal,blocked or deleted
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserStatusPut(user, status, options) {
                return exports.DefaultApiFp(configuration).userUserStatusPut(user, status, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Removes a user token
             * @param {string} user user login name
             * @param {string} value The token to be removed
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenDelete(user, value, options) {
                return exports.DefaultApiFp(configuration).userUserTokenDelete(user, value, options)(fetch, basePath);
            },
            /**
             * Permissions - Must be admin or the user. Valid from version 2.1
             * @summary Adds a token for a user
             * @param {string} user user login name
             * @param {string} purpose Purpose of the token. Not checked. Should contain either \&quot;password_reset\&quot; or \&quot;oauth\&quot;
             * @param {string} [value] Value of the token - by default generated by this call
             * @param {string} [reason] Free text explain where the token will be used (URL or others). Should be set for oauth, not needed for others
             * @param {number} [validity] Validity of the token in hours - if not set, doesn&#x27;t expire
             * @param {*} [options] Override http request option.
             * @throws {RequiredError}
             */
            userUserTokenPost(user, purpose, value, reason, validity, options) {
                return exports.DefaultApiFp(configuration).userUserTokenPost(user, purpose, value, reason, validity, options)(fetch, basePath);
            },
        };
    };
    /**
     * DefaultApi - object-oriented interface
     * @export
     * @class DefaultApi
     * @extends {BaseAPI}
     */
    class DefaultApi extends BaseAPI {
        /**
         * Permissions - No permissions needed. Valid from version 2.1
         * @summary Asks for the difference between A and B html exerpts, and produce the B html with annotations
         * @param {string} [arg] json object with the arguments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allCompareHtmlPost(arg, options) {
            return exports.DefaultApiFp(this.configuration).allCompareHtmlPost(arg, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Returns all info about a date
         * @param {string} [date] (optional) an input date formatted as iso8601. If not present, current date/time is used
         * @param {string} [dateformat] (optional) a date formatter. If not present, current date format is used
         * @param {string} [timeformat] (optional) a date-time formatter. If not present, current date/time format is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allDateGet(date, dateformat, timeformat, options) {
            return exports.DefaultApiFp(this.configuration).allDateGet(date, dateformat, timeformat, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have the right key to download the file. Valid from version 2.1
         * @summary Retrieve one customer file. The fileno is a simple fileId. This request returns the actual file
         * @param {number} fileno file number
         * @param {string} key The key of the file
         * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allFileFilenoGet(fileno, key, disposition, options) {
            return exports.DefaultApiFp(this.configuration).allFileFilenoGet(fileno, key, disposition, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Retrieve list of all customer-wide files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allFileGet(options) {
            return exports.DefaultApiFp(this.configuration).allFileGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Creates a new customer-wide file - the file should be uploaded as payload. Its mime type should be sent through the HTTP protocol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allFilePost(options) {
            return exports.DefaultApiFp(this.configuration).allFilePost(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Retrieve license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allLicenseGet(options) {
            return exports.DefaultApiFp(this.configuration).allLicenseGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Adds a log entry (server side).
         * @param {string} message Message to log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allLogPost(message, options) {
            return exports.DefaultApiFp(this.configuration).allLogPost(message, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - No permissions needed. Valid from version 2.1
         * @summary Monitoring object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allMonitorGet(options) {
            return exports.DefaultApiFp(this.configuration).allMonitorGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Find items based on a search string in all projects
         * @param {string} search search term
         * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
         * @param {string} [filter] (optional) applies a filter, can be negative
         * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
         * @param {number} [labels] (optional) set to 1 to return labels in the output
         * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allNeedleGet(search, id, filter, fieldsOut, labels, links, options) {
            return exports.DefaultApiFp(this.configuration).allNeedleGet(search, id, filter, fieldsOut, labels, links, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Find item ids based on a search string in all projects
         * @param {string} search search term
         * @param {string} [filter] (optional) applies a filter, can be negative
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allNeedleminimalGet(search, filter, options) {
            return exports.DefaultApiFp(this.configuration).allNeedleminimalGet(search, filter, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - No permissions needed. Valid from version 2.2
         * @summary The OpenAPI 3.0 definition of our REST API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allOpenapiGet(options) {
            return exports.DefaultApiFp(this.configuration).allOpenapiGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - No permissions needed. Valid from version 2.1
         * @summary Lists all reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allReportsGet(options) {
            return exports.DefaultApiFp(this.configuration).allReportsGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Sends an email. Non-optional parameters are sent as a POST JSON payload.
         * @param {SendmailParam} [body] Necessary information to send a mail
         * @param {number} [system] (optional) if set to 1 makes it a system email (not sent by the actual user)
         * @param {number} [noreply] (optional) if set to 1 makes it a no-reply email (not sent by the actual user)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allSendmailPost(body, system, noreply, options) {
            return exports.DefaultApiFp(this.configuration).allSendmailPost(body, system, noreply, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Creates a service desk issue. The parameters are sent as a POST JSON payload.
         * @param {ServiceDeskParam} [body] Necessary information to send a mail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allServicedeskPost(body, options) {
            return exports.DefaultApiFp(this.configuration).allServicedeskPost(body, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get all settings of a customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allSettingGet(options) {
            return exports.DefaultApiFp(this.configuration).allSettingGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Adds or changes a customer setting. If the value is empty, the setting will be deleted.
         * @param {string} key setting key
         * @param {string} value value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allSettingPost(key, value, options) {
            return exports.DefaultApiFp(this.configuration).allSettingPost(key, value, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get instance status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allStatusGet(options) {
            return exports.DefaultApiFp(this.configuration).allStatusGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - No permissions needed. Valid from version 2.1
         * @summary Returns all accepted time zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allTimezoneGet(options) {
            return exports.DefaultApiFp(this.configuration).allTimezoneGet(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
         * @summary Get all todos for the current user, for all projects
         * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
         * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allTodoGet(includeDone, includeFuture, options) {
            return exports.DefaultApiFp(this.configuration).allTodoGet(includeDone, includeFuture, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary WebHook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        allWebhookPost(options) {
            return exports.DefaultApiFp(this.configuration).allWebhookPost(options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.2
         * @summary Retrieves the group list
         * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGet(details, options) {
            return exports.DefaultApiFp(this.configuration).groupGet(details, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Removes a group
         * @param {string} groupId group Id
         * @param {string} confirm Needs to be yes for the method to be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdDelete(groupId, confirm, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdDelete(groupId, confirm, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.2
         * @summary Retrieves details of a group
         * @param {string} groupId group Id
         * @param {number} [details] (optional) -  if set to 1 returns all details -- in this case user needs to be ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdGet(groupId, details, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdGet(groupId, details, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Adds a group to a project (or removes it)
         * @param {string} groupId group Id
         * @param {string} project Project short label
         * @param {number} [permission] Specify the (new) permission for that group in that project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdProjectProjectPost(groupId, project, permission, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdProjectProjectPost(groupId, project, permission, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Renames a group
         * @param {string} groupId group Id
         * @param {string} newName The new group name. Cannot be one of the existing. Must start with &#x27;group.&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdRenamePut(groupId, newName, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdRenamePut(groupId, newName, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.2
         * @summary Adds a user to a group
         * @param {string} groupId group Id
         * @param {string} user user login name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdUserUserPut(groupId, user, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdUserUserPut(groupId, user, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Sets all users of a group (replacing potential former content)
         * @param {string} groupId group Id
         * @param {string} users List of all users members of that group, commas-separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupIdUserlistPut(groupId, users, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupIdUserlistPut(groupId, users, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Creates a new group
         * @param {string} groupName group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupNamePost(groupName, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupNamePost(groupName, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Removes a user from a group
         * @param {string} groupName group name
         * @param {string} user user login name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        groupGroupNameUserUserDelete(groupName, user, options) {
            return exports.DefaultApiFp(this.configuration).groupGroupNameUserUserDelete(groupName, user, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.3
         * @summary Merge branch into mainline. First project is the mainline, second is the branch. The payload must contain a json object with a list of actions to perform.
         * @param {string} mainproject mainproject
         * @param {string} branchproject branchproject
         * @param {string} reason The reason why the user is doing this
         * @param {MergeParam} [body] Actions to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options) {
            return exports.DefaultApiFp(this.configuration).mainprojectMergeBranchprojectPost(mainproject, branchproject, reason, body, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.2
         * @summary Retrieves all accesses in a project (list of groups and users who have access)
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectAccessGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectAccessGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Retrieves all changes in a project
         * @param {string} project Project short label
         * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
         * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
         * @param {string} [deleteOnly] (optional) if set to yes, only returns actions of type delete
         * @param {string} [tech] (optional) if set to yes, returns the underneath changes
         * @param {number} [auditIdMin] (optional) sets a minimum ID for audits, as returned by GET calendar
         * @param {number} [auditIdMax] (optional) sets a maximum ID for audits
         * @param {number} [noReport] (optional) set to 1 to avoid having reports
         * @param {number} [noImport] (optional) set to 1 to avoid having imports
         * @param {string} [include] (optional) set to a list of actions to include (delete,undelete,add,edit,...)
         * @param {number} [resolveRef] (optional) set to 1 to resolve item IDs into refs
         * @param {string} [itemRef] (optional) restrict the audit to only those mentionning this item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options) {
            return exports.DefaultApiFp(this.configuration).projectAuditGet(project, startAt, maxResults, deleteOnly, tech, auditIdMin, auditIdMax, noReport, noImport, include, resolveRef, itemRef, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.3
         * @summary Launches a server-side branch or clone - needs the 'merge' module if actual branching
         * @param {string} project Project short label
         * @param {string} label Branch project label
         * @param {string} shortLabel Branch project short label
         * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after branching)
         * @param {number} keepContent 1 or 0. Defaults to 1. 0 only works without branch and without history
         * @param {number} [branch] (optional) Set to 1 to branch (default), 0 to just copy/clone
         * @param {number} [history] (optional) Set to 1 to branch or copy with history, defaults to 0
         * @param {string} [tagToCreate] (optional) specify a tag (by default auto-generated)
         * @param {string} [branchInThePastTag] (optional) specify a tag to branch in the past (needs history&#x3D;1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options) {
            return exports.DefaultApiFp(this.configuration).projectBranchPost(project, label, shortLabel, keepPermissions, keepContent, branch, history, tagToCreate, branchInThePastTag, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get all dates at which a project has been modified
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCalendarGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectCalendarGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Removes (inactivate) a category. Will fail on REPORT and FOLDER categories
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatCategoryDelete(project, category, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectCatCategoryDelete(project, category, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get details of a category
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {string} [filter] (optional) specify a filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatCategoryGet(project, category, filter, options) {
            return exports.DefaultApiFp(this.configuration).projectCatCategoryGet(project, category, filter, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Modifies a categorie's labels, and fix the project's settings to reflect that change, OR modifies a category's order.
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {number} order The new order (for reordering)
         * @param {string} shortLabel The new short label for that category (for renaming)
         * @param {string} label The new long label for that category (for renaming)
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatCategoryPut(project, category, order, shortLabel, label, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectCatCategoryPut(project, category, order, shortLabel, label, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get all settings of a category
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatCategorySettingGet(project, category, options) {
            return exports.DefaultApiFp(this.configuration).projectCatCategorySettingGet(project, category, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Adds or changes a category setting. If the value is empty, the setting will be deleted
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {string} key setting key
         * @param {string} value value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatCategorySettingPost(project, category, key, value, options) {
            return exports.DefaultApiFp(this.configuration).projectCatCategorySettingPost(project, category, key, value, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get all categories of a project
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectCatGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Adds a fields in a category
         * @param {string} project Project short label
         * @param {string} label Field label
         * @param {string} category Category short label
         * @param {string} fieldType Type of field
         * @param {string} fieldParam Parameter for the field
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCatPost(project, label, category, fieldType, fieldParam, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectCatPost(project, label, category, fieldType, fieldParam, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Clones a project
         * @param {string} project Project short label
         * @param {string} label Project label
         * @param {string} shortLabel Project short label
         * @param {number} keepHistory 1 or 0. Defaults to 0
         * @param {number} keepContent 1 or 0. Defaults to 0 (only the REPORT part is kept, make sense only if keepHistory is 0)
         * @param {number} keepPermissions 1 or 0. Defaults to 0 (with 0 the project doesn&#x27;t have any permission after cloning)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options) {
            return exports.DefaultApiFp(this.configuration).projectClonePost(project, label, shortLabel, keepHistory, keepContent, keepPermissions, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Asks for the difference between 2 signed documents, as a Word document. The job ID is returned as answer
         * @param {string} project Project short label
         * @param {string} signitem1 SIGN-xx for the first SIGN document to compare
         * @param {string} signitem2 SIGN-xx for the 2nd SIGN document to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options) {
            return exports.DefaultApiFp(this.configuration).projectCompareSignitem1Signitem2Post(project, signitem1, signitem2, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get a project's schema
         * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectConfigcheckGet(excludeCategories, options) {
            return exports.DefaultApiFp(this.configuration).projectConfigcheckGet(excludeCategories, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.2
         * @summary Copy items from a folder to another one
         * @param {string} project Project short label
         * @param {string} itemOrFolder Item reference (XXX-nn) or folder (F-XXX-nn)
         * @param {string} targetFolder Reference of the target folder (F-categ-serial)
         * @param {string} reason The reason why the user is doing this
         * @param {string} [targetProject] (optional) project to copy into (by default, same project)
         * @param {number} [copyLabels] (optional) 0 or 1. Defaults to 0
         * @param {string} [map] (optional) mapN&#x3D;M -  map field N in source to field M in target
         * @param {string} [ignoreLabels] (optional) can contain a comma-delimited list of labels NOT to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options) {
            return exports.DefaultApiFp(this.configuration).projectCopyItemOrFolderPost(project, itemOrFolder, targetFolder, reason, targetProject, copyLabels, map, ignoreLabels, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
         * @summary Removes completely a project (only used for unit testing). This is an actual DELETE in the database.
         * @param {string} project Project short label
         * @param {string} confirm Needs to be yes for the method to be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectDelete(project, confirm, options) {
            return exports.DefaultApiFp(this.configuration).projectDelete(project, confirm, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Converts an excel file (xls, xlsx) into a XML version that we send straight back as an XML payload.
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectExcelxmlPost(project, options) {
            return exports.DefaultApiFp(this.configuration).projectExcelxmlPost(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Executes UC or TC into XTC items
         * @param {string} project Project short label
         * @param {ExecuteParam} [body] There must be a JSON as a payload. It includes all parameters AND the reason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectExecutePost(project, body, options) {
            return exports.DefaultApiFp(this.configuration).projectExecutePost(project, body, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Asks for an export of some items. The job ID is returned as answer
         * @param {string} project Project short label
         * @param {string} itemList Mandatory list of items to export.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectExportGet(project, itemList, options) {
            return exports.DefaultApiFp(this.configuration).projectExportGet(project, itemList, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Removes (inactivate) a field.
         * @param {string} project Project short label
         * @param {string} category Category short label
         * @param {number} field The field number (like field&#x3D;502)
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFieldCategoryDelete(project, category, field, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectFieldCategoryDelete(project, category, field, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get 1 field of an item. {item} has the form CATEG-number.
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} field Mandatory. Field number (faster) OR field label
         * @param {string} [format] Optional. Format for the return. Can be text, json, html, xml or xslt. Defaults to html
         * @param {number} [download] Optional. 1 to have in download, 0 as direct result. Defaults to 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFieldItemGet(project, item, field, format, download, options) {
            return exports.DefaultApiFp(this.configuration).projectFieldItemGet(project, item, field, format, download, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Modifies a field's label and parameter OR modifies a field's order.
         * @param {string} project Project short label
         * @param {number} field The field number (like field&#x3D;502)
         * @param {string} label The new label (for renaming)
         * @param {string} fieldParam The new parameter (for renaming)
         * @param {number} order The new order (for reordering)
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFieldPut(project, field, label, fieldParam, order, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectFieldPut(project, field, label, fieldParam, order, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have the right key to download the file. Valid from version 2.1
         * @summary Retrieve one project file. The fileno is a simple fileId. This request returns the actual file
         * @param {string} project Project short label
         * @param {number} fileno file number
         * @param {string} key The key of the file
         * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFileFilenoGet(project, fileno, key, disposition, options) {
            return exports.DefaultApiFp(this.configuration).projectFileFilenoGet(project, fileno, key, disposition, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Retrieve list of all files owned by a project
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFileGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectFileGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Creates a new file - the file should be uploaded as payload (or through the url argument as an alternative). It's mime type should be sent through the HTTP protocol.
         * @param {string} project Project short label
         * @param {string} [url] Optional argument -  the file could also come from an external URL. In this case there will be an error if we can&#x27;t retrieve it on the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFilePost(project, url, options) {
            return exports.DefaultApiFp(this.configuration).projectFilePost(project, url, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
         * @summary Creates a new folder
         * @param {string} project Project short label
         * @param {string} parent Reference of the parent folder in the form F-CATEG-serial (example -  F-SPEC-17)
         * @param {string} label folder label
         * @param {string} reason The reason why the user is doing this
         * @param {string} [fxField] (optional) Add one of each of these to set folder&#x27;s fields. fx is followed by the field ID (a number)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectFolderPost(project, parent, label, reason, fxField, options) {
            return exports.DefaultApiFp(this.configuration).projectFolderPost(project, parent, label, reason, fxField, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get list of project info -  users, settings, categories
         * @param {string} project Project short label
         * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have this project data even if you are not assigned to, as an admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectGet(project, adminUI, options) {
            return exports.DefaultApiFp(this.configuration).projectGet(project, adminUI, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Hides a project
         * @param {string} project Project short label
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectHidePut(project, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectHidePut(project, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.2
         * @summary Launches a server-side hook
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} hook name of the hook
         * @param {string} [body] Payload for the hook, treated as a string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectHookItemPost(project, item, hook, body, options) {
            return exports.DefaultApiFp(this.configuration).projectHookItemPost(project, item, hook, body, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
         * @summary Cleans up an input html blob according to the current html cleanup rules. The blob is passed in the POST payload. The payload must be a json object with {\"htmlToClean\" - \"x\"}
         * @param {string} project Project short label
         * @param {GetHmlBlobInput} [body] Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectHtmlCleanupBlobPost(project, body, options) {
            return exports.DefaultApiFp(this.configuration).projectHtmlCleanupBlobPost(project, body, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
         * @summary Get the list of items that would be changed if we applied html cleanup. You can pass a cleanup setting in the payload of the POST. If it's not there we take the customer (global) setting and force the cleanup to true
         * @param {string} project Project short label
         * @param {CleanupSetting} [body] Cleanup setting (optional)
         * @param {string} [categories] (optional) list of comma-delimited categories to go through, all by default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectHtmlCleanupTestPost(project, body, categories, options) {
            return exports.DefaultApiFp(this.configuration).projectHtmlCleanupTestPost(project, body, categories, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Imports some items into a project
         * @param {string} project Project short label
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectImportPost(project, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectImportPost(project, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get details of a folder. {folder} has the form F-CATEG-number[-vN].
         * @param {string} project Project short label
         * @param {string} folder Folder reference (F-XXX-nn)
         * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
         * @param {string} [filter] (optional) specify a filter
         * @param {string} [children] (optional) set to yes if you need the children as well (recursively).
         * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
         * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options) {
            return exports.DefaultApiFp(this.configuration).projectItemFolderGet(project, folder, history, filter, children, atDate, fields, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Removes (inactivate) an item (or a folder). Item has the form (F-)CATEG-number. Will fail on non-empty folders
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} confirm Needs to be yes for the method to be executed IF it is a non-empty folder
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemItemDelete(project, item, confirm, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectItemItemDelete(project, item, confirm, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get details of an item. {item} has the form CATEG-number[-vN].
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {number} [history] (optional) set history&#x3D;1 to retrieve list of all versions
         * @param {number} [fields] (optional) set fields&#x3D;1 to retrieve list of all fields, even the empty ones
         * @param {string} [filter] (optional) specify a filter
         * @param {string} [atDate] (optional) retrieves the item at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z. Not compatible with the version query -vN
         * @param {number} [withTree] (optional) retrieves the context tree if set to 1, in the field contextTree. Exclusive to filter and atDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options) {
            return exports.DefaultApiFp(this.configuration).projectItemItemGet(project, item, history, fields, filter, atDate, withTree, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Restores an item. Item has the form CATEG-number
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} reason The reason why the user is doing this
         * @param {number} [at] (optional) If set, specifies that the item should be restored as it was in that version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemItemPost(project, item, reason, at, options) {
            return exports.DefaultApiFp(this.configuration).projectItemItemPost(project, item, reason, at, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Modifies an item or a folder. Item has the form CATEG-number, folders -  F-CATEG-number
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} reason The reason why the user is doing this
         * @param {string} [title] Specify new title for the item -- if not there, keep the old title
         * @param {string} [fxid_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
         * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
         * @param {string} [auditAction] (optional) Specify a new verb for the audit action. Defaults to edit
         * @param {string} [newFolder] (optional) Name of a new folder to move the item into (exclusive from title and fx arguments)
         * @param {number} [newPosition] (optional) Indicates a new position within the newfolder. If newFolder is not specified, only changes the position. Exclusive of title and fx arguments. Position is an integer starting at 1
         * @param {string} [filter] (optional) A filter
         * @param {string} [linksUp] (optional) Comma-delimited (%2C)list of references to up items
         * @param {string} [linksDown] (optional) Comma-delimited (%2C)list of references to down items
         * @param {number} [currentVersion] (optional) will not make the change if the current version is not that one
         * @param {number} [onlyThoseFields] (optional) when set to 1 says that the only fields to change are those passed
         * @param {number} [onlyThoseLabels] (optional) when set to 1 says that the only labels to change are those passed. To remove a label in this case, prefix it with minus
         * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options) {
            return exports.DefaultApiFp(this.configuration).projectItemItemPut(project, item, reason, title, fxid_, labels, auditAction, newFolder, newPosition, filter, linksUp, linksDown, currentVersion, onlyThoseFields, onlyThoseLabels, failOnCleanup, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project - admins can impersonate. Valid from version 2.1
         * @summary Adds an item in a folder
         * @param {string} project Project short label
         * @param {string} title Item title
         * @param {string} folder Reference of the folder (F-categ-serial)
         * @param {string} reason The reason why the user is doing this
         * @param {string} linksUp Comma-delimited (%2C)list of references to up items
         * @param {string} linksDown Comma-delimited (%2C)list of references to down items
         * @param {string} [fxID_] Values of each field, the URI parameter name is fx followed by the ID of the field (fx501 for example)
         * @param {string} [labels] (optional) List of labels currently applied to this element. If none is specified, will consider there are none. Should be sent as a comma-delimited list of strings
         * @param {string} [author] The author (login name) - only works when superadmin is issuing this
         * @param {number} [failOnCleanup] (optional) when set to 1 (default) says that the call will fail if any HTML cleanup is involved. With 0 it will clean and not fail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options) {
            return exports.DefaultApiFp(this.configuration).projectItemPost(project, title, folder, reason, linksUp, linksDown, fxID_, labels, author, failOnCleanup, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - ?. Valid from version 2.1
         * @summary Removes (inactivate) a link between 2 items. Items are in the form CATEG-number
         * @param {string} project Project short label
         * @param {string} upitem Item reference (XXX-nn) for the UP item
         * @param {string} downitem Item reference (XXX-nn) for the DOWN item
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectItemlinkUpitemDownitemDelete(project, upitem, downitem, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Adds a link between 2 items. Both items are in the form CATEG-number
         * @param {string} project Project short label
         * @param {string} upitem Item reference (XXX-nn) for the UP item
         * @param {string} downitem Item reference (XXX-nn) for the DOWN item
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectItemlinkUpitemDownitemPost(project, upitem, downitem, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get the list of items that are detailed in a DOC/SIGN item.
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {number} [detailed] Optional. When set to 1 adds a secondaryItems list in the answer. Defaults to 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectItemlistItemGet(project, item, detailed, options) {
            return exports.DefaultApiFp(this.configuration).projectItemlistItemGet(project, item, detailed, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Retrieve list of all jobs in a project
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectJobGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectJobGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.3
         * @summary Aborts a job.
         * @param {string} project Project short label
         * @param {number} job job number
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectJobJobDelete(project, job, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectJobJobDelete(project, job, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get a job file. The job part is the jobID (a number) and the file is the fileID (a number)
         * @param {string} project Project short label
         * @param {number} job job number
         * @param {number} fileno file number
         * @param {string} [mode] (optional) set to mode&#x3D;direct to get the output in the response output instead of as a download file. This assumes the file is HTML
         * @param {string} [format] (optional) set to format&#x3D;json to get a json output instead of XML
         * @param {string} [disposition] (optional, from version 2.3) set to disposition&#x3D;inline to ask the server to send the disposition to &#x27;inline&#x27; instead of &#x27;attachment&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options) {
            return exports.DefaultApiFp(this.configuration).projectJobJobFilenoGet(project, job, fileno, mode, format, disposition, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get a job status, including generated files. The variable part is the jobID (a number)
         * @param {string} project Project short label
         * @param {number} job job number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectJobJobGet(project, job, options) {
            return exports.DefaultApiFp(this.configuration).projectJobJobGet(project, job, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.2
         * @summary Sets the progress of a job
         * @param {string} project Project short label
         * @param {number} job job number
         * @param {number} progress progress (0 to 100, 200 for error)
         * @param {string} [status] (optional( status text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectJobJobPost(project, job, progress, status, options) {
            return exports.DefaultApiFp(this.configuration).projectJobJobPost(project, job, progress, status, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
         * @summary Get the label history of a project -  list of all label changes for all items
         * @param {string} project Project short label
         * @param {string} [itemRef] (optional) ask for just one item (the return structure is still an array in that case)
         * @param {string} [from] (optional) date from
         * @param {string} [to] (optional) date to - works only if you only specified a from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectLabelhistoryGet(project, itemRef, from, to, options) {
            return exports.DefaultApiFp(this.configuration).projectLabelhistoryGet(project, itemRef, from, to, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
         * @summary Get the merge history of a project - needs the 'merge' module
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectMergehistoryGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectMergehistoryGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.3
         * @summary Get the merge information - needs the 'merge' module
         * @param {string} project Project short label
         * @param {string} [excludeCategories] (optional) comma-delimited list of categories to exclude
         * @param {string} [fromDate] (optional) date from which we consider the merges. ISO8601 format -- this parameter was introduced in v 2.3.4
         * @param {number} [push] (optional) set to 1 if you inquire about a push, not a merge -- this parameter was introduced in v 2.3.4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectMergeinfoGet(project, excludeCategories, fromDate, push, options) {
            return exports.DefaultApiFp(this.configuration).projectMergeinfoGet(project, excludeCategories, fromDate, push, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Move items into this folder
         * @param {string} project Project short label
         * @param {string} folder Folder reference (F-XXX-nn)
         * @param {string} reason The reason why the user is doing this
         * @param {string} [items] List of items to move in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectMoveinFolderPost(project, folder, reason, items, options) {
            return exports.DefaultApiFp(this.configuration).projectMoveinFolderPost(project, folder, reason, items, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Find items based on a search string in one project
         * @param {string} project Project short label
         * @param {string} search search term
         * @param {string} id search id. Used by MatrixJira js to match queries with answers. Is returned in the output structure
         * @param {string} [filter] (optional) applies a filter, can be negative
         * @param {string} [fieldsOut] (optional) comma-delimited list of fields to return -  101,102 - or * for all
         * @param {number} [labels] (optional) set to 1 to return labels in the output
         * @param {number} [treeOrder] (optional) set to 1 to return items in tree order (otherwise it&#x27;s project,category,serial)
         * @param {string} [links] (optional) set to up,down to return up and down items, or only up or only down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options) {
            return exports.DefaultApiFp(this.configuration).projectNeedleGet(project, search, id, filter, fieldsOut, labels, treeOrder, links, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Find item ids based on a search string in one project
         * @param {string} project Project short label
         * @param {string} search search term
         * @param {string} [filter] (optional) applies a filter, can be negative
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectNeedleminimalGet(project, search, filter, options) {
            return exports.DefaultApiFp(this.configuration).projectNeedleminimalGet(project, search, filter, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Adds a category to a project
         * @param {string} project Project short label
         * @param {string} label Category label
         * @param {string} shortLabel Category short label
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectPost(project, label, shortLabel, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectPost(project, label, shortLabel, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Publishes an item. Item has the form PUB-nnn
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} reason reason for the publication
         * @param {string} [trainingFor] (optional) list of items for which we need to add training. If list is not there, all trainings will be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectPublishItemPost(project, item, reason, trainingFor, options) {
            return exports.DefaultApiFp(this.configuration).projectPublishItemPost(project, item, reason, trainingFor, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have QMS viewer access (or higher) to the project. Valid from version 2.3
         * @summary Find a string in the QMS published items
         * @param {string} project Project short label
         * @param {string} [search] (optional) search term. Return an empty array on PUB &lt; 2.3.1 and et the list of all pub if not specified.
         * @param {string} [pubItem] (optional) PUB-x item if you want to search in another than the last one for that project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectQmsfindGet(project, search, pubItem, options) {
            return exports.DefaultApiFp(this.configuration).projectQmsfindGet(project, search, pubItem, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) for the reports, read/write for the signed reports. Valid from version 2.1
         * @summary Asks for a new report. The job ID is returned as answer. {report} can be REPORT-n, DOC-n, SIGN-n or a report name.To follow the progress of the job, the GET /{project}/job/{jobid} can be called
         * @param {string} project Project short label
         * @param {string} report name of the report
         * @param {string} isSignedReport If set to true, means the report needs to generate a signed record
         * @param {string} includeSignatures List of comma separated users who need to sign
         * @param {string} newTitle New title for the SIGN- item that is generated (only valid for isSignedReport)
         * @param {string} copyFields List of from-to fields (123,456),(124,457) that we can use to generate the fields in the SIGN record (only valid for isSignedReport)
         * @param {string} [itemList] (optional) list of items to use in the report. By default all categories are used
         * @param {string} [url] (optional) url to generate in the filter
         * @param {string} [resturl] (optional) REST url to generate in the filter
         * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx, zippdf or package (from 2.2), or mf (since 2.3)
         * @param {string} [filter] (optional) specify a comma-delimited filter list. Can be negative filters (with minus before)
         * @param {number} [useOld] (optional) ask to use the old report engine (pre 1.11) if set to 1.
         * @param {string} [atDate] (optional) generates the report at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options) {
            return exports.DefaultApiFp(this.configuration).projectReportReportPost(project, report, isSignedReport, includeSignatures, newTitle, copyFields, itemList, url, resturl, format, filter, useOld, atDate, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get a project's schema
         * @param {string} project Project short label
         * @param {number} [simple] (optional) set to simple&#x3D;1 to have a simpler output (no fields, round shape)
         * @param {string} [excludeCategories] (optional) comma-separated list of categories to exclude, like DOC,SIGN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSchemaGet(project, simple, excludeCategories, options) {
            return exports.DefaultApiFp(this.configuration).projectSchemaGet(project, simple, excludeCategories, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Get all settings of a project
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSettingGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectSettingGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Adds or changes a project setting. If the value is empty, the setting will be deleted.
         * @param {string} project Project short label
         * @param {string} key setting key
         * @param {string} value value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSettingPost(project, key, value, options) {
            return exports.DefaultApiFp(this.configuration).projectSettingPost(project, key, value, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Signs an item. Item has the form SIGN-nnn
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} password signature password - the user who is signing is the one who is logged in
         * @param {string} [acceptComments] (optional) adds an acceptance comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSignItemPost(project, item, password, acceptComments, options) {
            return exports.DefaultApiFp(this.configuration).projectSignItemPost(project, item, password, acceptComments, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Edit the signature parts
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} rejectSign The reason why the user is rejecting the signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSignItemPut(project, item, rejectSign, options) {
            return exports.DefaultApiFp(this.configuration).projectSignItemPut(project, item, rejectSign, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Asks for a new report. The job ID is returned as answer
         * @param {string} project Project short label
         * @param {string} [url] (optional) url to generate in the filter
         * @param {string} [resturl] (optional) REST url to generate in the filter
         * @param {string} [format] (optional) format -  html (default), pdf, docx, odt, xml, zipdocx or zippdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectSignedreportSIGNNPost(project, url, resturl, format, options) {
            return exports.DefaultApiFp(this.configuration).projectSignedreportSIGNNPost(project, url, resturl, format, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Get all tags of a project. Works on any project if user is admin
         * @param {string} project Project short label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTagGet(project, options) {
            return exports.DefaultApiFp(this.configuration).projectTagGet(project, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Adds a tag to a project
         * @param {string} project Project short label
         * @param {string} label Tag label. Must be unique within a project
         * @param {number} auditId Id of the audit this tag is based on
         * @param {string} type Type of tag (default -  tag)
         * @param {string} comments Free optional comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTagPost(project, label, auditId, type, comments, options) {
            return exports.DefaultApiFp(this.configuration).projectTagPost(project, label, auditId, type, comments, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
         * @summary Get all todos for the current user, for oneproject
         * @param {string} project Project short label
         * @param {string} [itemRef] (optional) set to an item to have all todos linked to an item, regardless of the user
         * @param {number} [includeDone] (optional) set to 1 to include done todos and todo&#x27;s created by the user
         * @param {number} [includeAllUsers] (optional) set to 1 to include all todos for all users
         * @param {number} [includeFuture] (optional) set to 1 to include future todos as well (defaults to 0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options) {
            return exports.DefaultApiFp(this.configuration).projectTodoGet(project, itemRef, includeDone, includeAllUsers, includeFuture, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.2
         * @summary Creates a todo on an item (note that you only need read access for this POST method) for you or others
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} text The todo reason
         * @param {number} [fieldId] (optional) If set, specifies that the todo is related to that field (review, ...)
         * @param {string} [logins] (optional) If set, a list of user logins or groups to which these todo apply
         * @param {string} [todoType] (optional) The todo type -  &#x27;user&#x27; by default
         * @param {string} [atDate] (optional) a date in the future for reminders
         * @param {number} [auto] (optional) set to 1 to create an auto-notification (0 by default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options) {
            return exports.DefaultApiFp(this.configuration).projectTodoItemPost(project, item, text, fieldId, logins, todoType, atDate, auto, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.2
         * @summary Removes (mark as done) a todo.
         * @param {string} project Project short label
         * @param {string} todoid todoid
         * @param {string} hardDelete Set to yes to actually remove the record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTodoTodoidDelete(project, todoid, hardDelete, options) {
            return exports.DefaultApiFp(this.configuration).projectTodoTodoidDelete(project, todoid, hardDelete, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Touches (set to same date) an item or folder
         * @param {string} project Project short label
         * @param {string} item Item reference (XXX-nn)
         * @param {string} reason The reason why the user is doing this
         * @param {number} [nbLayers] (optional) Number of layers -- 1 by default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTouchItemPut(project, item, reason, nbLayers, options) {
            return exports.DefaultApiFp(this.configuration).projectTouchItemPut(project, item, reason, nbLayers, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read access (or higher) to the project. Valid from version 2.1
         * @summary Get full tree
         * @param {string} project Project short label
         * @param {string} [fancy] (optional) returns a fancy tree
         * @param {string} [filter] (optional) applies a filter
         * @param {string} [atDate] (optional) generates the tree at that date - format is ISO8601 like atDate&#x3D;2018-05-30T14 - 48 - 27.223Z
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectTreeGet(project, fancy, filter, atDate, options) {
            return exports.DefaultApiFp(this.configuration).projectTreeGet(project, fancy, filter, atDate, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Unhides a project.
         * @param {string} project Project short label
         * @param {string} newShort The new project short name to use
         * @param {string} reason The reason why the user is doing this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectUnhidePut(project, newShort, reason, options) {
            return exports.DefaultApiFp(this.configuration).projectUnhidePut(project, newShort, reason, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have read/write access to the project. Valid from version 2.1
         * @summary Converts a word document to an HTML, with images pointing to uploaded files on the server
         * @param {string} project Project short label
         * @param {string} reason The reason why the user is doing this
         * @param {number} [fileNo] If specified, means that the conversion is from an already uploaded file. Otherwise the file must be uploaded as body of this call
         * @param {string} [targetDocumentFolder] target document folder (in this case creates a document)
         * @param {number} [useAsField] set to 1 to have this docx used as a field. In this case the return value is the html equivalent, with some meta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options) {
            return exports.DefaultApiFp(this.configuration).projectWordconvertPost(project, reason, fileNo, targetDocumentFolder, useAsField, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Get list of all projects, all settings and current user, all todos and JIRA meta create object
         * @param {number} [adminUI] (optional) set to adminUI&#x3D;1 to have all projects even the ones you are not assigned to, as an admin
         * @param {string} [output] (optional) comma-delimited list of requested output fields. Returns all fields if parameter is not present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        rootGet(adminUI, output, options) {
            return exports.DefaultApiFp(this.configuration).rootGet(adminUI, output, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Creates a new project. Either the full project is sent as XML payload, or the label and shortLabel are given. If uploading data for a whole project, label and shortLabel are optional but overwrite the XML content if present. Branching can be done with an audit report as payload, and branch* must be defined in that case
         * @param {string} label Project label
         * @param {string} shortLabel Project short label
         * @param {string} [overwrite] Must be set to yes if you&#x27;re overwriting an existing project
         * @param {string} [importUsers] Must be set to yes if you want to import users. false by default
         * @param {string} [branchLabel] Must be set to branch (optional)
         * @param {string} [branchTag] Must be set to branch, and match a tag in the audit export (optional)
         * @param {string} [branchComment] Comment for the branch (optional)
         * @param {string} [branchBaseProjectLabel] Label of the base Project (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options) {
            return exports.DefaultApiFp(this.configuration).rootPost(label, shortLabel, overwrite, importUsers, branchLabel, branchTag, branchComment, branchBaseProjectLabel, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Retrieves the user list
         * @param {string} details (optional) -  if set to 1 returns all details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userGet(details, options) {
            return exports.DefaultApiFp(this.configuration).userGet(details, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Creates a new user. Arguments are either a set of arguments or json
         * @param {string} login User login name
         * @param {string} email User email
         * @param {string} password User password in clear
         * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
         * @param {string} [first] User first name (optional)
         * @param {string} [last] User last name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userPost(login, email, password, json, first, last, options) {
            return exports.DefaultApiFp(this.configuration).userPost(login, email, password, json, first, last, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
         * @summary Retrieves all actions of a user
         * @param {string} user user login name
         * @param {number} [startAt] (optional) Pagination -  starts the audit after N records
         * @param {number} [maxResults] (optional) Pagination -  Retrieve N results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserAuditGet(user, startAt, maxResults, options) {
            return exports.DefaultApiFp(this.configuration).userUserAuditGet(user, startAt, maxResults, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
         * @summary Check a user's password
         * @param {string} user user login name
         * @param {string} password Asks for a check of the password1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserCheckGet(user, password, options) {
            return exports.DefaultApiFp(this.configuration).userUserCheckGet(user, password, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
         * @summary Check a user's password
         * @param {string} user user login name
         * @param {string} password Asks for a check of the password1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserCheckPost(user, password, options) {
            return exports.DefaultApiFp(this.configuration).userUserCheckPost(user, password, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Reserved to Matrix Requirements operations. Valid from version 2.1
         * @summary Removes completely a user (only used for unit testing)
         * @param {string} user user login name
         * @param {string} confirm Needs to be yes for the method to be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserDelete(user, confirm, options) {
            return exports.DefaultApiFp(this.configuration).userUserDelete(user, confirm, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
         * @summary Retrieves full details of a user
         * @param {string} user user login name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserGet(user, options) {
            return exports.DefaultApiFp(this.configuration).userUserGet(user, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - No permissions needed. Valid from version 2.1
         * @summary Login
         * @param {string} user user login name
         * @param {string} password password in clear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserLoginPost(user, password, options) {
            return exports.DefaultApiFp(this.configuration).userUserLoginPost(user, password, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must have a valid authentication. Valid from version 2.1
         * @summary Logout
         * @param {string} user user login name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserLogoutPost(user, options) {
            return exports.DefaultApiFp(this.configuration).userUserLogoutPost(user, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Sets a new password for an account that has a password_reset token in place (the {user} in the URL doesn't matter)
         * @param {string} user user login name
         * @param {string} token password_reset token
         * @param {string} password New password to use from now on
         * @param {string} [signaturePassword] (optional) New password to use from now on for signatures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserPasswordResetPost(user, token, password, signaturePassword, options) {
            return exports.DefaultApiFp(this.configuration).userUserPasswordResetPost(user, token, password, signaturePassword, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Adds a user to a project
         * @param {string} user user login name
         * @param {string} project Project short label
         * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin, 4 for visitor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserProjectPost(user, project, permission, options) {
            return exports.DefaultApiFp(this.configuration).userUserProjectPost(user, project, permission, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Edits the user permissions in a project. If permission is 0, it means the user has no longer access (but we retain its records for audit purposes)
         * @param {string} user user login name
         * @param {string} project Project short label
         * @param {number} permission 0 for no access, 1 for readonly, 2 for read/write (default), 3 for admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserProjectPut(user, project, permission, options) {
            return exports.DefaultApiFp(this.configuration).userUserProjectPut(user, project, permission, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be that user - Matrix operations can impersonate. Valid from version 2.1
         * @summary Retrieves all projects a user has access to
         * @param {string} user user login name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserProjectsGet(user, options) {
            return exports.DefaultApiFp(this.configuration).userUserProjectsGet(user, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Edits the user details. Arguments are all separated or a single json argument. Regular users can only change their signature and passwords.
         * @param {string} user user login name
         * @param {string} email User new email
         * @param {string} password User new password in clear
         * @param {string} json A json struct with login, email, password, first, last, signatureImage(int), signaturePassword, admin(int)
         * @param {string} [first] User first name (optional)
         * @param {string} [last] User last name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserPut(user, email, password, json, first, last, options) {
            return exports.DefaultApiFp(this.configuration).userUserPut(user, email, password, json, first, last, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.2
         * @summary Renames a user login
         * @param {string} user user login name
         * @param {string} newLogin The new login name. Cannot be one of the existing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserRenamePut(user, newLogin, options) {
            return exports.DefaultApiFp(this.configuration).userUserRenamePut(user, newLogin, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Adds or deletes a user setting.
         * @param {string} user user login name
         * @param {string} key Name of the setting
         * @param {string} value Value of the setting. If empty, deletes the setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserSettingPost(user, key, value, options) {
            return exports.DefaultApiFp(this.configuration).userUserSettingPost(user, key, value, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin. Valid from version 2.1
         * @summary Sets the new status of the user. Can be normal,blocked or deleted
         * @param {string} user user login name
         * @param {string} status Can be normal,blocked or deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserStatusPut(user, status, options) {
            return exports.DefaultApiFp(this.configuration).userUserStatusPut(user, status, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Removes a user token
         * @param {string} user user login name
         * @param {string} value The token to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserTokenDelete(user, value, options) {
            return exports.DefaultApiFp(this.configuration).userUserTokenDelete(user, value, options)(this.fetch, this.basePath);
        }
        /**
         * Permissions - Must be admin or the user. Valid from version 2.1
         * @summary Adds a token for a user
         * @param {string} user user login name
         * @param {string} purpose Purpose of the token. Not checked. Should contain either \&quot;password_reset\&quot; or \&quot;oauth\&quot;
         * @param {string} [value] Value of the token - by default generated by this call
         * @param {string} [reason] Free text explain where the token will be used (URL or others). Should be set for oauth, not needed for others
         * @param {number} [validity] Validity of the token in hours - if not set, doesn&#x27;t expire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof DefaultApi
         */
        userUserTokenPost(user, purpose, value, reason, validity, options) {
            return exports.DefaultApiFp(this.configuration).userUserTokenPost(user, purpose, value, reason, validity, options)(this.fetch, this.basePath);
        }
    }
    exports.DefaultApi = DefaultApi;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 188 */
/***/ ((module) => {

(function () {
  "use strict";

  function btoa(str) {
    var buffer;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = Buffer.from(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());


/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(190);
var util = __webpack_require__(191);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(192);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),
/* 191 */
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(193);
exports.encode = exports.stringify = __webpack_require__(194);


/***/ }),
/* 193 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 194 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(184);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=consoleapi.js.map